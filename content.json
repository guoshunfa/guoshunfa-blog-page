{"meta":{"title":"guoshunfa","subtitle":"快乐生活","description":"guoshunfa","author":"guoshunfa","url":"https://guoshunfa.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-01-28T11:41:38.863Z","updated":"2024-01-28T11:41:38.863Z","comments":false,"path":"/404.html","permalink":"https://guoshunfa.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2024-01-28T11:41:39.311Z","updated":"2024-01-28T11:41:39.311Z","comments":false,"path":"books/index.html","permalink":"https://guoshunfa.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-07-09T06:03:21.366Z","updated":"2024-07-09T06:03:21.366Z","comments":false,"path":"about/index.html","permalink":"https://guoshunfa.com/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031&#123; &quot;姓名&quot;: &quot;郭顺发&quot;, &quot;性别&quot;: &quot;男&quot;, &quot;公司&quot;: &quot;熊趣软件开发工作室&quot;, &quot;当前位置&quot;: &quot;深圳&quot;, &quot;老家&quot;: &quot;哈尔滨&quot;, &quot;github&quot;: &quot;https://github.com/guoshunfa&quot;, &quot;个人网站地址&quot;: &quot;https://www.guoshunfa.com&quot;, &quot;邮箱&quot;: &quot;16603684608@guoshunfa.com&quot;, &quot;手机号&quot;: &quot;16603684608&quot;, &quot;描述&quot;: &quot;承接：小程序开发、APP开发、网站开发、爬虫开发&quot;, &quot;承接&quot;: [ [&quot;微信小程序&quot;, &quot;抖音小程序&quot;, &quot;支付宝小程序&quot;], [&quot;安卓APP&quot;, &quot;苹果APP&quot;], [&quot;企业官网&quot;, &quot;管理平台&quot;, &quot;独立站&quot;, &quot;电商网站&quot;], [&quot;数据爬虫&quot;, &quot;数据分析&quot;, &quot;数据处理&quot;] ], &quot;技术栈&quot;: &#123; &quot;服务端&quot;: [&quot;Java&quot;, &quot;PHP&quot;, &quot;C++&quot;, &quot;NodeJS&quot;, &quot;Python&quot;], &quot;APP&quot;: [&quot;原生开发&quot;, &quot;UniApp&quot;], &quot;小程序&quot;: [&quot;原生开发&quot;, &quot;Uniapp&quot;], &quot;服务器&quot;: [&quot;Windows&quot;, &quot;Linux&quot;, &quot;银河麒麟&quot;], &quot;数据库&quot;: [&quot;Mysql&quot;, &quot;Oracle&quot;, &quot;MongoDB&quot;, &quot;Redis&quot;, &quot;SQL Server&quot;, &quot;达梦&quot;], &quot;爬虫&quot;: [&quot;Python&quot;, &quot;易语言&quot;] &#125;, &quot;额外服务内容&quot;: &#123; &quot;1&quot;: &quot;合同保障，源码交付&quot;, &quot;2&quot;: &quot;项目方案免费设计&quot; &#125;&#125;"},{"title":"分类","date":"2024-01-28T11:41:39.311Z","updated":"2024-01-28T11:41:39.311Z","comments":false,"path":"categories/index.html","permalink":"https://guoshunfa.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-01-28T11:41:39.312Z","updated":"2024-01-28T11:41:39.312Z","comments":false,"path":"tags/index.html","permalink":"https://guoshunfa.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-01-28T11:41:39.312Z","updated":"2024-01-28T11:41:39.312Z","comments":true,"path":"links/index.html","permalink":"https://guoshunfa.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-01-28T11:41:39.312Z","updated":"2024-01-28T11:41:39.312Z","comments":false,"path":"repository/index.html","permalink":"https://guoshunfa.com/repository/index.html","excerpt":"","text":""},{"title":"工具箱","date":"2024-01-28T11:41:39.312Z","updated":"2024-01-28T11:41:39.312Z","comments":true,"path":"tools/index.html","permalink":"https://guoshunfa.com/tools/index.html","excerpt":"","text":"🔧 var toolGroups = { \"常用\": [ {'name': 'vercel','link': 'https://vercel.com/','desc': '静态网站部署'}, {'name': 'Spring Initializr','link': 'https://start.spring.io/','desc': ''}, {'name': '流程图设计', 'link': 'https://app.diagrams.net/', 'desc': ''} , {'name': 'JSON格式化','link': 'https://www.bejson.com/jsonviewernew/','desc': ''}, {'name': '时间戳转换','link': 'http://tool.chinaz.com/tools/unixtime.aspx','desc': ''}, {'name': 'codepen','link': 'https://codepen.io/','desc': ''}, {'name': 'BootCDN','link': 'https://www.bootcdn.cn','desc': ''}, {'name': '单位转换','link': 'https://www.convertworld.com/zh-hans/','desc': ''}, {'name': '文件转换器','link': 'https://convertio.co/zh/','desc': ''}, {'name': '代码/文本 对比工具','link': 'https://www.diffchecker.com/','desc': ''}, {'name': 'PDF 转 Markdown','link': 'https://pdf2md.morethan.io/','desc': ''}, {'name': '加密/解密','link': 'http://tool.chinaz.com/tools/textencrypt.aspx','desc': ''}, {'name': 'vectorizer','link': 'https://www.vectorizer.io/','desc': '真正的 png 转 svg 神器'}, {'name': 'tinypng图片压缩','link': 'https://tinypng.com','desc': '压缩png很有用'}, {'name': '图片压缩','link': 'https://docsmall.com/','desc': ''}, {'name': 'Squoosh','link': 'https://squoosh.app/','desc': '谷歌出品在线免费图片压缩工具'}, {'name': 'jsDelivr', 'link': 'http://www.jsdelivr.com/', 'desc': ''} , {'name': 'unpkg', 'link': 'https://unpkg.com/', 'desc': ''} , {'name': '正则可视化', 'link': 'https://regex101.com/', 'desc': ''} , {'name': '反编译 Jar', 'link': 'http://www.decompiler.com', 'desc': ''} , {'name': '反编译 Class', 'link': 'http://javare.cn/De', 'desc': ''} , {'name': '代码图片生成器', 'link': 'https://carbon.now.sh/', 'desc': ''} , {'name': '图片转文字', 'link': 'https://web.baimiaoapp.com/', 'desc': ''} , {'name': 'JSON 转换 Excel', 'link': 'http://j2e.kpoda.com', 'desc': ''} , ], \"开发\" :[ {'name': 'Can I use','link': 'https://caniuse.com/','desc': '查看属性和方法的兼容性'}, {'name': '30 seconds of code','link': 'https://30secondsofcode.org/','desc': '收集了许多有用的代码小片段'}, {'name': 'codepen','link': 'https://codepen.io','desc': '在线代码编辑与演示'}, {'name': 'codesandbox','link': 'https://codesandbox.io','desc': '内嵌VSCode的在线IDE'}, {'name': '手册网','link': 'https://www.shouce.ren/','desc': ''}, ], \"API\": [ {'name': 'Java', 'link': 'https://docs.oracle.com/en/java/javase/index.html', 'desc': ''} , {'name': 'Spring', 'link': 'https://spring.io/projects', 'desc': ''} , {'name': 'MDN', 'link': 'https://developer.mozilla.org/zh-CN/docs/Web', 'desc': ''} , {'name': 'runoob', 'link': 'https://www.runoob.com', 'desc': ''} , {'name': 'React', 'link': 'https://zh-hans.reactjs.org/docs/getting-started.html', 'desc': ''} , {'name': 'React Router', 'link': 'https://reactrouter.com/docs/en/v6', 'desc': ''} , {'name': 'MongoDB', 'link': 'https://docs.mongodb.com', 'desc': ''} , {'name': 'Vue 3.x', 'link': 'https://cn.vuejs.org/', 'desc': ''} , {'name': 'element plus', 'link': 'https://element-plus.gitee.io/zh-CN/', 'desc': ''} , {'name': 'Vuepress v1.x', 'link': 'https://vuepress.vuejs.org/zh/', 'desc': ''} , {'name': 'Vuepress v2.x', 'link': 'https://v2.vuepress.vuejs.org/zh/', 'desc': ''} , {'name': 'Vdoing', 'link': 'https://doc.xugaoyi.com/pages/793dcb/', 'desc': ''} , {'name': 'jdk1.8', 'link': 'https://www.matools.com/api/java8', 'desc': ''} , {'name': 'hutool', 'link': 'https://hutool.cn/', 'desc': ''} , {'name': 'Linux 命令大全', 'link': 'https://www.linuxcool.com/', 'desc': ''} , {'name': 'Linux命令手册', 'link': 'https://ipcmen.com/', 'desc': ''} , {'name': 'docker hub', 'link': 'https://hub.docker.com/', 'desc': ''} , {'name': 'docker docs', 'link': 'https://docs.docker.com/', 'desc': ''} , {'name': '国内maven搜索', 'link': 'http://mvn.coderead.cn/', 'desc': ''} , {'name': '源码阅读网', 'link': 'https://www.coderead.cn/', 'desc': ''} , {'name': 'Jar包搜索', 'link': 'http://www.java2s.com/Code/Jar/CatalogJar.htm', 'desc': ''} , {'name': 'css学习', 'link': 'https://zh.learnlayout.com/', 'desc': ''} , ], \"运维管理平台\": [ {'name': 'dnspod域名控制台', 'link': 'https://console.dnspod.cn', 'desc': ''} , {'name': '腾讯云控制台', 'link': 'https://console.cloud.tencent.com/', 'desc': ''} , {'name': '阿里云控制台', 'link': 'https://homenew.console.aliyun.com/', 'desc': ''} , {'name': '微信公众号控制台', 'link': 'https://mp.weixin.qq.com/', 'desc': ''} , {'name': '百度站长平台', 'link': 'https://ziyuan.baidu.com/', 'desc': ''} , ], \"技术大佬博客\": [ {'name': 'Java 全栈知识体系', 'link': 'https://www.pdai.tech/', 'desc': ''} , {'name': 'Java 成神之路', 'link': 'http://hollischuang.gitee.io/tobetopjavaer/#/menu', 'desc': ''} , {'name': 'Bash 脚本教程', 'link': 'https://wangdoc.com/bash/', 'desc': ''} , {'name': 'ES6教程', 'link': 'http://es6.ruanyifeng.com/', 'desc': ''} , {'name': '腾讯云开发者手册', 'link': 'https://cloud.tencent.com/developer/devdocs', 'desc': ''} , {'name': '菜鸟教程', 'link': 'https://www.runoob.com/', 'desc': ''} , {'name': '现代JavaScript教程', 'link': 'https://zh.javascript.info', 'desc': ''} , ], \"设计-辅助开发利器\": [ {'name': '产品大牛', 'link': 'http://www.pmdaniu.com/', 'desc': ''} , {'name': '磨刀', 'link': 'https://modao.cc/pricing', 'desc': ''} , {'name': '创造师导航', 'link': 'http://chuangzaoshi.com/', 'desc': ''} , {'name': '设计师网址导航', 'link': 'http://hao.uisdc.com/', 'desc': ''} , {'name': 'uimovement', 'link': 'https://uimovement.com/', 'desc': ''} , {'name': 'awwwards', 'link': 'https://www.awwwards.com/', 'desc': ''} , {'name': 'dribbble', 'link': 'https://dribbble.com/', 'desc': ''} , {'name': 'Bēhance', 'link': 'https://www.behance.net/', 'desc': ''} , {'name': 'Logojoy', 'link': 'https://logojoy.com/', 'desc': ''} , {'name': 'brandmark', 'link': 'http://brandmark.io/', 'desc': ''} , {'name': 'instant', 'link': 'https://instantlogodesign.com/', 'desc': ''} , {'name': 'logo-maker', 'link': 'https://www.designevo.com/logo-maker/', 'desc': ''} , {'name': 'coolors', 'link': 'https://coolors.co/', 'desc': ''} , {'name': 'colorhunt', 'link': 'http://colorhunt.co/', 'desc': ''} , {'name': 'uigradients', 'link': 'https://uigradients.com/#SummerDog', 'desc': ''} , {'name': 'designcap', 'link': 'https://www.designcap.com/', 'desc': ''} , {'name': 'Flat UI 色表', 'link': 'https://flatuicolors.com/', 'desc': ''} , {'name': '0to255', 'link': 'https://www.0to255.com/', 'desc': ''} , {'name': 'nord ', 'link': 'https://github.com/arcticicestudio/nord', 'desc': ''} , {'name': 'colorkitty', 'link': 'https://colorkitty.com/', 'desc': ''} , {'name': 'design.youzan', 'link': 'http://design.youzan.com/', 'desc': ''} , {'name': '稿定设计', 'link': 'https://www.gaoding.com/', 'desc': ''} , {'name': '来画视频', 'link': 'https://www.laihua.com/', 'desc': ''} , {'name': 'Arkie 海报制作工具', 'link': 'https://www.arkie.cn/', 'desc': ''} , {'name': '比格 PPT', 'link': 'http://www.tretars.com/', 'desc': ''} , {'name': '优品 PPT', 'link': 'http://www.ypppt.com/', 'desc': ''} , {'name': 'processon在线作图', 'link': 'https://www.processon.com/', 'desc': ''} , {'name': '百度脑图', 'link': 'https://naotu.baidu.com', 'desc': ''} , {'name': 'uigradients', 'link': 'https://uigradients.com/', 'desc': ''} , {'name': 'freepik', 'link': 'https://www.freepik.com/', 'desc': ''} , {'name': '觅元素', 'link': 'http://www.51yuansu.com/', 'desc': ''} , {'name': '搞定设计', 'link': 'https://www.gaoding.com/', 'desc': ''} , {'name': '站酷', 'link': 'https://www.zcool.com.cn/', 'desc': ''} , {'name': '花瓣', 'link': 'https://huaban.com/', 'desc': ''} , {'name': '虎克', 'link': 'https://huke88.com/', 'desc': ''} , {'name': 'beTheme', 'link': 'https://themes.muffingroup.com/be/splash/', 'desc': ''} , {'name': '素材图片和视频', 'link': 'https://www.pexels.com/zh-cn/', 'desc': ''} , {'name': '图片集', 'link': 'https://zyj_yida.gitee.io/pic/', 'desc': ''} , {'name': 'PNG图片素材资源', 'link': 'https://www.pngsucai.com/', 'desc': ''} , {'name': '高清免费图片', 'link': 'https://www.pexels.com/', 'desc': ''} , {'name': '高清免费图片 2', 'link': 'https://unsplash.com/', 'desc': ''} , {'name': 'Unsplash', 'link': 'https://unsplash.com/', 'desc': ''} , {'name': 'iconfont', 'link': 'https://www.iconfont.cn/', 'desc': ''} , {'name': 'Ikonate', 'link': 'https://github.com/mikolajdobrucki/ikonate', 'desc': ''} , {'name': 'remixicon', 'link': 'https://remixicon.com/', 'desc': ''} , {'name': 'feather', 'link': 'https://github.com/feathericons/feather', 'desc': ''} , {'name': 'undraw', 'link': 'https://undraw.co/illustrations', 'desc': ''} , {'name': 'icomoon', 'link': 'https://icomoon.io/', 'desc': ''} , {'name': 'cssicon', 'link': 'http://cssicon.space/#/', 'desc': ''} , {'name': 'CSS triangle generator', 'link': 'http://apps.eky.hk/css-triangle-generator/', 'desc': ''} , {'name': 'clippy', 'link': 'http://bennettfeely.com/clippy/', 'desc': ''} , {'name': 'Lorem Picsum', 'link': 'https://picsum.photos/', 'desc': ''} , {'name': 'emoji表情', 'link': 'https://emojipedia.org/', 'desc': ''} , {'name': 'emoji表情备忘录', 'link': 'https://www.webfx.com/tools/emoji-cheat-sheet', 'desc': ''} , {'name': 'gitmoji', 'link': 'https://github.com/carloscuesta/gitmoji', 'desc': ''} , {'name': '微交互', 'link': 'http://aliscued.lofter.com/', 'desc': ''} , {'name': 'Little Big Details', 'link': 'http://littlebigdetails.com/', 'desc': ''} , {'name': 'cruip', 'link': 'https://cruip.com/', 'desc': ''} , {'name': 'Comixify', 'link': 'https://comixify.ii.pw.edu.pl/', 'desc': ''} , {'name': 'taiko-web', 'link': 'https://github.com/bui/taiko-web', 'desc': ''} , {'name': 'CSS Tricks','link': 'http://css-tricks.neatbang.com/','desc': 'CSS技巧收集与演示'}, {'name': 'CSS生成器', 'link': 'https://neumorphism.io/', 'desc': ''} , {'name': 'CSS渐变生成器', 'link': 'https://www.colorzilla.com/gradient-editor/', 'desc': ''} , {'name': 'CSS3-Box Shadow(阴影)', 'link': 'https://www.html.cn/tool/css3Preview/Box-Shadow.html', 'desc': ''} , {'name': '贝塞尔曲线生成器', 'link': 'https://cubic-bezier.com', 'desc': ''} , {'name': '花纹背景生成器', 'link': 'http://www.heropatterns.com/', 'desc': ''} , {'name': '花纹背景css', 'link': 'https://github.com/bansal-io/pattern.css', 'desc': ''} , ], \"娱乐\": [ {'name': '慕课网', 'link': 'https://www.imooc.com/', 'desc': ''} , {'name': '妙味课堂', 'link': 'https://www.miaov.com/', 'desc': ''} , {'name': '中国大学MOOC', 'link': 'https://www.icourse163.org/', 'desc': ''} , {'name': 'bilibili', 'link': 'https://www.bilibili.com/', 'desc': ''} , {'name': 'egghead', 'link': 'http://egghead.io', 'desc': ''} , {'name': 'CCTV、卫视高清直播', 'link': 'http://ivi.bupt.edu.cn/', 'desc': ''} , {'name': 'SoBooks', 'link': 'https://sobooks.cc/', 'desc': ''} , {'name': '鸠摩搜书', 'link': 'https://www.jiumodiary.com/', 'desc': ''} , {'name': '全历史', 'link': 'https://www.allhistory.com/', 'desc': ''} , {'name': '奇趣网站收藏家', 'link': 'https://fuun.fun/', 'desc': ''} , {'name': '帮你百度一下', 'link': 'http://www.baidu-x.com/', 'desc': ''} , {'name': '国际版', 'link': 'http://lmgtfy.com/', 'desc': ''} , {'name': 'wallhaven', 'link': 'https://alpha.wallhaven.cc/', 'desc': ''} , {'name': 'URL 地址播放 Emojis 动画', 'link': 'http://matthewrayfield.com/articles/animating-urls-with-javascript-and-emojis/#🌖', 'desc': ''} , {'name': \"Can't Unsee\", 'link': 'https://cantunsee.space/', 'desc': ''} , {'name': 'ggtalk', 'link': 'https://talk.swift.gg/', 'desc': ''} , {'name': 'awesome-comment', 'link': 'https://github.com/Blankj/awesome-comment', 'desc': ''} , {'name': 'text-img', 'link': 'https://www.text-image.com/index.html', 'desc': ''} , {'name': 'weird-fonts', 'link': 'https://github.com/beizhedenglong/weird-fonts', 'desc': ''} , {'name': 'snake', 'link': 'https://github.com/epidemian/snake', 'desc': ''} , {'name': 'zero-width-lib', 'link': 'https://github.com/yuanfux/zero-width-lib', 'desc': ''} , {'name': 'abbreviations', 'link': 'https://www.abbreviations.com/', 'desc': ''} , {'name': 'magi', 'link': 'https://magi.com/', 'desc': ''} , {'name': '诺基亚短信图片生成器', 'link': 'https://zzkia.noddl.me:8020/', 'desc': ''} , {'name': 'ENFI 下载器', 'link': 'https://www.macbl.com/app/internet/enfi', 'desc': ''} , {'name': 'macapp', 'link': 'https://www.macapp.so/', 'desc': ''} , {'name': 'appstorrent', 'link': 'https://appstorrent.ru/32-pixelmator-pro.html', 'desc': ''} , {'name': '大力盘', 'link': 'https://dalipan.com/', 'desc': ''} , {'name': '精校 完整 极致 Windows系统下载仓储站', 'link': 'https://www.hellowindows.cn/', 'desc': ''} , {'name': 'VideoFk','link': 'https://www.videofk.com/','desc': 'VideoFk 视频在线解析下载'}, ], \"接项目平台\": [ {'name': '云队友', 'link': 'https://www.duiyou360.com/', 'desc': ''} , {'name': 'upwork', 'link': 'https://www.fiverr.com/pages/freelancers-not-work?utm_source=google&utm_medium=cpc&utm_campaign=g_ge-row_ln-en_dv-desktop_cat-competitors_mt-exact_sf-upwork_qq-high-mid&utm_term=s_upwork_exact&utm_content=AdID%5e630319879658%5eKeyword%5eupwork%5ePlacement%5e%5eDevice%5ec&caid=17317009410&agid=137013247197&ad_id=630319879658&kw=upwork&lpcat=&show_join=true&cq_src=google_ads&cq_cmp=17317009410&cq_term=upwork&cq_plac=&cq_net=g&cq_plt=gp&gclid=Cj0KCQiA45qdBhD-ARIsAOHbVdGtPgJ8YHqIM_eGKydxWY8XKRcxe-hAH6o6m8nNuXpuIdrcf7vjShkaAmWTEALw_wcB&gclsrc=aw.ds', 'desc': ''} , {'name': 'toptal', 'link': 'https://www.toptal.com/', 'desc': ''} , {'name': '圆领', 'link': 'https://www.yuanling.com/home', 'desc': ''} , {'name': '程序员客栈', 'link': 'https://www.proginn.com', 'desc': ''} , {'name': '开源众包', 'link': 'https://zb.oschina.net', 'desc': ''} , {'name': '码市', 'link': 'https://www.codemart.com', 'desc': ''} , {'name': '猿急送', 'link': 'https://www.yuanjisong.com', 'desc': ''} , {'name': '开发邦', 'link': 'https://www.kaifabang.com', 'desc': ''} , ] }; for(var toolGroupName in toolGroups){ document.write(''+toolGroupName+''); for(var tool of toolGroups[toolGroupName]){ var desc = tool['desc'] === '' ? '' : '（'+tool['desc']+'）' document.write(''+tool['name']+desc+''); } document.write(''); } .tool { width: 25%; min-height: 30px; }"}],"posts":[{"title":"不卷学历和背景的赛道，也能月入过万？","slug":"创业笔记/不卷学历和背景的赛道，也能月入过万？","date":"2024-07-11T05:45:20.000Z","updated":"2024-07-11T07:55:19.549Z","comments":true,"path":"2024/07/不卷学历和背景的赛道，也能月入过万？/","link":"","permalink":"https://guoshunfa.com/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%8C%E6%99%AF%E7%9A%84%E8%B5%9B%E9%81%93%EF%BC%8C%E4%B9%9F%E8%83%BD%E6%9C%88%E5%85%A5%E8%BF%87%E4%B8%87%EF%BC%9F/","excerpt":"","text":"能力至上？好像并不是。现在就业环境首先看你的学历，其次是背景调查。能撑过去的还会有面试话术考核，在这种情况下大多数人可能就被筛选下来了。你说自己有能力，都没人鸟你。 有能力真的没饭吃？并不是，有个赛道并不需要学历和背景，那就是接单。这边很多伙伴靠接单月入过万，甚至几十个，还有正在当学生的程序员，只要有能力完全不看这些标签。 公司打工更多的是当螺丝钉，只需要管自己那一亩三分地。接单更考验的是综合实力，一人顶一个团队。举个例子，软件外包公司必要的环节：销售拉项目、项目经理管控项目、产品经理负责设计、美工负责界面设计、前端&amp;后端&amp;测试工程师负责开发和测试工作，让你自己做全部，其实也不太现实，毕竟一个人的精力是有限的，这个时候就需要考虑资源，你手里是否有这样的资源。假设我可以完成项目管理、开发测试，我可以找拉项目的伙伴接单，找懂界面设计的伙伴合作接单。这样一个项目你就可以接了，一个项目3w，按劳分配，共赢。 接单比技术更重要的是口碑。我们是要合作拿下这个项目，如果中途一个人掉链子，项目可就没了，你感觉无所谓，没了就看下一个单子。那我下次还会跟你合作嘛。所以口碑一定要保护好。合作的目的是共赢。感觉自己做不了，那就打个招呼退出，让组团的人再填充其他人。这样才有人跟你玩。 当然，你如果可以接受月入过万，就要接受一个月只能挣几千。接单本身就是不稳定的，接单人自称为自由职业者，自由本身就等于风险。能承担风险，就可以享受自由。 文章并不是希望各位都去接单，而是提供了一个可以选择的方向，提醒大家挣钱的方式有很多，没必要只看一种。 后面会陆续更新： 如何找靠谱的合作伙伴。 接单每个环节应该如何做。 如何接到优质单子。 光派单一个月能挣多少。 不了解互联网行业，如何在里面分一杯羹。","categories":[{"name":"创业","slug":"创业","permalink":"https://guoshunfa.com/categories/%E5%88%9B%E4%B8%9A/"}],"tags":[{"name":"知识","slug":"知识","permalink":"https://guoshunfa.com/tags/%E7%9F%A5%E8%AF%86/"}]},{"title":"回顾工作这几年","slug":"创业笔记/回顾工作这几年","date":"2024-07-09T06:19:23.000Z","updated":"2024-07-09T10:08:46.773Z","comments":true,"path":"2024/07/回顾工作这几年/","link":"","permalink":"https://guoshunfa.com/2024/07/%E5%9B%9E%E9%A1%BE%E5%B7%A5%E4%BD%9C%E8%BF%99%E5%87%A0%E5%B9%B4/","excerpt":"","text":"断更一年，今天开始恢复博客的更新。 ​ 先做个自我介绍，我叫郭顺发，哈尔滨人，坐标深圳，25岁，原Java全栈开发工程师，现在是自由职业者+创业。 ​ 回顾工作这几年…… ​ 19年毕业之后入职了一家北京的互联网企业，正式进入了软件开发工程师这个角色。跟大多数刚入行的同学一样，每天挠头，不清楚技术如何做，不清楚项目中的业务如何运转，我还偏内向，不太喜欢和同事沟通，导致效率很差。最后自己付出了很多努力才学会这些。非常感谢当时技术经理的耐心指导，和同事对我的帮助，这段经历是我最难忘的，也是我提升最多的。 ​ 疫情来了，年假回家，我被困到了哈尔滨，不让回北京。呆了一个多月，这也是我最后陪父亲的一段时光，我永远忘不了我爸火车站送我的样子。过了很短时间，父亲查出来了肝硬化，一个月就走了。当时直接辞职回家呆了一段时间，想陪陪家里人，也调整调整自己。后面回北京前后入职了几家公司，但是当时状态很不好，在北京的出租房颓废了半年。一直在思考一个问题，人生的意义是什么？想到一个人勤勤恳恳一辈子，就活到50出头。 ​ 后面玩了一款游戏，在游戏里遇到了很多伙伴，把自己投入进去后，突然想开了，我的人生就是要体验，要适当摆脱固有思维，做自己。 ​ 大变估真的能让一个人彻底改变，从那以后一改往日的性格，不再在乎别人的眼光，也不再那么内向。 ​ 后面联系了第一家公司的人事，又回到了那家公司，回去之后人都没变，还是那些个人，说实话感觉挺好的。 ​ 干了一年左右，感觉公司突然开始抓员工的考勤、日报，很不对劲，干活也很累，我对公司内部的事儿不想了解，我也不清楚发生了什么。 ​ 我突然有了个计划，回哈尔滨发展。 ​ 说做就做，哈尔滨的一家外包公司联系到了我，价格谈的不错，我就收拾收拾回去了。 ​ 体会了一下哈尔滨工作独特的处理方式，挺好玩的，工作也很轻松。项目一期做完，紧接着进入了二期，可惜的是外包公司换了，就是我的上级换了。合作的没那么愉快，控制欲太强了，哈，项目中节点交付完，我就撤了出来。 ​ 离职之后，计划找下一个落脚的城市，定制了一个1-2个月的旅游计划，到处逛逛。 济南：人是真多，红绿灯也多，去一个景点，打车跟步行一个时长。😑 青岛：都说青岛一半是东北人，去了是挺多，感觉到家了。我还是喜欢青岛的海边。 杭州：嗯，菜是不咋好吃。 苏州：风景挺好的。 东营：海边不错，就是没地铁。 深圳：啥都挺好，就是蟑螂大。 其他地方没啥影响了。 ​ 结束旅游之后，选了深圳这个城市，来了之后发现，md找不到工作（真不愿意背那些八股文）。 ​ 后面机缘巧合下发现了接单的方式，感觉很适合我，自由。就直接all in进去了，4月1号开始到现在，注册了一个工作室，全身心的投入进去，不断学习、复盘，总体来说感觉还行。但是感觉还是力使错了，还是得想办法。 ​ 最后总结一下，工作这几年遇到过大大小小的困难，但是回头看其实也就那样，有什么比死亡更难的呢。哈，干就完了。 后面会陆续更新博客内容，打算分享自己这段时间的创业经历和以往小小经验，感兴趣的同学可以关注一波。","categories":[{"name":"复盘","slug":"复盘","permalink":"https://guoshunfa.com/categories/%E5%A4%8D%E7%9B%98/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://guoshunfa.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"SpringBoot3集成Quartz极简版","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot/SpringBoot3集成Quartz极简版","date":"2023-07-18T01:14:01.000Z","updated":"2024-01-28T11:41:39.305Z","comments":true,"path":"2023/07/SpringBoot3集成Quartz极简版/","link":"","permalink":"https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E6%9E%81%E7%AE%80%E7%89%88/","excerpt":"","text":"文章项目：Github Project 前提文章所用版本： SpringBoot 3.1.1 Quartz 2.3.2 JDK 17 集成Quartz引入quartz maven库1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot用的是3.1.1，使用spring-boot-starter-quartz库，quartz版本默认为2.3.2。 添加Quartz配置文件将quartz.properties文件添加到resource目录下。 （quartz.properties文件不是必须的，但要使用除最基本的配置之外的任何配置，它必须位于类路径上。） 配置这是最重要的一点！Quartz是一个可配置的应用程序。配置 Quartz 的最佳方法是编辑 quartz.properties 文件，并将其放在应用程序的类路径中。 建议创建自己的 quartz.properties 文件，而不是复制其他案例的配置，这样更整洁。 可用属性的完整文档可在 Quartz 配置参考中找到。 为了快速启动和运行，基本的 quartz.properties 如下所示： 123org.quartz.scheduler.instanceName = MySchedulerorg.quartz.threadPool.threadCount = 3org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore 此配置创建的调度程序具有以下特征： org.quartz.scheduler.instanceName - 此调度程序的名称将是“MyScheduler”。 org.quartz.threadPool.threadCount - 线程池中有 3 个线程，这意味着最多可以同时运行 3 个作业。 org.quartz.jobStore.class - Quartz 的所有数据，例如作业和触发器的详细信息，都保存在内存中（而不是保存在数据库中）。 即使您有一个数据库并希望将其与Quartz一起使用，我也建议您在通过数据库打开一个全新的维度之前，先让Quartz与RamJobStore合作。 启动示例应用程序添加测试类QuartzTest 12345678910111213141516171819202122232425import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.impl.StdSchedulerFactory;import static org.quartz.JobBuilder.*;import static org.quartz.TriggerBuilder.*;import static org.quartz.SimpleScheduleBuilder.*;public class QuartzTest &#123; public static void main(String[] args) &#123; try &#123; // Grab the Scheduler instance from the Factory Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // and start it off scheduler.start(); scheduler.shutdown(); &#125; catch (SchedulerException se) &#123; se.printStackTrace(); &#125; &#125;&#125; 请注意代码示例中的静态导入;这些将在下面的代码示例中发挥作用。 如果您尚未设置日志记录，则所有日志都将发送到控制台，您的输出将如下所示： 12345678910111213141516171809:24:01.268 [main] INFO org.quartz.impl.StdSchedulerFactory -- Using default implementation for ThreadExecutor09:24:01.311 [main] INFO org.quartz.core.SchedulerSignalerImpl -- Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl09:24:01.311 [main] INFO org.quartz.core.QuartzScheduler -- Quartz Scheduler v.2.3.2 created.09:24:01.312 [main] INFO org.quartz.simpl.RAMJobStore -- RAMJobStore initialized.09:24:01.313 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler meta-data: Quartz Scheduler (v2.3.2) &#x27;MyScheduler&#x27; with instanceId &#x27;NON_CLUSTERED&#x27; Scheduler class: &#x27;org.quartz.core.QuartzScheduler&#x27; - running locally. NOT STARTED. Currently in standby mode. Number of jobs executed: 0 Using thread pool &#x27;org.quartz.simpl.SimpleThreadPool&#x27; - with 3 threads. Using job-store &#x27;org.quartz.simpl.RAMJobStore&#x27; - which does not support persistence. and is not clustered.09:24:01.313 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler &#x27;MyScheduler&#x27; initialized from default resource file in Quartz package: &#x27;quartz.properties&#x27;09:24:01.313 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler version: 2.3.209:24:01.314 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED started.09:24:01.315 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutting down.09:24:01.315 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED paused.09:24:01.315 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutdown complete. 为了更有效的展示定时器的呈现效果，这里再加一下。 调整QuartzTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.Trigger;import org.quartz.impl.StdSchedulerFactory;import static org.quartz.JobBuilder.*;import static org.quartz.TriggerBuilder.*;import static org.quartz.SimpleScheduleBuilder.*;public class QuartzTest &#123; public static void main(String[] args) &#123; try &#123; // 从工厂获取调度程序实例 Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 并启动它 scheduler.start(); // 定义作业并将其与我们的 HelloJob 类绑定 JobDetail job = newJob(HelloJob.class) .withIdentity(&quot;job1&quot;, &quot;group1&quot;) .build(); // 触发作业立即运行，然后每 3 秒重复一次 Trigger trigger = newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) .startNow() .withSchedule(simpleSchedule() .withIntervalInSeconds(3) .repeatForever()) .build(); // 告诉quartz使用我们的触发器安排作业 scheduler.scheduleJob(job, trigger); Thread.sleep(60000); scheduler.shutdown(); &#125; catch (SchedulerException se) &#123; se.printStackTrace(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 使用 StdSchedulerFactory.getDefaultScheduler（） 获取调度程序后，应用程序在调用 scheduler.shutdown（） 之前不会终止，因为会有活动线程。 添加定时任务类HelloJob 12345678910111213141516import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;public class HelloJob implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; try &#123; System.out.println(&quot;我是HelloJob，我开始执行。&quot;); Thread.sleep(600); System.out.println(&quot;我是HelloJob，我执行结束。&quot;); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 控制台输出结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626309:36:46.942 [main] INFO org.quartz.impl.StdSchedulerFactory -- Using default implementation for ThreadExecutor09:36:46.973 [main] INFO org.quartz.core.SchedulerSignalerImpl -- Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl09:36:46.973 [main] INFO org.quartz.core.QuartzScheduler -- Quartz Scheduler v.2.3.2 created.09:36:46.974 [main] INFO org.quartz.simpl.RAMJobStore -- RAMJobStore initialized.09:36:46.976 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler meta-data: Quartz Scheduler (v2.3.2) &#x27;MyScheduler&#x27; with instanceId &#x27;NON_CLUSTERED&#x27; Scheduler class: &#x27;org.quartz.core.QuartzScheduler&#x27; - running locally. NOT STARTED. Currently in standby mode. Number of jobs executed: 0 Using thread pool &#x27;org.quartz.simpl.SimpleThreadPool&#x27; - with 3 threads. Using job-store &#x27;org.quartz.simpl.RAMJobStore&#x27; - which does not support persistence. and is not clustered.09:36:46.976 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler &#x27;MyScheduler&#x27; initialized from default resource file in Quartz package: &#x27;quartz.properties&#x27;09:36:46.976 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler version: 2.3.209:36:46.977 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED started.我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。我是HelloJob，我执行结束。我是HelloJob，我开始执行。09:37:47.047 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutting down.09:37:47.047 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED paused.09:37:47.048 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutdown complete.我是HelloJob，我执行结束。与目标 VM 断开连接, 地址为: &#x27;&#x27;127.0.0.1:60612&#x27;，传输: &#x27;套接字&#x27;&#x27;进程已结束,退出代码0 参考文章 Configuration Reference (quartz-scheduler.org)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Quartz","slug":"Quartz","permalink":"https://guoshunfa.com/tags/Quartz/"}]},{"title":"SpringBoot3集成Quartz详细版","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot/SpringBoot3集成Quartz详细版","date":"2023-07-18T01:14:01.000Z","updated":"2024-01-28T11:41:39.306Z","comments":true,"path":"2023/07/SpringBoot3集成Quartz详细版/","link":"","permalink":"https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E8%AF%A6%E7%BB%86%E7%89%88/","excerpt":"","text":"文章项目：Github Project 简介本文章会描述如何用SpringBoot更好的集成Quartz定时器，从Quartz配置、如何持久化、如何设计等方面进行描述。本文章不 文章所用版本： SpringBoot 3.1.1 Quartz 2.3.2 JDK 17 Mysql 8.0.33 MongoDB 6.0.8 Quartz配置描述Quartz 的配置通常通过使用属性文件来完成，并结合使用 StdSchedulerFactory （使用配置文件并实例化调度程序）。 默认情况下，StdSchedulerFactory 从“当前工作目录”加载一个名为“quartz.properties”的属性文件。 如果失败，则加载位于 org&#x2F;quartz 包中的“quartz.properties”文件（作为资源）。如果你 希望使用这些默认值以外的文件，您必须定义系统属性“org.quartz.properties”以指向 所需的文件。 或者，您可以通过在之前调用 initialize（xx） 方法之一来显式初始化工厂 在 StdSchedulerFactory 上调用 getScheduler（）。 指定的 JobStore、ThreadPool 和其他 SPI 类的实例将按名称创建，然后按名称创建 配置文件中为它们指定的其他属性将通过调用等效的“set”在实例上设置。 方法。例如，如果属性文件包含属性“org.quartz.jobStore.myProp &#x3D; 10”，则在 JobStore 类已被实例化，将在其上调用方法 ‘setMyProp（）’。类型转换为基元 Java 类型（整数、长整型、浮点型、双精度型、布尔值和字符串）在调用属性的 setter 之前执行 方法。 一个属性可以通过按照约定指定值来引用另一个属性的值 “$@other.property.name”，例如，引用调度程序的实例名称作为某些其他属性的值， 您将使用“$@org.quartz.scheduler.instanceName”。 主配置 主调度程序设置的配置。 这些属性配置调度程序的标识以及各种其他“顶级”设置。 属性名称 要求 类型 默认值 org.quartz.scheduler.instanceName no string ‘QuartzScheduler’ org.quartz.scheduler.instanceId no string ‘NON_CLUSTERED’ org.quartz.scheduler.instanceIdGenerator.class no string (class name) org.quartz.simpl .SimpleInstanceIdGenerator org.quartz.scheduler.threadName no string instanceName + ‘_QuartzSchedulerThread’ org.quartz.scheduler .makeSchedulerThreadDaemon no boolean false org.quartz.scheduler .threadsInheritContextClassLoaderOfInitializer no boolean false org.quartz.scheduler.idleWaitTime no long 30000 org.quartz.scheduler.dbFailureRetryInterval no long 15000 org.quartz.scheduler.classLoadHelper.class no string (class name) org.quartz.simpl .CascadingClassLoadHelper org.quartz.scheduler.jobFactory.class no string (class name) org.quartz.simpl.PropertySettingJobFactory org.quartz.context.key.SOME_KEY no string none org.quartz.scheduler.userTransactionURL no string (url) ‘java:comp&#x2F;UserTransaction’ org.quartz.scheduler .wrapJobExecutionInUserTransaction no boolean false org.quartz.scheduler.skipUpdateCheck no boolean false org.quartz.scheduler .batchTriggerAcquisitionMaxCount no int 1 org.quartz.scheduler .batchTriggerAcquisitionFireAheadTimeWindow no long 0 org.quartz.scheduler.instanceName 可以是任何字符串，并且该值对调度程序本身没有意义 - 而是用作客户端的机制 用于在同一程序中使用多个实例时区分调度程序的代码。如果您使用的是群集 功能，您必须对集群中“逻辑上”相同的调度程序的每个实例使用相同的名称。 org.quartz.scheduler.instanceId 可以是任何字符串，但对于所有调度程序必须是唯一的，就好像它们是 簇。如果您希望为您生成 Id，则可以使用值“AUTO”作为实例 ID。或值 “SYS_PROP”，如果您希望值来自系统属性“org.quartz.scheduler.instanceId”。 org.quartz.scheduler.instanceIdGenerator.class 仅当 org.quartz.scheduler.instanceId 设置为“AUTO”时才使用。默认为 “org.quartz.simpl.SimpleInstanceIdGenerator”，它根据主机名和时间戳生成实例 ID。 其他 IntanceIdGenerator 实现包括 SystemPropertyInstanceIdGenerator（获取实例 ID 来自系统属性“org.quartz.scheduler.instanceId”，以及使用 本地主机名（InetAddress.getLocalHost().getHostName()）。您还可以实现 InstanceIdGenerator接口。 org.quartz.scheduler.threadName 可以是作为 java 线程的有效名称的任何字符串。如果未指定此属性，线程将收到 调度程序的名称（“org.quartz.scheduler.instanceName”）加上附加的字符串“_QuartzSchedulerThread”。 org.quartz.scheduler.makeSchedulerThreadDaemon 一个布尔值（“true”或“false”），它指定调度程序的主线程应该是守护程序线程还是 不。另请参阅 org.quartz.scheduler.makeSchedulerThreadDaemon 属性，用于调整 SimpleThreadPool （如果这是线程池实现） 您正在使用（很可能是这种情况）。 org.quartz.scheduler.threadsInheritContextClassLoaderOfInitializer 一个布尔值（“true”或“false”），它指定 Quartz 生成的线程是否将继承上下文 初始化线程（初始化 Quartz 实例的线程）的类加载器。这将影响石英主 调度线程、JDBCJobStore 的 misfire 处理线程（如果使用 JDBCJobStore）、集群恢复线程（如果使用 使用集群），以及 SimpleThreadPool 中的线程（如果使用 SimpleThreadPool）。将此值设置为“true”可能会 帮助类装入、JNDI 查找以及与在应用程序服务器中使用 Quartz 相关的其他问题。 org.quartz.scheduler.idleWaitTime 是计划程序在重新查询可用触发器之前等待的时间量（以毫秒为单位），当 否则调度程序处于空闲状态。通常，您不必“调整”此参数，除非您使用的是 XA 事务， 并且存在延迟触发应立即触发的触发器的问题。小于 5000 毫秒的值不是 建议使用，因为它会导致过多的数据库查询。小于 1000 的值是不合法的。 org.quartz.scheduler.dbFailureRetryInterval 计划程序在检测到丢失 作业存储中的连接（例如，与数据库的连接）。这个参数在使用时显然不是很有意义 RamJobStore. org.quartz.scheduler.classLoadHelper.class 默认使用最健壮的方法，即使用 “org.quartz.simpl.CascadingClassLoadHelper” 类 - 其中 turn 使用每隔一个 ClassLoadHelper 类，直到一个类工作。您可能不应该发现需要指定任何其他 类，尽管应用程序服务器中似乎发生了奇怪的事情。所有电流可能 ClassLoadHelper 实现可以在 org.quartz.simpl 包中找到。 org.quartz.scheduler.jobFactory.class 要使用的作业工厂的类名。JobFatcory 负责生成 JobClass 的实例。 默认值是“org.quartz.simpl.PropertySettingJobFactory”，它只是在类上调用 newInstance()来生成 每次即将执行时都有一个新实例。PropertySettingJobFactory 也反射性地 使用 SchedulerContext 和 Job and Trigger JobDataMap 的内容设置作业的 Bean 属性。 org.quartz.context.key.SOME_KEY 表示将作为字符串放入“调度程序上下文”的名称-值对。（请参阅 Scheduler.getContext（））。 例如，设置“org.quartz.context.key.MyKey &#x3D; MyValue”将执行等效于 scheduler.getContext().put(“MyKey”， “MyValue”). 除非使用的是 JTA 事务，否则配置文件中应省略与事务相关的属性。 org.quartz.scheduler.userTransactionURL 应设置为 JNDI URL，Quartz 可以在该 URL 上找到应用程序服务器的 UserTransaction 管理器。默认 值（如果未指定）为 “java:comp&#x2F;UserTransaction” - 它适用于几乎所有的应用程序服务器。网络圈 用户可能需要将此属性设置为“JTA&#x2F;UserTransaction”。仅当 Quartz 配置为使用 JobStoreCMT 和 org.quartz.scheduler.wrapJobExecutionInUserTransaction 设置为 true。 org.quartz.scheduler.wrapJobExecutionInUserTransaction 如果希望 Quartz 在对作业调用 execute 之前启动用户事务，则应设置为 “true”。Tx将 在作业的执行方法完成后提交，并在更新作业数据映射（如果它是有状态作业）之后提交。这 默认值为“假”。您可能还对使用 @ExecuteInJTATransaction 注释感兴趣 在您的作业类上，这使您可以控制单个作业是否应启动 JTA 事务 - 而此属性会导致它对所有作业发生。 org.quartz.scheduler.skipUpdateCheck 是否跳过运行快速 Web 请求以确定是否有可用于 Quartz 的更新版本 下载。如果检查运行，并找到更新，它将在 Quartz 的日志中报告为可用。你 还可以使用系统属性“org.terracotta.quartz.skipUpdateCheck&#x3D;true”禁用更新检查（其中 您可以在系统环境中设置，也可以在 java 命令行上设置为 -D）。建议您禁用 生产部署的更新检查。 org.quartz.scheduler.batchTriggerAcquisition MaxCount 允许调度程序节点一次获取（用于触发）的最大触发器数。默认值 为 1。数字越大，触发效率越高（在需要 一次全部触发） - 但代价是群集节点之间可能存在不平衡的负载。如果此值 属性设置为 &gt; 1，并使用 JDBC JobStore，然后属性“org.quartz.jobStore.acquireTriggersWithinLock” 必须设置为“true”以避免数据损坏。 org.quartz.scheduler.batchTriggerAcquisition FireAheadTimeWindow 允许在预定触发时间之前获取和触发触发器的时间量（以毫秒为单位）。默认值为 0。数字越大，批量获取触发触发器的可能性就越大 并一次触发多个触发器 - 代价是触发器时间表未得到精确遵守（触发器可能会 早点开这个量）。在调度程序具有非常大的情况下，这可能很有用（为了性能起见） 需要同时或接近同时触发的触发器数。 线程池的配置 调整作业执行的资源 Property Name Required Type Default Value org.quartz.threadPool.class yes string (class name) null org.quartz.threadPool.threadCount yes int -1 org.quartz.threadPool.threadPriority no int Thread.NORM_PRIORITY (5) org.quartz.threadPool.class 是要使用的线程池实现的名称。Quartz附带的线程池是“org.quartz.simpl.SimpleThreadPool”，应该满足几乎每个用户的需求。它的行为非常简单，并且经过了很好的测试。它提供了一个固定大小的线程池，这些线程池“存活”了调度程序的生存期。 org.quartz.threadPool.threadCount 可以是任何正整数，尽管您应该意识到只有 1 到 100 之间的数字非常实用。这是可用于并发执行作业的线程数。如果您只有几个作业每天触发几次，那么 1 个线程就足够了！如果您有数以万计的作业，每分钟都会触发许多作业，那么您可能希望线程计数更像 50 或 100（这在很大程度上取决于您的作业执行的工作的性质以及您的系统资源！ org.quartz.threadPool.threadPriority 可以是介于 Thread.MIN_PRIORITY (which is 1)和 Thread.MAX_PRIORITY (which is 10)之间的任何 int。默认值为 Thread.NORM_PRIORITY (5)。 特定于简单线程池的属性 Property Name Required Type Default Value org.quartz.threadPool.makeThreadsDaemons no boolean false org.quartz.threadPool.threadsInheritGroupOfInitializingThread no boolean true org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread no boolean false org.quartz.threadPool.threadNamePrefix no string [Scheduler Name]_Worker org.quartz.threadPool.makeThreadsDaemons 可以设置为“true”，以将池中的线程创建为守护程序线程。默认值为“假”。另请参阅 org.quartz.scheduler.makeSchedulerThreadDaemon 属性。 org.quartz.threadPool.threadsInheritGroupOfInitializingThread 可以为“真”或“假”，默认为 true。 org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread 可以是“真”或“假”，默认为假。 org.quartz.threadPool.threadNamePrefix 工作线程池中线程名称的前缀 - 将延迟一个数字。 自定义线程池如果使用自己的线程池实现，则只需将属性命名为： 设置自定义线程池的属性 12org.quartz.threadPool.class = com.mycompany.goo.FooThreadPoolorg.quartz.threadPool.somePropOfFooThreadPool = someValue 侦听器的配置全局侦听器可以由 StdSchedulerFactory 实例化和配置，或者您的应用程序可以自己完成 ，然后将侦听器注册到计划程序。“全局”听众收听每个事件 作业&#x2F;触发器，而不仅仅是直接引用它们的作业&#x2F;触发器。 通过配置文件配置侦听器包括给出一个名称，然后指定 类名，以及要在实例上设置的任何其他属性。该类必须具有无参数构造函数，并且 属性以反射方式设置。仅支持基元数据类型值（包括字符串）。 因此，定义“全局”触发器侦听器的常规模式是： 配置全局触发器侦听器 123org.quartz.triggerListener.NAME.class = com.foo.MyListenerClassorg.quartz.triggerListener.NAME.propName = propValueorg.quartz.triggerListener.NAME.prop2Name = prop2Value 定义“全局”JobListener 的一般模式是： 配置全局作业侦听器 123org.quartz.jobListener.NAME.class = com.foo.MyListenerClassorg.quartz.jobListener.NAME.propName = propValueorg.quartz.jobListener.NAME.prop2Name = prop2Value 配置调度程序插件 向调度程序添加功能 就像通过配置文件配置插件的侦听器一样，包括给出一个名称，然后指定类名，以及要在实例上设置的任何其他属性。该类必须具有 no-arg 构造函数，并且属性以反射方式设置。仅支持基元数据类型值（包括字符串）。 因此，定义插件的一般模式是： 配置插件 123org.quartz.plugin.NAME.class = com.foo.MyPluginClassorg.quartz.plugin.NAME.propName = propValueorg.quartz.plugin.NAME.prop2Name = prop2Value Quartz附带了几个插件，可以在org.quartz.plugins包（和子包）中找到。配置其中一些的示例如下： 日志记录触发器历史记录插件的示例配置日志记录触发器历史插件捕获触发事件（它也是一个触发器侦听器）并使用雅加达共享资源日志记录。请参阅该类的 JavaDoc 以获取所有可能参数的列表。 日志记录触发器历史记录插件的示例配置 123456org.quartz.plugin.triggHistory.class = \\ org.quartz.plugins.history.LoggingTriggerHistoryPluginorg.quartz.plugin.triggHistory.triggerFiredMessage = \\ Trigger \\&#123;1\\&#125;.\\&#123;0\\&#125; fired job \\&#123;6\\&#125;.\\&#123;5\\&#125; at: \\&#123;4, date, HH:mm:ss MM/dd/yyyy&#125;org.quartz.plugin.triggHistory.triggerCompleteMessage = \\ Trigger \\&#123;1\\&#125;.\\&#123;0\\&#125; completed firing job \\&#123;6\\&#125;.\\&#123;5\\&#125; at \\&#123;4, date, HH:mm:ss MM/dd/yyyy\\&#125;. XML 调度数据处理器插件的示例配置作业初始化插件从 XML 文件中读取一组作业和触发器，并在初始化期间将它们添加到调度程序中。它还可以删除现有数据。有关更多详细信息，请参阅该类的 JavaDoc。 作业初始化插件的示例配置 12345org.quartz.plugin.jobInitializer.class = \\ org.quartz.plugins.xml.XMLSchedulingDataProcessorPluginorg.quartz.plugin.jobInitializer.fileNames = \\ data/my_job_data.xmlorg.quartz.plugin.jobInitializer.failOnFileNotFound = true 该文件的 XML 架构定义可在此处找到： http://www.quartz-scheduler.org/xml/job_scheduling_data_1_8.xsd 关机钩子插件配置示例关闭钩子插件捕获 JVM 终止的事件，并在调度程序上调用关闭。 关机钩子插件的配置示例 123org.quartz.plugin.shutdownhook.class = \\ org.quartz.plugins.management.ShutdownHookPluginorg.quartz.plugin.shutdownhook.cleanShutdown = true RMI 服务器和客户机的配置 使用远程的 Quartz 实例 没有一个主要属性是必需的，并且所有属性都有“合理”的默认值。通过RMI使用石英时，您 需要启动一个 Quartz 实例，并将其配置为通过 RMI “导出”其服务。然后，创建客户端到 服务器通过配置 Quartz 调度程序将其工作“代理”到服务器。 某些用户在客户端和服务器之间遇到类可用性（即作业类）问题。要工作 通过这些问题，您需要了解RMI的“代码库”和RMI安全管理器。您可能会发现这些 有用的资源： RMI和代码库的出色描述：http://www.kedwards.com/jini/codebase.html。重点之一 就是要意识到“代码库”被客户端使用！ 有关安全管理器的快速信息：http://gethelp.devx.com/techtips/java_pro/10MinuteSolutions/10min0500.asp 最后，从Java API文档中，阅读RMISecurityManager的文档。 Property Name Required Default Value org.quartz.scheduler.rmi.export no false org.quartz.scheduler.rmi.registryHost no ‘localhost’ org.quartz.scheduler.rmi.registryPort no 1099 org.quartz.scheduler.rmi.createRegistry no ‘never’ org.quartz.scheduler.rmi.serverPort no random org.quartz.scheduler.rmi.proxy no false org.quartz.scheduler.rmi.export 如果您希望 Quartz 调度程序通过 RMI 将自身导出为服务器，请将“rmi.export”标志设置为 true。 org.quartz.scheduler.rmi.registryHost 可以找到 RMI 注册表的主机（通常为“本地主机”）。 org.quartz.scheduler.rmi.registryPort RMI 注册表正在侦听的端口（通常为 1099）。 org.quartz.scheduler.rmi.createRegistry 设置“rmi.createRegistry”标志，根据您希望Quartz如何导致创建RMI注册表。使用“假” 或“从不”，如果您不希望 Quartz 创建注册表（例如，如果您已经运行了外部注册表）。用 “true”或“as_needed”，如果您希望 Quartz 首先尝试使用现有注册表，然后回退到创建 一。如果您希望 Quartz 尝试创建注册表，然后回退到使用现有注册表，请使用“always”。如果 注册表已创建，它将绑定到给定的“org.quartz.scheduler.rmi.registryPort”属性中的端口号，并且 ‘org.quartz.rmi.registryHost’ 应该是 “localhost”。 org.quartz.scheduler.rmi.serverPort Quartz 计划程序服务将绑定和侦听连接的端口。默认情况下，RMI 服务 将“随机”选择一个端口，因为调度程序绑定到 RMI 注册表。 org.quartz.scheduler.rmi.proxy 如果要连接到（使用）远程服务的调度程序，请将“org.quartz.scheduler.rmi.proxy”标志设置为 true。 然后，还必须为 RMI 注册表进程指定主机和端口 - 通常是“localhost”端口 1099。 为“org.quartz.scheduler.rmi.export”和“org.quartz.scheduler.rmi.export”指定“true”值是没有意义的 “org.quartz.scheduler.rmi.proxy”在同一个配置文件中 - 如果这样做，“导出”选项将被忽略。值为 “export”和“proxy”属性的“false”当然是有效的，如果您没有通过RMI使用Quartz。 RAMJobStore 的配置 将作业和触发器存储在内存中 RAMJobStore 用于将调度信息（作业、触发器和日历）存储在内存中。RAMJobStore 快速且轻量级，但当进程终止时，所有调度信息都会丢失。 RAMJobStore 是通过设置“org.quartz.jobStore.class”属性来选择的，如下所示： 将调度程序的作业存储设置为 RAMJobStore 1org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore RAMJobStore 可以使用以下属性进行调整： Property Name Required Type Default Value org.quartz.jobStore.misfireThreshold no int 60000 org.quartz.jobStore.misfireThreshold 调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。 JDBC-JobStoreTX 的配置 通过JDBC将作业和触发器存储在数据库中 JDBCJobStore 用于在关系数据库中存储调度信息（作业、触发器和日历）。实际上，您可以根据所需的事务行为选择两个单独的 JDBCJobStore 类。 JobStoreTX 通过在每次操作（例如添加作业）后在数据库连接上调用 commit（）（或 rollback（））来管理所有事务本身。JDBCJobStore 适用于在独立应用程序中使用 Quartz，或者如果应用程序未使用 JTA 事务，则适用于 Servlet 容器。 JobStoreTX是通过设置“org.quartz.jobStore.class”属性来选择的，如下所示： 将调度程序的作业存储设置为 JobStoreTX 1org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX 可以使用以下属性调整 JobStoreTX： Property Name Required Type Default Value org.quartz.jobStore.driverDelegateClass yes string null org.quartz.jobStore.dataSource yes string null org.quartz.jobStore.tablePrefix no string “QRTZ_” org.quartz.jobStore.useProperties no boolean false org.quartz.jobStore.misfireThreshold no int 60000 org.quartz.jobStore.isClustered no boolean false org.quartz.jobStore.clusterCheckinInterval no long 15000 org.quartz.jobStore.maxMisfiresToHandleAtATime no int 20 org.quartz.jobStore.dontSetAutoCommitFalse no boolean false org.quartz.jobStore.selectWithLockSQL no string “SELECT * FROM {0}LOCKS WHERE SCHED_NAME &#x3D; {1} AND LOCK_NAME &#x3D; ? FOR UPDATE” org.quartz.jobStore.txIsolationLevelSerializable no boolean false org.quartz.jobStore.acquireTriggersWithinLock no boolean false (or true - see doc below) org.quartz.jobStore.lockHandler.class no string null org.quartz.jobStore.driverDelegateInitString no string null org.quartz.jobStore.driverDelegateClass 驱动程序代表了解不同数据库系统的特定“方言”。可能的选择包括： org.quartz.impl.jdbcjobstore.StdJDBCDelegate （用于完全符合JDBC的驱动程序） org.quartz.impl.jdbcjobstore.MSSQLDelegate （for Microsoft SQL Server， and Sybase） org.quartz.impl.jdbcjobstore.PostgreSQLDelegate org.quartz.impl.jdbcjobstore.WebLogicDelegate （for WebLogic drivers） org.quartz.impl.jdbcjobstore.oracle.OracleDelegate org.quartz.impl.jdbcjobstore.oracle.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序） org.quartz.impl.jdbcjobstore.oracle.weblogic.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序） org.quartz.impl.jdbcjobstore.CloudscapeDelegate org.quartz.impl.jdbcjobstore.DB2v6Delegate org.quartz.impl.jdbcjobstore.DB2v7Delegate org.quartz.impl.jdbcjobstore.DB2v8Delegate org.quartz.impl.jdbcjobstore.HSQLDBDelegate org.quartz.impl.jdbcjobstore.PointbaseDelegate org.quartz.impl.jdbcjobstore.SybaseDelegate 请注意，已知许多数据库与 StdJDBCDelegate 配合使用，而其他数据库已知与其他数据库的委托配合使用，例如 Derby 与 Cloudscape 委托配合良好（这并不奇怪）。 org.quartz.jobStore.dataSource 此属性的值必须是配置属性文件中定义的数据源之一的名称。有关详细信息，请参阅数据源的配置文档。 org.quartz.jobStore.tablePrefix JDBCJobStore 的“表前缀”属性是一个字符串，等于在数据库中创建的 Quartz 表的前缀。如果 Quartz 表使用不同的表前缀，则可以在同一数据库中拥有多组 Quartz 表。 org.quartz.jobStore.useProperties “use properties”标志指示 JDBCJobStore JobDataMaps 中的所有值都将是字符串，因此可以存储为名称-值对，而不是在 BLOB 列中以序列化形式存储更复杂的对象。这可能很方便，因为您可以避免将非字符串类序列化为 BLOB 时可能出现的类版本控制问题。 org.quartz.jobStore.misfireThreshold 调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。 org.quartz.jobStore.isClustered 设置为“true”以打开聚类功能。如果有多个 Quartz 实例使用同一组数据库表，则必须将此属性设置为“true”…否则你将经历浩劫。有关详细信息，请参阅群集的配置文档。 org.quartz.jobStore.clusterCheckinInterval 设置此实例与群集的其他实例“签入”*的频率（以毫秒为单位）。影响检测失败实例的速度。 org.quartz.jobStore.maxMisfiresToHandleAtATime 作业存储将在给定传递中处理的最大触发触发器数。一次处理多个（超过几十个）可能会导致数据库表被锁定足够长的时间，以至于触发其他（尚未错误触发）触发器的性能可能会受到阻碍。 org.quartz.jobStore.dontSetAutoCommitFalse 将此参数设置为“true”告诉 Quartz 不要在从数据源获取的连接上调用 setAutoCommit（false）。这在某些情况下可能会有所帮助，例如，如果您的驱动程序在已经关闭时被调用时会抱怨。此属性默认为 false，因为大多数驱动程序要求调用 setAutoCommit（false）。 org.quartz.jobStore.selectWithLockSQL 必须是在“LOCKS”表中选择一行并在该行上放置锁的 SQL 字符串。如果未设置，则默认值为“从{0}锁定中选择 *，其中 SCHED_NAME &#x3D; {1} 和 LOCK_NAME &#x3D; ？用于更新“，适用于大多数数据库。“{0}”在运行时替换为上面配置的TABLE_PREFIX。“{1}”将替换为调度程序的名称。 org.quartz.jobStore.txIsolationLevelSerializable 值“true”告诉Quartz（使用JobStoreTX或CMT时）在JDBC连接上调用setTransactionIsolation（Connection.TRANSACTION_SERIALIZABLE）。这有助于防止某些数据库在高负载下出现锁定超时，以及“持久”事务。 org.quartz.jobStore.acquireTriggersWithinLock 是否应在显式数据库锁中获取下一个要触发的触发器。这曾经是必要的（在以前的Quartz版本中）以避免特定数据库的死锁，但不再被认为是必要的，因此默认值为“false”。 如果将“org.quartz.scheduler.batchTriggerAcquisition MaxCount”设置为 &gt; 1，并且使用了 JDBC JobStore，则必须将此属性设置为“true”以避免数据损坏（从 Quartz 2.1.1 开始，如果 batchTriggerAcquisitionMaxCount 设置为 1，则“true”现在是默认值&gt;）。 org.quartz.jobStore.lockHandler.class 用于生成 org.quartz.impl.jdbcjobstore.Semaphore 实例的类名，用于对作业存储数据进行锁定控制。这是一项高级配置功能，大多数用户不应使用它。默认情况下，Quartz 将选择最合适的（预捆绑）信号量实现来使用。“org.quartz.impl.jdbcjobstore.UpdateLockRowSemaphore” QUARTZ-497可能对MS SQL Server用户感兴趣。参见石英-441。 org.quartz.jobStore.driverDelegateInitString 可在初始化期间传递给 DriverDelegate 的属性（及其值）的管道分隔列表。 字符串的格式如下： 1&quot;settingName=settingValue|otherSettingName=otherSettingValue|...&quot; StdJDBCDelegate 及其所有后代（所有随 Quartz 一起提供的委托）支持名为“triggerPersistenceDelegateClasses”的属性，该属性可以设置为以逗号分隔的类列表，这些类实现用于存储自定义触发器类型的 TriggerPersistenceDelegate 接口。有关为自定义触发器编写持久性委托的示例，请参阅 Java 类 SimplePropertiesTriggerPersistenceDelegateSupport 和 SimplePropertiesTriggerPersistenceDelegateSupport。 JDBC-JobStoreCMT 的配置 JDBC with JTA 容器管理 交易 JDBCJobStore 用于在关系数据库中存储调度信息（作业、触发器和日历）。实际上，您可以根据所需的事务行为选择两个单独的 JDBCJobStore 类。 JobStoreCMT依赖于由使用Quartz的应用程序管理的事务。在尝试调度（或取消调度）作业&#x2F;触发器之前，JTA 事务必须正在进行中。这允许调度的“工作”成为应用程序“更大”事务的一部分。JobStoreCMT 实际上需要使用两个数据源 - 一个数据源的连接事务由应用程序服务器（通过 JTA）管理，另一个数据源的连接不参与全局 （JTA） 事务。JobStoreCMT 适用于应用程序使用 JTA 事务（例如通过 EJB Session Beans）来执行其工作的情况。 通过设置“org.quartz.jobStore.class”属性来选择JobStore，如下所示： 将调度程序的作业存储设置为 JobStoreCMT 1org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreCMT 可以使用以下属性调整 JobStoreCMT： Property Name Required Type Default Value org.quartz.jobStore.driverDelegateClass yes string null org.quartz.jobStore.dataSource yes string null org.quartz.jobStore.nonManagedTXDataSource yes string null org.quartz.jobStore.tablePrefix no string “QRTZ_” org.quartz.jobStore.useProperties no boolean false org.quartz.jobStore.misfireThreshold no int 60000 org.quartz.jobStore.isClustered no boolean false org.quartz.jobStore.clusterCheckinInterval no long 15000 org.quartz.jobStore.maxMisfiresToHandleAtATime no int 20 org.quartz.jobStore.dontSetAutoCommitFalse no boolean false org.quartz.jobStore.dontSetNonManagedTXConnectionAutoCommitFalse no boolean false org.quartz.jobStore.selectWithLockSQL no string “SELECT * FROM {0}LOCKS WHERE SCHED_NAME &#x3D; {1} AND LOCK_NAME &#x3D; ? FOR UPDATE” org.quartz.jobStore.txIsolationLevelSerializable no boolean false org.quartz.jobStore.txIsolationLevelReadCommitted no boolean false org.quartz.jobStore.acquireTriggersWithinLock no boolean false (or true - see doc below) org.quartz.jobStore.lockHandler.class no string null org.quartz.jobStore.driverDelegateInitString no string null org.quartz.jobStore.driverDelegateClass 驱动程序代表了解不同数据库系统的特定“方言”。可能的选择包括： org.quartz.impl.jdbcjobstore.StdJDBCDelegate （用于完全符合JDBC的驱动程序） org.quartz.impl.jdbcjobstore.MSSQLDelegate （for Microsoft SQL Server， and Sybase） org.quartz.impl.jdbcjobstore.PostgreSQLDelegate org.quartz.impl.jdbcjobstore.WebLogicDelegate （for WebLogic drivers） org.quartz.impl.jdbcjobstore.oracle.OracleDelegate org.quartz.impl.jdbcjobstore.oracle.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序） org.quartz.impl.jdbcjobstore.oracle.weblogic.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序） org.quartz.impl.jdbcjobstore.CloudscapeDelegate org.quartz.impl.jdbcjobstore.DB2v6Delegate org.quartz.impl.jdbcjobstore.DB2v7Delegate org.quartz.impl.jdbcjobstore.DB2v8Delegate org.quartz.impl.jdbcjobstore.HSQLDBDelegate org.quartz.impl.jdbcjobstore.PointbaseDelegate org.quartz.impl.jdbcjobstore.SybaseDelegate 请注意，已知许多数据库与 StdJDBCDelegate 配合使用，而其他数据库已知与其他数据库的委托配合使用，例如 Derby 与 Cloudscape 委托配合良好（这并不奇怪）。 org.quartz.jobStore.dataSource 此属性的值必须是配置属性文件中定义的数据源之一的名称。对于 JobStoreCMT，此数据源需要包含能够参与 JTA（例如容器管理的）事务的连接。这通常意味着数据源将在应用程序服务器内部由应用程序服务器配置和维护，Quartz 将通过 JNDI 获取它的句柄。有关详细信息，请参阅数据源的配置文档。 org.quartz.jobStore.nonManagedTXDataSource JobStoreCMT 需要一个（第二个）数据源，其中包含不属于容器管理事务的连接。此属性的值必须是配置属性文件中定义的数据源之一的名称。此数据源必须包含非 CMT 连接，或者换句话说，Quartz 直接调用 commit（） 和 rollback（） 的连接是合法的。 org.quartz.jobStore.tablePrefix JDBCJobStore 的“表前缀”属性是一个字符串，等于在数据库中创建的 Quartz 表的前缀。如果 Quartz 表使用不同的表前缀，则可以在同一数据库中拥有多组 Quartz 表。 org.quartz.jobStore.useProperties “use properties”标志指示 JDBCJobStore JobDataMaps 中的所有值都将是字符串，因此可以存储为名称-值对，而不是在 BLOB 列中以序列化形式存储更复杂的对象。这可能很方便，因为您可以避免将非字符串类序列化为 BLOB 时可能出现的类版本控制问题。 org.quartz.jobStore.misfireThreshold 调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。 org.quartz.jobStore.isClustered 设置为“true”以打开聚类功能。如果有多个 Quartz 实例使用同一组数据库表，则必须将此属性设置为“true”…否则你将经历浩劫。有关详细信息，请参阅群集的配置文档。 org.quartz.jobStore.clusterCheckinInterval 设置此实例与群集的其他实例“签入”*的频率（以毫秒为单位）。影响检测失败实例的速度。 org.quartz.jobStore.maxMisfiresToHandleAtATime 作业存储将在给定传递中处理的最大触发触发器数。一次处理多个（超过几十个）可能会导致数据库表被锁定足够长的时间，以至于触发其他（尚未错误触发）触发器的性能可能会受到阻碍。 org.quartz.jobStore.dontSetAutoCommitFalse 将此参数设置为“true”告诉 Quartz 不要在从数据源获取的连接上调用 setAutoCommit（false）。这在某些情况下可能会有所帮助，例如，如果您的驱动程序在已经关闭时被调用时会抱怨。此属性默认为 false，因为大多数驱动程序要求调用 setAutoCommit（false）。 org.quartz.jobStore.dontSetNonManagedTXConnectionAutoCommitFalse 与属性 org.quartz.jobStore.dontSetAutoCommitFalse 相同，只是它适用于非 ManagedTXDataSource。 org.quartz.jobStore.selectWithLockSQL 必须是在“LOCKS”表中选择一行并在该行上放置锁的 SQL 字符串。如果未设置，则默认值为“从{0}锁定中选择 *，其中 SCHED_NAME &#x3D; {1} 和 LOCK_NAME &#x3D; ？用于更新“，适用于大多数数据库。“{0}”在运行时替换为上面配置的TABLE_PREFIX。“{1}”将替换为调度程序的名称。 org.quartz.jobStore.txIsolationLevelSerializable 值“true”告诉Quartz在JDBC连接上调用setTransactionIsolation（Connection.TRANSACTION_SERIALIZABLE）。这有助于防止某些数据库在高负载下出现锁定超时，以及“持久”事务。 org.quartz.jobStore.txIsolationLevelReadCommit 当设置为 “true” 时，此属性告诉 Quartz 在非托管 JDBC 连接上调用 setTransactionIsolation（Connection.TRANSACTION_READ_COMMITTED）。这有助于防止某些数据库（如 DB2）在高负载下出现锁定超时，以及“持久”事务。 org.quartz.jobStore.acquireTriggersWithinLock 是否应在显式数据库锁中获取下一个要触发的触发器。这曾经是必要的（在以前的Quartz版本中）以避免特定数据库的死锁，但不再被认为是必要的，因此默认值为“false”。 如果将“org.quartz.scheduler.batchTriggerAcquisition MaxCount”设置为 &gt; 1，并且使用了 JDBC JobStore，则必须将此属性设置为“true”以避免数据损坏（从 Quartz 2.1.1 开始，如果 batchTriggerAcquisitionMaxCount 设置为 1，则“true”现在是默认值&gt;）。 org.quartz.jobStore.lockHandler.class 用于生成 org.quartz.impl.jdbcjobstore.Semaphore 实例的类名，用于对作业存储数据进行锁定控制。这是一项高级配置功能，大多数用户不应使用它。默认情况下，Quartz 将选择最合适的（预捆绑）信号量实现来使用。“org.quartz.impl.jdbcjobstore.UpdateLockRowSemaphore” QUARTZ-497可能对MS SQL Server用户感兴趣。与Quartz捆绑在一起的“JTANonClusteredSemaphore”在使用JobStoreCMT时可能会提高性能，尽管它是一个实验性实现。参见石英-441和石英-442 org.quartz.jobStore.driverDelegateInitString 可在初始化期间传递给 DriverDelegate 的属性（及其值）的管道分隔列表。 字符串的格式如下： 1&quot;settingName=settingValue|otherSettingName=otherSettingValue|...&quot; StdJDBCDelegate 及其所有后代（所有随 Quartz 一起提供的委托）支持名为“triggerPersistenceDelegateClasses”的属性，该属性可以设置为以逗号分隔的类列表，这些类实现用于存储自定义触发器类型的 TriggerPersistenceDelegate 接口。有关为自定义触发器编写持久性委托的示例，请参阅 Java 类 SimplePropertiesTriggerPersistenceDelegateSupport 和 SimplePropertiesTriggerPersistenceDelegateSupport。 数据源的配置 供 JDBC-JobStore 使用 如果您使用的是 JDBC-Jobstore，则需要一个数据源（如果您使用的是 JobStoreCMT，则需要两个数据源）。 可以通过三种方式配置数据源： 在 quartz.properties 文件中指定的所有池属性，以便 Quartz 可以创建数据源本身。 可以指定应用程序服务器管理的数据源的 JNDI 位置，以便 Quartz 可以使用它。 自定义定义的org.quartz.utils.ConnectionProvider实现。 建议将数据源最大连接大小配置为至少为线程池中的工作线程数加 3。 如果应用程序还频繁调用计划程序 API，则可能需要其他连接。如果您使用的是 JobStoreCMT， “非托管”数据源的最大连接大小应至少为 4。 必须为您定义的每个数据源（通常为一个或两个）指定一个名称，并且为每个数据源定义的属性必须包含该名称，如下所示。数据源的“NAME”可以是您想要的任何内容，除了在分配给 JDBCJobStore 时能够识别它之外，没有任何意义。 Quartz 创建的数据源使用以下属性进行定义： Property Name Required Type Default Value org.quartz.dataSource.NAME.driver yes String null org.quartz.dataSource.NAME.URL yes String null org.quartz.dataSource.NAME.user no String “” org.quartz.dataSource.NAME.password no String “” org.quartz.dataSource.NAME.maxConnections no int 10 org.quartz.dataSource.NAME.validationQuery no String null org.quartz.dataSource.NAME.idleConnectionValidationSeconds no int 50 org.quartz.dataSource.NAME.validateOnCheckout no boolean false org.quartz.dataSource.NAME.discardIdleConnectionsSeconds no int 0 (disabled) org.quartz.dataSource.NAME.driver 必须是数据库的 JDBC 驱动程序的 Java 类名。 org.quartz.dataSource.NAME.URL 用于连接到数据库的连接 URL（主机、端口等）。 org.quartz.dataSource.NAME.user 连接到数据库时要使用的用户名。 org.quartz.dataSource.NAME.password 连接到数据库时要使用的密码。 org.quartz.dataSource.NAME.maxConnections 数据源可以在其连接池中创建的最大连接数。 org.quartz.dataSource.NAME.validationQuery 是可选的 SQL 查询字符串，数据源可用于检测和替换失败&#x2F;损坏的连接。例如，oracle 用户可能会选择“从user_tables中选择table_name”——这是一个永远不应该的查询。 失败 - 除非连接确实错误。 org.quartz.dataSource.NAME.idleConnectionValidationSeconds 空闲连接测试之间的秒数 - 仅在设置了验证查询属性时启用。默认值为 50 秒。 org.quartz.dataSource.NAME.validateOnCheckout 是否应在每次检索连接时执行用于验证连接的数据库 sql 查询 以确保它仍然有效。如果为 false，则验证将在签入时进行。默认值为假。 org.quartz.dataSource.NAME.discardIdleConnectionsSeconds 在连接空闲了这么多秒后丢弃连接。0 禁用该功能。默认值为 0。 石英定义的数据源示例 12345org.quartz.dataSource.myDS.driver = oracle.jdbc.driver.OracleDriverorg.quartz.dataSource.myDS.URL = jdbc:oracle:thin:@10.0.1.23:1521:demodborg.quartz.dataSource.myDS.user = myUserorg.quartz.dataSource.myDS.password = myPasswordorg.quartz.dataSource.myDS.maxConnections = 30 对应用程序服务器数据源的引用使用以下属性定义： Property Name Required Type Default Value org.quartz.dataSource.NAME.jndiURL yes String null org.quartz.dataSource.NAME.java.naming.factory.initial no String null org.quartz.dataSource.NAME.java.naming.provider.url no String null org.quartz.dataSource.NAME.java.naming.security.principal no String null org.quartz.dataSource.NAME.java.naming.security.credentials no String null org.quartz.dataSource.NAME.jndiURL 由应用程序服务器管理的数据源的 JNDI URL。 org.quartz.dataSource.NAME.java.nameing.factory.initial 您希望使用的 JNDI InitialContextFactory 的（可选）类名。 org.quartz.dataSource.NAME.java.naming.provider.url 用于连接到 JNDI 上下文的（可选）URL。 org.quartz.dataSource.NAME.java.nameing.security.principal 用于连接到 JNDI 上下文的（可选）用户主体。 org.quartz.dataSource.NAME.java.nameing.security.credentials 用于连接到 JNDI 上下文的（可选）用户凭证。 从应用程序服务器引用的数据源示例 12345org.quartz.dataSource.myOtherDS.jndiURL=jdbc/myDataSourceorg.quartz.dataSource.myOtherDS.java.naming.factory.initial=com.evermind.server.rmi.RMIInitialContextFactoryorg.quartz.dataSource.myOtherDS.java.naming.provider.url=ormi://localhostorg.quartz.dataSource.myOtherDS.java.naming.security.principal=adminorg.quartz.dataSource.myOtherDS.java.naming.security.credentials=123 自定义连接提供程序实现 Property Name Required Type Default Value org.quartz.dataSource.NAME.connectionProvider.class yes String (class name) null org.quartz.dataSource.NAME.connectionProvider.class 要使用的连接提供程序的类名。实例化类后，Quartz 可以自动设置实例上的配置属性，Bean 样式。 使用自定义连接提供程序实现的示例 123org.quartz.dataSource.myCustomDS.connectionProvider.class = com.foo.FooConnectionProviderorg.quartz.dataSource.myCustomDS.someStringProperty = someValueorg.quartz.dataSource.myCustomDS.someIntProperty = 5 数据库群集的配置 实现故障转移和 使用 JDBC-JobStore 进行负载平衡 Quartz 的集群功能通过故障转移和负载平衡功能为您的调度程序带来高可用性和可扩展性。 集群目前仅适用于 JDBC-Jobstore（JobStoreTX 或 JobStoreCMT），并且基本上是通过让集群的每个节点共享相同的数据库来工作的。 负载平衡会自动发生，群集的每个节点都会尽快触发作业。当触发器的触发时间发生时，第一个获取它的节点（通过在其上放置锁定）是将触发它的节点。 每次触发时，只有一个节点将触发作业。我的意思是，如果作业有一个重复触发器 告诉它每 10 秒触发一次，然后在 12：00：00 正好有一个节点将运行作业，而在 12：00：10 恰好运行一个节点 节点将运行作业等。它不一定每次都是同一个节点 - 它或多或少是随机的 节点运行它。对于繁忙的计划程序（大量触发器），负载平衡机制几乎是随机的，但有利于 非繁忙（例如几个触发器）调度程序的同一节点。 当其中一个节点在执行一个或多个作业时发生故障时，就会发生故障转移。当节点发生故障时， 其他节点检测情况并识别数据库中故障节点中正在进行的作业。任何标记为恢复的作业（在 JobDetail 上带有“请求恢复”属性）将由 其余节点。未标记为恢复的作业将只是在下次触发相关触发器时释放以执行。 群集功能最适合横向扩展长时间运行和&#x2F;或 CPU 密集型作业（分配工作负载 在多个节点上）。如果需要横向扩展以支持数千个短期运行（例如 1 秒）作业，请考虑 使用多个不同的计划程序（包括用于 HA 的多个群集计划程序）对作业集进行分区。 调度程序使用集群范围的锁定，这种模式会在您添加更多节点时降低性能（当进入时） 超过大约三个节点 - 取决于数据库的功能等）。 通过将“org.quartz.jobStore.isClustered”属性设置为“true”来启用群集。集群中的每个实例都应使用 quartz.properties 文件的相同副本。例外情况是使用相同的属性文件，但允许以下例外情况：不同的线程池大小和“org.quartz.scheduler.instanceId”属性的不同值。群集中的每个节点都必须具有唯一的 instanceId，通过将“AUTO”作为此属性的值，可以轻松完成此操作（无需不同的属性文件）。有关详细信息，请参阅有关 JDBC-JobStore 的配置属性的信息。 切勿在单独的计算机上运行群集，除非它们的时钟使用某种形式的时间同步服务（守护程序）进行同步，该服务非常有规律地运行（时钟必须在一秒内）。如果您不熟悉如何执行此操作，请参阅 http://www.boulder.nist.gov/timefreq/service/its.htm。 切勿针对任何其他实例正在运行的同一组数据库表启动 （scheduler.start（）） 非集群实例。您可能会遇到严重的数据损坏，并且肯定会遇到不稳定的行为。 群集调度程序的示例属性 12345678910111213141516171819202122232425262728293031323334353637383940#============================================================================# Configure Main Scheduler Properties #============================================================================org.quartz.scheduler.instanceName = MyClusteredSchedulerorg.quartz.scheduler.instanceId = AUTO#============================================================================# Configure ThreadPool #============================================================================org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPoolorg.quartz.threadPool.threadCount = 25org.quartz.threadPool.threadPriority = 5#============================================================================# Configure JobStore #============================================================================org.quartz.jobStore.misfireThreshold = 60000org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTXorg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.oracle.OracleDelegateorg.quartz.jobStore.useProperties = falseorg.quartz.jobStore.dataSource = myDSorg.quartz.jobStore.tablePrefix = QRTZ_org.quartz.jobStore.isClustered = trueorg.quartz.jobStore.clusterCheckinInterval = 20000#============================================================================# Configure Datasources #============================================================================org.quartz.dataSource.myDS.driver = oracle.jdbc.driver.OracleDriverorg.quartz.dataSource.myDS.URL = jdbc:oracle:thin:@polarbear:1521:devorg.quartz.dataSource.myDS.user = quartzorg.quartz.dataSource.myDS.password = quartzorg.quartz.dataSource.myDS.maxConnections = 5org.quartz.dataSource.myDS.validationQuery=select 0 from dual TerracottaJobStore 的配置 没有数据库的集群！ TerracottaJobStore 用于在 Terracotta 服务器中存储调度信息（作业、触发器和日历）。TerracottaJobStore比使用数据库存储调度数据（通过JDBC-JobStore）的性能要高得多， 而且还提供群集功能，例如负载平衡和故障转移。 您可能需要考虑如何设置 Terracotta 服务器的影响，尤其是配置 用于打开诸如在磁盘上存储数据、利用 fsync 和运行 Terracotta 数组等功能的选项 HA 服务器。 群集功能最适合横向扩展长时间运行和&#x2F;或 CPU 密集型作业（分配工作负载 在多个节点上）。如果需要横向扩展以支持数千个短期运行（例如 1 秒）作业，请考虑 使用多个不同的计划程序对作业集进行分区。使用多个调度程序当前强制使用 群集范围的锁定，这种模式会在添加更多客户端时降低性能。 有关此 JobStore 和兵马俑的更多信息，请访问 http://www.terracotta.org/quartz › TerracottaJobStore 是通过设置“org.quartz.jobStore.class”属性来选择的，如下所示： 将调度程序的作业存储设置为兵马俑作业商店 1org.quartz.jobStore.class = org.terracotta.quartz.TerracottaJobStore 可以使用以下属性调整 TerracottaJobStore： Property Name Required Type Default Value org.quartz.jobStore.tcConfigUrl yes string org.quartz.jobStore.misfireThreshold no int 60000 org.quartz.jobStore.tcConfigUrl 标识要连接到的 Terracotta 服务器位置的主机和端口，例如“localhost：9510”。 org.quartz.jobStore.misfireThreshold 调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。 参考文章 Configuration Reference (quartz-scheduler.org)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Quartz","slug":"Quartz","permalink":"https://guoshunfa.com/tags/Quartz/"}]},{"title":"SpringBoot3集成Swagger","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot/SpringBoot3集成Swagger","date":"2023-07-11T06:52:01.000Z","updated":"2024-01-28T11:41:39.306Z","comments":true,"path":"2023/07/SpringBoot3集成Swagger/","link":"","permalink":"https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Swagger/","excerpt":"","text":"文章项目：Github Project 前提 jdk17 SpringBoot3.1.1 SpringDoc2.1.0 为什么不继续使用springfox？springfox 已经停止更新很久了，SpringBoot新版本都不支持。为了能够继续使用Swagger，只能调整继承库。 什么是SpringDoc？springdoc-openapiJava 库有助于使用 Spring 引导项目自动生成 API 文档。 通过在运行时检查应用程序来根据 Spring 配置、类结构和各种注释推断 API 语义。springdoc-openapi 自动生成 JSON&#x2F;YAML 和 HTML 格式 API 中的文档。 本文档可以通过使用 swagger-api 注释的评论来完成。 此库支持： OpenAPI 3 Spring-boot v3 （Java 17 &amp; Jakarta EE 9） JSR-303，专门用于@NotNull、@Min、@Max和@Size。 招摇的用户界面 OAuth 2 GraalVM 原生镜像 以下视频介绍了库： 这是一个基于社区的项目，不是由Spring框架贡献者（Pivotal）维护的。 集成Swagger引入maven12345&lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; SpringBoot引入Swagger的maven库之前，需要先引入springboot-web的maven，否则没有效果。 12345&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 添加API接口12345678910111213141516171819import io.swagger.v3.oas.annotations.Operation;import io.swagger.v3.oas.annotations.Parameter;import io.swagger.v3.oas.annotations.tags.Tag;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@Tag(name = &quot;测试controller&quot;, description = &quot;测试&quot;)@RequestMapping(&quot;/guoshunfa&quot;)public class TestController &#123; @Operation(summary = &quot;测试接口&quot;, description = &quot;测试接口&quot;) @GetMapping(&quot;/swagger/test/&quot;) public String test(@Parameter(name = &quot;param1&quot;, description = &quot;阿拉啦啦&quot;) String param1) &#123; return &quot;成功&quot;; &#125;&#125; 启动项目查看效果浏览器前往：http://ip:port/swagger-ui/index.html 如何从Swagger低版本迁移 删除 springfox 和 swagger 2 依赖项。改为添加依赖项。springdoc-openapi-starter-webmvc-ui 12345&lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 将 swagger 2 注释替换为 swagger 3 注释（它已包含在依赖项中）。 招摇 3 注释的包是 .springdoc-openapi-starter-webmvc-ui io.swagger.v3.oas.annotations @Api→@Tag @ApiIgnore→或@Parameter(hidden = true) @Operation(hidden = true) @Hidden @ApiImplicitParam→@Parameter @ApiImplicitParams→@Parameters @ApiModel→@Schema @ApiModelProperty(hidden = true)→@Schema(accessMode = READ_ONLY) @ApiModelProperty→@Schema @ApiOperation(value = &quot;foo&quot;, notes = &quot;bar&quot;)→@Operation(summary = &quot;foo&quot;, description = &quot;bar&quot;) @ApiParam→@Parameter @ApiResponse(code = 404, message = &quot;foo&quot;)→@ApiResponse(responseCode = &quot;404&quot;, description = &quot;foo&quot;) 此步骤是可选的：仅当您有多个 bean 时，才将它们替换为 bean。Docket``GroupedOpenApi 以前： 12345678910111213141516171819202122@Beanpublic Docket publicApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(&quot;org.github.springshop.web.public&quot;)) .paths(PathSelectors.regex(&quot;/public.*&quot;)) .build() .groupName(&quot;springshop-public&quot;) .apiInfo(apiInfo());&#125;@Beanpublic Docket adminApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(&quot;org.github.springshop.web.admin&quot;)) .paths(PathSelectors.regex(&quot;/admin.*&quot;)) .apis(RequestHandlerSelectors.withMethodAnnotation(Admin.class)) .build() .groupName(&quot;springshop-admin&quot;) .apiInfo(apiInfo());&#125; 现在： 123456789101112131415@Beanpublic GroupedOpenApi publicApi() &#123; return GroupedOpenApi.builder() .group(&quot;springshop-public&quot;) .pathsToMatch(&quot;/public/**&quot;) .build();&#125;@Beanpublic GroupedOpenApi adminApi() &#123; return GroupedOpenApi.builder() .group(&quot;springshop-admin&quot;) .pathsToMatch(&quot;/admin/**&quot;) .addOpenApiMethodFilter(method -&gt; method.isAnnotationPresent(Admin.class)) .build();&#125; 如果你只有一个 - 删除它，而是将属性添加到你的 ：Docket application.properties 12springdoc.packagesToScan=package1, package2springdoc.pathsToMatch=/v1, /api/balance/** 添加类型的 bean。请参阅示例：OpenAPI 1234567891011@Beanpublic OpenAPI springShopOpenAPI() &#123; return new OpenAPI() .info(new Info().title(&quot;SpringShop API&quot;) .description(&quot;Spring shop sample application&quot;) .version(&quot;v0.0.1&quot;) .license(new License().name(&quot;Apache 2.0&quot;).url(&quot;http://springdoc.org&quot;))) .externalDocs(new ExternalDocumentation() .description(&quot;SpringShop Wiki Documentation&quot;) .url(&quot;https://springshop.wiki.github.org/docs&quot;));&#125; Springdoc-openapi 配置springdoc-openapi依赖于使用标准文件位置的标准 Spring 配置属性（YML 或属性）。 Springdoc-OpenAPI 核心属性 参数名称 默认值 描述 springdoc.api-docs.path /v3/api-docs String，用于 Json 格式的 OpenAPI 文档的自定义路径。 springdoc.api-docs.enabled true Boolean.禁用 springdoc-openapi 端点（默认为 &#x2F;v3&#x2F;api-docs）。 springdoc.packages-to-scan * List of Strings.要扫描的包列表（逗号分隔） springdoc.paths-to-match /* List of Strings.要匹配的路径列表（逗号分隔） springdoc.produces-to-match-to /* List of Strings.生成要匹配的媒体类型列表（逗号分隔） springdoc.headers-to-match /* List of Strings.要匹配的标头列表（逗号分隔） springdoc.consumptions-to-matchs. /* List of Strings.要匹配的消耗媒体类型列表（逗号分隔） springdoc.paths-to-exclude List of Strings.要排除的路径列表（逗号分隔） springdoc.packages-to-exclude List of Strings.要排除的包列表（逗号分隔） springdoc.default-consumptions-media-type application/json String.默认使用媒体类型。 springdoc.default-produces-media-type **/** String.默认生成媒体类型。 springdoc.cache.disabled false Boolean.禁用计算的 OpenAPI 的 springdoc-openapi 缓存。 springdoc.show-actuator false Boolean.显示执行器端点。 springdoc.auto-tag-classes true Boolean.禁用 springdoc-openapi 自动标记。 springdoc.model-and-view-allow false Boolean.允许带有 ModelAndView 的 RestControllers 返回出现在 OpenAPI 描述中。 springdoc.override-with-generic-response true Boolean.如果为 true，则自动将@ControllerAdvice响应添加到所有生成的响应中。 springdoc.api-docs.groups.enabled true Boolean.禁用 springdoc-openapi 组。 springdoc.group-configs[0].group String.组名称 springdoc.group-configs[0].display-name String.组的显示名称。 springdoc.group-configs[0].packages-to-scan * List of Strings.要扫描组的包列表（逗号分隔） springdoc.group-configs[0].paths-to-match /* List of Strings.要为组匹配的路径列表（逗号分隔） springdoc.group-configs[0].paths-to-exclude &#96;&#96; List of Strings.要为组排除的路径列表（逗号分隔） springdoc.group-configs[0].packages-to-exclude List of Strings.要为组排除的包列表（逗号分隔） springdoc.group-configs[0].produces-to-match /* List of Strings.生成要匹配的媒体类型列表（逗号分隔） springdoc.group-configs[0].consumes-to-match /* List of Strings.要匹配的消耗媒体类型列表（逗号分隔） springdoc.group-configs[0].headers-to-match /* List of Strings.要匹配的标头列表（逗号分隔） springdoc.webjars.prefix /webjars String，要更改 webjars 前缀，该前缀可见 swagger-ui 的 URL 为 spring-webflux。 springdoc.api-docs.resolve-schema-properties false Boolean.在@Schema（名称、标题和说明）上启用属性解析程序。 springdoc.remove-broken-reference-definition true Boolean.禁用删除损坏的引用定义。 springdoc.writer-with-default-pretty-printer false Boolean.启用OpenApi规范的漂亮打印。 springdoc.model-converters.deprecating-converter.enabled true Boolean.禁用弃用模型转换器。 springdoc.model-converters.polymorphic-converter.enabled true Boolean.禁用多态模型转换器。 springdoc.model-converters.pageable-converter.enabled true Boolean.禁用可分页模型转换器。 springdoc.model-converters.sort-converter.enabled true Boolean.禁用排序转换器。 springdoc.use-fqn false Boolean.启用完全限定名称。 springdoc.show-login-endpoint false Boolean.使 Spring 安全登录端点可见。 springdoc.pre-load-enabled false Boolean.预加载设置，用于在应用程序启动时加载 OpenAPI。 springdoc.writer-with-order-by-keys false Boolean.启用确定性&#x2F;字母顺序排序。 springdoc.use-management-port false Boolean.在执行器管理端口上公开招摇 UI。 springdoc.disable-i18n false Boolean.使用 i18n 禁用自动翻译。 springdoc.show-spring-cloud-functions true Boolean.显示弹簧云函数 Web 终结点。 springdoc.enable-groovy true Boolean.启用 Groovy 支持。 springdoc.enable-spring-security true Boolean.启用弹簧安全支持。 springdoc.enable-kotlin true Boolean.启用 Kotlin 支持。 Springdoc.enable-hateoas true Boolean.启用弹簧支持。 springdoc.enable-data-rest true Boolean.启用弹簧数据休息支持。 springdoc.api-docs.version openapi_3_0 String.选择或（使用值 ）。OpenAPI 3.0``OpenAPI 3.1``OPENAPI_3_1 springdoc.default-flat-param-object false Boolean.默认平展参数。 springdoc.default-support-form-data false Boolean.在指定 api 以接受表单数据时默认设置表单数据的参数。 springdoc.nullable-request-parameter-enabled true Boolean.默认启用对 Kotlin 中可为空的请求参数的支持。 springdoc.show-oauth2-endpoint false Boolean.使 Spring 安全性 oauth2 端点可见。 Swagegr UI 属性 上提供了对 swagger-ui 属性的支持。请参阅官方文档。springdoc-openapi 您可以在文档中使用与 Spring 引导属性相同的 swagger-ui 属性。 所有这些属性都应使用以下前缀声明：springdoc.swagger-ui 参数名称 默认值 描述 springdoc.swagger-ui.path /swagger-ui.html String，用于 swagger-ui HTML 文档的自定义路径。 springdoc.swagger-ui.enabled true Boolean.禁用 swagger-ui 端点（默认情况下为 &#x2F;swagger-ui.html）。 springdoc.swagger-ui.configUrl /v3/api-docs/swagger-config String.要从中获取外部配置文档的 URL。 springdoc.swagger-ui.layout BaseLayout String.通过插件系统提供的组件的名称，用作 Swagger UI 的顶级布局。 springdoc.swagger-ui.validatorUrl validator.swagger.io/validator 默认情况下，Swagger UI 会尝试根据 swagger.io 的在线验证器验证规范。您可以使用此参数设置不同的验证程序 URL，例如，对于本地部署的验证程序验证程序徽章。将其设置为 ，或者将禁用验证。none``127.0.0.1``localhost springdoc.swagger-ui.tryItOutEnabled false Boolean.控制默认情况下是否应启用“试用”部分。 springdoc.swagger-ui.filter false Boolean OR String.如果设置，则启用筛选。顶部栏将显示一个编辑框，可用于筛选显示的标记操作。可以是用于启用或禁用的布尔值，也可以是字符串，在这种情况下，将使用该字符串作为筛选器表达式启用筛选。筛选区分大小写，与标记内任意位置的筛选器表达式匹配。 springdoc.swagger-ui.operationsSorter Function=(a ⇒ a).对每个 API 的操作列表应用排序。它可以是“alpha”（按路径字母数字排序），“method”（按HTTP方法排序）或函数（参见Array.prototype.sort（）以了解排序函数的工作原理）。默认值为服务器返回的顺序不变。 springdoc.swagger-ui.tagsSorter Function=(a ⇒ a).对每个 API 的标记列表应用排序。它可以是“alpha”（按路径字母数字排序）或函数，请参阅 Array.prototype.sort（） 以学习如何编写排序函数）。每次传递时，将两个标记名称字符串传递给分拣机。默认值是由 Swagger UI 确定的顺序。 springdoc.swagger-ui.oauth2RedirectUrl /swagger-ui/oauth2-redirect.html String.OAuth 重定向网址。 springdoc.swagger-ui.displayOperationId false Boolean.控制操作 ID 在操作列表中的显示。缺省值为 。false springdoc.swagger-ui.displayRequestDuration false Boolean.控制“试用”请求的请求持续时间（以毫秒为单位）的显示。 springdoc.swagger-ui.deepLink false Boolean.如果设置为 ，则启用标签和操作的深层链接。有关更多信息，请参阅 [深层链接文档]（&#x2F;docs&#x2F;usage&#x2F;deep-linking.md）。true springdoc.swagger-ui.defaultModelsExpandDepth 1 Number.模型的默认扩展深度（设置为 -1 将完全隐藏模型）。 springdoc.swagger-ui.defaultModelExpandDepth 1 Number.模型示例部分上模型的默认扩展深度。 springdoc.swagger-ui.defaultModelRendering String=[&quot;example&quot;*, &quot;model&quot;].控制首次呈现 API 时模型的显示方式。（用户始终可以通过单击“模型”和“示例值”链接来切换给定模型的渲染。 springdoc.swagger-ui.docExpansion String=[&quot;list&quot;*, &quot;full&quot;, &quot;none&quot;].控制操作和标记的默认展开设置。它可以是“列表”（仅展开标签）、“完整”（展开标签和操作）或“无”（不展开任何内容）。 springdoc.swagger-ui.maxDisplayTags Number.如果设置，将显示的标记操作数限制为最多此数量。默认值为显示所有操作。 springdoc.swagger-ui.showExtensions false Boolean.控制供应商扩展 （） 字段和操作、参数和架构的值的显示。x- springdoc.swagger-ui.url String.要配置，自定义 OpenAPI 文件的路径。如果使用，将被忽略。urls springdoc.swagger-ui.showCommonExtensions false Boolean.控制参数的扩展 （、、、、） 字段和值的显示。pattern``maxLength``minLength``maximum``minimum springdoc.swagger-ui.supportedSubmitMethods Array=[&quot;get&quot;, &quot;put&quot;, &quot;post&quot;, &quot;delete&quot;, &quot;options&quot;, &quot;head&quot;, &quot;patch&quot;, &quot;trace&quot;].启用了“试用”功能的 HTTP 方法列表。空数组禁用所有操作的“试用”。这不会从显示中过滤操作。 springdoc.swagger-ui.queryConfigEnabled false Boolean.自 以来禁用。此参数启用（旧版）通过 URL 搜索参数覆盖配置参数。在启用此功能之前，请参阅安全公告。v1.6.0 springdoc.swagger-ui.oauth. additionalQueryStringParams String.添加到授权 URL 和令牌 URL 的其他查询参数。 springdoc.swagger-ui.disable-swagger-default-url false Boolean.禁用 swagger-ui 默认宠物商店网址。（从 v1.4.1 开始可用）。 springdoc.swagger-ui.urls[0].url URL.Topbar 插件使用的 swagger 组的 url。URL 在此数组中的所有项中必须是唯一的，因为它们用作标识符。 springdoc.swagger-ui.urls[0].name String.Topbar 插件使用的 swagger 组的名称。名称在此数组中的所有项中必须是唯一的，因为它们用作标识符。 springdoc.swagger-ui.urlsPrimaryName String.加载 Swagger UI 时将显示的招摇组的名称。 springdoc.swagger-ui.oauth.clientId String.默认客户端 ID。必须是字符串。 springdoc.swagger-ui.oauth.clientSecret String.默认客户端机密。切勿在生产环境中使用此参数。它公开了重要的安全信息。此功能仅适用于开发&#x2F;测试环境。 springdoc.swagger-ui.oauth.realm String.领域查询参数（适用于 OAuth 1）已添加到授权 URL 和令牌 URL。 springdoc.swagger-ui.oauth.appName String.OAuth 应用程序名称，显示在授权弹出窗口中。 springdoc.swagger-ui.oauth.scopeSeparator String.用于传递范围的 OAuth 范围分隔符，在调用之前进行编码，默认值为空格（编码值 %20）。 springdoc.swagger-ui.csrf.enabled false Boolean.启用 CSRF 支持 springdoc.swagger-ui.csrf.use-local-storage false Boolean.从本地存储获取 CSRF 令牌。 springdoc.swagger-ui.csrf.use-session-storage false Boolean.从会话存储中获取 CSRF 令牌。 springdoc.swagger-ui.csrf.cookie-name XSRF-TOKEN String.可选的 CSRF，用于设置 CSRF cookie 名称。 springdoc.swagger-ui.csrf.header-name X-XSRF-TOKEN String.可选的 CSRF，用于设置 CSRF 标头名称。 springdoc.swagger-ui.syntaxHighlight.activated true Boolean.是否应激活语法突出显示。 springdoc.swagger-ui.syntaxHighlight.theme agate String..突出显示.js要使用的语法着色主题。（只有这 6 种样式可用。String=[&quot;agate&quot;*, &quot;arta&quot;, &quot;monokai&quot;, &quot;nord&quot;, &quot;obsidian&quot;, &quot;tomorrow-night&quot;] springdoc.swagger-ui.oauth. useBasicAuthentication WithAccessCodeGrant false Boolean.仅针对访问代码流激活。在对 tokenURL 的authorization_code请求期间，使用 HTTP 基本身份验证方案（具有基本 base64encode（client_id + client_secret）的授权标头）传递客户端密码。 springdoc.swagger-ui.oauth. usePkceWithAuthorization CodeGrant false Boolean.仅适用于授权代码流。代码交换的证明密钥为 OAuth 公共客户端带来了增强的安全性。 springdoc.swagger-ui.persistAuthorization false Boolean.如果设置为 true，它将保留授权数据，并且在浏览器关闭&#x2F;刷新时不会丢失 springdoc.swagger-ui.use-root-path false Boolean.如果设置为 true，则可以直接从应用程序根路径访问 swagger-u。 参考文章 Springdoc-OpenAPI v2.1.0 Swagger官网 Swagger官方Github主页 Swagegr Core Github Swagger 官方WIKI SpringDoc官网 SpringDoc Github springdoc-openapi Github 了解更多 SpringBoot2集成Swagger SpringBoot3集成Swagger","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Swagger","slug":"Swagger","permalink":"https://guoshunfa.com/tags/Swagger/"}]},{"title":"SpringBoot2集成Swagger","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot/SpringBoot2集成Swagger","date":"2023-07-11T04:01:01.000Z","updated":"2024-01-28T11:41:39.303Z","comments":true,"path":"2023/07/SpringBoot2集成Swagger/","link":"","permalink":"https://guoshunfa.com/2023/07/SpringBoot2%E9%9B%86%E6%88%90Swagger/","excerpt":"","text":"文章仓库：Github Project 前提本文章所用版本： SpringBoot 2.2.6.RELEASE springfox 3.0.0 jdk 8 不同的版本会导致版本冲突，切换版本时建议先去官方查看是否互相兼容。 开始集成 Swagger导入swagger maven 库123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; SpringBoot引入Swagger的maven库之前，需要先引入springboot-web的maven，否则没有效果。 12345&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 添加swagger配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import io.swagger.annotations.ApiOperation;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.oas.annotations.EnableOpenApi;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;// @Configuration 标识当前类是配置类，与@Bean搭配使用会直接注册为bean。@Configuration// @EnableOpenApi 标识开启生成接口文档功能（只有开启了OpenApi,才可以实现生成接口文档的功能）@EnableOpenApi@EnableSwagger2public class SwaggerConfig &#123; @Bean(&quot;swagger-1&quot;) public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) .groupName(&quot;swagger-1&quot;) .apiInfo(apiInfo()) .select() .apis( RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; @Bean(&quot;swagger-2&quot;) public Docket createRest2Api() &#123; return new Docket(DocumentationType.OAS_30) .groupName(&quot;swagger-2&quot;) .apiInfo(apiInfo()) .select() .apis( RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() // 添加标题 .title(&quot;郭顺发 SpringBoot+Swagger接口文档平台&quot; + System.currentTimeMillis()) // 添加描述 .description(&quot;https://www.guoshunfa.com&quot;) // 添加版本 .version(&quot;1.0&quot;) .build(); &#125;&#125; 编写API接口1234567891011121314151617import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@Api(&quot;测试controller&quot;)@RequestMapping(&quot;/guoshunfa&quot;)public class TestController &#123; @ApiOperation(&quot;测试接口&quot;) @GetMapping(&quot;/swagger/test/&quot;) public void test(@ApiParam(&quot;阿拉啦啦&quot;) String param1) &#123;&#125; &#125; 查看swagger-ui效果启动项目，将 浏览器访问 http://ip:port/swagger-ui/index.html 其他页面展示效果 - swagger-bootstrap-ui 效果使用其他ui需要引入maven 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 效果 浏览器访问 http://ip:port/doc.html Swagger API 注解 描述 @Api 将类标记为 Swagger 资源。 @ApiImplicitParam 表示 API 操作中的单个参数。 @ApiImplicitParams 允许多个 ApiImplicitParam 对象列表的包装器。 @ApiModel 提供有关 Swagger 模型的其他信息。 @ApiModelProperty 添加和操作模型属性的数据。 @ApiOperation 描述针对特定路径的操作或通常是 HTTP 方法。 @ApiParam 为操作参数添加额外的元数据。 @ApiResponse 描述操作的可能响应。 @ApiResponses 允许多个 ApiResponse 对象列表的包装器。 @Authorization 声明要在资源或操作上使用的授权方案。 @AuthorizationScope 描述 OAuth2 授权范围。 @ResponseHeader 表示可以作为响应的一部分提供的标头。 最新版本还添加了许多注释，用于在 Swagger 定义级别添加扩展和元数据： 注解 描述 @SwaggerDefinition 要添加到生成的 Swagger 定义中的定义级属性 @Info Swagger 定义的一般元数据 @Contact 用于描述 Swagger 定义的联系人的属性 @License 用于描述 Swagger 定义的许可证的属性 @Extension 添加包含属性的扩展 @ExtensionProperty 将自定义属性添加到扩展 资源 API 声明@Api在 Swagger 2.0 中，资源被标签替换，这会影响@Api注释。它不再用于声明资源，而现在用于为在它下定义的所有操作应用定义。 JAX-RS 的用法是： 12345678@Path(&quot;/pet&quot;)@Api(value = &quot;pet&quot;, authorizations = &#123; @Authorization(value=&quot;sampleoauth&quot;, scopes = &#123;&#125;) &#125;)@Produces(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)public class PetResource &#123; ...&#125; 在这个例子中，我们说这个类下的操作的标签是pet（所以它们都会被组合在一起）。Swagger 将获取@Produces注释，但如果您愿意，您可以覆盖此值。 @Api也可用于在资源级别声明授权。这些定义适用于该资源下的所有操作，但如果需要，可以在操作级别覆盖。在上面的示例中，我们添加了一个先前声明的 OAuth2 授权方案，没有任何范围。有关更多详细信息，请检查@Authorization注释。 除了使用value()，您可以使用tags()允许您为操作设置多个标签的属性。例如： 1@Api(tags = &#123;&quot;external_info&quot;,&quot;user_info&quot;&#125;) 请注意，在这种情况下，value()即使它存在也会被忽略。 布尔hidden属性可用于完全隐藏 @Api，即使它已声明。这在使用子资源删除不需要的工件时特别有用。 在 swagger-core 1.5.X 中，description()不再使用basePath()、 和。position() 有关此注释、用法和边缘情况的更多详细信息，请查看javadocs。 运营声明@ApiOperation@ApiOperation用于声明单个操作。操作被认为是路径和 HTTP 方法的唯一组合。 JAX-RS 的用法是： 1234567@GET@Path(&quot;/findByStatus&quot;)@ApiOperation(value = &quot;Finds Pets by status&quot;, notes = &quot;Multiple status values can be provided with comma seperated strings&quot;, response = Pet.class, responseContainer = &quot;List&quot;)public Response findPetsByStatus(...) &#123; ... &#125; 注释的value是对 API 的简短描述。由于它显示在 Swagger-UI 的操作列表中，并且位置大小有限，因此应保持简短（最好小于 120 个字符）。这notes允许您提供有关操作的更多详细信息。response是方法的返回类型。请注意，实际的方法声明返回的Response是一个通用 JAX-RS 类，而不是发送给用户的实际响应。如果返回的对象是实际结果，可以直接使用，不用在注解中声明。由于我们想要返回一个宠物列表，我们使用responseContainer. 请记住，Java 具有类型擦除，因此在返回类型中使用泛型可能无法正确解析，并且response应该直接使用。JAX-RS 注释将@GET用作操作的 (HTTP)method字段，它@Path会告诉我们操作的路径（操作分组在同一路径下，每个使用的 HTTP 方法一个）。 输出将是： 1234567891011121314151617181920 &quot;/pet/findByStatus&quot;: &#123;&quot;get&quot;: &#123; &quot;tags&quot;: [ &quot;pet&quot; ], &quot;summary&quot;: &quot;Finds Pets by status&quot;, &quot;description&quot;: &quot;Multiple status values can be provided with comma seperated strings&quot;, &quot;responses&quot;: &#123; &quot;200&quot;: &#123; &quot;description&quot;: &quot;successful operation&quot;, &quot;schema&quot;: &#123; &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;$ref&quot;: &quot;#/definitions/Pet&quot; &#125; &#125; &#125;, . . . 有关此注释、用法和边缘情况的更多详细信息，请查看javadocs。 @ApiResponses , @ApiResponse使用 HTTP 状态代码返回错误（或其他成功消息）是一种常见的做法。虽然在@ApiOperation中定义了操作的一般返回类型，但应使用这些注释来描述其余的返回代码。 描述了一个具体的@ApiResponse可能响应。不能直接在方法或类&#x2F;接口上使用，需要包含在数组值中@ApiResponses（无论是一个响应还是多个响应）。 如果响应伴随着身体，也可以描述身体模型（每个响应一个模型）。 12345@ApiResponses(value = &#123; @ApiResponse(code = 400, message = &quot;Invalid ID supplied&quot;, responseHeaders = @ResponseHeader(name = &quot;X-Rack-Cache&quot;, description = &quot;Explains whether or not a cache was used&quot;, response = Boolean.class)), @ApiResponse(code = 404, message = &quot;Pet not found&quot;) &#125;)public Response getPetById(...) &#123;...&#125; 在 swagger-core 1.5.X 中，您还可以添加响应标头的描述，如上例所示。 有关此注释、用法和边缘情况的更多详细信息，请查看 javadocs（@ApiResponses、@ApiResponse）。 @Authorization , @AuthorizationScope这些注释仅用作@Api和@ApiOperation的输入，而不是直接用于资源和操作。一旦您声明并配置了您在 API 中支持的授权方案，您就可以使用这些注释来记录资源或特定操作需要哪种授权方案。这@AuthorizationScope是特定于 OAuth2 授权方案的情况，您可能希望指定特定的支持范围。 @Authorization 和 @AuthorizationScope 转换为Security Requirement Object。 实现（JAX-RS、Servlet 或其他）之间的行为是相同的： 123456789@ApiOperation(value = &quot;Add a new pet to the store&quot;, authorizations = &#123; @Authorization( value=&quot;petoauth&quot;, scopes = &#123; @AuthorizationScope(scope = &quot;add:pet&quot;) &#125; ) &#125;)public Response addPet(...) &#123;...&#125; 在这种情况下，我们声明该addPet操作使用petoauth授权方案（我们假设它是 OAuth2 授权方案）。然后使用我们通过说它需要范围@AuthorizationScope来微调定义。add:pet如上所述，您可以看到@AuthorizationScope用作 的输入@Authorization，而后者又用作 的输入@ApiOperation。请记住，这些注释只能用作 和 的@Api输入@ApiOperation。直接在类或方法上使用它们中的任何一个都将被忽略。 输出将是： 1234567&quot;security&quot;: [ &#123; &quot;petoauth&quot;: [ &quot;add:pet&quot; ] &#125;] 有关此注解、用法和边缘情况的更多详细信息，请查看 javadocs（@Authorization、@AuthorizationScope）。 @ApiParam@ApiParam仅与 JAX-RS 参数注释（@PathParam、@QueryParam、@HeaderParam和@FormParamJAX-RS 2 中的）一起使用@BeanParam。虽然 swagger-core 默认扫描这些注释，但@ApiParam可用于在参数中添加更多详细信息或更改从代码中读取的值。 在 Swagger 规范中，这转换为Parameter Object。 Swagger 将选取value()这些注解并将它们用作参数名称，并且基于注解它还将设置参数类型。 如果存在，Swagger 还将使用 的值@DefaultValue作为默认值属性。 123456 @Path(&quot;/&#123;username&#125;&quot;) @ApiOperation(value = &quot;Updated user&quot;, notes = &quot;This can only be done by the logged in user.&quot;)public Response updateUser( @ApiParam(value = &quot;name that need to be updated&quot;, required = true) @PathParam(&quot;username&quot;) String username, @ApiParam(value = &quot;Updated user object&quot;, required = true) User user) &#123;...&#125; 这里我们有两个参数。第一个，username它是路径的一部分。第二个是主体，在本例中是一个用户对象。请注意，这两个参数的required属性都设置为true。对于@PathParam，这是多余的，因为默认情况下它是强制性的并且不能被覆盖。 输出将是： 123456789101112131415161718 &quot;parameters&quot;: [ &#123; &quot;name&quot;: &quot;username&quot;, &quot;in&quot;: &quot;path&quot;, &quot;description&quot;: &quot;name that need to be deleted&quot;, &quot;required&quot;: true, &quot;type&quot;: &quot;string&quot; &#125;, &#123; &quot;in&quot;: &quot;body&quot;, &quot;name&quot;: &quot;body&quot;, &quot;description&quot;: &quot;Updated user object&quot;, &quot;required&quot;: true, &quot;schema&quot;: &#123; &quot;$ref&quot;: &quot;#/definitions/User&quot; &#125; &#125;] 有关此注释、用法和边缘情况的更多详细信息，请查看javadocs。 @ApiImplicitParam , @ApiImplicitParams您可能希望手动描述操作参数。这可能有多种原因，例如： 使用不使用 JAX-RS 注释的 Servlet。 想要隐藏定义的参数并用完全不同的定义覆盖它。 描述在到达 JAX-RS 实现之前由过滤器或其他资源使用的参数。 由于可以包含多个参数，因此@ApiImplicitParams允许多个@ApiImplicitParam定义。 在 Swagger 规范中，这些转换为Parameter Object。 隐式定义参数时，设置name和dataTypeSwaggerparamType的定义正确很重要。 123456@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;name&quot;, value = &quot;User&#x27;s name&quot;, required = true, dataType = &quot;string&quot;, paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;email&quot;, value = &quot;User&#x27;s email&quot;, required = false, dataType = &quot;string&quot;, paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;id&quot;, value = &quot;User ID&quot;, required = true, dataType = &quot;long&quot;, paramType = &quot;query&quot;) &#125;)public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;...&#125; 在上面的示例中，我们可以看到一个带有多个参数的 Servlet 定义。dataType可以是原始名称或类名称。可以是 Swagger 支持的paramType任何参数类型（有关详细信息，请参阅 javadocs 或规范）。 123456789101112131415161718192021222324 &quot;parameters&quot;: [ &#123; &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: &quot;User&#x27;s name&quot;, &quot;required&quot;: true, &quot;type&quot;: &quot;string&quot;, &quot;in&quot;: &quot;query&quot; &#125;, &#123; &quot;name&quot;: &quot;email&quot;, &quot;description&quot;: &quot;User&#x27;s email&quot;, &quot;required&quot;: false, &quot;type&quot;: &quot;string&quot;, &quot;in&quot;: &quot;query&quot; &#125;, &#123; &quot;name&quot;: &quot;id&quot;, &quot;description&quot;: &quot;User ID&quot;, &quot;required&quot;: true, &quot;type&quot;: &quot;integer&quot;, &quot;format&quot;: &quot;int64&quot;, &quot;in&quot;: &quot;query&quot; &#125;] 有关此注释、用法和边缘情况的更多详细信息，请查看 javadocs（@ApiImplicitParam、@ApiImplicitParams）。 @ResponseHeader如果要描述响应标头，只需将其添加到@ApiOperation或@ApiResponse，同时提供标头的名称、描述和类型。 例如，在给定的响应中，它将如下所示： 12345@ApiResponses(value = &#123; @ApiResponse(code = 400, message = &quot;Invalid ID supplied&quot;, responseHeaders = @ResponseHeader(name = &quot;X-Rack-Cache&quot;, description = &quot;Explains whether or not a cache was used&quot;, response = Boolean.class)), @ApiResponse(code = 404, message = &quot;Pet not found&quot;) &#125;)public Response getPetById(...) &#123;...&#125; 有关此注释、用法和边缘情况的更多详细信息，请查看javadocs。 模型声明@ApiModelSwagger-core 基于在整个 API 内省中对模型定义的引用来构建模型定义。允许您操作模型的@ApiModel元数据，从简单的描述或名称更改到多态性的定义。 这转化为 Swagger 规范中的模式对象。 在其基本功能中，您@ApiModel可以更改模型的名称并为其添加描述： 12@ApiModel(value=&quot;DifferentModel&quot;, description=&quot;Sample model for the documentation&quot;)class OriginalModel &#123;...&#125; 在这里，我们将模型的名称从 OriginalModel 更改为 DifferentModel。 输出将是： 12345&quot;DifferentModel&quot;: &#123; &quot;description&quot;: &quot;Sample model for the documentation&quot;, . . &#125; 您还可以@ApiModel通过指定子类型来实现模型组合，例如： 1234@ApiModel(value = &quot;Pet&quot;, subTypes = &#123;Cat.class&#125;)public class Pet &#123;&#125; swagger-samples 中提供了此场景的示例： https://github.com/swagger-api/swagger-samples/blob/master/java/java-jaxrs/src/main/java/io/swagger/sample/model/Pet.java https://github.com/swagger-api/swagger-samples/blob/master/java/java-jaxrs/src/main/java/io/swagger/sample/model/Vehicle.java 有关此注释、用法和边缘情况的更多详细信息，请查看javadocs。 @ApiModelProperty虽然 swagger-core 将自省字段和 setter&#x2F;getter，但它还将读取和处理 JAXB 注释。允许控制 Swagger 特定的@ApiModelProperty定义，例如允许的值和附加注释。如果您想在某些情况下隐藏该属性，它还提供了额外的过滤属性。 1234@ApiModelProperty(value = &quot;pet status in the store&quot;, allowableValues = &quot;available,pending,sold&quot;)public String getStatus() &#123; return status;&#125; 这是向模型属性添加简短描述的简单示例。还可以观察到，虽然status是一个字符串，但我们将它记录为只有三个可能的值。 它的输出将是： 123456789101112&quot;properties&quot;: &#123; ..., &quot;status&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;pet status in the store&quot;, &quot;enum&quot;: [ &quot;available&quot;, &quot;pending&quot;, &quot;sold&quot; ] &#125; &#125; 有关此注释、用法和边缘情况的更多详细信息，请查看javadocs。 定义@SwaggerDefinitionSwaggerDefinition 注释提供了与Swagger对象的许多（但不是全部）顶级属性相对应的属性，允许您为自动生成的定义设置这些属性。注释可以在 Swagger 自动配置过程中扫描的任何类上，即它不必在 JAX-RS API 类上，而可以只是在标记&#x2F;配置接口上，例如： 1234567891011121314151617181920212223242526@SwaggerDefinition( info = @Info( description = &quot;Gets the weather&quot;, version = &quot;V12.0.12&quot;, title = &quot;The Weather API&quot;, termsOfService = &quot;http://theweatherapi.io/terms.html&quot;, contact = @Contact( name = &quot;Rain Moore&quot;, email = &quot;rain.moore@theweatherapi.io&quot;, url = &quot;http://theweatherapi.io&quot; ), license = @License( name = &quot;Apache 2.0&quot;, url = &quot;http://www.apache.org/licenses/LICENSE-2.0&quot; ) ), consumes = &#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;, produces = &#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;, schemes = &#123;SwaggerDefinition.Scheme.HTTP, SwaggerDefinition.Scheme.HTTPS&#125;, tags = &#123; @Tag(name = &quot;Private&quot;, description = &quot;Tag used to denote operations as private&quot;) &#125;, externalDocs = @ExternalDocs(value = &quot;Meteorology&quot;, url = &quot;http://theweatherapi.io/meteorology.html&quot;))public interface TheWeatherApiConfig &#123;&#125; 上面显示的属性会导致相应的元数据被添加到生成的 swagger.json &#x2F; swagger.yaml 文件中 如果您有多个 @SwaggerDefinition 注释，它们将按照它们被发现的顺序进行聚合 - 任何重复的注释属性都将覆盖以前的属性。 @Info@Info 注释为 Swagger 定义添加通用元数据属性 - 对应于规范中的Info对象。如上例所示： 123456789@SwaggerDefinition( info = @Info( description = &quot;Gets the weather&quot;, version = &quot;V12.0.12&quot;, title = &quot;The Weather API&quot;, termsOfService = &quot;http://theweatherapi.io/terms.html&quot;, ... ),... 有关受支持属性的完整列表，请参阅javadoc 。 @Contact@Contact 注释将联系人属性添加到 Swagger 定义的 @Info 部分 - 对应于规范中的联系人对象。如上例所示： 1234567891011@SwaggerDefinition( info = @Info( ... contact = @Contact( name = &quot;Rain Moore&quot;, email = &quot;rain.moore@theweatherapi.io&quot;, url = &quot;http://theweatherapi.io&quot; ), ... ),... 有关受支持属性的列表，请参阅javadoc 。 @License@License 注释将许可证属性添加到 Swagger 定义的 @Info 部分 - 对应于规范中的许可证对象。如上例所示： 123456789@SwaggerDefinition( info = @Info( ... license = @License( name = &quot;Apache 2.0&quot;, url = &quot;http://www.apache.org/licenses/LICENSE-2.0&quot; ) ),... 有关受支持属性的列表，请参阅javadoc 。 @Extension扩展注释允许将扩展属性添加到 Swagger 定义中。它目前在 @ApiOperation、@Info 和 @Tag 注释中受支持。有两种使用方法： 12345678... extensions = &#123; @Extension(properties = &#123; @ExtensionProperty(name = &quot;test1&quot;, value = &quot;value1&quot;), @ExtensionProperty(name = &quot;test2&quot;, value = &quot;value2&quot;) &#125;) &#125;... 这将导致以下json： 1234... &quot;x-test1&quot; : &quot;value1&quot;, &quot;x-test2&quot; : &quot;value2&quot;... 如果在注释中没有明确地这样做，属性名称将自动以“x-”为前缀。 或者，您可以将扩展名命名为： 12345678... extensions = &#123; @Extension( name = &quot;my-extension&quot;, properties = &#123; @ExtensionProperty(name = &quot;test1&quot;, value = &quot;value1&quot;), @ExtensionProperty(name = &quot;test2&quot;, value = &quot;value2&quot;) &#125;) &#125;... 这将导致以下json： 123456... &quot;x-my-extension&quot; : &#123; &quot;test1&quot; : &quot;value1&quot;, &quot;test2&quot; : &quot;value2&quot; &#125;... 它将包含的扩展属性包装在 JSON 对象中。 @ExtensionProperty扩展中的单个属性 - 有关示例，请参见前面的@Extension部分。 自定义 Swagger 定义如果您出于任何原因想要自定义生成的 Swagger 定义超出注释的范围，您可以为 Swagger 引擎提供提供相应回调的 ReaderListener： 12345678910111213141516171819202122public interface ReaderListener &#123; /** * Called before the Swagger definition gets populated from scanned classes. Use this method to * pre-process the Swagger definition before it gets populated. * * @param reader the reader used to read annotations and build the Swagger definition * @param swagger the initial swagger definition */ void beforeScan(Reader reader, Swagger swagger); /** * Called after a Swagger definition has been populated from scanned classes. Use this method to * post-process Swagger definitions. * * @param reader the reader used to read annotations and build the Swagger definition * @param swagger the configured Swagger definition */ void afterScan(Reader reader, Swagger swagger);&#125; 在使用此注解进行资源扫描期间找到的任何类都将被实例化并相应地调用。例如下面的类： 1234567public class BasePathModifier implements ReaderListener &#123; void beforeScan(Reader reader, Swagger swagger)&#123;&#125; void afterScan(Reader reader, Swagger swagger)&#123; swagger.setBasePath( System.getProperty( &quot;swagger.basepath&quot;, swagger.getBasePath() )); &#125;&#125; 将允许您从系统属性覆盖生成的 basePath。 参考文档 Swagger官网 Swagger官方Github主页 Swagegr Core Github Swagger 官方WIKI","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Swagger","slug":"Swagger","permalink":"https://guoshunfa.com/tags/Swagger/"}]},{"title":"同步至腾讯云开发者社区","slug":"同步至腾讯云开发者社区","date":"2023-07-03T08:28:15.000Z","updated":"2024-01-28T11:41:39.236Z","comments":true,"path":"2023/07/同步至腾讯云开发者社区/","link":"","permalink":"https://guoshunfa.com/2023/07/%E5%90%8C%E6%AD%A5%E8%87%B3%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA/","excerpt":"","text":"我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=eiey4wuskvsz","categories":[],"tags":[]},{"title":"Linux CentOS安装宝塔","slug":"软件开发/技术/服务器/Linux-CentOS安装宝塔","date":"2023-06-16T13:48:34.000Z","updated":"2024-01-28T11:41:39.265Z","comments":true,"path":"2023/06/Linux-CentOS安装宝塔/","link":"","permalink":"https://guoshunfa.com/2023/06/Linux-CentOS%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94/","excerpt":"","text":"宝塔是一个安全高效的服务器运维面板，可以直接从宝塔平台上部署web项目、监控服务器资源使用情况、快捷操作文件、一键安装软件及部署源码。详细内容可以移步前往宝塔官网。 CentOS安装宝塔 前往宝塔官网。 点击“立即免费安装”按钮，页面会跳转到宝塔安装界面。 到达宝塔安装界面后，往下滑，找到标题“Linux面板*.*.*安装脚本”。 找到Centos安装脚本。 这里备份一下备份一下脚本内容，如果需要请前往官网制定位置进行查看。 Centos安装脚本：yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec 万能安装脚本：if [ -f /usr/bin/curl ];then curl -sSO https://download.bt.cn/install/install_panel.sh;else wget -O install_panel.sh https://download.bt.cn/install/install_panel.sh;fi;bash install_panel.sh ed8484bec 下载完成之后，命令行会给提示。前往提示中的url地址，输入用户名和密码，即可到达服务器内的宝塔平台。","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"宝塔","slug":"宝塔","permalink":"https://guoshunfa.com/tags/%E5%AE%9D%E5%A1%94/"},{"name":"Linux","slug":"Linux","permalink":"https://guoshunfa.com/tags/Linux/"}]},{"title":"韩剧推荐","slug":"娱乐/韩剧推荐","date":"2023-06-16T13:29:49.000Z","updated":"2024-01-28T11:41:39.236Z","comments":true,"path":"2023/06/韩剧推荐/","link":"","permalink":"https://guoshunfa.com/2023/06/%E9%9F%A9%E5%89%A7%E6%8E%A8%E8%8D%90/","excerpt":"","text":"我的解放日志类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2022 主演：李民基,金智媛,孙锡久 导演：金锡允 简介：此剧讲述了关于想要逃离无语人生的昌锡，基正，美正三姐弟以及一个神秘外地人之间的温情故事。是一部讲述了人生到达了界限，即使没有对策下猛药也想要脱离“现在”的他们的解放期温暖共鸣故事。李民基剧中饰演二儿子廉昌熙一角，没有梦想，无欲无求，经常被家人无视。金智媛剧中饰演在无色彩人生中，渴望得到解放的小女儿廉美贞一角，天生内向，小心谨慎。孙锡久饰演神秘外来人具氏一角。365天都喝醉，不知道他到底是个什么样的人。李艾儿饰演大女儿廉基正一角，对爱情真挚，像火一样的性格。 评分：9.1 （截止2022年5月24日） 个人评价：🌟🌟🌟🌟🌟 极大程度的反应了社会的真实现状，主角三个人在性格、遭遇、机遇完全不同的情况下，最终找到了人生的价值。很多读者在观看时都会产生共鸣，这也是这个电视剧成功的部分。 我们的蓝调类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2022 主演：李秉宪,申敏儿,车胜元,金宇彬,韩智敏,李姃垠,严正化,金惠子,高斗心,朴智焕,崔英俊 导演：金奎泰 简介：该剧是卢熙京编剧和金圭泰导演继《那年冬天风在吹》《LIVE》后再次合作的作品，共20集，将描绘不同人的人生，本剧已于7月底开拍。讲述的是年轻时学生时代青涩的朋友们上了年纪再见面发生的故事，是一部颇具抒情色彩的作品。 评分：8.0 （截止2022年5月24日） 个人评价：🌟🌟🌟🌟 再次我的人生类型：剧情,犯罪,奇幻 &#x2F; 地区：韩国 &#x2F; 年份：2022 主演：李准基,李璟荣,金智恩,郑尚勋,金永勋,李顺载,崔光一,红毗罗,金炯默,朴哲民,金姬贞,车珠英,玄宇成,柳东根,金希珍, 导演：韩哲洙 简介：该片改编自同名小说，讲述人生第二次的热血检察官绝对的对恶的惩罚记。一个雨夜，检察官金奚宇在与罪犯最后的对决中落败。跌入江水本该死去的他却被上天给予了重生一次的契机。再次醒来的他发现自己回到了高中时代，一场为了正义之名的复仇，展开了，这一次他能将位高权重的罪犯绳之以法吗？ 评分：8.3（截止2022年5月24日） 个人评价：🌟🌟🌟 杀人者的购物目录类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2022 主演：李光洙,金雪炫 导演：李彦禧 简介：《杀人者的购物目录》是一部讲述我们这个虽然知道表面但完全不知道全貌的时代，看似熟悉的邻里却发生着儿童虐待，再开发等各种犯罪和危机状况的社区现实型惊悚剧。李光洙在剧中饰演超市的取货员大成。《杀人者的购物目录》改编自姜智英（音译）作家的同名小说，剧本由韩志完（音译）作家执笔，导演由曾与李光洙合作过电影《侦探2》的导演李彦禧担任，播出平台正在讨论中。 评分：7.0（截止2022年5月24日） 个人评价：🌟🌟🌟 向你奔去的速度493km类型：爱情,运动 &#x2F; 地区：韩国 &#x2F; 年份：2022 主演：朴柱炫,蔡钟协,权昭贤,徐智蕙,金茂俊,曹秀香,全惠媛,朴智炫 导演：赵雄 简介：此剧是一部运动爱情题材电视剧，讲述了25岁，羽毛球实业组选手们的故事。主要讲述了混合双打男女主对羽毛球的热爱和爱情故事。 评分：7.3（截止2022年5月24日） 个人评价：🌟🌟🌟 二十五，二十一类型：爱情 &#x2F; 地区：韩国 &#x2F; 年份：2022 主演：金泰梨,南柱赫,金知妍,崔显旭,李周明 导演：郑志贤 简介：南柱赫、金泰梨有望主演tvN新剧《二十五 二十一》(스물다섯 스물하나，暂译)。该剧由郑志贤(《国王：永远的君主》)执导，权度恩(《请输入搜索词：WWW》)操刀剧本，讲述1998-2021年间的故事，1998年22岁和18岁的两位主人公相遇，到了1999年时两人开始互相伤害，2000年时两人开始互相依靠，直到2001年两人才开始一段恋情。 南柱赫将饰演UBS体育记者白一镇，他23岁时成为电台记者，在暗访时伪装成化妆品推销员，后来在亚运会期间成为体育记者。在亚运会的比赛中他与金牌得主罗熙度(金泰梨饰)相遇。女主角罗熙度是高中击剑部的国家代表队队员。目前，两人经纪公司表示正在商议中，该剧计划今年冬天tvN播出。 评分：9.1（截止2022年5月24日） 个人评价：🌟🌟🌟🌟🌟 废柴舅舅类型：剧情,喜剧 &#x2F; 地区：韩国 &#x2F; 年份：2021 主演：吴政世,全慧珍,黄雨瑟惠,李时媛,朴善英,李尚禹,李庆勋 导演：池英洙 更新：2022-01-31 04:01:56 简介：该剧翻拍自同名BBC英剧，讲述照顾12岁侄子，为了守护侄子的无业游民叔叔孤军奋斗成长故事。 评分：7.2（截止2022年5月24日） 个人评价：🌟🌟🌟 那年，我们的夏天类型：爱情 &#x2F; 地区：韩国 &#x2F; 年份：2021 主演：崔宇植,金多美, 金圣喆,卢正义 简介：这对争吵不休的昔日恋人，高中时曾拍过一部爆红纪录片。因为这部作品，两人时隔多年又被拉回镜头前，也回到彼此的生活中。 评分：8.7（截止2022年5月24日） 个人评价：🌟🌟🌟🌟🌟 鱿鱼游戏类型：悬疑,惊悚 &#x2F; 地区：韩国 &#x2F; 年份：2021 主演：李政宰,魏化俊,许成泰,金周灵,朴海秀,孔刘,元春圭,郑浩妍 导演：黄东赫 简介：Netflix |《鱿鱼游戏》「一切只是一场游戏。」456 位参赛者，456 亿元奖金赌上自己的命，玩小孩玩的游戏《鱿鱼游戏》将于9月17日Netflix 独家上线。 评分：8.6（截止2022年5月24日） 个人评价：🌟🌟🌟🌟🌟 机智医生生活第二季类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2021 主演：曹政奭,柳演锡,郑敬淏,金大明,田美都,河允庆 导演：申元浩 简介：在医院里，每位病人及每件事都至关重要，身为医生同时也是平凡人的五人帮，将在此面对人生的起起落落。 评分：9.5（截止2022年5月24日） 个人评价：🌟🌟🌟🌟🌟 窥探类型：剧情,悬疑,犯罪 &#x2F; 地区：韩国 &#x2F; 年份：2021 主演：李昇基,李熙俊,朴柱炫,景收真,安在旭,金贞兰,权华焕,赵在允,金英玉,安内相,金英在,表志勋,禹志贤 导演：崔俊裴 简介：以「如果可以通过胎儿基因检测是否为精神病患者，肚子里的孩子被确认是患者，您是否会选择生下来？」为主题所展开的故事。将不同于以往精神病题材的电视剧。李昇基饰演正直的年轻刑警，面对不公正的事就据理力争，将与让全国陷入恐怖的先天精神病患的罪犯对峙，完全改变自己人生的角色。 评分：8.6（截止2022年5月24日） 个人评价：🌟🌟🌟🌟","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://guoshunfa.com/categories/%E5%A8%B1%E4%B9%90/"}],"tags":[{"name":"韩剧","slug":"韩剧","permalink":"https://guoshunfa.com/tags/%E9%9F%A9%E5%89%A7/"}]},{"title":"思维模式","slug":"阅读/思维模式","date":"2023-01-16T13:41:31.000Z","updated":"2024-01-28T11:41:39.311Z","comments":true,"path":"2023/01/思维模式/","link":"","permalink":"https://guoshunfa.com/2023/01/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"优质思维模式 二八原则。相对于全面的人，这个社会更加愿意奖励有专长的人。事业发展的好的人，在某方面都有特长。雷军“Are you ok？”鬼畜都看过，一般大学生比雷军英语都好，但他的管理能力，商业洞察却是少有人的企及。他在商业上的成功依靠的是他的长处。 默认设置。“默认设置”拉长到三年时间，足以拉长人与人的差距。默认设置指的是一个人在没有外力强制需要完成任务的时候，他自发地会做什么。有些人没事的时候喜欢刷视频（比如我），有些人则会喜欢在没事的时候看书。建议现在开始优化自己2-3个“默认设置”。 对答案、抄答案。不要有“问答案”而是“对答案”的意识。“问答案”是直接要结果不管中间的推导过程。而“对答案”则是自己通过努力思考，做好准备之后询问别人的思路，寻找差异，进行学习。 只有捍卫你自己的权利，别人才会尊重你的诉求。不要做老好人，一次又一次的退让只会换来别人变本加厉的压榨。要想清楚自己的底线。 情绪有变现价值。不要给自己的情绪带着走。想想当下想要达成的目的，然后用合适的情绪来帮助目的的达成。 常用的思维方式5W2H分析法 适用于分析问题、解决问题。 ​ 5W2H分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。简单、方便，易于理解、使用，富有启发意义，广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。 （1）WHAT——是什么？目的是什么？做什么工作？ （2）WHY——为什么要做？可不可以不做？有没有替代方案？ （3）WHO——谁？由谁来做？ （4）WHEN——何时？什么时间做？什么时机最适宜？ （5）WHERE——何处？在哪里做？ （6）HOW ——怎么做？如何提高效率？如何实施？方法是什么？ （7）HOW MUCH——多少？做到什么程度？数量如何？质量水平如何？费用产出如何？ 费曼学习法 适用于学习概念、内容。 ​ 费曼学习法的核心要义是通过复述概念并反馈结果来加强记忆。 （1）明确目标：你想学习的概念、内容。 （2）以教促学：写出自己的理解。 （3）化整为零：将目标内容分解为一个个基础知识点。 （4）总结提炼：合并内容，简化并提炼核心内容，通过联想来打比方。 二八法则（马特莱法则） 适用于如何以正确的视角观看事物。（着重点） 百度百科 ​ 在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此称二八定律。 多场景的例子： 时间法则：化20%的时间会产生成果的80%。 咨询法则：20%的人占用了我们时间的80%。 产品法则：产品的20%带来利润的80%。 阅读法则：20%的书篇幅包括了内容的80%。 工作法则：20%的工作给80%的满意。 演讲法则：20%的演讲产生影响的80%。 捐赠法则：20%的人捐出金钱的80%。 领导法则：20%的人作出80%的决定。 资源法则：20%的人耗掉资源的80%。 金钱法则：20%的人占有财富的80%。 圈子密友五次元理论一个人的财富和智慧，就是他最常接触的5个人平均值。 时刻清醒 如果你想要脱胎换骨般的改变，你必须有意识的生活，这个方法非常简单，不容错过，大多数人没有过自己的生活，他们只是接受了生活，但你一旦接受了生活，你就得靠某些事物生活，浪费你时间和精力的事物。 精神的成熟者，他对外表现出来的不是老，精神的成熟者，他对外表现出来的是一种内部世界的和谐，他对外表现出来的是一种凡事都很从容，他表现出来的是一种他的心灵啊，总是很轻盈，他表现出来的是他的胸襟总是很坦荡，这才是真正精神成熟的人。 只有当你真正的体会到了痛苦，你才会真正的知道，平凡的幸福有多么幸福，你才会珍惜这些平凡的幸福。 真正的幸福啊，并不是得到你极力追求的东西，而是那些你习以为常，知道失去后悔莫及的东西。真正的富有，并不是拥有豪车豪宅，狐朋狗友遍天下，因为这些看似的富有，无法填满你内心那个千疮百孔的心。 ———罗翔 参考资料 世上最强学习方法——费曼学习法（深度学习）","categories":[],"tags":[]},{"title":"《100天后会死的鳄鱼君》第一遍阅读","slug":"阅读/《100天后会死的鳄鱼君》第一遍阅读","date":"2022-11-07T11:20:09.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/11/《100天后会死的鳄鱼君》第一遍阅读/","link":"","permalink":"https://guoshunfa.com/2022/11/%E3%80%8A100%E5%A4%A9%E5%90%8E%E4%BC%9A%E6%AD%BB%E7%9A%84%E9%B3%84%E9%B1%BC%E5%90%9B%E3%80%8B%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/","excerpt":"","text":"编写时间：2022&#x2F;11&#x2F;07 19:20 作者：【日】菊池祐纪。 《100天后会死的鳄鱼君》主要记录着一个鳄鱼（主人公），将在100天后去世的故事。 故事的内容很简单，也很平淡，只是记录者主人公一天的日常。但是唯一不同的是，站在上帝视角的我，是知道100天后他会死亡的。抱着这种心态去看这部作品，就会不断的反思。 故事以四格漫画的进行进行记载，一页代表着一天，上方记录着正在进行的天数，下方记录着100天倒计时，这种描述方式很压抑，也在不断的提醒读者，主人公的生命快到了尽头。 鳄鱼君也是只是一个很普通的人，所以很容易让读者产生共鸣。故事没有说明鳄鱼君是否知道自己的寿命已经进入了倒计时，鳄鱼君每天都还在全力以赴的活着。 从故事中可以看到鳄鱼君真的和大多数普通人一样： 憧憬着自己的爱情，但没有足够的勇气去争取，对方的任何细节都会注意，一点点拒绝就会想要退缩，一点点希望就会很开心，也不敢去打扰对方，总觉得自己会被拒绝； 做着自己不喜欢的工作，只是为了维持生计； 有自己的梦想，但不敢承受后果； 有两三个真心朋友，平时嘻嘻哈哈，有困难了还能互相搀扶； 有一个压榨自己的领导，每天干不完的工作； 一两个不错的同事，工作时不至于太消极； 平时喜欢撸串，隔三差五找朋友聚一聚； 喜欢看综艺节目，每次都能逗的哈哈大笑； 看到心动的商品，会忍不住的下单； 保留了本心，保留了善良； 休息日喜欢睡懒觉，谁也叫不醒； 喜欢和朋友玩街机游戏，感觉那个时候才是最放松的； 自己能做到的事但别人没做到，就会感觉别人没有认真； 喜欢追剧，即使他的上映时间是明年春天； 对任何事都很乐观，躺平能解决一切； 喜欢玩扭蛋，虽然每次手气都很差； 好句我和你都是“100天”后即将死去的鳄鱼，虽然不知道生命什么时候终结，但还是要全力以赴的活着。 每个人的终点都是一样的，其实相比于结果我觉得更应该注重过程，每天都活成自己希望的样子，对自己抱有足够的信心，更加努力的向目标前进，拒绝任何负面情绪的入侵，更加注重做一件事的过程而不是结果。 总结在信息发达的时代，可以0成本的能看到别人形形色色的人生，不断的攀比才会产生焦虑。其实平凡、普通才是大多数人的生活。保留住本心，健康快乐的生活，才是我所期望的。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://guoshunfa.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://guoshunfa.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"心理","slug":"心理","permalink":"https://guoshunfa.com/tags/%E5%BF%83%E7%90%86/"}]},{"title":"《刻意练习》回顾第一遍阅读","slug":"阅读/《刻意练习》回顾第一遍阅读","date":"2022-11-02T18:13:50.000Z","updated":"2024-01-28T11:41:39.311Z","comments":true,"path":"2022/11/《刻意练习》回顾第一遍阅读/","link":"","permalink":"https://guoshunfa.com/2022/11/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E5%9B%9E%E9%A1%BE%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/","excerpt":"","text":"编写时间：2022&#x2F;11&#x2F;03 02:13 （失眠ing） 《刻意练习》Anders Ericsson | Robert Pool 距离上次阅读完《刻意练习》已经有半年的时间了，为了加深对这本书的印象，临时写一篇读书笔记。 首先，先说一下《刻意练习》这本书能给我带来什么，当时看了这本书的书名，我的感觉是他应该能给我带来一个学习东西的方法，其实并不是。《刻意练习》这本书是通过大量的案例来告诉我们一个真实的想象：所有人都以为“杰出”源于“天赋”，“天才”却说：我的成就源于“正确的练习”。 “天才真的存在吗”，好多人对于别人的“擅长”，都认定他是一个“天赋”极好的“天才”，现实真的如此吗。同样做编程的开发人，有的工作3年只能到中级的水平，有的工作3年已经是资深了。从结果上看，同样的时间，最终的水平有很大的差异，从过程上看，两个人都是在持续学习，也都很刻苦。感觉3年就达到资深水平的人很有编程的“天赋”，但真的是这样吗。我们反观两位的学习过程就可以看出端倪。工作3年到达中级水平的开发者，每天虽然很充实，但是重复性工作太多，也没有一个明确的规划、良好的学习氛围、厉害的导师，导致3年内的进步极少。而3年就到达资深水平的开发者，自己有一套学习方式和明确的规划，时常请教公司内部的技术大拿，才会在短短的3年时间里让自己的能力有很大的提升。这是这本书传递给我的一个最重要的思想之一：通过正确的训练与练习，每个人都可以有“天赋”。 “有目的的练习”，作者记录了一个实验，我说出9位数的数字，说完后让你迅速默写出来。这个实验的实验对象是一个十几岁的孩子，在不断更新迭代练习方式和大量时间的训练之后，那个孩子从一开始的默写9位数，到后来的默写几十位数，再到几百位数。通过有目的的练习，可以激发出来你想象不到的“潜力”。那什么是有目的的练习：走出你的舒适区，但要以专注的方式制定明确的目标，为达到那些目标制定一个计划，而且想出监视你的进步的方法。还要想办法保持你的动机。 “大脑的适应能力”，不要低估自己大脑的适应能力，当你走出舒适圈后，通过不断的挑战自己的极限，来改变自己的大脑。但是要有尺度，在过长的时间内过分的逼迫自己，可能导致倦怠和学习低效。当然，如果停止训练，便不会再进步， 刻意练习的特点： 刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能。训练的方案应当由导师或教练来设计和监管，他们即熟悉杰出人物的能力，也熟悉怎么样才能最好的提高那种能力。刻意练习发生在人们的舒适区之外，而且要求学生持续不断的尝试那些刚好超过他当前能力范围的事物。因此，它需要人们付出近乎最大限度的努力。一般来讲，这并不令人心情愉快。刻意练习包含得到良好的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进。一旦设定了总体目标，导师或教练将制订一个计划，以便实现一系列微小的改变，最后将这些改变积累起来，构成之前期望的更大的变化。改进目标表现的某些方面，使得从业者能够看到他的表现通过训练得到了提高。刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动。简单的遵照导师或教练的之事去做，还不够，学生必须紧跟他的练习和特定目标，以便能做出适当的调整，控制练习。刻意练习包含反馈，以及为应对那些反馈而进行调整的努力，在练习过程的早期，大量的反馈来自导师或教练，他们将监测学生的进步，指出存在的问题，而且提供解决这些问题的方法。随着时间的推移，学生必须学会自己监测自己、自己发现错误，并做出相应调整。这种自我检测，薛瑶高效的心理表征。刻意练习既产生有效的心理表征，又依靠有效的心理表征。提高水平与改进心理表征是相辅相成的，两者不可偏废；随着人们水平的提升，表征也变得更加详尽和有效，反过来使得人们可能实现更大程度的改进。心理表征使人们能监测在训练中和实际的工作中做得怎么样。它们表明了做某件事的正确方法，并使得人们注意到什么时候做的不对，以及怎样来纠正。刻意练习通过着重关注过去获取的技能的某些特定方面，致力于针对性的提高那些方面，而且几乎总是包括构建或修改那些过去已经获取的技能；随着时间的推移，这种逐步的改进最终将造就卓越的表现。由于新技能的学习是建立在现有技能基础上的，因此导师会为初学者提供正确的基本技能，使学生后来能在更高层面上重新学习那些基本的技能。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://guoshunfa.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://guoshunfa.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"心理","slug":"心理","permalink":"https://guoshunfa.com/tags/%E5%BF%83%E7%90%86/"}]},{"title":"Final Cat Pro 软件操作","slug":"自媒体/Final-Cat-Pro-软件操作","date":"2022-10-16T13:34:41.000Z","updated":"2024-01-28T11:41:39.236Z","comments":true,"path":"2022/10/Final-Cat-Pro-软件操作/","link":"","permalink":"https://guoshunfa.com/2022/10/Final-Cat-Pro-%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"高质量教学视频：PAPAYA电脑教室 | youtube 苹果公司御用剪辑师教你如何使用final cut pro让你成为电影大师 &#x2F; 附带bilibili视频 快捷键视频文件操作将视频加入主故事线最后：选择视频文件 + E。（E：end） 将视频加入主故事线最前方：选择视频文件 + W。 叠加视频，放入主故事线上方：Q 以覆盖的方式插入视频：D 切割视频：command + B 视频速度控制：command + R 速度控制拦切割：shift + B 设定界限：X 直接删除视频片段：backspace。 删除视频片段，保留视频所在区间：delete 做记号：M 位置迁移：P 视频素材截取：I 左截取 O 右截取 视频素材标记 &#x2F; 视频素材取消标记：F &#x2F; U 时间轴控制shift + Z，可将影片拉长到跟时间轴等宽。 command + （ - &#x2F; + ）可以缩放&#x2F;拉伸时间轴。","categories":[],"tags":[]},{"title":"乐观锁解决数据库并发修改问题","slug":"软件开发/场景/乐观锁解决数据库并发修改问题","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.236Z","comments":true,"path":"2022/07/乐观锁解决数据库并发修改问题/","link":"","permalink":"https://guoshunfa.com/2022/07/%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/","excerpt":"","text":"1. 相关信息描述1.1. 数据库并发场景描述表中有一属性，记录着当前记录被查询的次数。每一次查询之后会把处理过程甩给event（观察者模式）。如果一段时间内访问量变大会出现并发问题。并发会导致数据的不准确。 1.2. 什么是乐观锁 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号等于数据库表当前版本号，则予以更新，否则认为是过期数据。 2. 实现2.1. 场景描述SpringBoot + Mysql 2.2. 数据库表调整加入属性version，用来做乐观锁验证。 2.3. sql调整1update test_user set age=age+1,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;; 2.4. 服务层逻辑加入乐观锁12345678910public void userAgeAddOne(String id) &#123; TestUser testUser = userTestMapper.findById(id); int i = userTestMapper.userAgeAddOne(testUser.getId(), testUser.getVersion()); if (i == 0) &#123; userAgeAddOne(id); &#125; else &#123; return ; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"乐观锁","slug":"乐观锁","permalink":"https://guoshunfa.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"},{"name":"并发","slug":"并发","permalink":"https://guoshunfa.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"解决方案","slug":"解决方案","permalink":"https://guoshunfa.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"如何搭建图床","slug":"软件开发/场景/如何搭建图床","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/如何搭建图床/","link":"","permalink":"https://guoshunfa.com/2022/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"Q：为什么要使用图床呢？什么是图床？ A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用markdown+图片url的方式写作文章，一次编写，到处使用~ Q：搭建图床的方式 A：推荐使用GitHub作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsDelivr免费CDN加速。jsDelivr是国外的一家优秀的公共 CDN 服务提供商，该平台是首个「打通中国大陆与海外的免费CDN服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/(opens new window), B：Gitee+PicX。 B：OSS存储，特点是稳定、容量大，缺点就是存储付费+流量付费（大），可以使用ECS内网访问躲避流量费用。 Q：如何统一管理 A：使用域名进行解析。 方案一：GitHub + jsDelivr + PicGo Evan’s blog 新建GitHub仓库，注意仓库要设置成公开。 参照 官方文档 生成一个token密钥。 在 这里 下载PicGo，安装完成后打开，图床设置 选 GitHub图床，并填写相应的信息 仓库名：前面新建的仓库，格式：&lt;用户名&gt;/&lt;仓库名&gt; 分支名：填写主分支master即可 Token：前面生成的token密钥 存储路径：按你自己的需求填写 自定义域名：图片上传后，PicGo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsDelivr的CDN加速地址，格式：https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt; 方案二：OSS + ECS +PicGo 手里有一个准备好的OSS，一般购买的都是只是存储，而外网访问会产生流量，流量费用见下图。内网访问免费，可以使用ECS云服务器做代理转发。 ECS云服务器使用nginx做转发。 12345678910111213141516server &#123;listen 80 default_server;listen [::]:80 default_server;server_name 47.**.**.43; root /usr/share/nginx/html;# Load configuration files for the default server block.include /etc/nginx/default.d/*.conf;location / &#123;proxy_pass https://bucketname.oss-cn-beijing-internal.aliyuncs.com; proxy_set_header Host $host; &#125;&#125; server_name：对外提供反向代理服务的IP，即ECS实例的外网地址。 proxy_pass ：填写跳转的域名。 当ECS实例与Bucket在同一地域时，填写目标Bucket的内网访问域名。访问域名介绍请参见OSS访问域名使用规则。 当ECS实例与Bucket不在同一地域时，填写目标Bucket的外网访问域名。 因OSS的安全设置，当使用默认域名通过浏览器访问OSS中的图片或网页文件时，会直接下载。所以，若您的用户需通过浏览器预览Bucket中的图片或网页文件，需为Bucket绑定自定义域名，并在此项中添加已绑定的域名。绑定自定义域名操作请参见绑定自定义域名。 proxy_set_header Host $host ：添加此项时，Nginx会在向OSS请求的时候，将host替换为ECS的访问地址。遇到以下情况时，您需要添加此项。 遇到签名错误问题。 如果您的域名已解析到ECS实例的外网上，且您的用户需要通过浏览器预览Bucket中的图片或网页文件。您可以将您的域名绑定到ECS实例代理的Bucket上，不配置CNAME。这种情况下，proxy_pass项可直接配置Bucket的内网或外网访问地址。绑定自定义域名操作请参见绑定自定义域名。 12nginx -t # 验证配置文件是否正确service nginx restart # 重启nginx服务","categories":[{"name":"服务","slug":"服务","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"解决方案","slug":"解决方案","permalink":"https://guoshunfa.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"图床","slug":"图床","permalink":"https://guoshunfa.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"Mysql 介绍","slug":"软件开发/技术/数据库/Mysql-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/Mysql-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Mysql-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"安装MysqlMac 安装Mysql MySQL安装（Mac版） 1brew install mysql Docker 安装 Mysql12345678910111213# docker查询mysql镜像docker search mysql# 拉取mysql镜像docker pull mysql# 启动容器docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=root docker.io/mysql:latest### 参数说明：# -p 3306:3306 将主机3306端口映射到容器3306端口# -e MYSQL_ROOT_PASSWORD=root 设置远程登录的root用户密码为root# --name zyz-name 可选，设置容器别名# mysql 镜像名称##","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://guoshunfa.com/tags/Mysql/"}]},{"title":"Oracle 介绍","slug":"软件开发/技术/数据库/Oracle-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Oracle-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Oracle-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1. Oracle 安装1.1. Docker 快捷安装 还没有安装docker服务的，请跳转到Docker - 介绍章节。 拉取oracle镜像 1docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 安装oracle容器 1docker run -dp 9090:8080 -p 1521:1521 registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 初始用户名密码：system&#x2F;helowin；服务名：helowin 参考文章 Mac 上如何安装 Oracle 客户端？","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"}]},{"title":"Oracle 错误记录","slug":"软件开发/技术/数据库/Oracle-错误记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Oracle-错误记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Oracle-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"错误：sqlplus: command not found 转载自：https://www.cnblogs.com/sprinng/p/6548540.html 12345678# 调整成对应oracle地址export ORACLE_BASE=/u01/app/oracle# 注意调整对应版本export ORACLE_HOME=$ORACLE_BASE/product/10.2.0/db_1su - rootln -s $ORACLE_HOME/bin/sqlplus /usr/binsu - oraclesqlplus /nolog","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"}]},{"title":"Oracle 设置ID自增","slug":"软件开发/技术/数据库/Oracle设置ID自增","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Oracle设置ID自增/","link":"","permalink":"https://guoshunfa.com/2022/07/Oracle%E8%AE%BE%E7%BD%AEID%E8%87%AA%E5%A2%9E/","excerpt":"","text":"1. 先有个表123456789# 首先得有个表create table t_user(user_id number not null primary key,user_name varchar2(30),credits number,user_password varchar2(32),last_visit date,last_ip varchar2(23)) 2. 创建一个序列 转载自：https://blog.csdn.net/jiejie5945/article/details/44198283 1234567# 为这个表创建序列create sequence T_USER_SEQminvalue 1maxvalue 999999999999999999999999999start with 21increment by 1cache 20; 参数描述： create sequence seq_name：创建序列，seq_name为序列名称 minvalue：自增最小值，缺省值为nominvalue，即不设置最小值。 maxvalue：自增最大值，缺省值为nomaxvalue，即不设置最大值；系统能产生的最大值为10的27次方。 start with：自增开始值，设置成21则从21开始自增。 increment by：自增数值，设置成1则每次递增1，负数表示递减，缺省值为1。 cache：定义缓存序列的个数，缺省值为20，nocache表示不设置缓存；使用缓存可以提高序列的性能，但数据库出错时会造成数据丢失使序列不连续。 NOCYCLE：一直累加，不循环 cycle：定义当序列达到最大&#x2F;小值后是否循环，缺省值为不循环；nocycle：不循环；**cycle：循环；如果不使用循环达到限制值后继续产生新值就会出错；使用循环达到最大值后的下一个值为1，和start** **with**设置的值无关，递增还是increment **by**设置的值； 2.1. 序列详细描述一旦定义了emp_sequence，你就可以用CURRVAL，NEXTVALCURRVAL &#x3D; 返回sequence的当前值NEXTVAL &#x3D; 增加sequence的值，然后返回sequence值比如：emp_sequence.CURRVALemp_sequence.NEXTVAL 可以使用sequence的地方： 不包含子查询、snapshot、VIEW的 SELECT 语句 INSERT语句的子查询中 NSERT语句的VALUES中 UPDATE 的 SET中 可以看如下例子： 1234INSERT INTO emp VALUES(empseq.nextval, &#x27;LEWIS&#x27;, &#x27;CLERK&#x27;,7902, SYSDATE, 1200, NULL, 20); SELECT empseq.currval FROM DUAL; 但是要注意的是： 第一次NEXTVAL返回的是初始值；随后的NEXTVAL会自动增加你定义的INCREMENT BY值，然后返回增加后的值。CURRVAL 总是返回当前sequence的值，但是在第一次NEXTVAL初始化之后才能使用CURRVAL，否则会出错。一次NEXTVAL会增加一次sequence的值，所以如果你在同一个语句里面使用多个NEXTVAL，其值就是不一样的。明白？ 如果指定CACHE值，oracle就可以预先在内存里面放置一些sequence，这样存取的快些。 cache里面的取完后，oracle自动再取一组到cache。 使用cache或许会跳号， 比如数据库突然不正常down掉（shutdown abort),cache中的sequence就会丢失. 所以可以在create sequence的时候用nocache防止这种情况。 2.2. 调整序列你或者是该sequence的owner，或者有ALTER ANY sequence权限才能改动sequence。 可以alter除start值之外的所有sequence参数。如果想要改变start值，必须drop sequence再re-create。例子： 12345ALTER sequence emp_sequenceINCREMENT BY 10MAXVALUE 10000CYCLE -- 到10000后从头开始NOCACHE; 影响sequence的初始化参数：sequence_CACHE_ENTRIES =设置能同时被cache的sequence数目。 可以很简单的Drop sequence DROP sequence order_seq; 3. 创建一个触发器123456create or replace trigger t_user_trbefore insert on t_userfor each rowbeginselect t_user_seq.nextval into :new.user_id from dual;end t_user_tr; 参数描述： t_user_tr: 随意的名字，不要重复就行 t_user: 表名 user_id ：自增的id 删除触发器： 1DROP TRIGGER trigger_name; 参数描述 trigger_name：要删除的触发器的名称。 4. 测试123456789101112insert into t_user values(null,&#x27;xiaoming&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming1&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming1&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming1&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming2&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);insert into t_user values(null,&#x27;xiaoming&#x27;,123,&#x27;1114&#x27;,sysdate,&#x27;192.168.37.132&#x27;);select * from t_user 参考文章 https://blog.csdn.net/qq_42055933/article/details/117401672 oracle如何实现ID自增长","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"}]},{"title":"Redis 介绍","slug":"软件开发/技术/数据库/Redis-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Redis-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Redis-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"redis 官方文档 | redis 中文网 1. Mac 系统安装Reids1.1. 安装Homebrew如果已经安装可以忽略，没有安装的请查看小明之前写好的文章 mac安装homebrew 1.2. 使用Homebrew安装Redis1.2.1. 安装命令1brew install redis 1.2.2. 查看软件安装及配置文件位置Homebrew安装的软件会默认在/usr/local/Cellar/路径下； redis的配置文件redis.conf存放在/usr/local/etc路径下。 1.2.3. 启动redis服务1.2.3.1. 方法一：brew除了可以帮助我们安装软件以外，还可以帮助我们启动软件 1brew services start redis 1.2.3.2. 方法二：1redis-server /usr/local/etc/redis.conf 1.2.4. 查看redis服务进程我们可以通过下面命令查看redis是否正在运行 1ps axu | grep redis 1.2.5. redis-cli连接redis服务redis默认端口号6379，默认auth为空，输入以下命令即可连接 1redis-cli -h 127.0.0.1 -p 6379 1.2.6. 关闭redis服务优雅的关闭redis-cli shutdown或者杀死sudo pkill redis-server 1.2.7. redis.conf配置文件说明redis默认是前台启动，如果我们想以守护进程的方式运行（后台运行），可以在redis.conf中将daemonize no,修改成yes即可。 Linux 系统Linux安装Redis","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://guoshunfa.com/tags/Redis/"}]},{"title":"Redis 错误日志记录","slug":"软件开发/技术/数据库/Redis-错误日志记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Redis-错误日志记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Redis-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","excerpt":"","text":"WRONGPASS invalid username-password pair or user is disabled.日志描述：用户密码错误。 解决方案： 1234# 设置密码为pandaconfig set requirepass panda# 使用密码auth panda 日志输出 OK ，便成功。 (error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error．日志描述：（错误）misconf redis被配置以保存数据库快照，但misconf redis目前不能在硬盘上持久化。用来修改数据集合的命令不能用，请使用日志的错误详细信息。 原因：这是由于强制停止redis快照，不能持久化引起的，运行info命令查看redis快照的状态 解决方案： 连接redis后运行 config set stop-writes-on-bgsave-error no 命令 关闭配置项stop-writes-on-bgsave-error解决该问题。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://guoshunfa.com/tags/Redis/"}]},{"title":"SQL预编译","slug":"软件开发/技术/数据库/SQL预编译","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/SQL预编译/","link":"","permalink":"https://guoshunfa.com/2022/07/SQL%E9%A2%84%E7%BC%96%E8%AF%91/","excerpt":"","text":"作者：嘻洋洋链接：https://www.jianshu.com/p/9972d7b33061来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 数据库预编译起源（1）数据库SQL语句编译特性： 数据库接受到sql语句之后，需要词法和语义解析，优化sql语句，制定执行计划。这需要花费一些时间。但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。 （2）减少编译的方法 如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。为了解决上面的问题，于是就有了预编译，预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化。一次编译、多次运行，省去了解析优化等过程。 （3）缓存预编译 预编译语句被DB的编译器编译后的执行代码被缓存下来,那么下次调用时只要是相同的预编译语句就不需要编译,只要将参数直接传入编译过的语句执行代码中(相当于一个涵数)就会得到执行。 并不是所以预编译语句都一定会被缓存,数据库本身会用一种策略（内部机制）。 (4) 预编译的实现方法 预编译是通过PreparedStatement和占位符来实现的。 预编译作用 预编译阶段可以优化 sql 的执行 预编译之后的 sql 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。可以提升性能。 防止SQL注入 使用预编译，而其后注入的参数将不会再进行SQL编译。也就是说其后注入进来的参数系统将不会认为它会是一条SQL语句，而默认其是一个参数，参数中的or或者and 等就不是SQL语法保留字了。 预编译开启（1）数据库是否默认开启预编译和JDBC版本有关。 也可以配置jdbc链接时强制开启预编译和缓存:useServerPrepStmts和cachePrepStmts参数。预编译和预编译缓存一定要同时开启或同时关闭。否则会影响执行效率 1conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/prepare_stmt_test?user=root&amp;password=root&amp;useServerPrepStmts=true&amp;cachePrepStmts=true&quot;); （2）mysql的预编译 开启了预编译缓存后，connection之间，预编译的结果是独立的，是无法共享的，一个connection无法得到另外一个connection的预编译缓存结果。 经过试验，mysql的预编译功能对性能影响不大，但在jdbc中使用PreparedStatement是必要的，可以有效地防止sql注入。 相同PreparedStatement的对象 ，可以不用开启预编译缓存。 12345678910111213 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/prepare_stmt_test?user=root&amp;password=root&amp;useServerPrepStmts=true&quot;); PreparedStatement stmt = conn.prepareStatement(sql); stmt.setString(1, &quot;aaa&quot;); ResultSet rs1 = stmt.executeQuery();//第一次执行 s1.close(); stmt.setString(1, &quot;ddd&quot;); ResultSet rs2 = stmt.executeQuery();//第二次执行 rs2.close(); stmt.close(); //查看mysql日志 1 Prepare select * from users where name = ? 1 Execute select * from users where name = &#x27;aaa&#x27; 1 Execute select * from users where name = &#x27;ddd&#x27; mybatis是如何实现预编译的mybatis 默认情况下，将对所有的 sql 进行预编译。mybatis底层使用PreparedStatement，过程是先将带有占位符（即”?”）的sql模板发送至mysql服务器，由服务器对此无参数的sql进行编译后，将编译结果缓存，然后直接执行带有真实参数的sql。核心是通过#&#123; &#125; 实现的。 在预编译之前，#{ } 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符?。 1234//sqlMap 中如下的 sql 语句select * from user where name = #&#123;name&#125;;//解析成为预编译语句select * from user where name = ?; 如果${ }，SQL 解析阶段将会进行变量替换。不能实现预编译。 123select * from user where name = &#x27;$&#123;name&#125;&#x27;//传递的参数为 &quot;ruhua&quot; 时,解析为如下，然后发送数据库服务器进行编译。select * from user where name = &quot;ruhua&quot;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://guoshunfa.com/tags/SQL/"}]},{"title":"Mac系统安装Docker","slug":"软件开发/技术/服务器/Mac系统安装Docker","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Mac系统安装Docker/","link":"","permalink":"https://guoshunfa.com/2022/07/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Docker/","excerpt":"","text":"转载自：https://blog.csdn.net/qq_42405688/article/details/124468315 开始安装： 1、终端输入： 1brew install --cask --appdir=/Applications docker 2、出现：docker was successfully installed! 安装成功。 3、 第一次使用，是需要本机密码确认的。 4、输入密码后，弹出以下界面。 5、安装成功后，可在终端检查docker版本，显示版本后，表示安装成功。 1docker --version 二、docker国内镜像配置 在红框处进行添加以下代码后，点击Apply &amp; Restart 按钮： 123456789101112131415&#123; &quot;builder&quot;: &#123; &quot;gc&quot;: &#123; &quot;enabled&quot;: true, &quot;defaultKeepStorage&quot;: &quot;20GB&quot; &#125; &#125;, &quot;experimental&quot;: false, &quot;features&quot;: &#123; &quot;buildkit&quot;: true &#125;, &quot;registry-mirrors&quot;:[ &quot;http://hub-mirror.c.163.com&quot; ]&#125; 查看是否应用镜像成功，红框内容就是上面配置的国内镜像： 1docker info 附docker国内常用镜像： 1、中科大: https://docker.mirrors.ustc.edu.cn 2、网易: http://hub-mirror.c.163.com 3、Docker 官方中国区: https://registry.docker-cn.com 4、七牛云: https://reg-mirror.qiniu.com","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://guoshunfa.com/tags/mac/"},{"name":"docker","slug":"docker","permalink":"https://guoshunfa.com/tags/docker/"}]},{"title":"Shell expect用法描述","slug":"软件开发/技术/服务器/Shell-expect-用法描述","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Shell-expect-用法描述/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-expect-%E7%94%A8%E6%B3%95%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"1. expect 自动化交互脚本1.1. 介绍expect是一个自动化交互套件，主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。 1.2. 安装12sudo apt-get updatesudo apt-get install expect 1.3. 命令介绍Expect中最关键的四个命令是send,expect,spawn,interact。 send：向进程发送字符串，用于模拟用户的输入， 该命令不能自动回车换行，一般要加\\r（回车） expect： expect的一个内部命令，判断上次输出结果里是否包含指定的字符串，如果有则立即返回，否则就等待超时时间后返回，只能捕捉由spawn启动的进程的输出expect spawn：启动进程，并跟踪后续交互信息 interact：执行完成后保存交互状态，把控制权交给控制台 set timeout 30：设置超时时间为30秒(默认的超时时间是 10 秒，通过 set 命令可以设置会话超时时间, 若不限制超时时间则应设置为-1) exp_continue： 允许expect继续向下执行指令meout：指定超时时间，过期则继续执行后续指令 send_user： 回显命令，相当于echo $argv参数数组：Expect脚本可以接受从bash传递的参数，可以使用 [lindex $argv n] 获得，n从0开始，分别表示第一个$1，第二个$2，第三个$3……参数 ($argvn没有空格则表示脚本名称 ； $argv n有空格则代表下标) 一般流程：spawn 启动追踪 —&gt; expect 匹配捕捉关键字 ——&gt; 捕捉到将触发send 代替人为输入指令—&gt; interact &#x2F;expect eof Expect脚本必须以interact或expect eof 结束，执行自动化任务通常expect eof就够了 expect eof 是在等待结束标志。由spawn启动的命令在结束时会产生一个eof标记，expect eof 即在等待这个标记 1.4. bash shell内加入expect脚本使用&lt;&lt;-EOF ，引入expect脚本。 1234#!/bin/base/usr/bin/expect &lt;&lt;-EOFEOF 2. 事例2.1. ssh 连接远端服务器1). 开始构建文件 1vi test_expect.exp 2). 构建文件内容 12345678910111213141516171819202122232425262728#!/usr/bin/expect# 传入参数数量验证if &#123;$argc &lt; 3&#125; &#123; #do something send_user &quot;usage: $argv0 &lt;remote_user&gt; &lt;remote_host&gt; &lt;remote_pwd&gt;&quot; exit&#125;// 将超时设置为-1以禁用超时功能。set timeout -1# 远程服务器用户名set remote_user [lindex $argv 0] # 远程服务器域名set remote_host [lindex $argv 1] # 远程服务器密码set remote_pwd [lindex $argv 2]# 远程登录spawn ssh $&#123;remote_user&#125;@$&#123;remote_host&#125;expect &#123; &quot;*password&quot; &#123;send &quot;$&#123;remote_pwd&#125;\\r&quot;;&#125; &quot;*yes/no&quot; &#123;send &quot;yes\\r&quot;;exp_continue&#125;&#125;# ssh登陆成功后，继续进行操作。expect &quot;]#&quot; &#123; send &quot;cd /\\r&quot; &#125;# 结束expect eof 3). 使用脚本 1./test_expect.exp username ip password 🌟 注意事项 脚本文件内容第一行必须加入#!/usr/bin/expect。 expect 脚本文件执行必须使用 .&#x2F;test_expect.exp。","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"},{"name":"Expect","slug":"Expect","permalink":"https://guoshunfa.com/tags/Expect/"}]},{"title":"IDEA Debug调试","slug":"软件开发/技术/软件使用/IDEA-Debug调试","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/IDEA-Debug调试/","link":"","permalink":"https://guoshunfa.com/2022/07/IDEA-Debug%E8%B0%83%E8%AF%95/","excerpt":"","text":"debug 基本操作这里主要描述这些按钮的用处。 按钮依次的用处是： 回到断点处 步过 步入 强制步入 步出 丢帧 运行到光标处 评估表达式 跟踪当前流链 回到断点处当不知道当前断点停留在何处时，点击这个按钮，即可回到当前断点处。 步过正常执行下一行代码。 步入进入到方法中。 强制步入进入到方法的源码中。 步出于步入相反，步出是让方法正常执行结果，并且返回到方法调用方。 丢帧如果一部分代码没有调试到，可以点击这个按钮，将断点会退到原来位置。 运行到光标处光标指定将要执行的一行代码，点击此按钮，断点会停留到光标所在的那一行。 评估表达式可以通过代码段的方式，对当前的调试内容进行进一步分析。 跟踪当前流链主要用于JDK8 的 Stream调试。 针对Stream的调试，idea提供了一个很强大的功能。通过流跟踪，可以清晰的看出数据的走向。 debug 高级操作debug高级调试分为几种： 字段断点调试 异常断点调试 方法断点调试 手动制造抛出异常 和 强制返回 字段断点调试字段左侧打上断点，右键断点位置，根据需要调整配置。 我这里选中了“字段修改时监听”。 Debug时字段如果在某个位置进行了修改，断点会自动打到修改的那行代码，详细请看下方截图。 异常断点调试先看一下这段代码。 12345@Testpublic void exceptionTest() &#123; String str = null; boolean bool = str.equals(&quot;xxx&quot;);&#125; 这段代码会报一个错误：NullPointerException（空指针异常），下面我们通过debug进行捕捉NullPointerException。 首先打开debug断点面板 打开断点面板后，点击左上角加号（➕），选择Java异常断点，查找并添加NullPointerException。 这样就能够拦截到NullPointerException了。 方法断点调试在方法处加入断点，右键断点进行断点详情，可以在方法输入或输出时进行调试。 我这里选择了方法输入和方法输出，在进行debug时，断点会停留在方法的第一行和结束行。 手动制造抛出异常 和 强制返回在线程执行过程中，想在某一行代码手动的制造异常抛出或者强制返回，只需要在当前帧右键，选择抛出异常（或者强制返回），输入异常值（或者返回数据），即可直接抛出异常（或者返回）。 debug 调试远端服务如果通过debug 调试远端服务的代码，下面描述几种方式。 服务启动时添加参数 切记，仅可以用于测试环境。 1oracle-java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://guoshunfa.com/tags/IDEA/"},{"name":"Debug","slug":"Debug","permalink":"https://guoshunfa.com/tags/Debug/"}]},{"title":"IDEA Maven依赖版本冲突","slug":"软件开发/技术/软件使用/IDEA-Maven依赖版本冲突","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/IDEA-Maven依赖版本冲突/","link":"","permalink":"https://guoshunfa.com/2022/07/IDEA-Maven%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/","excerpt":"","text":"在idea中，如何查看maven中哪些依赖存在着版本冲突。 我们这边用mybatisplus举例，引入了不同版本的依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 点击右侧边框中的maven按钮 找到并点击分析依赖关系（放大镜），页面会弹出一个签儿。 通过左侧“已解析的依赖项”，可以看出哪些以来存在问题（感叹号标识）。 点击出现问题的依赖项，可以查看详细。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://guoshunfa.com/tags/IDEA/"},{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"}]},{"title":"IDEA 实用插件","slug":"软件开发/技术/软件使用/IDEA实用插件","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/IDEA实用插件/","link":"","permalink":"https://guoshunfa.com/2022/07/IDEA%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6/","excerpt":"","text":"RestfulTool：可以根据接口url，快速定位controller代码位置的插件。 vo2dto：vo、dto转换的快捷代码生成插件。 Easy Javadoc：快速生成注释的插件，可以通过英文自动生成对应注释内容。 MyBatisCodeHelperPro：可以将mybatis xml文件中的sql片段，转换成可执行的sql，还支持执行sql，和查看执行之后的数据的功能。 CamelCase：修改字段的驼峰式命名。 Alibaba Java Coding Guidelines：代码规范检测插件。 GsonFormPlus：通过json数据，动态生成DTO文件。可以用于快速封装第三方接口。 maven-search：快速搜索maven依赖的插件，减少去maven官网仓库查找的操作。 POJO to JSON：将pojo内容转换成json数据，还支持填入随机值。 Properties to YAML Convert：springboot的配置文件***.properties转换成yaml的插件。 JRebal and XRebel：热部署代码。 JRebal mybatisPlus extension：热部署mybatis xml文件。 Grep Console：调整控制台日志颜色的插件。 RainBow Brackers：代码彩色括号。 CodeGlance Pro：代码缩略图插件，展示在代码右侧滚轮处。 Material Theme UI：idea主题库。 Mybatis Log: 查看Mybatis 中sql的执行内容。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://guoshunfa.com/tags/IDEA/"},{"name":"插件","slug":"插件","permalink":"https://guoshunfa.com/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"IDEA 拒绝卡顿","slug":"软件开发/技术/软件使用/IDEA拒绝卡顿","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/IDEA拒绝卡顿/","link":"","permalink":"https://guoshunfa.com/2022/07/IDEA%E6%8B%92%E7%BB%9D%E5%8D%A1%E9%A1%BF/","excerpt":"","text":"IDEA - 拒绝卡顿在同样内存的电脑，为什么别人能启动10个Java程序，而你只能启动5个。 其实他们改了下面这些配置。 1. Java程序启动配置给每一个启动服务，都配置一下vm options，合理的降低每个服务占用的资源。 下面进行调整，首先要找到“运行配置模版”选项。 选择SpringBoot，将vm options填入。-Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps 添加完默认值后，以后创建的Springboot运行配置，都会默认是这个。 2. 调整idea vm optionsidea默认的vm options，会占用很大的资源。这里进行合理的调整 将这两项配置调整为： 12-Xmx1024m-Xms1024m","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://guoshunfa.com/tags/IDEA/"}]},{"title":"搭建单体SpringBoot项目 特殊响应结构","slug":"软件开发/场景/搭建单体SpringBoot项目/01统一结构/搭建单体SpringBoot项目-特殊响应结构","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-特殊响应结构/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E7%89%B9%E6%AE%8A%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%84/","excerpt":"","text":"并不是所有的需求都要求使用统一的响应结构，在编写对外开放的接口时，可能会使用另外一套响应规则进行返回。 这里在原有的统一响应结构的基础上，进行一些定制化处理。 定义一个特殊响应注解定义一个用于特殊响应的注解，把注解放在想要特殊响应的接口方法上。 1234567import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface NotUnifiedResult &#123;&#125; 调整封装返回结果123456789101112131415161718192021222324252627282930313233343536import org.springframework.core.MethodParameter;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.method.support.HandlerMethodReturnValueHandler;import org.springframework.web.method.support.ModelAndViewContainer;/** * 封装返回结果 */public class PandaHandlerMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; private final HandlerMethodReturnValueHandler returnValueHandler; public PandaHandlerMethodReturnValueHandler(HandlerMethodReturnValueHandler returnValueHandler) &#123; this.returnValueHandler = returnValueHandler; &#125; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return returnValueHandler.supportsReturnType(returnType); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; // 不需要统一封装的接口，直接返回。 if (returnType.hasMethodAnnotation(NotUnifiedResult.class)) &#123; this.returnValueHandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); return; &#125; // 人为的使用的统一封装，不会再次封装。 if (returnValue instanceof ApiResult) &#123; this.returnValueHandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); return; &#125; this.returnValueHandler.handleReturnValue(ApiResult.ok(returnValue), returnType, mavContainer, webRequest); &#125;&#125;","categories":[{"name":"搭建单体SpringBoot项目","slug":"搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"搭建单体SpringBoot项目 统一响应结构","slug":"软件开发/场景/搭建单体SpringBoot项目/01统一结构/搭建单体SpringBoot项目-统一响应结构","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-统一响应结构/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%84/","excerpt":"","text":"每个接口都需要有一个统一的响应结构。比如： 12345&#123; &quot;code&quot;: 200, &quot;msg&quot;: &quot;OK&quot;, &quot;data&quot;: &quot;我是数据&quot;&#125; 结果展示接口定义： 请求响应结果： 设定一个统一的响应模版接口响应内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(&quot;接口响应内容&quot;)public class ApiResult&lt;T&gt; &#123; @ApiModelProperty(&quot;响应码&quot;) private Integer code; @ApiModelProperty(&quot;消息内容&quot;) private String msg; @ApiModelProperty(&quot;响应数据&quot;) private T data; public static ApiResult ok() &#123; return ok(null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; ok(T data) &#123; return ok(&quot;请求成功&quot;, data); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; ok(String msg, T data) &#123; return init(ApiResultCodeEnum.SUCCESS.getCode(), msg, data); &#125; public static ApiResult fail() &#123; return fail(null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; fail(T data) &#123; return fail(&quot;请求失败&quot;, data); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; fail(String msg, T data) &#123; return init(ApiResultCodeEnum.FAILURE.getCode(), msg, data); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; init(Integer code, String msg, T data) &#123; ApiResult&lt;T&gt; apiResult = new ApiResult&lt;T&gt;(); apiResult.setCode(code); apiResult.setMsg(msg); apiResult.setData(data); return apiResult; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 响应码枚举123456789101112131415161718192021222324252627282930313233343536/** * 响应码枚举 */public enum ApiResultCodeEnum &#123; SUCCESS(200, &quot;SUCCESS&quot;), FAILURE(500, &quot;FAILURE&quot;), UN_LOGIN(401, &quot;请求未授权&quot;), NOT_FOUND(404, &quot;接口不存在&quot;); private Integer code; private String msg; ApiResultCodeEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 封装返回结果123456789101112131415161718192021222324252627282930import org.springframework.core.MethodParameter;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.method.support.HandlerMethodReturnValueHandler;import org.springframework.web.method.support.ModelAndViewContainer;/** * 封装返回结果 */public class PandaHandlerMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; private final HandlerMethodReturnValueHandler returnValueHandler; public PandaHandlerMethodReturnValueHandler(HandlerMethodReturnValueHandler returnValueHandler) &#123; this.returnValueHandler = returnValueHandler; &#125; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return returnValueHandler.supportsReturnType(returnType); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue instanceof ApiResult) &#123; this.returnValueHandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); return; &#125; this.returnValueHandler.handleReturnValue(ApiResult.ok(returnValue), returnType, mavContainer, webRequest); &#125;&#125; 添加配置123456789101112131415161718192021222324252627282930import org.springframework.beans.factory.InitializingBean;import org.springframework.context.annotation.Configuration;import org.springframework.web.method.support.HandlerMethodReturnValueHandler;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;@Configurationpublic class ReturnValueConfig implements InitializingBean &#123; @Resource RequestMappingHandlerAdapter requestMappingHandlerAdapter; @Override public void afterPropertiesSet() &#123; List&lt;HandlerMethodReturnValueHandler&gt; unmodifiableList = requestMappingHandlerAdapter.getReturnValueHandlers(); List&lt;HandlerMethodReturnValueHandler&gt; list = new ArrayList&lt;&gt;(unmodifiableList.size()); for (HandlerMethodReturnValueHandler returnValueHandler : unmodifiableList) &#123; if (returnValueHandler instanceof RequestResponseBodyMethodProcessor) &#123; list.add(new PandaHandlerMethodReturnValueHandler(returnValueHandler)); &#125; else &#123; list.add(returnValueHandler); &#125; &#125; requestMappingHandlerAdapter.setReturnValueHandlers(list); &#125;&#125;","categories":[{"name":"搭建单体SpringBoot项目","slug":"搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"搭建单体SpringBoot项目 统一异常处理","slug":"软件开发/场景/搭建单体SpringBoot项目/01统一结构/搭建单体SpringBoot项目-统一异常处理","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-统一异常处理/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"所有的异常信息进行统一处理。 关于异常相关的知识，请移步到Java基础 - 异常 结果展示加入测试代码： 请求响应信息： 添加统一异常处理类12345678910111213141516171819202122232425262728import com.panda.base.exception.custom.PandaException;import com.panda.base.result.vo.ApiResult;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@RestControllerAdvicepublic class PandaGlobalExceptionHandler &#123; /** * 这是我的自定义异常 * * @param e * @return */ @ExceptionHandler(&#123;PandaException.class&#125;) public ApiResult runtimeException(PandaException e) &#123; return ApiResult.fail(&quot;PandaException:&quot; + e); &#125; /** * 兜底异常，其他异常都没有匹配到的会来到这个方法进行处理。 */ @ExceptionHandler(&#123;Exception.class&#125;) public ApiResult Exception(Exception e) &#123; return ApiResult.fail(&quot;Exception:&quot; + e); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"搭建单体SpringBoot项目 统一时间响应格式","slug":"软件开发/场景/搭建单体SpringBoot项目/01统一结构/搭建单体SpringBoot项目-统一时间响应格式","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-统一时间响应格式/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E7%BB%9F%E4%B8%80%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"在日常的接口开发中，不免会遇到时间类型的数据。时间类型如果什么都不处理就响应给前端的话，不太友好。 这里后端做一些配置，就可以让响应的时间根据制定格式进行转换，将转换后的时间响应给前端。 配置前后的区别没添加配置前： 12345&#123; &quot;code&quot;: 200, &quot;msg&quot;: &quot;请求成功&quot;, &quot;data&quot;: &quot;2022-10-13T05:22:01.961+00:00&quot;&#125; 添加配置后： 12345&#123; &quot;code&quot;: 200, &quot;msg&quot;: &quot;请求成功&quot;, &quot;data&quot;: &quot;2022-10-13 13:13:23&quot;&#125; 添加配置信息添加配置信息到springboot配置文件application.properties。 1234# json入参及返回值Date时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ss# 时区spring.jackson.time-zone=GMT+8","categories":[{"name":"搭建单体SpringBoot项目","slug":"搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"搭建单体SpringBoot项目 集成SpringSecurity","slug":"软件开发/场景/搭建单体SpringBoot项目/10集成用户权限验证框架/搭建单体SpringBoot项目-集成SpringSecurity","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成SpringSecurity/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90SpringSecurity/","excerpt":"","text":"SpringSecurity框架 - 官方介绍 SpringSecurity框架 - 理解与使用","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://guoshunfa.com/tags/SpringSecurity/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"用户权限验证","slug":"用户权限验证","permalink":"https://guoshunfa.com/tags/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/"}]},{"title":"搭建单体SpringBoot项目 Scheduled注解实现定时器","slug":"软件开发/场景/搭建单体SpringBoot项目/20集成定时器/搭建单体SpringBoot项目-Scheduled注解实现定时器","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-Scheduled注解实现定时器/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-Scheduled%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"使用springboot携带的Scheduled注解实现定时器功能。 1. 添加定时任务1234567891011121314151617181920import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.concurrent.TimeUnit;@Componentpublic class ScheduledTest &#123; @Scheduled(cron = &quot;0/1 * * * * ?&quot;) public void test1() throws InterruptedException &#123; System.out.println(&quot;test1: &quot; + System.currentTimeMillis()); TimeUnit.SECONDS.sleep(10); &#125; @Scheduled(cron = &quot;0/2 * * * * ?&quot;) public void test2() &#123; System.out.println(&quot;test2: &quot; + System.currentTimeMillis()); &#125;&#125; 2. 添加定时器配置12345678910111213141516import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableScheduling;import org.springframework.scheduling.annotation.SchedulingConfigurer;import org.springframework.scheduling.config.ScheduledTaskRegistrar;import java.util.concurrent.Executors;@Configuration@EnableSchedulingpublic class ScheduledConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; // 配置线程池，可以根据实际情况调整线程池大小。 taskRegistrar.setScheduler(Executors.newScheduledThreadPool(20)); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Scheduled","slug":"Scheduled","permalink":"https://guoshunfa.com/tags/Scheduled/"},{"name":"定时器","slug":"定时器","permalink":"https://guoshunfa.com/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"}]},{"title":"搭建单体SpringBoot项目 集成 Logback(日志管理)","slug":"软件开发/场景/搭建单体SpringBoot项目/21集成日志管理/搭建单体SpringBoot项目-集成 Logback(日志管理)","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.238Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成 Logback(日志管理)/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90%20Logback(%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86)/","excerpt":"","text":"集成 Logback(日志管理)application.properties123logging.config=classpath:config/logback.xmllogging.level.dao=debuglog.path=/Library/work/workspace-learn/springboot/gsf/gsf-log logback.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;&lt;!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --&gt;&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- 读取application.properties信息 --&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;logPath&quot; source=&quot;log.path&quot; defaultValue=&quot;logdir&quot;/&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;$&#123;logPath&#125;&quot; /&gt; &lt;!--0. 日志格式和颜色渲染 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt; &lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt; &lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt; &lt;!--1. 输出到控制台--&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;debug&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--2. 输出到文档--&gt; &lt;!-- 2.1 level为 DEBUG 日志，时间滚动输出 --&gt; &lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/gsf_debug.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 日志归档 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/gsf-debug-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录debug级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;debug&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.2 level为 INFO 日志，时间滚动输出 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/gsf_info.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/gsf-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;info&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.3 level为 WARN 日志，时间滚动输出 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/gsf_warn.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/gsf-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.4 level为 ERROR 日志，时间滚动输出 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/gsf_error.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/gsf-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、 以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前logger将会继承上级的级别。 addtivity:是否向上级logger传递打印信息。默认是true。 &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;/&gt; &lt;logger name=&quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&quot; level=&quot;INFO&quot;/&gt; --&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;info&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别： 【logging.level.org.mybatis=debug logging.level.dao=debug】 --&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 不能设置为INHERITED或者同义词NULL。默认是DEBUG 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 --&gt; &lt;!-- 4. 最终的策略 --&gt; &lt;!-- 4.1 开发环境:打印控制台--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;logger name=&quot;com.sdcm.pmp&quot; level=&quot;debug&quot;/&gt; &lt;/springProfile&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;/root&gt; &lt;!-- 4.2 生产环境:输出到文档 &lt;springProfile name=&quot;pro&quot;&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt; --&gt;&lt;/configuration&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Logback","slug":"Logback","permalink":"https://guoshunfa.com/tags/Logback/"}]},{"title":"搭建单体SpringBoot项目 集成定时器Quartz","slug":"软件开发/场景/搭建单体SpringBoot项目/20集成定时器/搭建单体SpringBoot项目-集成定时器Quartz","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.237Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成定时器Quartz/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90%E5%AE%9A%E6%97%B6%E5%99%A8Quartz/","excerpt":"","text":"1. Quartz 介绍 Quartz是功能强大的开源作业调度库，几乎可以集成到任何Java应用程序中-从最小的独立应用程序到最大的电子商务系统。Quartz可用于创建简单或复杂的计划，以执行数以十计，百计，万计的工作。任务标准Java组件的任务，都可以执行您对其执行的任何编程操作。Quartz Scheduler包含许多企业级功能，例如对JTA事务和集群的支持。 Quartz是免费使用的，并根据Apache 2.0许可获得许可。 2. 集成 Quartz架构描述： Mysql作为Quartz持久化数据库。 MongoDB作为主数据存储数据库。 SpringBoot框架。 支持服务： 根据cron定时执行任务。 （可扩展一次执行。） 2.1. 项目框架准备2.1.1. 添加maven库12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Spring Boot web启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- MongoDB --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 2.1.2. 执行 Mysql sql文件 job运行时需要的文件，主要作用是持久化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169## Quartz seems to work best with the driver mm.mysql-2.0.7-bin.jar## PLEASE consider using mysql with innodb tables to avoid locking issues## In your Quartz properties file, you&#x27;ll need to set# org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate#DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;DROP TABLE IF EXISTS QRTZ_LOCKS;DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;DROP TABLE IF EXISTS QRTZ_TRIGGERS;DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;DROP TABLE IF EXISTS QRTZ_CALENDARS;CREATE TABLE QRTZ_JOB_DETAILS ( SCHED_NAME VARCHAR(120) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, JOB_CLASS_NAME VARCHAR(250) NOT NULL, IS_DURABLE VARCHAR(1) NOT NULL, IS_NONCONCURRENT VARCHAR(1) NOT NULL, IS_UPDATE_DATA VARCHAR(1) NOT NULL, REQUESTS_RECOVERY VARCHAR(1) NOT NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE QRTZ_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, NEXT_FIRE_TIME BIGINT(13) NULL, PREV_FIRE_TIME BIGINT(13) NULL, PRIORITY INTEGER NULL, TRIGGER_STATE VARCHAR(16) NOT NULL, TRIGGER_TYPE VARCHAR(8) NOT NULL, START_TIME BIGINT(13) NOT NULL, END_TIME BIGINT(13) NULL, CALENDAR_NAME VARCHAR(200) NULL, MISFIRE_INSTR SMALLINT(2) NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP) REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE QRTZ_SIMPLE_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, REPEAT_COUNT BIGINT(7) NOT NULL, REPEAT_INTERVAL BIGINT(12) NOT NULL, TIMES_TRIGGERED BIGINT(10) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_CRON_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, CRON_EXPRESSION VARCHAR(200) NOT NULL, TIME_ZONE_ID VARCHAR(80), PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_SIMPROP_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, STR_PROP_1 VARCHAR(512) NULL, STR_PROP_2 VARCHAR(512) NULL, STR_PROP_3 VARCHAR(512) NULL, INT_PROP_1 INT NULL, INT_PROP_2 INT NULL, LONG_PROP_1 BIGINT NULL, LONG_PROP_2 BIGINT NULL, DEC_PROP_1 NUMERIC(13,4) NULL, DEC_PROP_2 NUMERIC(13,4) NULL, BOOL_PROP_1 VARCHAR(1) NULL, BOOL_PROP_2 VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_BLOB_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, BLOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_CALENDARS ( SCHED_NAME VARCHAR(120) NOT NULL, CALENDAR_NAME VARCHAR(200) NOT NULL, CALENDAR BLOB NOT NULL, PRIMARY KEY (SCHED_NAME,CALENDAR_NAME));CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_FIRED_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, ENTRY_ID VARCHAR(95) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, FIRED_TIME BIGINT(13) NOT NULL, SCHED_TIME BIGINT(13) NOT NULL, PRIORITY INTEGER NOT NULL, STATE VARCHAR(16) NOT NULL, JOB_NAME VARCHAR(200) NULL, JOB_GROUP VARCHAR(200) NULL, IS_NONCONCURRENT VARCHAR(1) NULL, REQUESTS_RECOVERY VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,ENTRY_ID));CREATE TABLE QRTZ_SCHEDULER_STATE ( SCHED_NAME VARCHAR(120) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, LAST_CHECKIN_TIME BIGINT(13) NOT NULL, CHECKIN_INTERVAL BIGINT(13) NOT NULL, PRIMARY KEY (SCHED_NAME,INSTANCE_NAME));CREATE TABLE QRTZ_LOCKS ( SCHED_NAME VARCHAR(120) NOT NULL, LOCK_NAME VARCHAR(40) NOT NULL, PRIMARY KEY (SCHED_NAME,LOCK_NAME));commit; 2.1.3. 项目配置1234567891011121314151617181920212223242526272829303132333435server.port=9992# MongoDB数据库spring.data.mongodb.uri=mongodb://127.0.0.1:27017/gsf_mongodb_20210710#=======================================================#调度器配置#=======================================================org.quartz.scheduler.instanceId=AUTOorg.quartz.scheduler.instanceName=project1QuartzSchedulerorg.quartz.scheduler.rmi.export=falseorg.quartz.scheduler.rmi.proxy=false#=======================================================#线程池配置#=======================================================org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPoolorg.quartz.threadPool.threadCount=5org.quartz.threadPool.threadPriority=5org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread=true#=======================================================#JobStore配置#=======================================================org.quartz.jobStore.misfireThreshold=60000org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTXorg.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegateorg.quartz.jobStore.isClustered=falseorg.quartz.jobStore.tablePrefix=QRTZ_org.quartz.jobStore.dataSource=myDS#=======================================================#Mysql数据库配置#=======================================================org.quartz.dataSource.myDS.driver=com.mysql.jdbc.Driverorg.quartz.dataSource.myDS.URL=jdbc:mysql://localhost:3306/gsf_quartz_20210711?characterEncoding=utf-8org.quartz.dataSource.myDS.user=rootorg.quartz.dataSource.myDS.password=guoshunfaorg.quartz.dataSource.myDS.maxConnections=5 2.2. 服务代码2.2.1. Job服务统一执行类1234567891011121314151617181920212223242526272829303132333435363738394041424344import cn.hutool.extra.spring.SpringUtil;import com.gsf.job.entity.JobDataMap;import lombok.Getter;import lombok.Setter;import org.quartz.JobDetail;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.scheduling.quartz.QuartzJobBean;import java.lang.reflect.Method;//@DisallowConcurrentExecution // 并发处理public class JobAutoExe extends QuartzJobBean &#123; /** * 由quartz框架自动设值：jobDetail.getJobDataMap().put(&quot;jobId&quot;, bean.getId()) 这里面的值都会被设置到实例中 */ @Getter @Setter private String jobId; @Autowired private MongoTemplate mongoTemplate; @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; JobDetail jobdetail = jobExecutionContext.getJobDetail(); JobDataMap jobDataMap = mongoTemplate.findById(jobId, JobDataMap.class); if (jobDataMap == null) &#123; return; &#125; Object service = SpringUtil.getBean(jobDataMap.getClassName()); try &#123; Method method = service.getClass().getMethod(jobDataMap.getMethodName()); method.invoke(service); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;job统一执行类&quot;); &#125;&#125; 2.2.2. Job服务调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import com.gsf.job.entity.JobDataMap;import org.quartz.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import java.text.ParseException;@Servicepublic class QuartzService &#123; @Autowired private MongoTemplate mongoTemplate; @Autowired private Scheduler scheduler; /** * 保存/修改job * @param bean */ public void saveJob(JobDataMap bean) &#123; try &#123; JobKey jobKey = new JobKey(bean.getJobName()); JobDetail jobDetail = scheduler.getJobDetail(jobKey); if (jobDetail == null) &#123; jobDetail = newJobDetail(bean); &#125; Trigger trigger = newCronTrigger(bean); if (trigger != null) &#123; scheduler.scheduleJob(jobDetail, trigger); &#125; cronUpdate(bean); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /** * 移除job * @param bean */ public void removeJob(JobDataMap bean) &#123; try &#123; TriggerKey key = new TriggerKey(bean.getJobName()); scheduler.pauseTrigger(key); scheduler.unscheduleJob(key); JobKey jobKey = new JobKey(bean.getJobName()); scheduler.deleteJob(jobKey); &#125; catch (SchedulerException e) &#123; throw new RuntimeException(e); &#125; &#125; public void pausedJob(JobDataMap bean) &#123; try &#123; if (bean.isPaused()) &#123; scheduler.pauseTrigger(new TriggerKey(bean.getJobName())); &#125; else &#123; scheduler.resumeTrigger(new TriggerKey(bean.getJobName())); &#125; &#125; catch (SchedulerException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * cron 调整 * @param bean */ private void cronUpdate(JobDataMap bean) &#123; try &#123; JobKey jobKey = new JobKey(bean.getJobName()); JobDetail quartzJob = scheduler.getJobDetail(jobKey); if (quartzJob == null) &#123;//没有任务时创建任务并调度 quartzJob = newJobDetail(bean); Trigger trigger = newCronTrigger(bean); if (trigger != null) &#123; scheduler.scheduleJob(quartzJob, trigger); &#125; &#125; else &#123;//重新调度 TriggerKey triggerKey = new TriggerKey(bean.getJobName()); Trigger trigger = newCronTrigger(bean); scheduler.rescheduleJob(triggerKey, trigger); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private JobDetail newJobDetail(JobDataMap bean) throws InstantiationException, IllegalAccessException &#123; JobDetail jobDetail = JobBuilder.newJob(JobAutoExe.class) .withIdentity(bean.getJobName()).build(); jobDetail.getJobDataMap().put(&quot;jobId&quot;, bean.getId());//job实例执行前会将这些属性值设置进实例中，运行前根据id查询详情 return jobDetail; &#125; /** * 根据调度设置决定使用cron还是毫秒数 * * @param bean * @return * @throws ParseException */ private Trigger newCronTrigger(JobDataMap bean) throws ParseException &#123; if (StringUtils.isEmpty(bean.getCron())) &#123; return null; &#125; return TriggerBuilder.newTrigger().forJob(bean.getJobName()) .withIdentity(bean.getJobName()) .withSchedule(CronScheduleBuilder.cronSchedule(bean.getCron())) .build(); &#125;&#125; 2.2.3. Job通用实体类123456789101112131415161718192021import com.gsf.common.base.BaseEntity;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Datapublic class JobDataMap extends BaseEntity &#123; @ApiModelProperty(&quot;job名称&quot;) private String jobName; @ApiModelProperty(&quot;类名称&quot;) private String className; @ApiModelProperty(&quot;方法名称&quot;) private String methodName; @ApiModelProperty(&quot;cron规则&quot;) private String cron; @ApiModelProperty(&quot;任务状态，是否暂停。默认不暂停&quot;) private boolean paused = false;&#125; 2.2.4. Job服务调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.gsf.job.entity.JobDataMap;import com.gsf.job.schedule.QuartzService;import com.mongodb.client.result.DeleteResult;import com.mongodb.client.result.UpdateResult;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class JobController &#123; @Autowired private MongoTemplate mongoTemplate; @Autowired private QuartzService quartzService; @PostMapping(&quot;/job/save&quot;) @ApiOperation(value = &quot;创建/修改job信息&quot;) public JobDataMap saveJob(@RequestBody JobDataMap jobData) &#123; JobDataMap data = mongoTemplate.save(jobData); quartzService.saveJob(data); return data; &#125; @GetMapping(&quot;/job/remove&quot;) @ApiOperation(value = &quot;删除job&quot;) public DeleteResult removeJob(@ApiParam(name = &quot;jobId&quot;, required = true) String jobId) &#123; DeleteResult deleteResult = mongoTemplate.remove(Query.query(Criteria.where(&quot;id&quot;).is(jobId)), JobDataMap.class); JobDataMap data = mongoTemplate.findById(jobId, JobDataMap.class); quartzService.removeJob(data); return deleteResult; &#125; @GetMapping(&quot;/job/paused&quot;) @ApiOperation(value = &quot;暂停/运行job&quot;) public UpdateResult pausedJob( @ApiParam(name = &quot;jobId&quot;, required = true) String jobId , @ApiParam(name = &quot;paused&quot;, required = true) Boolean paused) &#123; UpdateResult updateResult = mongoTemplate.updateFirst(Query.query(Criteria.where(&quot;id&quot;).is(jobId)), Update.update(&quot;paused&quot;, paused), JobDataMap.class); JobDataMap data = mongoTemplate.findById(jobId, JobDataMap.class); quartzService.pausedJob(data); return updateResult; &#125;&#125; 2.2.5. 测试123456789101112131415161718public class TestJob &#123; @Test public void saveJob() &#123; String url = &quot;http://127.0.0.1:9992/job/save&quot;; JobDataMap jobDataMap = new JobDataMap(); jobDataMap.setClassName(&quot;TestJob&quot;); jobDataMap.setJobName(&quot;测试job&quot;); jobDataMap.setCron(&quot;*/5 * * * * ?&quot;); // 每隔5秒执行一次 jobDataMap.setMethodName(&quot;doJob&quot;); jobDataMap.setPaused(true); String post = HttpUtil.post(url, JSONUtil.toJsonStr(jobDataMap)); System.out.println(post); &#125;&#125; 3. 提升3.1. 并发控制（DisallowConcurrentExecution注解）​ Quartz定时任务默认都是并发执行的，不会等待上一次任务执行完毕，只要间隔时间到就会执行, 如果定时任执行太长，会长时间占用资源，导致其它任务堵塞。 ​ 在Spring中这时需要设置concurrent的值为false, 禁止并发执行。 ​ &lt;property name=&quot;concurrent&quot; value=&quot;true&quot; /&gt;​ 当不使用spring的时候就需要在Job的实现类上加@DisallowConcurrentExecution的注释@DisallowConcurrentExecution 禁止并发执行多个相同定义的JobDetail, 这个注解是加在Job类上的, 但意思并不是不能同时执行多个Job, 而是不能并发执行同一个Job Definition(由JobDetail定义), 但是可以同时执行多个不同的JobDetail, 举例说明,我们有一个Job类,叫做SayHelloJob, 并在这个Job上加了这个注解, 然后在这个Job上定义了很多个JobDetail, 如sayHelloToJoeJobDetail, sayHelloToMikeJobDetail, 那么当scheduler启动时, 不会并发执行多个sayHelloToJoeJobDetail或者sayHelloToMikeJobDetail, 但可以同时执行sayHelloToJoeJobDetail跟sayHelloToMikeJobDetail @PersistJobDataAfterExecution 同样, 也是加在Job上,表示当正常执行完Job后, JobDataMap中的数据应该被改动, 以被下一次调用时用。当使用- - @PersistJobDataAfterExecution 注解时, 为了避免并发时, 存储数据造成混乱, 强烈建议把@DisallowConcurrentExecution注解也加上。 @DisallowConcurrentExecution 此标记用在实现Job的类上面,意思是不允许并发执行,按照我之前的理解是 不允许调度框架在同一时刻调用Job类，后来经过测试发现并不是这样，而是Job(任务)的执行时间[比如需要10秒]大于任务的时间间隔[Interval（5秒)],那么默认情况下,调度框架为了能让 任务按照我们预定的时间间隔执行,会马上启用新的线程执行任务。否则的话会等待任务执行完毕以后 再重新执行！（这样会导致任务的执行不是按照我们预先定义的时间间隔执行） 测试代码，这是官方提供的例子。设定的时间间隔为3秒,但job执行时间是5秒,设置@DisallowConcurrentExecution以后程序会等任务执行完毕以后再去执行,否则会在3秒时再启用新的线程执行","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"quartz","slug":"quartz","permalink":"https://guoshunfa.com/tags/quartz/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://guoshunfa.com/tags/spring-boot/"}]},{"title":"搭建单体SpringBoot项目 集成Kafka消息队列","slug":"软件开发/场景/搭建单体SpringBoot项目/22集成消息队列/搭建单体SpringBoot项目-集成Kafka消息队列","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.238Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Kafka消息队列/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"1. SpringBoot 集成 kafka 下面的例子是一个SpringBoot项目引入多个Kafka服务，如果只需要引入一个，只需要有一个配置就好。 1.1. 引入kafka依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;1.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.2. 修改配置文件(application.yml)1234567891011121314spring: kafka: one: bootstrap-servers: IP:PORT consumer: group-id: YOUR_GROUP_ID enable-auto-commit: true .......其他属性 two: bootstrap-servers: IP:PORT consumer: group-id: YOUR_GROUP_ID enable-auto-commit: true .......其他属性 1.3. Kafka生产者和消费者的配置通过@Configuration、@EnableKafka，声明Config并且打开KafkaTemplate能力。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@EnableKafka@Configurationpublic class KafkaOneConfig &#123; @Value(&quot;$&#123;spring.kafka.one.bootstrap-servers&#125;&quot;) private String bootstrapServers; @Value(&quot;$&#123;spring.kafka.one.consumer.group-id&#125;&quot;) private String groupId; @Value(&quot;$&#123;spring.kafka.one.consumer.enable-auto-commit&#125;&quot;) private boolean enableAutoCommit; @Bean public KafkaTemplate&lt;String, String&gt; kafkaOneTemplate() &#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125; @Bean KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt; kafkaOneContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(3); factory.getContainerProperties().setPollTimeout(3000); return factory; &#125; private ProducerFactory&lt;String, String&gt; producerFactory() &#123; return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs()); &#125; public ConsumerFactory&lt;Integer, String&gt; consumerFactory() &#123; return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); &#125; private Map&lt;String, Object&gt; producerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.RETRIES_CONFIG, 0); props.put(ProducerConfig.ACKS_CONFIG, &quot;1&quot;); // 不能写成 1 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return props; &#125; private Map&lt;String, Object&gt; consumerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, enableAutoCommit); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; &#125;&#125; 1.4. 多个kafka则继续加配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class KafkaTwoConfig &#123; @Value(&quot;$&#123;spring.kafka.two.bootstrap-servers&#125;&quot;) private String bootstrapServers; @Value(&quot;$&#123;spring.kafka.two.consumer.group-id&#125;&quot;) private String groupId; @Value(&quot;$&#123;spring.kafka.two.consumer.enable-auto-commit&#125;&quot;) private boolean enableAutoCommit; @Bean public KafkaTemplate&lt;String, String&gt; kafkaTwoTemplate() &#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125; @Bean KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt; kafkaTwoContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(3); factory.getContainerProperties().setPollTimeout(3000); return factory; &#125; private ProducerFactory&lt;String, String&gt; producerFactory() &#123; return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs()); &#125; public ConsumerFactory&lt;Integer, String&gt; consumerFactory() &#123; return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); &#125; private Map&lt;String, Object&gt; producerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.RETRIES_CONFIG, 0); props.put(ProducerConfig.ACKS_CONFIG, &quot;1&quot;); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return props; &#125; private Map&lt;String, Object&gt; consumerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, enableAutoCommit); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; &#125;&#125; 1.5. Kafka 消息生产者123456789101112131415161718@Controllerpublic class TestController &#123; @Autowired private KafkaTemplate kafkaOneTemplate; @Autowired private KafkaTemplate kafkaTwoTemplate; @RequestMapping(&quot;/send&quot;) @ResponseBody public String send() &#123; final String TOPIC = &quot;TOPIC_1&quot;; kafkaOneTemplate.send(TOPIC, &quot;kafka one&quot;); kafkaTwoTemplate.send(TOPIC, &quot;kafka two&quot;); return &quot;success&quot;; &#125;&#125; 1.6. Kafka 消息消费者123456789101112131415161718@Componentpublic class KafkaConsumer &#123; private static final Logger LOGGER = LoggerFactory.getLogger(KafkaConsumer.class); final String TOPIC = &quot;TOPIC_1&quot;; // containerFactory的值要与配置中KafkaListenerContainerFactory的Bean名称相同 @KafkaListener(topics = &#123;TOPIC&#125;, containerFactory = &quot;kafkaOneContainerFactory&quot;) public void listenerOne(ConsumerRecord&lt;?, ?&gt; record) &#123; LOGGER.info(&quot; kafka one 接收到消息：&#123;&#125;&quot;, record.value()); &#125; @KafkaListener(topics = &#123;TOPIC&#125;, containerFactory = &quot;kafkaTwoContainerFactory&quot;) public void listenerTwo(ConsumerRecord&lt;?, ?&gt; record) &#123; LOGGER.info(&quot; kafka two 接收到消息：&#123;&#125;&quot;, record.value()); &#125;&#125; 运行结果如下：","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Kafka","slug":"Kafka","permalink":"https://guoshunfa.com/tags/Kafka/"}]},{"title":"搭建单体SpringBoot项目 集成Activiti7 整合","slug":"软件开发/场景/搭建单体SpringBoot项目/23集成流程引擎/搭建单体SpringBoot项目-集成Activiti7-整合","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.247Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Activiti7-整合/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Activiti7-%E6%95%B4%E5%90%88/","excerpt":"","text":"一、Activiti与Spring整合开发1.1 Activiti与Spring整合的配置1)、在pom.xml文件引入坐标如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;properties&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt; &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alfresco&lt;/id&gt; &lt;name&gt;Activiti Releases&lt;/name&gt; &lt;url&gt;https://artifacts.alfresco.com/nexus/content/repositories/activiti-releases/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt;&lt;/repositories&gt; 在Activiti中核心类的是ProcessEngine流程引擎，与Spring整合就是让Spring来管理ProcessEngine 通过org.activiti.spring.SpringProcessEngineConfiguration 与Spring整合方式来创建ProcessEngine对象。 创建spring与activiti的整合配置文件：activiti-spring.xml（名称不固定） 2)、创建activiti-spring.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/activiti&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt; &lt;!-- 工作流引擎配置bean --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 使用spring事务管理器 --&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;!-- 数据库策略 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;drop-create&quot;/&gt; &lt;/bean&gt; &lt;!-- 流程引擎 --&gt; &lt;bean id=&quot;processEngine&quot; class=&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;&gt; &lt;property name=&quot;processEngineConfiguration&quot; ref=&quot;processEngineConfiguration&quot;/&gt; &lt;/bean&gt; &lt;!-- 资源服务service --&gt; &lt;bean id=&quot;repositoryService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRepositoryService&quot;/&gt; &lt;!-- 流程运行service --&gt; &lt;bean id=&quot;runtimeService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRuntimeService&quot;/&gt; &lt;!-- 任务管理service --&gt; &lt;bean id=&quot;taskService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getTaskService&quot;/&gt; &lt;!-- 历史管理service --&gt; &lt;bean id=&quot;historyService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getHistoryService&quot;/&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面，根据具体项目修改切点配置 &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(*com.itheima.service.impl..(..))&quot;/&gt; &lt;/aop:config&gt;--&gt;&lt;/beans&gt; databaseSchemaUpdate的取值内容： flase： 默认值。activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常。（生产环境常用）true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建。（开发时常用）create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）。（单元测试常用）drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）。 1.2 测试Activiti与Spring整合1）、测试代码1234567891011121314/** 测试activiti与spring整合是否成功**/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:activiti-spring.xml&quot;) public class ActivitiTest &#123; @Autowired private RepositoryService repositoryService; @Test public void test01()&#123; System.out.println(&quot;部署对象:&quot;+repositoryService); &#125; &#125; 2）、执行流程分析下面我们一起来分析Activiti与Spring整合加载的过程。 1、加载activiti-spring.xml配置文件 2、加载SpringProcessEngineConfiguration对象，这个对象它需要依赖注入dataSource对象和transactionManager对象。 3、加载ProcessEngineFactoryBean工厂来创建ProcessEngine对象，而ProcessEngineFactoryBean工厂又需要依赖注入processEngineConfiguration对象。 4、processEngine对象来负责创建我们的Service对象，从而简化Activiti的开发过程。 二、Activiti7与SpringBoot整合开发Activiti7发布正式版之后，它与SpringBoot2.x已经完全支持整合开发。 2.1 SpringBoot整合Activiti7的配置为了能够实现SpringBoot与Activiti7整合开发，首先我们要引入相关的依赖支持。 在工程的pom.xml文件中引入相关的依赖，其中activiti的依赖是：activiti-spring-boot-starter。 具体依赖如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.29&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 通过该pom.xml文件所导入的坐标，我们就可以实现activiti7与Springboot整合。 2.2 SpringBoot的application.yml文件配置为了能够实现Activiti7生成的表放到Mysql数据库中，需要在配置文件application.yml中添加相关的配置 注意：activiti7默认没有开启数据库历史记录，需要手动配置开启 12345678910111213141516171819202122spring: datasource: url: jdbc:mysql:///activiti?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver activiti: #1.flase：默认值。activiti在启动时，对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常 #2.true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建 #3.create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表） #4.drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎） database-schema-update: true #检测历史表是否存在 activiti7默认没有开启数据库历史记录 启动数据库历史记录 db-history-used: true #记录历史等级 可配置的历史级别有none, activity, audit, full #none：不保存任何的历史数据，因此，在流程执行过程中，这是最高效的。 #activity：级别高于none，保存流程实例与流程行为，其他数据不保存。 #audit：除activity级别会保存的数据外，还会保存全部的流程任务及其属性。audit为history的默认值。 #full：保存历史数据的最高级别，除了会保存audit级别的数据外，还会保存其他全部流程相关的细节数据，包括一些流程参数等。 history-level: full #校验流程文件，默认校验resources下的processes文件夹里的流程文件 check-process-definitions: false 2.3 编写启动类123456789101112package com.itheima;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ActApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ActApplication.class,args); &#125;&#125; 2.4 添加SpringSecurity安全框架整合配置因为Activiti7与SpringBoot整合后，默认情况下，集成了SpringSecurity安全框架，这样我们就要去准备SpringSecurity整合进来的相关用户权限配置信息。 SpringBoot的依赖包已经将SpringSecurity的依赖包也添加进项目中。 2.4.1 添加SecurityUtil类为了能够快速实现SpringSecurity安全框架的配置，所添加的一个组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.itheima.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.context.SecurityContextImpl;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.stereotype.Component;import java.util.Collection;@Componentpublic class SecurityUtil &#123; private Logger logger = LoggerFactory.getLogger(SecurityUtil.class); @Autowired @Qualifier(&quot;myUserDetailsService&quot;) private UserDetailsService userDetailsService; public void logInAs(String username) &#123; UserDetails user = userDetailsService.loadUserByUsername(username); if (user == null) &#123; throw new IllegalStateException(&quot;User &quot; + username + &quot; doesn&#x27;t exist, please provide a valid user&quot;); &#125; logger.info(&quot;&gt; Logged in as: &quot; + username); SecurityContextHolder.setContext( new SecurityContextImpl( new Authentication() &#123; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return user.getAuthorities(); &#125; @Override public Object getCredentials() &#123; return user.getPassword(); &#125; @Override public Object getDetails() &#123; return user; &#125; @Override public Object getPrincipal() &#123; return user; &#125; @Override public boolean isAuthenticated() &#123; return true; &#125; @Override public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123; &#125; @Override public String getName() &#123; return user.getUsername(); &#125; &#125;)); org.activiti.engine.impl.identity.Authentication.setAuthenticatedUserId(username); &#125; &#125; 这个类可以从我们下载的Activiti7官方提供的Example中找到。 2.4.2 添加DemoApplicationConfig类在Activiti7官方下载的Example中找到DemoApplicationConfig类，它的作用是为了实现SpringSecurity框架的用户权限的配置，这样我们就可以在系统中使用用户权限信息。 本次项目中基本是在文件中定义出来的用户信息，当然也可以是数据库中查询的用户权限信息。 后面处理流程时用到的任务负责人，需要添加在这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.config;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.provisioning.InMemoryUserDetailsManager;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;@Configurationpublic class DemoApplicationConfiguration &#123; private Logger logger = LoggerFactory.getLogger(DemoApplicationConfiguration.class); @Bean public UserDetailsService myUserDetailsService() &#123; InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager(); //这里添加用户，后面处理流程时用到的任务负责人，需要添加在这里 String[][] usersGroupsAndRoles = &#123; &#123;&quot;jack&quot;, &quot;password&quot;, &quot;ROLE_ACTIVITI_USER&quot;, &quot;GROUP_activitiTeam&quot;&#125;, &#123;&quot;rose&quot;, &quot;password&quot;, &quot;ROLE_ACTIVITI_USER&quot;, &quot;GROUP_activitiTeam&quot;&#125;, &#123;&quot;tom&quot;, &quot;password&quot;, &quot;ROLE_ACTIVITI_USER&quot;, &quot;GROUP_activitiTeam&quot;&#125;, &#123;&quot;other&quot;, &quot;password&quot;, &quot;ROLE_ACTIVITI_USER&quot;, &quot;GROUP_otherTeam&quot;&#125;, &#123;&quot;system&quot;, &quot;password&quot;, &quot;ROLE_ACTIVITI_USER&quot;&#125;, &#123;&quot;admin&quot;, &quot;password&quot;, &quot;ROLE_ACTIVITI_ADMIN&quot;&#125;, &#125;; for (String[] user : usersGroupsAndRoles) &#123; List&lt;String&gt; authoritiesStrings = Arrays.asList(Arrays.copyOfRange(user, 2, user.length)); logger.info(&quot;&gt; Registering new user: &quot; + user[0] + &quot; with the following Authorities[&quot; + authoritiesStrings + &quot;]&quot;); inMemoryUserDetailsManager.createUser(new User(user[0], passwordEncoder().encode(user[1]), authoritiesStrings.stream().map(s -&gt; new SimpleGrantedAuthority(s)).collect(Collectors.toList()))); &#125; return inMemoryUserDetailsManager; &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.5 创建Bpmn文件Activiti7可以自动部署流程，前提是在resources目录下，创建一个新的目录processes，用来放置bpmn文件。 创建一个简单的Bpmn流程文件，并设置任务的用户组Candidate Groups。 Candidate Groups中的内容与上面DemoApplicationConfiguration类中出现的用户组名称要保持一致，可以填写：activitiTeam 或者 otherTeam。 这样填写的好处：当不确定到底由谁来负责当前任务的时候，只要是Groups内的用户都可以拾取这个任务 2.6 使用Junit方式测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.itheima.test;import com.itheima.utils.SecurityUtil;import org.activiti.api.process.model.ProcessInstance;import org.activiti.api.process.model.builders.ProcessPayloadBuilder;import org.activiti.api.process.runtime.ProcessRuntime;import org.activiti.api.runtime.shared.query.Page;import org.activiti.api.runtime.shared.query.Pageable;import org.activiti.api.task.model.Task;import org.activiti.api.task.model.builders.TaskPayloadBuilder;import org.activiti.api.task.runtime.TaskRuntime;import org.activiti.engine.repository.ProcessDefinition;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest public class Actviti7DemoApplicationTests &#123; @Autowired private ProcessRuntime processRuntime; @Autowired private TaskRuntime taskRuntime; @Autowired private SecurityUtil securityUtil; @Test public void testActBoot()&#123; System.out.println(taskRuntime); &#125; /** * 查看流程定义 */ @Test public void contextLoads() &#123; securityUtil.logInAs(&quot;system&quot;); Page&lt;org.activiti.api.process.model.ProcessDefinition&gt; processDefinitionPage = processRuntime.processDefinitions(Pageable.of(0, 10)); System.out.println(&quot;可用的流程定义数量：&quot; + processDefinitionPage.getTotalItems()); for (org.activiti.api.process.model.ProcessDefinition pd : processDefinitionPage.getContent()) &#123; System.out.println(&quot;流程定义：&quot; + pd); &#125; &#125; /** * 启动流程实例 */ @Test public void testStartProcess() &#123; securityUtil.logInAs(&quot;system&quot;); ProcessInstance pi = processRuntime.start(ProcessPayloadBuilder. start(). withProcessDefinitionKey(&quot;myProcess&quot;). build()); System.out.println(&quot;流程实例ID：&quot; + pi.getId()); &#125; /** **查询任务，并完成自己的任务 **/ @Test public void testTask() &#123; securityUtil.logInAs(&quot;jack&quot;); Page&lt;Task&gt; taskPage=taskRuntime.tasks(Pageable.of(0,10)); if (taskPage.getTotalItems()&gt;0)&#123; for (Task task:taskPage.getContent())&#123; taskRuntime.claim(TaskPayloadBuilder. claim(). withTaskId(task.getId()).build()); System.out.println(&quot;任务：&quot;+task); taskRuntime.complete(TaskPayloadBuilder. complete(). withTaskId(task.getId()).build()); &#125; &#125; Page&lt;Task&gt; taskPage2=taskRuntime.tasks(Pageable.of*(0,10)); if (taskPage2.getTotalItems()&gt;0)&#123; System.out.println(&quot;任务：&quot;+taskPage2.getContent()); &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://guoshunfa.com/tags/Activiti7/"}]},{"title":"搭建单体SpringBoot项目 集成Activiti7 基础","slug":"软件开发/场景/搭建单体SpringBoot项目/23集成流程引擎/搭建单体SpringBoot项目-集成Activiti7-基础","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.238Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Activiti7-基础/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Activiti7-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"B站教学视频:https://www.bilibili.com/video/BV1H54y167gf?p=1&amp;vd_source=4f29ed23e5c29723fd1ba4fc53288e87 一、工作流介绍1.1 概念工作流(Workflow)，就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。 1.2 工作流系统一个软件系统中具有工作流的功能，我们把它称为工作流系统，一个系统中工作流的功能是什么？就是对系统的业务流程进行自动化管理，所以工作流是建立在业务流程的基础上，所以一个软件的系统核心根本上还是系统的业务流程，工作流只是协助进行业务流程管理。即使没有工作流业务系统也可以开发运行，只不过有了工作流可以更好的管理业务流程，提高系统的可扩展性。 1.3 适用行业消费品行业，制造业，电信服务业，银证险等金融服务业，物流服务业，物业服务业，物业管理，大中型进出口贸易公司，政府事业机构，研究院所及教育服务业等，特别是大的跨国企业和集团公司。 1.4 具体应用1、关键业务流程：订单、报价处理、合同审核、客户电话处理、供应链管理等 2、行政管理类:出差申请、加班申请、请假申请、用车申请、各种办公用品申请、购买申请、日报周报等凡是原来手工流转处理的行政表单。 3、人事管理类：员工培训安排、绩效考评、职位变动处理、员工档案信息管理等。 4、财务相关类：付款请求、应收款处理、日常报销处理、出差报销、预算和计划申请等。 5、客户服务类：客户信息管理、客户投诉、请求处理、售后服务管理等。 6、特殊服务类：ISO系列对应流程、质量管理对应流程、产品数据信息管理、贸易公司报关处理、物流公司货物跟踪处理等各种通过表单逐步手工流转完成的任务均可应用工作流软件自动规范地实施。 1.5 实现方式在没有专门的工作流引擎之前，我们之前为了实现流程控制，通常的做法就是采用状态字段的值来跟踪流程的变化情况。这样不用角色的用户，通过状态字段的取值来决定记录是否显示。 针对有权限可以查看的记录，当前用户根据自己的角色来决定审批是否合格的操作。如果合格将状态字段设置一个值，来代表合格；当然如果不合格也需要设置一个值来代表不合格的情况。 这是一种最为原始的方式。通过状态字段虽然做到了流程控制，但是当我们的流程发生变更的时候，这种方式所编写的代码也要进行调整。 那么有没有专业的方式来实现工作流的管理呢？并且可以做到业务流程变化之后，我们的程序可以不用改变，如果可以实现这样的效果，那么我们的业务系统的适应能力就得到了极大提升。 二、Activiti7概述2.1 介绍Alfresco软件在2010年5月17日宣布Activiti业务流程管理（BPM）开源项目的正式启动，其首席架构师由业务流程管理BPM的专家 Tom Baeyens担任，Tom Baeyens就是原来jbpm的架构师，而jbpm是一个非常有名的工作流引擎，当然activiti也是一个工作流引擎。 Activiti是一个工作流引擎， activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。 官方网站：https://www.activiti.org/ 经历的版本: 目前最新版本：Activiti7.0.0.Beta 2.1.1 BPMBPM（Business Process Management），即业务流程管理，是一种规范化的构造端到端的业务流程，以持续的提高组织业务效率。常见商业管理教育如EMBA、MBA等均将BPM包含在内。 2.1.2 BPM软件BPM软件就是根据企业中业务环境的变化，推进人与人之间、人与系统之间以及系统与系统之间的整合及调整的经营方法与解决方案的IT工具。 通过BPM软件对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升。 BPM软件在企业中应用领域广泛，凡是有业务流程的地方都可以BPM软件进行管理，比如企业人事办公管理、采购流程管理、公文审批流程管理、财务管理等。 2.1.3 BPMNBPMN（Business Process Model AndNotation）- 业务流程模型和符号 是由BPMI（BusinessProcess Management Initiative）开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。 2004年5月发布了BPMN1.0规范.BPMI于2005年9月并入OMG（The Object Management Group对象管理组织)组织。OMG于2011年1月发布BPMN2.0的最终版本。 具体发展历史如下: BPMN 是目前被各 BPM 厂商广泛接受的 BPM 标准。Activiti 就是使用 BPMN 2.0 进行流程建模、流程执行管理，它包括很多的建模符号，比如： Event 用一个圆圈表示，它是流程中运行过程中发生的事情。 活动用圆角矩形表示，一个流程由一个活动或多个活动组成 Bpmn图形其实是通过xml表示业务流程，上边的.bpmn文件使用文本编辑器打开： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:activiti=&quot;http://activiti.org/bpmn&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; targetNamespace=&quot;http://www.activiti.org/test&quot;&gt; &lt;process id=&quot;myProcess&quot; name=&quot;My process&quot; isExecutable=&quot;true&quot;&gt; &lt;startEvent id=&quot;startevent1&quot; name=&quot;Start&quot;&gt;&lt;/startEvent&gt; &lt;userTask id=&quot;usertask1&quot; name=&quot;创建请假单&quot;&gt;&lt;/userTask&gt; &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;startevent1&quot; targetRef=&quot;usertask1&quot;&gt;&lt;/sequenceFlow&gt; &lt;userTask id=&quot;usertask2&quot; name=&quot;部门经理审核&quot;&gt;&lt;/userTask&gt; &lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;usertask1&quot; targetRef=&quot;usertask2&quot;&gt;&lt;/sequenceFlow&gt; &lt;userTask id=&quot;usertask3&quot; name=&quot;人事复核&quot;&gt;&lt;/userTask&gt; &lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;usertask2&quot; targetRef=&quot;usertask3&quot;&gt;&lt;/sequenceFlow&gt; &lt;endEvent id=&quot;endevent1&quot; name=&quot;End&quot;&gt;&lt;/endEvent&gt; &lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;usertask3&quot; targetRef=&quot;endevent1&quot;&gt;&lt;/sequenceFlow&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram id=&quot;BPMNDiagram_myProcess&quot;&gt; &lt;bpmndi:BPMNPlane bpmnElement=&quot;myProcess&quot; id=&quot;BPMNPlane_myProcess&quot;&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;startevent1&quot; id=&quot;BPMNShape_startevent1&quot;&gt; &lt;omgdc:Bounds height=&quot;35.0&quot; width=&quot;35.0&quot; x=&quot;130.0&quot; y=&quot;160.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;usertask1&quot; id=&quot;BPMNShape_usertask1&quot;&gt; &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;105.0&quot; x=&quot;210.0&quot; y=&quot;150.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;usertask2&quot; id=&quot;BPMNShape_usertask2&quot;&gt; &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;105.0&quot; x=&quot;360.0&quot; y=&quot;150.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;usertask3&quot; id=&quot;BPMNShape_usertask3&quot;&gt; &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;105.0&quot; x=&quot;510.0&quot; y=&quot;150.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;endevent1&quot; id=&quot;BPMNShape_endevent1&quot;&gt; &lt;omgdc:Bounds height=&quot;35.0&quot; width=&quot;35.0&quot; x=&quot;660.0&quot; y=&quot;160.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow1&quot; id=&quot;BPMNEdge_flow1&quot;&gt; &lt;omgdi:waypoint x=&quot;165.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;210.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow2&quot; id=&quot;BPMNEdge_flow2&quot;&gt; &lt;omgdi:waypoint x=&quot;315.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;360.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow3&quot; id=&quot;BPMNEdge_flow3&quot;&gt; &lt;omgdi:waypoint x=&quot;465.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;510.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow4&quot; id=&quot;BPMNEdge_flow4&quot;&gt; &lt;omgdi:waypoint x=&quot;615.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;660.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; 2.2 使用步骤部署activitiActiviti是一个工作流引擎（其实就是一堆jar包API），业务系统访问(操作)activiti的接口，就可以方便的操作流程相关数据，这样就可以把工作流环境与业务系统的环境集成在一起。 流程定义使用activiti流程建模工具(activity-designer)定义业务流程(.bpmn文件) 。 .bpmn文件就是业务流程定义文件，通过xml定义业务流程。 流程定义部署activiti部署业务流程定义（.bpmn文件）。 使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容 Activiti执行把流程定义内容存储在数据库中 启动一个流程实例流程实例也叫：ProcessInstance 启动一个流程实例表示开始一次业务流程的运行。 在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响。 用户查询待办任务(Task)因为现在系统的业务流程已经交给activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写在sql语句查询。 用户办理任务用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其它用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。 流程结束当任务办理完成没有下一个任务结点了，这个流程实例就完成了。 三、Activiti环境3.1 开发环境Jdk1.8或以上版本 Mysql 5及以上的版本 Tomcat8.5 IDEA 注意：activiti的流程定义工具插件可以安装在IDEA下，也可以安装在Eclipse工具下 3.2 Activiti环境我们使用：Activiti7.0.0.Beta1 默认支持spring5 3.2.1 下载activiti7Activiti下载地址：http://activiti.org/download.html ，Maven的依赖如下： 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1) Database： activiti运行需要有数据库的支持，支持的数据库有：h2, mysql, oracle, postgres, mssql, db2。 3.2.2 流程设计器IDEA下安装在IDEA的File菜单中找到子菜单”Settings”,后面我们再选择左侧的“plugins”菜单，如下图所示： 此时我们就可以搜索到actiBPM插件，它就是Activiti Designer的IDEA版本，我们点击Install安装。 安装好后，页面如下： 提示需要重启idea，点击重启。 重启完成后，再次打开Settings 下的 Plugins（插件列表），点击右侧的Installed（已安装的插件），在列表中看到actiBPM，就说明已经安装成功了，如下图所示： 后面的课程里，我们会使用这个流程设计器进行Activiti的流程设计。 3.3 Activiti的数据库支持Activiti 在运行时需要数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中，以供后续使用。 3.3.1 Activiti 支持的数据库activiti 支持的数据库和版本如下： 数据库类型 版本 JDBC连接示例 说明 h2 1.3.168 jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;activiti 默认配置的数据库 mysql 5.1.21 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;activiti?autoReconnect&#x3D;true 使用 mysql-connector-java 驱动测试 oracle 11.2.0.1.0 jdbc:oracle:thin:@localhost:1521:xe postgres 8.1 jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;activiti db2 DB2 10.1 using db2jcc4 jdbc:db2:&#x2F;&#x2F;localhost:50000&#x2F;activiti mssql 2008 using sqljdbc4 jdbc:sqlserver:&#x2F;&#x2F;localhost:1433&#x2F;activiti 3.3.2 在MySQL生成表3.3.2.1 创建数据库创建 mysql 数据库 activiti （名字任意）： CREATE DATABASE activiti DEFAULT CHARACTER SET utf8; 3.3.2.2 使用java代码生成表1） 创建 java 工程使用idea 创建 java 的maven工程，取名：activiti01。 2） 加入 maven 依赖的坐标（jar 包）首先需要在 java 工程中加入 ProcessEngine 所需要的 jar 包，包括： activiti-engine-7.0.0.beta1.jar activiti 依赖的 jar 包： mybatis、 alf4j、 log4j 等 activiti 依赖的 spring 包 mysql数据库驱动 第三方数据连接池 dbcp 单元测试 Junit-4.12.jar 我们使用 maven 来实现项目的构建，所以应当导入这些 jar 所对应的坐标到 pom.xml 文件中。 完整的依赖内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;properties&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;activiti.version&gt;7.0.0.Beta1&lt;/activiti.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn 模型处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn 转换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn json数据转换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn 布局 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- activiti 云支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt; &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 链接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3） 添加log4j日志配置我们使用log4j日志包，可以对日志进行配置 在resources 下创建log4j.properties 123456789101112131415# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=debug, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m\\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=f:\\act\\activiti.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m\\n 4） 添加activiti配置文件我们使用activiti提供的默认方式来创建mysql的表。 默认方式的要求是在 resources 下创建 activiti.cfg.xml 文件，注意：默认方式目录和文件名不能修改，因为activiti的源码中已经设置，到固定的目录读取固定文件名的文件。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexhttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;/beans&gt; 5） 在 activiti.cfg.xml 中进行配置默认方式要在在activiti.cfg.xml中bean的名字叫processEngineConfiguration，名字不可修改 在这里有2中配置方式：一种是单独配置数据源，一种是不单独配置数据源 1、直接配置processEngineConfigurationprocessEngineConfiguration 用来创建 ProcessEngine，在创建 ProcessEngine 时会执行数据库的操作。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexhttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 默认id对应的值 为processEngineConfiguration --&gt; &lt;!-- processEngine Activiti的流程引擎 --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///activiti&quot;/&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;123456&quot;/&gt; &lt;!-- activiti数据库表处理策略 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 2、配置数据源后，在processEngineConfiguration 引用首先配置数据源 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexhttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 这里可以使用 链接池 dbcp--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///activiti&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!-- 引用数据源 上面已经设置好了--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- activiti数据库表处理策略 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 6） java类编写程序生成表创建一个测试类，调用activiti的工具类，生成acitivti需要的数据库表。 直接使用activiti提供的工具类ProcessEngines，会默认读取classpath下的activiti.cfg.xml文件，读取其中的数据库配置，创建 ProcessEngine，在创建ProcessEngine 时会自动创建表。 代码如下： 123456789101112131415161718package com.itheima.activiti01.test;import org.activiti.engine.ProcessEngine;import org.activiti.engine.ProcessEngineConfiguration;import org.junit.Test;public class TestDemo &#123; /** * 生成 activiti的数据库表 */ @Test public void testCreateDbTable() &#123; //使用classpath下的activiti.cfg.xml中的配置创建processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); System.out.println(processEngine); &#125;&#125; 说明：1、运行以上程序段即可完成 activiti 表创建，通过改变 activiti.cfg.xml 中databaseSchemaUpdate 参数的值执行不同的数据表处理策略。2 、 上 边 的 方法 getDefaultProcessEngine方法在执行时，从activiti.cfg.xml 中找固定的名称 processEngineConfiguration 。 在测试程序执行过程中，idea的控制台会输出日志，说明程序正在创建数据表，类似如下,注意红线内容： 执行完成后我们查看数据库， 创建了 25 张表，结果如下： 到这，我们就完成activiti运行需要的数据库和表的创建。 3.4 表结构介绍3.4.1 表的命名规则和作用看到刚才创建的表，我们发现Activiti 的表都以 ACT_ 开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的 API 对应。ACT_RE ：’RE’表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。ACT_RU：’RU’表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti 只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。ACT_HI：’HI’表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACT_GE ： GE 表示 general。 通用数据， 用于不同场景下 3.4.2 Activiti数据表介绍 表分类 表名 解释 一般数据 [ACT_GE_BYTEARRAY] 通用的流程定义和流程资源 [ACT_GE_PROPERTY] 系统相关属性 流程历史记录 [ACT_HI_ACTINST] 历史的流程实例 [ACT_HI_ATTACHMENT] 历史的流程附件 [ACT_HI_COMMENT] 历史的说明性信息 [ACT_HI_DETAIL] 历史的流程运行中的细节信息 [ACT_HI_IDENTITYLINK] 历史的流程运行过程中用户关系 [ACT_HI_PROCINST] 历史的流程实例 [ACT_HI_TASKINST] 历史的任务实例 [ACT_HI_VARINST] 历史的流程运行中的变量信息 流程定义表 [ACT_RE_DEPLOYMENT] 部署单元信息 [ACT_RE_MODEL] 模型信息 [ACT_RE_PROCDEF] 已部署的流程定义 运行实例表 [ACT_RU_EVENT_SUBSCR] 运行时事件 [ACT_RU_EXECUTION] 运行时流程执行实例 [ACT_RU_IDENTITYLINK] 运行时用户关系信息，存储任务节点与参与者的相关信息 [ACT_RU_JOB] 运行时作业 [ACT_RU_TASK] 运行时任务 [ACT_RU_VARIABLE] 运行时变量表 四、Activiti类关系图上面我们完成了Activiti数据库表的生成，java代码中我们调用Activiti的工具类，下面来了解Activiti的类关系 4.1 类关系图 在新版本中，我们通过实验可以发现IdentityService，FormService两个Serivce都已经删除了。 所以后面我们对于这两个Service也不讲解了，但老版本中还是有这两个Service，同学们需要了解一下 4.2 activiti.cfg.xmlactiviti的引擎配置文件，包括：ProcessEngineConfiguration的定义、数据源定义、事务管理器等，此文件其实就是一个spring配置文件。 4.3 流程引擎配置类流程引擎的配置类（ProcessEngineConfiguration），通过ProcessEngineConfiguration可以创建工作流引擎ProceccEngine，常用的两种方法如下： 4.3.1 StandaloneProcessEngineConfiguration使用StandaloneProcessEngineConfigurationActiviti可以单独运行，来创建ProcessEngine，Activiti会自己处理事务。 配置文件方式： 通常在activiti.cfg.xml配置文件中定义一个id为 processEngineConfiguration 的bean. 方法如下： 1234567891011121314&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!--配置数据库相关的信息--&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!--数据库链接--&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///activiti&quot;/&gt; &lt;!--数据库用户名--&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot;/&gt; &lt;!--数据库密码--&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;123456&quot;/&gt; &lt;!--actviti数据库表在生成时的策略 true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; 还可以加入连接池: 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexhttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///activiti&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt; &lt;!--在默认方式下 bean的id 固定为 processEngineConfiguration--&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!--引入上面配置好的 链接池--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--actviti数据库表在生成时的策略 true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.3.2 SpringProcessEngineConfiguration通过org.activiti.spring.SpringProcessEngineConfiguration 与Spring整合。 创建spring与activiti的整合配置文件： activity-spring.cfg.xml（名称可修改） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd &quot;&gt; &lt;!-- 工作流引擎配置bean --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 使用spring事务管理器 --&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt; &lt;!-- 数据库策略 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;drop-create&quot; /&gt; &lt;!-- activiti的定时任务关闭 --&gt; &lt;property name=&quot;jobExecutorActivate&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- 流程引擎 --&gt; &lt;bean id=&quot;processEngine&quot; class=&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;&gt; &lt;property name=&quot;processEngineConfiguration&quot; ref=&quot;processEngineConfiguration&quot; /&gt; &lt;/bean&gt; &lt;!-- 资源服务service --&gt; &lt;bean id=&quot;repositoryService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRepositoryService&quot; /&gt; &lt;!-- 流程运行service --&gt; &lt;bean id=&quot;runtimeService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRuntimeService&quot; /&gt; &lt;!-- 任务管理service --&gt; &lt;bean id=&quot;taskService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getTaskService&quot; /&gt; &lt;!-- 历史管理service --&gt; &lt;bean id=&quot;historyService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getHistoryService&quot; /&gt; &lt;!-- 用户管理service --&gt; &lt;bean id=&quot;identityService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getIdentityService&quot; /&gt; &lt;!-- 引擎管理service --&gt; &lt;bean id=&quot;managementService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getManagementService&quot; /&gt; &lt;!-- 数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/activiti&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;mysql&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt;&lt;/tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面，根据具体项目修改切点配置 --&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.itheima.ihrm.service.impl.*.(..))&quot;* /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 创建processEngineConfiguration1ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;) ​ 上边的代码要求activiti.cfg.xml中必须有一个processEngineConfiguration的bean 也可以使用下边的方法，更改bean 的名字： 1ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName); 4.4 工作流引擎创建工作流引擎（ProcessEngine），相当于一个门面接口，通过ProcessEngineConfiguration创建processEngine，通过ProcessEngine创建各个service接口。 4.4.1 默认创建方式将activiti.cfg.xml文件名及路径固定，且activiti.cfg.xml文件中有 processEngineConfiguration的配置， 可以使用如下代码创建processEngine: 123//直接使用工具类 ProcessEngines，使用classpath下的activiti.cfg.xml中的配置创建processEngineProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();System.out.println(processEngine); 4.4.2 一般创建方式1234//先构建ProcessEngineConfigurationProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;);//通过ProcessEngineConfiguration创建ProcessEngine，此时会创建数据库ProcessEngine processEngine = configuration.buildProcessEngine(); 4.5 Servcie服务接口Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表 4.5.1 Service创建方式通过ProcessEngine创建Service 方式如下： 123RuntimeService runtimeService = processEngine.getRuntimeService();RepositoryService repositoryService = processEngine.getRepositoryService();TaskService taskService = processEngine.getTaskService(); 4.5.2 Service总览 service名称 service作用 RepositoryService activiti的资源管理类 RuntimeService activiti的流程运行管理类 TaskService activiti的任务管理类 HistoryService activiti的历史管理类 ManagerService activiti的引擎管理类 简单介绍： RepositoryService 是activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作。使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。 除了部署流程定义以外还可以：查询引擎中的发布包和流程定义。 暂停或激活发布包，对应全部和特定流程定义。 暂停意味着它们不能再执行任何操作了，激活是对应的反向操作。获得多种资源，像是包含在发布包里的文件， 或引擎自动生成的流程图。 获得流程定义的pojo版本， 可以用来通过java解析流程，而不必通过xml。 RuntimeServiceActiviti的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息 TaskServiceActiviti的任务管理类。可以从这个类中获取任务的信息。 HistoryServiceActiviti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。 ManagementServiceActiviti的引擎管理类，提供了对 Activiti 流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于 Activiti 系统的日常维护。 五、Activiti入门在本章内容中，我们来创建一个Activiti工作流，并启动这个流程。 创建Activiti工作流主要包含以下几步： 1、定义流程，按照BPMN的规范，使用流程定义工具，用流程符号把整个流程描述出来 2、部署流程，把画好的流程定义文件，加载到数据库中，生成表的数据 3、启动流程，使用java代码来操作数据库表中的内容 5.1 流程符号BPMN 2.0是业务流程建模符号2.0的缩写。 它由Business Process Management Initiative这个非营利协会创建并不断发展。作为一种标识，BPMN 2.0是使用一些符号来明确业务流程设计流程图的一整套符号规范，它能增进业务建模时的沟通效率。 目前BPMN2.0是最新的版本，它用于在BPM上下文中进行布局和可视化的沟通。 接下来我们先来了解在流程设计中常见的 符号。 BPMN2.0的基本符合主要包含： 事件 Event 活动 Activity活动是工作或任务的一个通用术语。一个活动可以是一个任务，还可以是一个当前流程的子处理流程； 其次，你还可以为活动指定不同的类型。常见活动如下： 网关 GateWay网关用来处理决策，有几种常用网关需要了解： 排他网关 (x)——只有一条路径会被选择。流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流； ​ 如果多条线路计算结果都是 true，则会执行第一个值为 true 的线路。如果所有网关计算结果没有true，则引擎会抛出异常。 ​ 排他网关需要和条件顺序流结合使用，default 属性指定默认顺序流，当所有的条件不满足时会执行默认顺序流。 并行网关 (+)——所有路径会被同时选择 ​ 拆分 —— 并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。 ​ 合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。 包容网关 (+)—— 可以同时执行多条线路，也可以在网关上设置条件 ​ 拆分 —— 计算每条线路上的表达式，当表达式计算结果为true时，创建一个并行线路并继续执行 ​ 合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。 事件网关 (+)—— 专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件。当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。 流向 Flow流是连接两个流程节点的连线。常见的流向包含以下几种： 5.2 流程设计器使用Activiti-Designer使用Palette（画板）在idea中安装插件即可使用，画板中包括以下结点： Connection—连接 Event—事件 Task—任务 Gateway—网关 Container—容器 Boundary event—边界事件 Intermediate event- -中间事件 流程图设计完毕保存生成.bpmn文件 新建流程(IDEA工具)首先选中存放图形的目录(选择resources下的bpmn目录)，点击菜单：New -&gt; BpmnFile，如图： 弹出如下图所示框，输入evection 表示 出差审批流程： 起完名字evection后（默认扩展名为bpmn），就可以看到流程设计页面，如图所示： 左侧区域是绘图区，右侧区域是palette画板区域 鼠标先点击画板的元素即可在左侧绘图 绘制流程使用滑板来绘制流程，通过从右侧把图标拖拽到左侧的画板，最终效果如下： 指定流程定义Key流程定义key即流程定义的标识，通过properties视图查看流程的key 指定任务负责人在properties视图指定每个任务结点的负责人，如：填写出差申请的负责人为 zhangsan 经理审批负责人为 jerry 总经理审批负责人为 jack 财务审批负责人为 rose 六、流程操作6.1 流程定义概述流程定义是线下按照bpmn2.0标准去描述 业务流程，通常使用idea中的插件对业务流程进行建模。 使用idea下的designer设计器绘制流程，并会生成两个文件：.bpmn和.png .bpmn文件使用activiti-desinger设计业务流程，会生成.bpmn文件，上面我们已经创建好了bpmn文件 BPMN 2.0根节点是definitions节点。 这个元素中，可以定义多个流程定义（不过我们建议每个文件只包含一个流程定义， 可以简化开发过程中的维护难度）。 注意，definitions元素 最少也要包含xmlns 和 targetNamespace的声明。 targetNamespace可以是任意值，它用来对流程实例进行分类。 流程定义部分：定义了流程每个结点的描述及结点之间的流程流转。 流程布局定义：定义流程每个结点在流程图上的位置坐标等信息。 生成.png图片文件IDEA工具中的操作方式 1、修改文件后缀为xml首先将evection.bpmn文件改名为evection.xml，如下图： evection.xml修改前的bpmn文件，效果如下： 2、使用designer设计器打开.xml文件在evection.xml文件上面，点右键并选择Diagrams菜单，再选择Show BPMN2.0 Designer… 3、查看打开的文件打开后，却出现乱码，如图： 4、解决中文乱码1、打开Settings，找到File Encodings，把encoding的选项都选择UTF-8 2、打开IDEA安装路径，找到如下的安装目录 根据自己所安装的版本来决定，我使用的是64位的idea，所以在idea64.exe.vmoptions文件的最后一行追加一条命令： -Dfile.encoding&#x3D;UTF-8 如下所示： 一定注意，不要有空格，否则重启IDEA时会打不开，然后 重启IDEA。 如果以上方法已经做完，还出现乱码，就再修改一个文件，并在文件的末尾添加： -Dfile.encoding&#x3D;UTF-8，然后重启idea，如图： 最后重新在evection.xml文件上面，点右键并选择Diagrams菜单，再选择Show BPMN2.0 Designer…，看到生成图片，如图： 到此，解决乱码问题 5、导出为图片文件点击Export To File的小图标，打开如下窗口，注意填写文件名及扩展名，选择好保存图片的位置： 然后，我们把png文件拷贝到resources下的bpmn目录，并且把evection.xml改名为evection.bpmn。 6.2 流程定义部署概述将上面在设计器中定义的流程部署到activiti数据库中，就是流程定义部署。 通过调用activiti的api将流程定义的bpmn和png两个文件一个一个添加部署到activiti中，也可以将两个文件打成zip包进行部署。 单个文件部署方式分别将bpmn文件和png图片文件部署。 123456789101112131415161718192021222324252627282930package com.itheima.test;import org.activiti.engine.ProcessEngine;import org.activiti.engine.ProcessEngines;import org.activiti.engine.RepositoryService;import org.activiti.engine.repository.Deployment;import org.junit.Test;public class ActivitiDemo &#123; /** * 部署流程定义 */ @Test public void testDeployment()&#123;// 1、创建ProcessEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 2、得到RepositoryService实例 RepositoryService repositoryService = processEngine.getRepositoryService();// 3、使用RepositoryService进行部署 Deployment deployment = repositoryService.createDeployment() .addClasspathResource(&quot;bpmn/evection.bpmn&quot;) // 添加bpmn资源 .addClasspathResource(&quot;bpmn/evection.png&quot;) // 添加png资源 .name(&quot;出差申请流程&quot;) .deploy();// 4、输出部署信息 System.out.println(&quot;流程部署id：&quot; + deployment.getId()); System.out.println(&quot;流程部署名称：&quot; + deployment.getName()); &#125;&#125; 执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。 压缩包部署方式将evection.bpmn和evection.png压缩成zip包。 1234567891011121314151617181920@Test public void deployProcessByZip() &#123; // 定义zip输入流 InputStream inputStream = this .getClass() .getClassLoader() .getResourceAsStream( &quot;bpmn/evection.zip&quot;); ZipInputStream zipInputStream = new ZipInputStream(inputStream); // 获取repositoryService RepositoryService repositoryService = processEngine .getRepositoryService(); // 流程部署 Deployment deployment = repositoryService.createDeployment() .addZipInputStream(zipInputStream) .deploy(); System.out.println(&quot;流程部署id：&quot; + deployment.getId()); System.out.println(&quot;流程部署名称：&quot; + deployment.getName()); &#125; 执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。 操作数据表流程定义部署后操作activiti的3张表如下： act_re_deployment 流程定义部署表，每部署一次增加一条记录 act_re_procdef 流程定义表，部署每个新的流程定义都会在这张表中增加一条记录 act_ge_bytearray 流程资源表 接下来我们来看看，写入了什么数据： 1SELECT * FROM act_re_deployment #流程定义部署表，记录流程部署信息 结果： 1SELECT * FROM act_re_procdef #流程定义表，记录流程定义信息 结果： 注意，KEY 这个字段是用来唯一识别不同流程的关键字 1SELECT * FROM act_ge_bytearray #资源表 结果： 注意： act_re_deployment和act_re_procdef一对多关系，一次部署在流程部署表生成一条记录，但一次部署可以部署多个流程定义，每个流程定义在流程定义表生成一条记录。每一个流程定义在act_ge_bytearray会存在两个资源记录，bpmn和png。 建议：一次部署一个流程，这样部署表和流程定义表是一对一有关系，方便读取流程部署及流程定义信息。 6.3 启动流程实例流程定义部署在activiti后就可以通过工作流管理业务流程了，也就是说上边部署的出差申请流程可以使用了。 针对该流程，启动一个流程表示发起一个新的出差申请单，这就相当于java类与java对象的关系，类定义好后需要new创建一个对象使用，当然可以new多个对象。对于请出差申请流程，张三发起一个出差申请单需要启动一个流程实例，出差申请单发起一个出差单也需要启动一个流程实例。 代码如下： 123456789101112131415161718 /** * 启动流程实例 */ @Test public void testStartProcess()&#123;// 1、创建ProcessEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 2、获取RunTimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 3、根据流程定义Id启动流程 ProcessInstance processInstance = runtimeService .startProcessInstanceByKey(&quot;myEvection&quot;);// 输出内容 System.out.println(&quot;流程定义id：&quot; + processInstance.getProcessDefinitionId()); System.out.println(&quot;流程实例id：&quot; + processInstance.getId()); System.out.println(&quot;当前活动Id：&quot; + processInstance.getActivityId()); &#125; 输出内容如下： 操作数据表 act_hi_actinst 流程实例执行历史 act_hi_identitylink 流程的参与用户历史信息 act_hi_procinst 流程实例历史信息 act_hi_taskinst 流程任务历史信息 act_ru_execution 流程执行信息 act_ru_identitylink 流程的参与用户信息 act_ru_task 任务信息 6.4 任务查询流程启动后，任务的负责人就可以查询自己当前需要处理的任务，查询出来的任务都是该用户的待办任务。 12345678910111213141516171819202122232425/** * 查询当前个人待执行的任务 */ @Test public void testFindPersonalTaskList() &#123;// 任务负责人 String assignee = &quot;zhangsan&quot;; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 创建TaskService TaskService taskService = processEngine.getTaskService();// 根据流程key 和 任务负责人 查询任务 List&lt;Task&gt; list = taskService.createTaskQuery() .processDefinitionKey(&quot;myEvection&quot;) //流程Key .taskAssignee(assignee)//只查询该任务负责人的任务 .list(); for (Task task : list) &#123; System.out.println(&quot;流程实例id：&quot; + task.getProcessInstanceId()); System.out.println(&quot;任务id：&quot; + task.getId()); System.out.println(&quot;任务负责人：&quot; + task.getAssignee()); System.out.println(&quot;任务名称：&quot; + task.getName()); &#125; &#125; 输出结果如下： 1234流程实例id：2501任务id：2505任务负责人：zhangsan任务名称：创建出差申请 6.5 流程任务处理任务负责人查询待办任务，选择任务进行处理，完成任务。 12345678910111213141516171819// 完成任务 @Test public void completTask()&#123;// 获取引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取taskService TaskService taskService = processEngine.getTaskService();// 根据流程key 和 任务的负责人 查询任务// 返回一个任务对象 Task task = taskService.createTaskQuery() .processDefinitionKey(&quot;myEvection&quot;) //流程Key .taskAssignee(&quot;zhangsan&quot;) //要查询的负责人 .singleResult();// 完成任务,参数：任务id taskService.complete(task.getId()); &#125; 6.6 流程定义信息查询查询流程相关信息，包含流程定义，流程部署，流程定义版本 123456789101112131415161718192021222324252627282930 /** * 查询流程定义 */ @Test public void queryProcessDefinition()&#123; // 获取引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// repositoryService RepositoryService repositoryService = processEngine.getRepositoryService();// 得到ProcessDefinitionQuery 对象 ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();// 查询出当前所有的流程定义// 条件：processDefinitionKey =evection// orderByProcessDefinitionVersion 按照版本排序// desc倒叙// list 返回集合 List&lt;ProcessDefinition&gt; definitionList = processDefinitionQuery.processDefinitionKey(&quot;myEvection&quot;) .orderByProcessDefinitionVersion() .desc() .list();// 输出流程定义信息 for (ProcessDefinition processDefinition : definitionList) &#123; System.out.println(&quot;流程定义 id=&quot;+processDefinition.getId()); System.out.println(&quot;流程定义 name=&quot;+processDefinition.getName()); System.out.println(&quot;流程定义 key=&quot;+processDefinition.getKey()); System.out.println(&quot;流程定义 Version=&quot;+processDefinition.getVersion()); System.out.println(&quot;流程部署ID =&quot;+processDefinition.getDeploymentId()); &#125; &#125; 输出结果： 1234流程定义id：myEvection:1:4流程定义名称：出差申请单流程定义key：myEvection流程定义版本：1 6.7 流程删除1234567891011121314public void deleteDeployment() &#123; // 流程部署id String deploymentId = &quot;1&quot;; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 通过流程引擎获取repositoryService RepositoryService repositoryService = processEngine .getRepositoryService(); //删除流程定义，如果该流程定义已有流程实例启动则删除时出错 repositoryService.deleteDeployment(deploymentId); //设置true 级联删除流程定义，即使该流程有流程实例启动也可以删除，设置为false非级别删除方式，如果流程 //repositoryService.deleteDeployment(deploymentId, true); &#125; 说明： 使用repositoryService删除流程定义，历史表信息不会被删除 如果该流程定义下没有正在运行的流程，则可以用普通删除。 如果该流程定义下存在已经运行的流程，使用普通删除报错，可用级联删除方法将流程及相关记录全部删除。 先删除没有完成流程节点，最后就可以完全删除流程定义信息 项目开发中级联删除操作一般只开放给超级管理员使用. 6.8 流程资源下载现在我们的流程资源文件已经上传到数据库了，如果其他用户想要查看这些资源文件，可以从数据库中把资源文件下载到本地。 解决方案有： 1、jdbc对blob类型，clob类型数据读取出来，保存到文件目录 2、使用activiti的api来实现 使用commons-io.jar 解决IO的操作 引入commons-io依赖包 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 通过流程定义对象获取流程定义资源，获取bpmn和png 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.commons.io.IOUtils;@Test public void deleteDeployment()&#123;// 获取引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取repositoryService RepositoryService repositoryService = processEngine.getRepositoryService();// 根据部署id 删除部署信息,如果想要级联删除，可以添加第二个参数，true repositoryService.deleteDeployment(&quot;1&quot;); &#125; public void queryBpmnFile() throws IOException &#123;// 1、得到引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 2、获取repositoryService RepositoryService repositoryService = processEngine.getRepositoryService();// 3、得到查询器：ProcessDefinitionQuery，设置查询条件,得到想要的流程定义 ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery() .processDefinitionKey(&quot;myEvection&quot;) .singleResult();// 4、通过流程定义信息，得到部署ID String deploymentId = processDefinition.getDeploymentId();// 5、通过repositoryService的方法，实现读取图片信息和bpmn信息// png图片的流 InputStream pngInput = repositoryService.getResourceAsStream(deploymentId, processDefinition.getDiagramResourceName());// bpmn文件的流 InputStream bpmnInput = repositoryService.getResourceAsStream(deploymentId, processDefinition.getResourceName());// 6、构造OutputStream流 File file_png = new File(&quot;d:/evectionflow01.png&quot;); File file_bpmn = new File(&quot;d:/evectionflow01.bpmn&quot;); FileOutputStream bpmnOut = new FileOutputStream(file_bpmn); FileOutputStream pngOut = new FileOutputStream(file_png);// 7、输入流，输出流的转换 IOUtils.copy(pngInput,pngOut); IOUtils.copy(bpmnInput,bpmnOut);// 8、关闭流 pngOut.close(); bpmnOut.close(); pngInput.close(); bpmnInput.close(); &#125; 说明： deploymentId为流程部署ID resource_name为act_ge_bytearray表中NAME_列的值 使用repositoryService的getDeploymentResourceNames方法可以获取指定部署下得所有文件的名称 使用repositoryService的getResourceAsStream方法传入部署ID和资源图片名称可以获取部署下指定名称文件的输入流 最后的将输入流中的图片资源进行输出。 6.9 流程历史信息的查看即使流程定义已经删除了，流程执行的历史信息通过前面的分析，依然保存在activiti的act_hi_*相关的表中。所以我们还是可以查询流程执行的历史信息，可以通过HistoryService来查看相关的历史记录。 12345678910111213141516171819202122232425262728 /** * 查看历史信息 */ @Test public void findHistoryInfo()&#123;// 获取引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取HistoryService HistoryService historyService = processEngine.getHistoryService();// 获取 actinst表的查询对象 HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();// 查询 actinst表，条件：根据 InstanceId 查询// instanceQuery.processInstanceId(&quot;2501&quot;);// 查询 actinst表，条件：根据 DefinitionId 查询 instanceQuery.processDefinitionId(&quot;myEvection:1:4&quot;);// 增加排序操作,orderByHistoricActivityInstanceStartTime 根据开始时间排序 asc 升序 instanceQuery.orderByHistoricActivityInstanceStartTime().asc();// 查询所有内容 List&lt;HistoricActivityInstance&gt; activityInstanceList = instanceQuery.list();// 输出 for (HistoricActivityInstance hi : activityInstanceList) &#123; System.out.println(hi.getActivityId()); System.out.println(hi.getActivityName()); System.out.println(hi.getProcessDefinitionId()); System.out.println(hi.getProcessInstanceId()); System.out.println(&quot;&lt;==========================&gt;&quot;); &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://guoshunfa.com/tags/Activiti7/"}]},{"title":"搭建单体SpringBoot项目 集成Activiti7 进阶","slug":"软件开发/场景/搭建单体SpringBoot项目/23集成流程引擎/搭建单体SpringBoot项目-集成Activiti7-进阶","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.248Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Activiti7-进阶/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Activiti7-%E8%BF%9B%E9%98%B6/","excerpt":"","text":"一、流程实例什么是流程实例流程实例（ProcessInstance）代表流程定义的执行实例。 一个流程实例包括了所有的运行节点。我们可以利用这个对象来了解当前流程实例的进度等信息。 例如：用户或程序按照流程定义内容发起一个流程，这就是一个流程实例。 流程定义和流程实例的图解： 启动流程实例 并添加Businesskey（业务标识）流程定义部署在activiti后，就可以在系统中通过activiti去管理该流程的执行，执行流程表示流程的一次执行。 比如部署系统出差流程后，如果某用户要申请出差这时就需要执行这个流程，如果另外一个用户也要申请出差则也需要执行该流程，每个执行互不影响，每个执行是单独的流程实例。 启动流程实例时，指定的businesskey，就会在act_ru_execution #流程实例的执行表中存储businesskey。 Businesskey：业务标识，通常为业务表的主键，业务标识和流程实例一一对应。业务标识来源于业务系统。存储业务标识就是根据业务标识来关联查询业务系统的数据。 比如：出差流程启动一个流程实例，就可以将出差单的id作为业务标识存储到activiti中，将来查询activiti的流程实例信息就可以获取出差单的id从而关联查询业务系统数据库得到出差单信息。 12345678910111213141516 /** * 启动流程实例，添加businessKey */ @Test public void addBusinessKey()&#123;// 1、得到ProcessEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 2、得到RunTimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 3、启动流程实例，同时还要指定业务标识businessKey，也就是出差申请单id，这里是1001 ProcessInstance processInstance = runtimeService. startProcessInstanceByKey(&quot;myEvection&quot;,&quot;1001&quot;);// 4、输出processInstance相关属性 System.out.println(&quot;业务id==&quot;+processInstance.getBusinessKey()); &#125; Activiti的act_ru_execution中存储业务标识： 操作数据库表启动流程实例，操作如下数据库表： SELECT * FROM act_ru_execution #流程实例执行表，记录当前流程实例的执行情况 说明： 流程实例执行，如果当前只有一个分支时，一个流程实例只有一条记录且执行表的主键id和流程实例id相同，如果当前有多个分支正在运行则该执行表中有多条记录，存在执行表的主键和流程实例id不相同的记录。不论当前有几个分支总会有一条记录的执行表的主键和流程实例id相同 一个流程实例运行完成，此表中与流程实例相关的记录删除。 SELECT * FROM act_ru_task #任务执行表，记录当前执行的任务 说明：启动流程实例，流程当前执行到第一个任务结点，此表会插入一条记录表示当前任务的执行情况，如果任务完成则记录删除。 SELECT * FROM act_ru_identitylink #任务参与者，记录当前参与任务的用户或组 SELECT * FROM act_hi_procinst #流程实例历史表 流程实例启动，会在此表插入一条记录，流程实例运行完成记录也不会删除。 SELECT * FROM act_hi_taskinst #任务历史表，记录所有任务 开始一个任务，不仅在act_ru_task表插入记录，也会在历史任务表插入一条记录，任务历史表的主键就是任务id，任务完成此表记录不删除。 SELECT * FROM act_hi_actinst #活动历史表，记录所有活动 活动包括任务，所以此表中不仅记录了任务，还记录了流程执行过程的其它活动，比如开始事件、结束事件。 查询流程实例流程在运行过程中可以查询流程实例的状态，当前运行结点等信息。 123456789101112131415161718192021222324@Test public void queryProcessInstance() &#123; // 流程定义key String processDefinitionKey = &quot;evection&quot;; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 获取RunTimeService RuntimeService runtimeService = processEngine.getRuntimeService(); List&lt;ProcessInstance&gt; list = runtimeService .createProcessInstanceQuery() .processDefinitionKey(processDefinitionKey)// .list(); for (ProcessInstance processInstance : list) &#123; System.out.println(&quot;----------------------------&quot;); System.out.println(&quot;流程实例id：&quot; + processInstance.getProcessInstanceId()); System.out.println(&quot;所属流程定义id：&quot; + processInstance.getProcessDefinitionId()); System.out.println(&quot;是否执行完成：&quot; + processInstance.isEnded()); System.out.println(&quot;是否暂停：&quot; + processInstance.isSuspended()); System.out.println(&quot;当前活动标识：&quot; + processInstance.getActivityId()); &#125; &#125; 关联BusinessKey需求： 在activiti实际应用时，查询流程实例列表时可能要显示出业务系统的一些相关信息，比如：查询当前运行的出差流程列表需要将出差单名称、出差天数等信息显示出来，出差天数等信息在业务系统中存在，而并没有在activiti数据库中存在，所以是无法通过activiti的api查询到出差天数等信息。 实现： 在查询流程实例时，通过businessKey（业务标识 ）关联查询业务系统的出差单表，查询出出差天数等信息。 通过下面的代码就可以获取activiti中所对应实例保存的业务Key。而这个业务Key一般都会保存相关联的业务操作表的主键，再通过主键ID去查询业务信息，比如通过出差单的ID，去查询更多的请假信息（出差人，出差时间，出差天数，出差目的地等） String businessKey &#x3D; processInstance.getBusinessKey(); 在activiti的act_ru_execution表，字段BUSINESS_KEY就是存放业务KEY的。 挂起、激活流程实例某些情况可能由于流程变更需要将当前运行的流程暂停而不是直接删除，流程暂停后将不会继续执行。 全部流程实例挂起操作流程定义为挂起状态，该流程定义下边所有的流程实例全部暂停： 流程定义为挂起状态该流程定义将不允许启动新的流程实例，同时该流程定义下所有的流程实例将全部挂起暂停执行。 1234567891011121314151617181920212223242526272829303132333435/** * 全部流程实例挂起与激活 */ @Test public void SuspendAllProcessInstance()&#123;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取repositoryService RepositoryService repositoryService = processEngine.getRepositoryService();// 查询流程定义的对象 ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery(). processDefinitionKey(&quot;myEvection&quot;). singleResult();// 得到当前流程定义的实例是否都为暂停状态 boolean suspended = processDefinition.isSuspended();// 流程定义id String processDefinitionId = processDefinition.getId();// 判断是否为暂停 if(suspended)&#123;// 如果是暂停，可以执行激活操作 ,参数1 ：流程定义id ，参数2：是否激活，参数3：激活时间 repositoryService.activateProcessDefinitionById(processDefinitionId, true, null ); System.out.println(&quot;流程定义：&quot;+processDefinitionId+&quot;,已激活&quot;); &#125;else&#123;// 如果是激活状态，可以暂停，参数1 ：流程定义id ，参数2：是否暂停，参数3：暂停时间 repositoryService.suspendProcessDefinitionById(processDefinitionId, true, null); System.out.println(&quot;流程定义：&quot;+processDefinitionId+&quot;,已挂起&quot;); &#125; &#125; 单个流程实例挂起操作流程实例对象，针对单个流程执行挂起操作，某个流程实例挂起则此流程不再继续执行，完成该流程实例的当前任务将报异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 单个流程实例挂起与激活 */ @Test public void SuspendSingleProcessInstance()&#123;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// RuntimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 查询流程定义的对象 ProcessInstance processInstance = runtimeService. createProcessInstanceQuery(). processInstanceId(&quot;15001&quot;). singleResult();// 得到当前流程定义的实例是否都为暂停状态 boolean suspended = processInstance.isSuspended();// 流程定义id String processDefinitionId = processInstance.getId();// 判断是否为暂停 if(suspended)&#123;// 如果是暂停，可以执行激活操作 ,参数：流程定义id runtimeService.activateProcessInstanceById(processDefinitionId); System.out.println(&quot;流程定义：&quot;+processDefinitionId+&quot;,已激活&quot;); &#125;else&#123;// 如果是激活状态，可以暂停，参数：流程定义id runtimeService.suspendProcessInstanceById( processDefinitionId); System.out.println(&quot;流程定义：&quot;+processDefinitionId+&quot;,已挂起&quot;); &#125; &#125; /** * 测试完成个人任务 */ @Test public void completTask()&#123;// 获取引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取操作任务的服务 TaskService TaskService taskService = processEngine.getTaskService();// 完成任务,参数：流程实例id,完成zhangsan的任务 Task task = taskService.createTaskQuery() .processInstanceId(&quot;15001&quot;) .taskAssignee(&quot;rose&quot;) .singleResult(); System.out.println(&quot;流程实例id=&quot;+task.getProcessInstanceId()); System.out.println(&quot;任务Id=&quot;+task.getId()); System.out.println(&quot;任务负责人=&quot;+task.getAssignee()); System.out.println(&quot;任务名称=&quot;+task.getName()); taskService.complete(task.getId()); &#125; 二、个人任务2.1、分配任务负责人2.1.1、固定分配在进行业务流程建模时指定固定的任务负责人， 如图： 并在 properties 视图中，填写 Assignee 项为任务负责人。 2.1.2、表达式分配由于固定分配方式，任务只管一步一步执行任务，执行到每一个任务将按照 bpmn 的配置去分配任务负责人。 2.1.2.1、UEL 表达式Activiti 使用 UEL 表达式， UEL 是 java EE6 规范的一部分， UEL（Unified Expression Language）即 统一表达式语言， activiti 支持两个 UEL 表达式： UEL-value 和 UEL-method。 1）UEL-value 定义如图： assignee 这个变量是 activiti 的一个流程变量， 或者使用这种方式定义： 如图： user 也是 activiti 的一个流程变量， user.assignee 表示通过调用 user 的 getter 方法获取值。 2）UEL-method 方式如图： userBean 是 spring 容器中的一个 bean，表示调用该 bean 的 getUserId()方法。 3）UEL-method 与 UEL-value 结合再比如：${ldapService.findManagerForEmployee(emp)}ldapService 是 spring 容器的一个 bean，findManagerForEmployee 是该 bean 的一个方法，emp 是 activiti流程变量， emp 作为参数传到 ldapService.findManagerForEmployee 方法中。 4）其它表达式支持解析基础类型、 bean、 list、 array 和 map，也可作为条件判断。如下：${order.price &gt; 100 &amp;&amp; order.price &lt; 250} 2.1.2.2、编写代码配置负责人1)定义任务分配流程变量如图： 2)设置流程变量在启动流程实例时设置流程变量，如下： 1234567891011121314151617181920 /** * 设置流程负责人 */ @Test public void assigneeUEL()&#123;// 获取流程引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取 RuntimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 设置assignee的取值，用户可以在界面上设置流程的执行 Map&lt;String,Object&gt; assigneeMap = new HashMap&lt;&gt;(); assigneeMap.put(&quot;assignee0&quot;,&quot;张三&quot;); assigneeMap.put(&quot;assignee1&quot;,&quot;李经理&quot;); assigneeMap.put(&quot;assignee2&quot;,&quot;王总经理&quot;); assigneeMap.put(&quot;assignee3&quot;,&quot;赵财务&quot;);// 启动流程实例，同时还要设置流程定义的assignee的值 runtimeService.startProcessInstanceByKey(&quot;myEvection1&quot;,assigneeMap);// 输出 System.out.println(processEngine.getName()); &#125; 执行成功后，可以在act_ru_variable表中看到刚才map中的数据 2.1.2.3、注意事项由于使用了表达式分配，必须保证在任务执行过程表达式执行成功，比如：某个任务使用了表达式${order.price &gt; 100 &amp;&amp; order.price &lt; 250}，当执行该任务时必须保证 order 在流程变量中存在，否则 activiti 异常。 2.1.3、监听器分配可以使用监听器来完成很多Activiti流程的业务。 在本章我们使用监听器的方式来指定负责人，那么在流程设计时就不需要指定assignee。 任务监听器是发生对应的任务相关事件时执行自定义 java 逻辑 或表达式。任务相当事件包括： Event的选项包含： 1234Create：任务创建后触发Assignment：任务分配后触发Delete：任务完成后触发All：所有事件发生都触发 定义任务监听类，且类必须实现 org.activiti.engine.delegate.TaskListener 接口 12345678910public class MyTaskListener implements TaskListener &#123; @Override public void notify(DelegateTask delegateTask) &#123; if(delegateTask.getName().equals(&quot;创建出差申请&quot;)&amp;&amp; delegateTask.getEventName().equals(&quot;create&quot;))&#123; //这里指定任务负责人 delegateTask.setAssignee(&quot;张三&quot;); &#125; &#125;&#125; DelegateTask对象的内容如下： 2.1.3.1、注意事项使用监听器分配方式，按照监听事件去执行监听类的 notify 方法，方法如果不能正常执行也会影响任务的执行。 2.2、查询任务查询任务负责人的待办任务代码如下： 12345678910111213141516171819202122// 查询当前个人待执行的任务@Testpublic void findPersonalTaskList() &#123; // 流程定义key String processDefinitionKey = &quot;myEvection1&quot;; // 任务负责人 String assignee = &quot;张三&quot;; // 获取TaskService TaskService taskService = processEngine.getTaskService(); List&lt;Task&gt; taskList = taskService.createTaskQuery() .processDefinitionKey(processDefinitionKey) .includeProcessVariables() .taskAssignee(assignee) .list(); for (Task task : taskList) &#123; System.out.println(&quot;----------------------------&quot;); System.out.println(&quot;流程实例id： &quot; + task.getProcessInstanceId()); System.out.println(&quot;任务id： &quot; + task.getId()); System.out.println(&quot;任务负责人： &quot; + task.getAssignee()); System.out.println(&quot;任务名称： &quot; + task.getName()); &#125;&#125; 关联 businessKey需求：在 activiti 实际应用时，查询待办任务可能要显示出业务系统的一些相关信息。 比如：查询待审批出差任务列表需要将出差单的日期、 出差天数等信息显示出来。 出差天数等信息在业务系统中存在，而并没有在 activiti 数据库中存在，所以是无法通过 activiti 的 api 查询到出差天数等信息。实现：在查询待办任务时，通过 businessKey（业务标识 ）关联查询业务系统的出差单表，查询出出差天数等信息。 12345678910111213141516171819202122232425@Test public void findProcessInstance()&#123;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取TaskService TaskService taskService = processEngine.getTaskService();// 获取RuntimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 查询流程定义的对象 Task task = taskService.createTaskQuery() .processDefinitionKey(&quot;myEvection1&quot;) .taskAssignee(&quot;张三&quot;) .singleResult();// 使用task对象获取实例id String processInstanceId = task.getProcessInstanceId();// 使用实例id，获取流程实例对象 ProcessInstance processInstance = runtimeService.createProcessInstanceQuery() .processInstanceId(processInstanceId) .singleResult();// 使用processInstance，得到 businessKey String businessKey = processInstance.getBusinessKey(); System.out.println(&quot;businessKey==&quot;+businessKey); &#125; 2.3、办理任务注意：在实际应用中，完成任务前需要校验任务的负责人是否具有该任务的办理权限 。 12345678910111213141516171819202122232425/** * 完成任务，判断当前用户是否有权限 */ @Test public void completTask() &#123; //任务id String taskId = &quot;15005&quot;;// 任务负责人 String assingee = &quot;张三&quot;; //获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 创建TaskService TaskService taskService = processEngine.getTaskService();// 完成任务前，需要校验该负责人可以完成当前任务// 校验方法：// 根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成 Task task = taskService.createTaskQuery() .taskId(taskId) .taskAssignee(assingee) .singleResult(); if(task != null)&#123; taskService.complete(taskId); System.out.println(&quot;完成任务&quot;); &#125; &#125; 三、流程变量3.1、什么是流程变量流程变量在 activiti 中是一个非常重要的角色，流程运转有时需要靠流程变量，业务系统和 activiti结合时少不了流程变量，流程变量就是 activiti 在管理工作流时根据管理需要而设置的变量。比如：在出差申请流程流转时如果出差天数大于 3 天则由总经理审核，否则由人事直接审核， 出差天数就可以设置为流程变量，在流程流转时使用。 注意：虽然流程变量中可以存储业务数据可以通过activiti的api查询流程变量从而实现 查询业务数据，但是不建议这样使用，因为业务数据查询由业务系统负责，activiti设置流程变量是为了流程执行需要而创建。 3.2、流程变量类型如果将 pojo 存储到流程变量中，必须实现序列化接口 serializable，为了防止由于新增字段无法反序列化，需要生成 serialVersionUID。 3.3、流程变量作用域流程变量的作用域可以是一个流程实例(processInstance)，或一个任务(task)，或一个执行实例(execution) 3.3.1、globa变量流程变量的默认作用域是流程实例。当一个流程变量的作用域为流程实例时，可以称为 global 变量 注意： 如： Global变量：userId（变量名）、zhangsan（变量值） global 变量中变量名不允许重复，设置相同名称的变量，后设置的值会覆盖前设置的变量值。 3.3.2、local变量任务和执行实例仅仅是针对一个任务和一个执行实例范围，范围没有流程实例大， 称为 local 变量。 Local 变量由于在不同的任务或不同的执行实例中，作用域互不影响，变量名可以相同没有影响。Local 变量名也可以和 global 变量名相同，没有影响。 3.4、流程变量的使用方法3.4.1、在属性上使用UEL表达式可以在 assignee 处设置 UEL 表达式，表达式的值为任务的负责人，比如： ${assignee}， assignee 就是一个流程变量名称。 Activiti获取UEL表达式的值，即流程变量assignee的值 ，将assignee的值作为任务的负责人进行任务分配 3.4.2、在连线上使用UEL表达式可以在连线上设置UEL表达式，决定流程走向。 比如：${price&lt;10000} 。price就是一个流程变量名称，uel表达式结果类型为布尔类型。 如果UEL表达式是true，要决定 流程执行走向。 3.5、使用Global变量控制流程3.5.1、需求员工创建出差申请单，由部门经理审核，部门经理审核通过后出差3天及以下由人财务直接审批，3天以上先由总经理审核，总经理审核通过再由财务审批。 3.5.2、流程定义1）、出差天数大于等于3连线条件 也可以使用对象参数命名，如evection.num： 2）、出差天数小于3连线条件 也可以使用对象参数命名，如： 3.5.3、设置global流程变量在部门经理审核前设置流程变量，变量值为出差单信息（包括出差天数），部门经理审核后可以根据流程变量的值决定流程走向。 在设置流程变量时，可以在启动流程时设置，也可以在任务办理时设置 3.5.3.1、创建POJO对象创建出差申请pojo对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.itheima.demo.pojo;import java.io.Serializable;import java.util.Date;/** * 出差申请 pojo */public class Evection implements Serializable &#123; /** * 主键id */ private Long id; /** * 出差申请单名称 */ private String evectionName; /** * 出差天数 */ private Double num; /** * 预计开始时间 */ private Date beginDate; /** * 预计结束时间 */ private Date endDate; /** * 目的地 */ private String destination; /** * 出差事由 */ private String reson; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getEvectionName() &#123; return evectionName; &#125; public void setEvectionName(String evectionName) &#123; this.evectionName = evectionName; &#125; public Date getBeginDate() &#123; return beginDate; &#125; public void setBeginDate(Date beginDate) &#123; this.beginDate = beginDate; &#125; public Date getEndDate() &#123; return endDate; &#125; public void setEndDate(Date endDate) &#123; this.endDate = endDate; &#125; public String getDestination() &#123; return destination; &#125; public void setDestination(String destination) &#123; this.destination = destination; &#125; public String getReson() &#123; return reson; &#125; public void setReson(String reson) &#123; this.reson = reson; &#125; public Double getNum() &#123; return num; &#125; public void setNum(Double num) &#123; this.num = num; &#125;&#125; 3.5.3.2、启动流程时设置变量在启动流程时设置流程变量，变量的作用域是整个流程实例。 通过Map&lt;key,value&gt;设置流程变量，map中可以设置多个变量，这个key就是流程变量的名字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /** * 启动流程实例,设置流程变量的值 */ @Test public void startProcess()&#123;// 获取流程引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取RunTimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 流程定义key String key = &quot;myEvection2&quot;;// 创建变量集合 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();// 创建出差pojo对象 Evection evection = new Evection();// 设置出差天数 evection.setNum(2d);// 定义流程变量，把出差pojo对象放入map map.put(&quot;evection&quot;,evection);// 设置assignee的取值，用户可以在界面上设置流程的执行 map.put(&quot;assignee0&quot;,&quot;张三&quot;); map.put(&quot;assignee1&quot;,&quot;李经理&quot;); map.put(&quot;assignee2&quot;,&quot;王总经理&quot;); map.put(&quot;assignee3&quot;,&quot;赵财务&quot;);// 启动流程实例，并设置流程变量的值（把map传入） ProcessInstance processInstance = runtimeService .startProcessInstanceByKey(key, map);// 输出 System.out.println(&quot;流程实例名称=&quot;+processInstance.getName()); System.out.println(&quot;流程定义id==&quot;+processInstance.getProcessDefinitionId()); &#125; /** * 完成任务，判断当前用户是否有权限 */ @Test public void completTask() &#123; //任务id String key = &quot;myEvection2&quot;;// 任务负责人 String assingee = &quot;张三&quot;; //获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 创建TaskService TaskService taskService = processEngine.getTaskService();// 完成任务前，需要校验该负责人可以完成当前任务// 校验方法：// 根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成 Task task = taskService.createTaskQuery() .processDefinitionKey(key) .taskAssignee(assingee) .singleResult(); if(task != null)&#123; taskService.complete(task.getId()); System.out.println(&quot;任务执行完成&quot;); &#125; &#125; 说明： startProcessInstanceByKey(processDefinitionKey, variables) 流程变量作用域是一个流程实例，流程变量使用Map存储，同一个流程实例设置变量map中key相同，后者覆盖前者。 3.5.3.2、任务办理时设置变量在完成任务时设置流程变量，该流程变量只有在该任务完成后其它结点才可使用该变量，它的作用域是整个流程实例，如果设置的流程变量的key在流程实例中已存在相同的名字则后设置的变量替换前边设置的变量。 这里需要在创建出差单任务完成时设置流程变量 12345678910111213141516171819202122232425262728293031323334 /** * 完成任务，判断当前用户是否有权限 */ @Test public void completTask() &#123; //任务id String key = &quot;myEvection2&quot;;// 任务负责人 String assingee = &quot;张三&quot;;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 创建TaskService TaskService taskService = processEngine.getTaskService();// 创建变量集合 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();// 创建出差pojo对象 Evection evection = new Evection();// 设置出差天数 evection.setNum(2d);// 定义流程变量 map.put(&quot;evection&quot;,evection);// 完成任务前，需要校验该负责人可以完成当前任务// 校验方法：// 根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成 Task task = taskService.createTaskQuery() .processDefinitionKey(key) .taskAssignee(assingee) .singleResult(); if(task != null)&#123; //完成任务是，设置流程变量的值 taskService.complete(task.getId(),map); System.out.println(&quot;任务执行完成&quot;); &#125; &#125; 说明： 通过当前任务设置流程变量，需要指定当前任务id，如果当前执行的任务id不存在则抛出异常。 任务办理时也是通过map&lt;key,value&gt;设置流程变量，一次可以设置多个变量。 3.5.3.3、通过当前流程实例设置通过流程实例id设置全局变量，该流程实例必须未执行完成。 123456789101112131415161718 @Test public void setGlobalVariableByExecutionId()&#123;// 当前流程实例执行 id，通常设置为当前执行的流程实例 String executionId=&quot;2601&quot;;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 获取RuntimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 创建出差pojo对象 Evection evection = new Evection();// 设置天数 evection.setNum(3d);// 通过流程实例 id设置流程变量 runtimeService.setVariable(executionId, &quot;evection&quot;, evection);// 一次设置多个值// runtimeService.setVariables(executionId, variables) &#125; 注意： executionId必须当前未结束 流程实例的执行id，通常此id设置流程实例 的id。也可以通runtimeService.getVariable()获取流程变量。 3.5.3.4、通过当前任务设置12345678910111213141516@Test public void setGlobalVariableByTaskId()&#123; //当前待办任务id String taskId=&quot;1404&quot;;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); TaskService taskService = processEngine.getTaskService(); Evection evection = new Evection(); evection.setNum(3); //通过任务设置流程变量 taskService.setVariable(taskId, &quot;evection&quot;, evection); //一次设置多个值 //taskService.setVariables(taskId, variables) &#125; 注意： 任务id必须是当前待办任务id，act_ru_task中存在。如果该任务已结束，会报错 也可以通过taskService.getVariable()获取流程变量。 3.5.4、测试正常测试： ​ 设置流程变量的值大于等于3天 ​ 设计流程变量的值小于3天 异常测试： ​ 流程变量不存在 ​ 流程变量的值为空NULL，price属性为空 ​ UEL表达式都不符合条件 ​ 不设置连线的条件 3.5.5、注意事项1、 如果UEL表达式中流程变量名不存在则报错。 2、 如果UEL表达式中流程变量值为空NULL，流程不按UEL表达式去执行，而流程结束 。 3、 如果UEL表达式都不符合条件，流程结束 4、 如果连线不设置条件，会走flow序号小的那条线 3.5.6、操作数据库表设置流程变量会在当前执行流程变量表插入记录，同时也会在历史流程变量表也插入记录。 12//当前流程变量表SELECT * FROM act_ru_variable 记录当前运行流程实例可使用的流程变量，包括 global和local变量 Id_：主键 Type_：变量类型 Name_：变量名称 Execution_id_：所属流程实例执行id，global和local变量都存储 Proc_inst_id_：所属流程实例id，global和local变量都存储 Task_id_：所属任务id，local变量存储 Bytearray_：serializable类型变量存储对应act_ge_bytearray表的id Double_：double类型变量值 Long_：long类型变量值 Text_：text类型变量值 12 #历史流程变量表SELECT * FROM act_hi_varinst 记录所有已创建的流程变量，包括 global和local变量 字段意义参考当前流程变量表。 3.6、设置local流程变量3.6.1、任务办理时设置 任务办理时设置local流程变量，当前运行的流程实例只能在该任务结束前使用，任务结束该变量无法在当前流程实例使用，可以通过查询历史任务查询。 1234567891011121314151617181920212223/**处理任务时设置local流程变量*/@Testpublic void completTask() &#123; //任务id String taskId = &quot;1404&quot;;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); TaskService taskService = processEngine.getTaskService();// 定义流程变量 Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;(); Evection evection = new Evection (); evection.setNum(3d);// 定义流程变量 Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();// 变量名是holiday，变量值是holiday对象 variables.put(&quot;evection&quot;, evection);// 设置local变量，作用域为该任务 taskService.setVariablesLocal(taskId, variables);// 完成任务 taskService.complete(taskId);&#125; ​ 说明： 设置作用域为任务的local变量，每个任务可以设置同名的变量，互不影响。 3.6.2、通过当前任务设置1234567891011121314@Testpublic void setLocalVariableByTaskId()&#123;// 当前待办任务id String taskId=&quot;1404&quot;;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); TaskService taskService = processEngine.getTaskService(); Evection evection = new Evection (); evection.setNum(3d);// 通过任务设置流程变量 taskService.setVariableLocal(taskId, &quot;evection&quot;, evection);// 一次设置多个值 //taskService.setVariablesLocal(taskId, variables)&#125; 注意： 任务id必须是当前待办任务id，act_ru_task中存在。 3.6.3、 Local变量测试1如果上边例子中设置global变量改为设置local变量是否可行？为什么？ Local变量在任务结束后无法在当前流程实例执行中使用，如果后续的流程执行需要用到此变量则会报错。 3.6.4、 Local变量测试2在部门经理审核、总经理审核、财务审核时设置local变量，可通过historyService查询每个历史任务时将流程变量的值也查询出来。 代码如下： 123456789101112// 创建历史任务查询对象 HistoricTaskInstanceQuery historicTaskInstanceQuery = historyService.createHistoricTaskInstanceQuery(); // 查询结果包括 local变量 historicTaskInstanceQuery.includeTaskLocalVariables();for (HistoricTaskInstance historicTaskInstance : list) &#123; System.out.println(&quot;==============================&quot;); System.out.println(&quot;任务id：&quot; + historicTaskInstance.getId()); System.out.println(&quot;任务名称：&quot; + historicTaskInstance.getName()); System.out.println(&quot;任务负责人：&quot; + historicTaskInstance.getAssignee()); System.out.println(&quot;任务local变量：&quot;+ historicTaskInstance.getTaskLocalVariables());&#125; 注意：查询历史流程变量，特别是查询pojo变量需要经过反序列化，不推荐使用。 四、组任务4.1、需求在流程定义中在任务结点的 assignee 固定设置任务负责人，在流程定义时将参与者固定设置在.bpmn 文件中，如果临时任务负责人变更则需要修改流程定义，系统可扩展性差。 针对这种情况可以给任务设置多个候选人，可以从候选人中选择参与者来完成任务。 4.2、设置任务候选人在流程图中任务节点的配置中设置 candidate-users(候选人)，多个候选人之间用逗号分开。 查看bpmn文件 1&lt;userTask activiti:candidateUsers=&quot;lisi,wangwu&quot; activiti:exclusive=&quot;true&quot; id=&quot;_3&quot; name=&quot;经理审批&quot;/&gt; 我们可以看到部门经理的审核人已经设置为 lisi,wangwu 这样的一组候选人，可以使用 activiti:candiateUsers&#x3D;”用户 1,用户 2,用户 3”的这种方式来实现设置一组候选人 4.3、组任务4.3.1、组任务办理流程a、查询组任务指定候选人，查询该候选人当前的待办任务。 候选人不能立即办理任务。 b、拾取(claim)任务该组任务的所有候选人都能拾取。 将候选人的组任务，变成个人任务。原来候选人就变成了该任务的负责人。 如果拾取后不想办理该任务？ 需要将已经拾取的个人任务归还到组里边，将个人任务变成了组任务。 c、查询个人任务查询方式同个人任务部分，根据assignee查询用户负责的个人任务。 d、办理个人任务4.3.2、 查询组任务 根据候选人查询组任务 1234567891011121314151617181920212223@Test public void findGroupTaskList() &#123; // 流程定义key String processDefinitionKey = &quot;evection3&quot;; // 任务候选人 String candidateUser = &quot;lisi&quot;; // 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 创建TaskService TaskService taskService = processEngine.getTaskService(); //查询组任务 List&lt;Task&gt; list = taskService.createTaskQuery() .processDefinitionKey(processDefinitionKey) .taskCandidateUser(candidateUser)//根据候选人查询 .list(); for (Task task : list) &#123; System.out.println(&quot;----------------------------&quot;); System.out.println(&quot;流程实例id：&quot; + task.getProcessInstanceId()); System.out.println(&quot;任务id：&quot; + task.getId()); System.out.println(&quot;任务负责人：&quot; + task.getAssignee()); System.out.println(&quot;任务名称：&quot; + task.getName()); &#125; &#125; 4.3.3 、 拾取组任务 候选人员拾取组任务后该任务变为自己的个人任务。 12345678910111213141516171819202122@Test public void claimTask()&#123; // 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); TaskService taskService = processEngine.getTaskService(); //要拾取的任务id String taskId = &quot;6302&quot;; //任务候选人id String userId = &quot;lisi&quot;; //拾取任务 //即使该用户不是候选人也能拾取(建议拾取时校验是否有资格) //校验该用户有没有拾取任务的资格 Task task = taskService.createTaskQuery() .taskId(taskId) .taskCandidateUser(userId)//根据候选人查询 .singleResult(); if(task!=null)&#123; //拾取任务 taskService.claim(taskId, userId); System.out.println(&quot;任务拾取成功&quot;); &#125; &#125; 说明：即使该用户不是候选人也能拾取，建议拾取时校验是否有资格 组任务拾取后，该任务已有负责人，通过候选人将查询不到该任务 4.3.4、 查询个人待办任务 查询方式同个人任务查询 12345678910111213141516171819202122@Testpublic void findPersonalTaskList() &#123; // 流程定义key String processDefinitionKey = &quot;evection1&quot;; // 任务负责人 String assignee = &quot;zhangsan&quot;; // 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 创建TaskService TaskService taskService = processEngine.getTaskService(); List&lt;Task&gt; list = taskService.createTaskQuery() .processDefinitionKey(processDefinitionKey) .taskAssignee(assignee) .list(); for (Task task : list) &#123; System.out.println(&quot;----------------------------&quot;); System.out.println(&quot;流程实例id：&quot; + task.getProcessInstanceId()); System.out.println(&quot;任务id：&quot; + task.getId()); System.out.println(&quot;任务负责人：&quot; + task.getAssignee()); System.out.println(&quot;任务名称：&quot; + task.getName()); &#125;&#125; 4.3.5、 办理个人任务同个人任务办理 1234567891011 /*完成任务*/ @Test public void completeTask()&#123;// 任务ID String taskId = &quot;12304&quot;;// 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); processEngine.getTaskService() .complete(taskId); System.out.println(&quot;完成任务：&quot;+taskId); &#125; 说明：建议完成任务前校验该用户是否是该任务的负责人。 4.3.6、 归还组任务 如果个人不想办理该组任务，可以归还组任务，归还后该用户不再是该任务的负责人 123456789101112131415161718192021222324/**归还组任务，由个人任务变为组任务，还可以进行任务交接*/@Testpublic void setAssigneeToGroupTask() &#123; // 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 查询任务使用TaskService TaskService taskService = processEngine.getTaskService(); // 当前待办任务 String taskId = &quot;6004&quot;; // 任务负责人 String userId = &quot;zhangsan2&quot;; // 校验userId是否是taskId的负责人，如果是负责人才可以归还组任务 Task task = taskService .createTaskQuery() .taskId(taskId) .taskAssignee(userId) .singleResult(); if (task != null) &#123; // 如果设置为null，归还组任务,该 任务没有负责人 taskService.setAssignee(taskId, null); &#125;&#125; 说明：建议归还任务前校验该用户是否是该任务的负责人 也可以通过setAssignee方法将任务委托给其它用户负责，注意被委托的用户可以不是候选人（建议不要这样使用） 4.3.7、 任务交接任务交接,任务负责人将任务交给其它候选人办理该任务 12345678910111213141516171819202122@Test public void setAssigneeToCandidateUser() &#123; // 获取processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 查询任务使用TaskService TaskService taskService = processEngine.getTaskService(); // 当前待办任务 String taskId = &quot;6004&quot;; // 任务负责人 String userId = &quot;zhangsan2&quot;;// 将此任务交给其它候选人办理该 任务 String candidateuser = &quot;zhangsan&quot;; // 校验userId是否是taskId的负责人，如果是负责人才可以归还组任务 Task task = taskService .createTaskQuery() .taskId(taskId) .taskAssignee(userId) .singleResult(); if (task != null) &#123; taskService.setAssignee(taskId, candidateuser); &#125; &#125; 4.3.8、 数据库表操作查询当前任务执行表 1SELECT * FROM act_ru_task 任务执行表，记录当前执行的任务，由于该任务当前是组任务，所有assignee为空，当拾取任务后该字段就是拾取用户的id 查询任务参与者 1SELECT * FROM act_ru_identitylink 任务参与者，记录当前参考任务用户或组，当前任务如果设置了候选人，会向该表插入候选人记录，有几个候选就插入几个 与act_ru_identitylink对应的还有一张历史表act_hi_identitylink，向act_ru_identitylink插入记录的同时也会向历史表插入记录。任务完成 五、网关网关用来控制流程的流向 5.1 排他网关ExclusiveGateway5.1.1 什么是排他网关：排他网关，用来在流程中实现决策。 当流程执行到这个网关，所有分支都会判断条件是否为true，如果为true则执行该分支， 注意：排他网关只会选择一个为true的分支执行。如果有两个分支条件都为true，排他网关会选择id值较小的一条分支去执行。 为什么要用排他网关？ 不用排他网关也可以实现分支，如：在连线的condition条件上设置分支条件。 在连线设置condition条件的缺点：如果条件都不满足，流程就结束了(是异常结束)。 如果 使用排他网关决定分支的走向，如下： 如果从网关出去的线所有条件都不满足则系统抛出异常。 123org.activiti.engine.ActivitiException: No outgoing sequence flow of the exclusive gateway &#x27;exclusivegateway1&#x27; could be selected for continuing the process at org.activiti.engine.impl.bpmn.behavior.ExclusiveGatewayActivityBehavior.leave(ExclusiveGatewayActivityBehavior.java:85) 5.1.2 流程定义 排他网关图标，红框内： 5.1.3 测试在部门经理审核后，走排他网关，从排他网关出来的分支有两条，一条是判断出差天数是否大于3天，另一条是判断出差天数是否小于等于3天。 设置分支条件时，如果所有分支条件都不是true，报错： 1234org.activiti.engine.ActivitiException: No outgoing sequence flow of the exclusive gateway &#x27;exclusivegateway1&#x27; could be selected for continuing the process at org.activiti.engine.impl.bpmn.behavior.ExclusiveGatewayActivityBehavior.leave(ExclusiveGatewayActivityBehavior.java:85) 5.2 并行网关ParallelGateway5.2.1 什么是并行网关并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起，并行网关的功能是基于进入和外出顺序流的： l fork分支： 并行后的所有外出顺序流，为每个顺序流都创建一个并发分支。 l join汇聚： 所有到达并行网关，在此等待的进入分支， 直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关。 注意，如果同一个并行网关有多个进入和多个外出顺序流， 它就同时具有分支和汇聚功能。 这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。 与其他网关的主要区别是，并行网关不会解析条件。 即使顺序流中定义了条件，也会被忽略。 例子： 说明： 技术经理和项目经理是两个execution分支，在act_ru_execution表有两条记录分别是技术经理和项目经理，act_ru_execution还有一条记录表示该流程实例。 待技术经理和项目经理任务全部完成，在汇聚点汇聚，通过parallelGateway并行网关。 并行网关在业务应用中常用于会签任务，会签任务即多个参与者共同办理的任务。 5.2.2 流程定义并行网关图标，红框内： 5.2.3 测试当执行到并行网关数据库跟踪如下： 当前任务表：SELECT * FROM act_ru_task 上图中：有两个任务当前执行。 查询流程实例执行表：SELECT * FROM act_ru_execution 上图中，说明当前流程实例有多个分支(两个)在运行。 对并行任务的执行： 并行任务执行不分前后，由任务的负责人去执行即可。 执行技术经理任务后，查询当前任务表 SELECT * FROM act_ru_task 已完成的技术经理任务在当前任务表act_ru_task_已被删除。 在流程实例执行表：SELECT * FROM act_ru_execution有中多个分支存在且有并行网关的汇聚结点。 有并行网关的汇聚结点：说明有一个分支已经到汇聚，等待其它的分支到达。 当所有分支任务都完成，都到达汇聚结点后： 流程实例执行表：SELECT * FROM act_ru_execution，执行流程实例已经变为总经理审批，说明流程执行已经通过并行网关 总结：所有分支到达汇聚结点，并行网关执行完成。 5.3 包含网关InclusiveGateway5.3.1 什么是包含网关包含网关可以看做是排他网关和并行网关的结合体。 和排他网关一样，你可以在外出顺序流上定义条件，包含网关会解析它们。 但是主要的区别是包含网关可以选择多于一条顺序流，这和并行网关一样。 包含网关的功能是基于进入和外出顺序流的： l 分支： 所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行， 会为每个顺序流创建一个分支。 l 汇聚： 所有并行分支到达包含网关，会进入等待状态， 直到每个包含流程token的进入顺序流的分支都到达。 这是与并行网关的最大不同。换句话说，包含网关只会等待被选中执行了的进入顺序流。 在汇聚之后，流程会穿过包含网关继续执行。 5.3.2 流程定义：出差申请大于等于3天需要由项目经理审批，小于3天由技术经理审批，出差申请必须经过人事经理审批。 包含网关图标，红框内： 定义流程： 注意：通过包含网关的每个分支的连线上设置condition条件。 5.3.3 测试如果包含网关设置的条件中，流程变量不存在，报错; 1org.activiti.engine.ActivitiException: Unknown property used in expression: $&#123;evection.num&gt;=3&#125; 需要在流程启动时设置流程变量evection.num。 1）、当流程执行到第一个包含网关后，会根据条件判断，当前要走哪几个分支： 流程实例执行表：SELECT * FROM act_ru_execution 第一条记录：包含网关分支。 后两条记录代表两个要执行的分支： ACT_ID &#x3D; “_13” 代表 项目经理神品 ACT_ID &#x3D; “_5” 代表 人事经理审批 当前任务表：ACT_RU_TASK 上图中，项目经理审批、人事经理审批 都是当前的任务，在并行执行。 如果有一个分支执行先走到汇聚结点的分支，要等待其它执行分支走到汇聚。 2）、先执行项目经理审批，然后查询当前任务表：ACT_RU_TASK 当前任务还有人事经理审批需要处理。 流程实例执行表：SELECT * FROM act_ru_execution 发现人事经理的分支还存在，而项目经理分支已经走到ACT_ID &#x3D; _18的节点。而ACT_ID&#x3D;__18就是第二个包含网关 这时，因为有2个分支要执行，包含网关会等所有分支走到汇聚才能执行完成。 3）、执行人事经理审批 然后查询当前任务表：ACT_RU_TASK 当前任务表已经不是人事经理审批了，说明人事经理审批已经完成。 流程实例执行表：SELECT * FROM act_ru_execution 包含网关执行完成，分支和汇聚就从act_ru_execution删除。 小结：在分支时，需要判断条件，符合条件的分支，将会执行，符合条件的分支最终才进行汇聚。 5.4 事件网关EventGateway事件网关允许根据事件判断流向。网关的每个外出顺序流都要连接到一个中间捕获事件。 当流程到达一个基于事件网关，网关会进入等待状态：会暂停执行。与此同时，会为每个外出顺序流创建相对的事件订阅。 事件网关的外出顺序流和普通顺序流不同，这些顺序流不会真的”执行”， 相反它们让流程引擎去决定执行到事件网关的流程需要订阅哪些事件。 要考虑以下条件： 事件网关必须有两条或以上外出顺序流； 事件网关后，只能使用intermediateCatchEvent类型（activiti不支持基于事件网关后连接ReceiveTask） 连接到事件网关的中间捕获事件必须只有一个入口顺序流。 5.4.1流程定义事件网关图标，红框内 intermediateCatchEvent： intermediateCatchEvent支持的事件类型： Message Event: 消息事件 Singal Event： 信号事件 Timer Event： 定时事件 使用事件网关定义流程：","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://guoshunfa.com/tags/Activiti7/"}]},{"title":"搭建单体SpringBoot项目 集成Druid数据库连接池和监控","slug":"软件开发/场景/搭建单体SpringBoot项目/24集成数据库/搭建单体SpringBoot项目-集成Druid数据库连接池和监控","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Druid数据库连接池和监控/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8C%E7%9B%91%E6%8E%A7/","excerpt":"","text":"druid 官网github地址 Druid Spring Boot Starter 用于帮助你在Spring Boot项目中轻松集成Druid数据库连接池和监控。 如何使用 在 Spring Boot 项目中加入druid-spring-boot-starter依赖 (点击查询最新版本) Maven 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; Gradle 1compile &#x27;com.alibaba:druid-spring-boot-starter:1.1.17&#x27; 添加配置 1234spring.datasource.url= spring.datasource.username=spring.datasource.password=# ...其他配置（可选，不是必须的，使用内嵌数据库的话上述三项也可省略不填） 配置属性Druid Spring Boot Starter 配置属性的名称完全遵照 Druid，你可以通过 Spring Boot 配置文件来配置Druid数据库连接池和监控，如果没有配置则使用默认值。 JDBC 配置 1234567# 数据库地址spring.datasource.druid.url= # 或spring.datasource.url= # 数据库用户名spring.datasource.druid.username= # 或spring.datasource.username=# 数据库密码spring.datasource.druid.password= # 或spring.datasource.password=spring.datasource.druid.driver-class-name= #或 spring.datasource.driver-class-name= 连接池配置 12345678910111213141516171819202122# 数据库连接池初始值spring.datasource.druid.initial-size=# 数据库连接池最大值spring.datasource.druid.max-active=# 数据库连接池最小空闲值spring.datasource.druid.min-idle=# 获取连接时最大等待时间，单位毫秒(1分钟)spring.datasource.druid.max-wait=spring.datasource.druid.pool-prepared-statements=spring.datasource.druid.max-pool-prepared-statement-per-connection-size= spring.datasource.druid.max-open-prepared-statements= #和上面的等价spring.datasource.druid.validation-query=spring.datasource.druid.validation-query-timeout=spring.datasource.druid.test-on-borrow=spring.datasource.druid.test-on-return=spring.datasource.druid.test-while-idle=spring.datasource.druid.time-between-eviction-runs-millis=spring.datasource.druid.min-evictable-idle-time-millis=spring.datasource.druid.max-evictable-idle-time-millis=spring.datasource.druid.filters= #配置多个英文逗号分隔....//more 监控配置 123456789101112131415161718192021# WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilterspring.datasource.druid.web-stat-filter.enabled= #是否启用StatFilter默认值falsespring.datasource.druid.web-stat-filter.url-pattern=spring.datasource.druid.web-stat-filter.exclusions=spring.datasource.druid.web-stat-filter.session-stat-enable=spring.datasource.druid.web-stat-filter.session-stat-max-count=spring.datasource.druid.web-stat-filter.principal-session-name=spring.datasource.druid.web-stat-filter.principal-cookie-name=spring.datasource.druid.web-stat-filter.profile-enable=# StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置spring.datasource.druid.stat-view-servlet.enabled= #是否启用StatViewServlet（监控页面）默认值为false（考虑到安全问题默认并未启动，如需启用建议设置密码或白名单以保障安全）spring.datasource.druid.stat-view-servlet.url-pattern=spring.datasource.druid.stat-view-servlet.reset-enable=spring.datasource.druid.stat-view-servlet.login-username=spring.datasource.druid.stat-view-servlet.login-password=spring.datasource.druid.stat-view-servlet.allow=spring.datasource.druid.stat-view-servlet.deny=# Spring监控配置，说明请参考Druid Github Wiki，配置_Druid和Spring关联监控配置spring.datasource.druid.aop-patterns= # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 Druid Spring Boot Starter 不仅限于对以上配置属性提供支持，DruidDataSource 内提供setter方法的可配置属性都将被支持。你可以参考WIKI文档或通过IDE输入提示来进行配置。配置文件的格式你可以选择.properties或.yml，效果是一样的，在配置较多的情况下推荐使用.yml。 如何配置多数据源 添加配置 123456789101112131415161718192021spring.datasource.url=spring.datasource.username=spring.datasource.password=# Druid 数据源配置，继承spring.datasource.* 配置，相同则覆盖...spring.datasource.druid.initial-size=5spring.datasource.druid.max-active=5...# Druid 数据源 1 配置，继承spring.datasource.druid.* 配置，相同则覆盖...spring.datasource.druid.one.max-active=10spring.datasource.druid.one.max-wait=10000...# Druid 数据源 2 配置，继承spring.datasource.druid.* 配置，相同则覆盖...spring.datasource.druid.two.max-active=20spring.datasource.druid.two.max-wait=20000... 强烈注意：Spring Boot 2.X 版本不再支持配置继承，多数据源的话每个数据源的所有配置都需要单独配置，否则配置不会生效 创建数据源 1234567891011@Primary@Bean@ConfigurationProperties(&quot;spring.datasource.druid.one&quot;)public DataSource dataSourceOne()&#123; return DruidDataSourceBuilder.create().build();&#125;@Bean@ConfigurationProperties(&quot;spring.datasource.druid.two&quot;)public DataSource dataSourceTwo()&#123; return DruidDataSourceBuilder.create().build();&#125; 如何配置 Filter你可以通过 spring.datasource.druid.filters=stat,wall,log4j ... 的方式来启用相应的内置Filter，不过这些Filter都是默认配置。如果默认配置不能满足你的需求，你可以放弃这种方式，通过配置文件来配置Filter，下面是例子。 12345678910111213# 配置StatFilter spring.datasource.druid.filter.stat.enabled=truespring.datasource.druid.filter.stat.db-type=h2spring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=2000# 配置WallFilter spring.datasource.druid.filter.wall.enabled=truespring.datasource.druid.filter.wall.db-type=h2spring.datasource.druid.filter.wall.config.delete-allow=falsespring.datasource.druid.filter.wall.config.drop-table-allow=false# 其他 Filter 配置不再演示 目前为以下 Filter 提供了配置支持，请参考文档或者根据IDE提示（spring.datasource.druid.filter.*）进行配置。 StatFilter WallFilter ConfigFilter EncodingConvertFilter Slf4jLogFilter Log4jFilter Log4j2Filter CommonsLogFilter 要想使自定义 Filter 配置生效需要将对应 Filter 的 enabled 设置为 true ，Druid Spring Boot Starter 默认禁用 StatFilter，你也可以将其 enabled 设置为 true 来启用它。 如何获取 Druid 的监控数据Druid 的监控数据可以在开启 StatFilter 后通过 DruidStatManagerFacade 进行获取，获取到监控数据之后你可以将其暴露给你的监控系统进行使用。Druid 默认的监控系统数据也来源于此。下面给做一个简单的演示，在 Spring Boot 中如何通过 HTTP 接口将 Druid 监控数据以 JSON 的形式暴露出去，实际使用中你可以根据你的需要自由地对监控数据、暴露方式进行扩展。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@RestControllerpublic class DruidStatController &#123; @GetMapping(&quot;/druid/stat&quot;) public Object druidStat()&#123; // DruidStatManagerFacade#getDataSourceStatDataList 该方法可以获取所有数据源的监控数据，除此之外 DruidStatManagerFacade 还提供了一些其他方法，你可以按需选择使用。 return DruidStatManagerFacade.getInstance().getDataSourceStatDataList(); &#125;&#125;[ &#123; &quot;Identity&quot;: 1583082378, &quot;Name&quot;: &quot;DataSource-1583082378&quot;, &quot;DbType&quot;: &quot;h2&quot;, &quot;DriverClassName&quot;: &quot;org.h2.Driver&quot;, &quot;URL&quot;: &quot;jdbc:h2:file:./demo-db&quot;, &quot;UserName&quot;: &quot;sa&quot;, &quot;FilterClassNames&quot;: [ &quot;com.alibaba.druid.filter.stat.StatFilter&quot; ], &quot;WaitThreadCount&quot;: 0, &quot;NotEmptyWaitCount&quot;: 0, &quot;NotEmptyWaitMillis&quot;: 0, &quot;PoolingCount&quot;: 2, &quot;PoolingPeak&quot;: 2, &quot;PoolingPeakTime&quot;: 1533782955104, &quot;ActiveCount&quot;: 0, &quot;ActivePeak&quot;: 1, &quot;ActivePeakTime&quot;: 1533782955178, &quot;InitialSize&quot;: 2, &quot;MinIdle&quot;: 2, &quot;MaxActive&quot;: 30, &quot;QueryTimeout&quot;: 0, &quot;TransactionQueryTimeout&quot;: 0, &quot;LoginTimeout&quot;: 0, &quot;ValidConnectionCheckerClassName&quot;: null, &quot;ExceptionSorterClassName&quot;: null, &quot;TestOnBorrow&quot;: true, &quot;TestOnReturn&quot;: true, &quot;TestWhileIdle&quot;: true, &quot;DefaultAutoCommit&quot;: true, &quot;DefaultReadOnly&quot;: null, &quot;DefaultTransactionIsolation&quot;: null, &quot;LogicConnectCount&quot;: 103, &quot;LogicCloseCount&quot;: 103, &quot;LogicConnectErrorCount&quot;: 0, &quot;PhysicalConnectCount&quot;: 2, &quot;PhysicalCloseCount&quot;: 0, &quot;PhysicalConnectErrorCount&quot;: 0, &quot;ExecuteCount&quot;: 102, &quot;ErrorCount&quot;: 0, &quot;CommitCount&quot;: 100, &quot;RollbackCount&quot;: 0, &quot;PSCacheAccessCount&quot;: 100, &quot;PSCacheHitCount&quot;: 99, &quot;PSCacheMissCount&quot;: 1, &quot;StartTransactionCount&quot;: 100, &quot;TransactionHistogram&quot;: [ 55, 44, 1, 0, 0, 0, 0 ], &quot;ConnectionHoldTimeHistogram&quot;: [ 53, 47, 3, 0, 0, 0, 0, 0 ], &quot;RemoveAbandoned&quot;: false, &quot;ClobOpenCount&quot;: 0, &quot;BlobOpenCount&quot;: 0, &quot;KeepAliveCheckCount&quot;: 0, &quot;KeepAlive&quot;: false, &quot;FailFast&quot;: false, &quot;MaxWait&quot;: 1234, &quot;MaxWaitThreadCount&quot;: -1, &quot;PoolPreparedStatements&quot;: true, &quot;MaxPoolPreparedStatementPerConnectionSize&quot;: 5, &quot;MinEvictableIdleTimeMillis&quot;: 30001, &quot;MaxEvictableIdleTimeMillis&quot;: 25200000, &quot;LogDifferentThread&quot;: true, &quot;RecycleErrorCount&quot;: 0, &quot;PreparedStatementOpenCount&quot;: 1, &quot;PreparedStatementClosedCount&quot;: 0, &quot;UseUnfairLock&quot;: true, &quot;InitGlobalVariants&quot;: false, &quot;InitVariants&quot;: false &#125;] IDE 提示支持 演示克隆项目，运行test包内的DemoApplication。 文章参考 druid 官方readme.md springboot下使用druid-spring-boot-starter","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Druid","slug":"Druid","permalink":"https://guoshunfa.com/tags/Druid/"}]},{"title":"搭建单体SpringBoot项目 集成MongoDB数据库","slug":"软件开发/场景/搭建单体SpringBoot项目/24集成数据库/搭建单体SpringBoot项目-集成MongoDB数据库","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成MongoDB数据库/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"1. 集成1.1. Maven1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 1.2. 环境配置123# application.properties# MongoDB数据库spring.data.mongodb.uri=mongodb://127.0.0.1:27017/gsf_test spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;name:pass@localhost:27017&#x2F;test，其中name是用户名，pass是密码 如果要配置多个数据库，则中间用”,”分割，例如 spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;192.168.1.1:20000,192.168.1.2:20000,192.168.252.12:20000&#x2F;test 1.3. demo12345678910111213141516171819@SpringBootTestclass TestMongodbApplicationTests &#123; @Autowired private MongoTemplate mongoTemplate; @Test void contextLoads() &#123; HouseHold houseHold = mongoTemplate.findById(&quot;60fa3b3635f8c5790b880297&quot;, HouseHold.class, &quot;HouseHold&quot;); System.out.println(houseHold.getId() + houseHold.getCreateTime()); &#125; class HouseHold &#123; private String id; private Date createTime; // 省略set get &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"}]},{"title":"搭建单体SpringBoot项目 集成Mysql数据库","slug":"软件开发/场景/搭建单体SpringBoot项目/24集成数据库/搭建单体SpringBoot项目-集成Mysql数据库","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Mysql数据库/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"&#96; 1. SpringBoot框架集成Mysql1.1. 引入mysql maven包123456789101112131415 &lt;!--集成mysql数据库--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 1.2. 添加数据库配置 druid配置请前往：Druid数据库连接池和监控 在spring boot项目的配置文件application.properties中添加如下配置： 12345678910111213spring.datasource.druid.url=jdbc:mysql://127.0.0.1:3306/db?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.druid.username=rootspring.datasource.druid.password=pandacodespring.datasource.druid.max-active=20spring.datasource.druid.initial-size=5spring.datasource.druid.min-idle=5spring.datasource.druid.min-evictable-idle-time-millis=300000spring.datasource.druid.max-wait=60000spring.datasource.druid.validation-query=select 1spring.datasource.druid.test-on-borrow=falsespring.datasource.druid.test-on-return=falsespring.datasource.druid.test-while-idle=truespring.datasource.druid.time-between-eviction-runs-millis=60000","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"mysql","slug":"mysql","permalink":"https://guoshunfa.com/tags/mysql/"}]},{"title":"搭建单体SpringBoot项目 集成Redis数据库","slug":"软件开发/场景/搭建单体SpringBoot项目/24集成数据库/搭建单体SpringBoot项目-集成Redis数据库","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Redis数据库/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"引入maven依赖1234567891011121314151617181920&lt;!-- redis 数据库 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 添加配置类12345678910111213141516171819202122import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(factory); template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); template.afterPropertiesSet(); return template; &#125;&#125; RedisTemplate使用使用RedisTemplate的opsFor***方法，进行操控指定类型的数据。","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"https://guoshunfa.com/tags/Redis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"}]},{"title":"搭建单体SpringBoot项目 集成MybatisPlus-Mybatis增强器","slug":"软件开发/场景/搭建单体SpringBoot项目/25集成持久层框架/搭建单体SpringBoot项目-集成MybatisPlus-Mybatis增强器","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成MybatisPlus-Mybatis增强器/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90MybatisPlus-Mybatis%E5%A2%9E%E5%BC%BA%E5%99%A8/","excerpt":"","text":"集成MybatisPlus(Mybatis增强器) Mybatis Plus详细讲解 引入maven12345&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://guoshunfa.com/tags/Mybatis/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://guoshunfa.com/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"},{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://guoshunfa.com/tags/MybatisPlus/"}]},{"title":"搭建单体SpringBoot项目 集成MybatisPlus代码生成","slug":"软件开发/场景/搭建单体SpringBoot项目/25集成持久层框架/搭建单体SpringBoot项目-集成MybatisPlus代码生成","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成MybatisPlus代码生成/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90MybatisPlus%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/","excerpt":"","text":"官方 说明文档 引入maven123456789101112131415&lt;!-- mybatis plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mybatis plus generator --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- freemarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.OutputFile;import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;import com.baomidou.mybatisplus.generator.config.querys.MySqlQuery;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import com.baomidou.mybatisplus.generator.fill.Column;import com.baomidou.mybatisplus.generator.fill.Property;import com.baomidou.mybatisplus.generator.keywords.MySqlKeyWordsHandler;import com.panda.common.base.*;import java.util.Collections;/** * mybatis plus 代码生成&lt;br/&gt; * 详细配置请前往 https://baomidou.com/pages/981406/ * @author guoshunfa */public class CodeGenerate &#123; // 数据库url地址 public static final String URL = &quot;jdbc:mysql://127.0.0.1:3306/attacking-panda-db?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;; // 数据库用户名 public static final String USERNAME = &quot;root&quot;; // 数据库密码 public static final String PASSWORD = &quot;guoshunfa&quot;; // 代码开发作者 public static final String AUTHOR = &quot;guoshunfa&quot;; // 代码生成到指定目录 public static final String OUTPUT_DIR = &quot;/Users/guoshunfa/workspace/my/my-main-git-project/attacking-panda/attacking-panda-java/codeGenerate&quot;; // 父包名 public static final String PARENT = &quot;com.panda.admin&quot;; // 父包模块 public static final String MODULE_NAME = &quot;system&quot;; // 需要生成的表 public static final String[] ADD_INCLUDE = &#123;&quot;sys_user&quot;, &quot;sys_dept&quot;&#125;; // 设置过滤表前缀，例子：&quot;t_&quot;, &quot;c_&quot; public static final String[] ADD_TABLE_PREFIX = &#123;&#125;; public static void main(String[] args) &#123; FastAutoGenerator.create( new DataSourceConfig.Builder(URL, USERNAME, PASSWORD) .dbQuery(new MySqlQuery()) // 数据库查询 .schema(&quot;&quot;) // 数据库 schema(部分数据库适用)// .typeConvert(new MySqlTypeConvert()) // 数据库类型转换器 .keyWordsHandler(new MySqlKeyWordsHandler()) // 数据库关键字处理器 ) // 数据库配置 // ----------------------------------全局配置---------------------------------- .globalConfig(builder -&gt; &#123; builder.fileOverride() // 覆盖已生成文件，默认值:false// .disableOpenDir() // 禁止打开输出目录，默认值:true .outputDir(OUTPUT_DIR) // 指定输出目录 .author(AUTHOR) // 作者名// .enableKotlin() // 开启 kotlin 模式，默认值:false .enableSwagger() // 开启 swagger 模式，默认值:false .dateType(DateType.TIME_PACK) // 时间策略 .commentDate(&quot;yyyy-MM-dd&quot;); // 注释日期 &#125;) // ----------------------------------包配置---------------------------------- .packageConfig(builder -&gt; &#123; builder.parent(PARENT) // 父包名 默认值:com.baomidou .moduleName(MODULE_NAME) // 父包模块名 默认值:无 .entity(&quot;entity&quot;) // Entity 包名 默认值:entity .service(&quot;service&quot;) // Service 包名 默认值:service .serviceImpl(&quot;service.impl&quot;) // Service Impl 包名 默认值:service.impl .mapper(&quot;mapper&quot;) // Mapper 包名 默认值:mapper .xml(&quot;mapper.xml&quot;) // Mapper XML 包名 默认值:mapper.xml .controller(&quot;controller&quot;) // Controller 包名 默认值:controller .other(&quot;other&quot;) // 自定义文件包名 输出自定义文件时所用到的包名 .pathInfo(Collections.singletonMap(OutputFile.mapperXml, OUTPUT_DIR)) // 路径配置信息 .build(); &#125;) // ----------------------------------模板配置----------------------------------// .templateConfig(builder -&gt; &#123;&#125;) // ----------------------------------注入配置---------------------------------- .injectionConfig(builder -&gt; &#123; builder.beforeOutputFile(((tableInfo, objectMap) -&gt; &#123; System.out.println(&quot;tableInfo: &quot; + tableInfo.getEntityName() + &quot; objectMap: &quot; + objectMap.size()); &#125;)) // 输出文件之前消费者// .customMap(Collections.singletonMap(&quot;test&quot;, &quot;baomidou&quot;)) // 自定义配置 Map 对象// .customFile(Collections.singletonMap(&quot;test.txt&quot;, &quot;/templates/test.vm&quot;)) // 自定义配置模板文件 .build(); &#125;) // ----------------------------------策略配置---------------------------------- .strategyConfig(builder -&gt; &#123; builder.enableCapitalMode() // 开启大写命名 默认值:false .enableSkipView() // 开启跳过视图 默认值:false .disableSqlFilter() // 禁用 sql 过滤 默认值:true，语法不能支持使用 sql 过滤表的话，可以考虑关闭此开关 .enableSchema() // 启用 schema 默认值:false，多 schema 场景的时候打开// .likeTable(new LikeTable(&quot;USER&quot;)) // 模糊表匹配(sql 过滤) likeTable 与 notLikeTable 只能配置一项// .notLikeTable(new LikeTable(&quot;USER&quot;)) // 模糊表排除(sql 过滤) likeTable 与 notLikeTable 只能配置一项 .addInclude(ADD_INCLUDE) // 增加表匹配(内存过滤) include 与 exclude 只能配置一项// .addExclude(&quot;a_abc&quot;) // 增加表排除匹配(内存过滤) include 与 exclude 只能配置一项 .addTablePrefix(ADD_TABLE_PREFIX) // 增加过滤表前缀// .addTableSuffix(&quot;abc&quot;) // 增加过滤表后缀// .addFieldPrefix(&quot;sys_&quot;) // 增加过滤字段前缀// .addFieldSuffix(&quot;_flag&quot;) // 增加过滤字段后缀 // ----------------------------------Entity 策略配置---------------------------------- .entityBuilder().superClass(BaseEntity.class) // 设置父类// .disableSerialVersionUID() // 禁用生成 serialVersionUID 默认值:true// .enableColumnConstant() // 开启生成字段常量 默认值:false .enableChainModel() // 开启链式模型 默认值:false// .enableLombok() // 开启 lombok 模型 默认值:false .enableRemoveIsPrefix() // 开启 Boolean 类型字段移除 is 前缀 默认值:false .enableTableFieldAnnotation() // 开启生成实体时生成字段注解 默认值:false .enableActiveRecord() // 开启 ActiveRecord 模型 默认值:false .versionColumnName(&quot;version&quot;) // 乐观锁字段名(数据库) .versionPropertyName(&quot;version&quot;) // 乐观锁属性名(实体) .logicDeleteColumnName(&quot;delete_flag&quot;) // 逻辑删除字段名(数据库) .logicDeletePropertyName(&quot;deleteFlag&quot;) // 逻辑删除属性名(实体)// .naming(NamingStrategy.no_change) // 数据库表映射到实体的命名策略 默认下划线转驼峰命名:NamingStrategy.underline_to_camel// .columnNaming(NamingStrategy.underline_to_camel) // 数据库表字段映射到实体的命名策略 默认为 null，未指定按照 naming 执行 .addSuperEntityColumns(&quot;id&quot;, &quot;delete_flag&quot;, &quot;version&quot;, &quot;created_by&quot;, &quot;created_time&quot;, &quot;updated_by&quot;, &quot;updated_time&quot;) // 添加父类公共字段// .addIgnoreColumns(&quot;age&quot;) // 添加忽略字段 .addTableFills(new Column(&quot;create_time&quot;, FieldFill.INSERT)) // 添加表字段填充 .addTableFills(new Property(&quot;updateTime&quot;, FieldFill.INSERT_UPDATE)) // 添加表字段填充 .idType(IdType.ASSIGN_UUID) // 全局主键类型// .formatFileName(&quot;%sEntity&quot;) // 格式化文件名称 .build() // ----------------------------------Controller 策略配置---------------------------------- .controllerBuilder() .superClass(BaseController.class) // 设置父类 .enableHyphenStyle() // 开启驼峰转连字符 .enableRestStyle() // 开启生成@RestController 控制器// .convertFileName() // 转换文件名称 .formatFileName(&quot;%sController&quot;) // 格式化文件名称 .build() // ----------------------------------Service 策略配置---------------------------------- .serviceBuilder() .superServiceClass(BaseService.class) // 设置 service 接口父类 .superServiceImplClass(BaseServiceImpl.class) // 设置 service 实现类父类// .convertServiceFileName() // 转换 service 接口文件名称// .convertServiceImplFileName() // 转换 service 实现类文件名称 .formatServiceFileName(&quot;I%sService&quot;) // 格式化 service 接口文件名称 .formatServiceImplFileName(&quot;%sServiceImpl&quot;) // 格式化 service 实现类文件名称 .build() // ----------------------------------Mapper 策略配置---------------------------------- .mapperBuilder() .superClass(BaseMapper.class) // 设置父类 .enableMapperAnnotation() // 开启 @Mapper 注解 默认值:false .enableBaseResultMap() // 启用 BaseResultMap 生成 .enableBaseColumnList() // 启用 BaseColumnList// .cache(MyMapperCache.class) // 设置缓存实现类// .convertMapperFileName(ConverterFileName) // 转换 mapper 类文件名称// .convertXmlFileName(ConverterFileName) // 转换 xml 文件名称 .formatMapperFileName(&quot;%sMapper&quot;) // 格式化 mapper 文件名称 .formatXmlFileName(&quot;%sXml&quot;) // 格式化 xml 实现类文件名称 .build(); &#125;) // ----------------------------------自定义模版支持(DTO\\VO等)配置---------------------------------- .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; 基础类 最简单的基础类，当然也可以不使用自己的基础类，直接使用MybatisPlus默认的基础类，只需要把配置父类的代码删掉就可以。 但是我建议是使用自己的基础类，这样可以扩展。 BaseController12345678910/** * 基础控制器 * * @className: BaseController * @author: GuoShunFa * @date: 2022/11/10 **/public class BaseController &#123;&#125; BaseEntity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.extension.activerecord.Model;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import java.io.Serializable;import java.util.Date;/** * 基础实体类 * * @className: BaseEntity * @author: GuoShunFa * @date: 2022/11/10 **/@ApiModel(&quot;基础类&quot;)public class BaseEntity&lt;T&gt; extends Model implements Serializable &#123; @ApiModelProperty(&quot;主键id字段&quot;) @TableField(&quot;id&quot;) @TableId private String id; @ApiModelProperty(&quot;乐观锁字段&quot;) @TableField(&quot;version&quot;) private String version; @ApiModelProperty(&quot;逻辑删除字段&quot;) @TableField(&quot;delete_flag&quot;) private String deleteFlag; @ApiModelProperty(&quot;记录创建时间&quot;) @TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT) private Date createTime; @ApiModelProperty(&quot;记录创建人&quot;) @TableField(&quot;create_by&quot;) private String createBy; @ApiModelProperty(&quot;记录修改时间&quot;) @TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE) private Date updateTime; @ApiModelProperty(&quot;记录创建人&quot;) @TableField(&quot;update_by&quot;) private String updateBy; public String getCreateBy() &#123; return createBy; &#125; public void setCreateBy(String createBy) &#123; this.createBy = createBy; &#125; public String getUpdateBy() &#123; return updateBy; &#125; public void setUpdateBy(String updateBy) &#123; this.updateBy = updateBy; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public Date getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(Date updateTime) &#123; this.updateTime = updateTime; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getVersion() &#123; return version; &#125; public void setVersion(String version) &#123; this.version = version; &#125; public String getDeleteFlag() &#123; return deleteFlag; &#125; public void setDeleteFlag(String deleteFlag) &#123; this.deleteFlag = deleteFlag; &#125;&#125; BaseMapper123456789/** * 基础映射类 * * @className: BaseMapper * @author: GuoShunFa * @date: 2022/11/10 **/public interface BaseMapper&lt;T&gt; extends com.baomidou.mybatisplus.core.mapper.BaseMapper&lt;T&gt; &#123;&#125; BaseService1234567891011import com.baomidou.mybatisplus.extension.service.IService;/** * 基础服务接口 * * @className: BaseService * @author: GuoShunFa * @date: 2022/11/10 **/public interface BaseService&lt;T&gt; extends IService &#123;&#125; BaseServiceImpl123456789import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;/** * @className: BaseServiceImpl * @author: GuoShunFa * @date: 2022/11/10 **/public class BaseServiceImpl&lt;M, T&gt; extends ServiceImpl implements BaseService&lt;T&gt; &#123;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://guoshunfa.com/tags/Mybatis/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://guoshunfa.com/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"},{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://guoshunfa.com/tags/MybatisPlus/"}]},{"title":"搭建单体SpringBoot项目 集成Mybatis持久层框架","slug":"软件开发/场景/搭建单体SpringBoot项目/25集成持久层框架/搭建单体SpringBoot项目-集成Mybatis持久层框架","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Mybatis持久层框架/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Mybatis%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Mybatis详细讲解 引入maven12345&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://guoshunfa.com/tags/Mybatis/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://guoshunfa.com/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}]},{"title":"搭建单体SpringBoot项目 集成FreeMarker模板引擎","slug":"软件开发/场景/搭建单体SpringBoot项目/30集成模版引擎/搭建单体SpringBoot项目-集成FreeMarker模板引擎","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成FreeMarker模板引擎/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90FreeMarker%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","excerpt":"","text":"官网 | 中文官网 本文暂不介绍freemarker api，以案例的方式进行介绍。 项目引入freemarker 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt; FreeMarker使用doc模板使用doc模版，将数据引入。 模版示例： 结果示例： 先准备doc模版文件。将需要放入值的属性加上$&#123;&#125;，如：$&#123;aa&#125;。 将准备好的doc文件转换成html文件。 将html文件放入同项目的templates中（如要调整存放文件位置，可以同步把下方工具类里路径也调整了。） 引入下方工具类。 使用工具类。 工具类可以根据个人需求进行调整。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 工具类import com.ruoyi.common.config.RuoYiConfig;import com.ruoyi.common.core.domain.AjaxResult;import freemarker.template.Configuration;import freemarker.template.Template;import java.io.*;import java.util.Map;import java.util.UUID;public class WordUtil &#123; private static Configuration configuration = null; static &#123; configuration = new Configuration(); configuration.setDefaultEncoding(&quot;utf-8&quot;); configuration.setClassForTemplateLoading(WordUtil.class, &quot;/templates&quot;); &#125; private WordUtil() &#123; throw new AssertionError(); &#125; public static AjaxResult exportMillCertificateWord(Map map, String title, String ftlFile) throws IOException &#123; Template freemarkerTemplate = configuration.getTemplate(ftlFile); String fileName = UUID.randomUUID().toString() + &quot;_&quot; + title + &quot;.doc&quot;; String downloadPath = RuoYiConfig.getDownloadPath() + fileName; File desc = new File(downloadPath); if (!desc.getParentFile().exists()) &#123; desc.getParentFile().mkdirs(); &#125; // 调用工具类的createDoc方法生成Word文档 createDoc(map,freemarkerTemplate,downloadPath); return AjaxResult.success(fileName); &#125; private static File createDoc(Map&lt;?, ?&gt; dataMap, Template template, String name) &#123; File f = new File(name); Template t = template; try &#123; // 这个地方不能使用FileWriter因为需要指定编码类型否则生成的Word文档会因为有无法识别的编码而无法打开 Writer w = new OutputStreamWriter(new FileOutputStream(f), &quot;utf-8&quot;); t.process(dataMap, w); w.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); throw new RuntimeException(ex); &#125; return f; &#125;&#125; 12345678// 使用工具类Map map = new HashMap();map.put(&quot;aa&quot;,&quot;张三&quot;);map.put(&quot;bb&quot;,&quot;李四&quot;);map.put(&quot;cc&quot;,&quot;王五&quot;);map.put(&quot;dd&quot;,&quot;赵六&quot;);map.put(&quot;ee&quot;,&quot;孙七&quot;);return WordUtil.exportMillCertificateWord(map,&quot;offer&quot;,&quot;test.html&quot;); 参考文档 java使用freemarker通过模板导出word(基于若依)","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"FreeMarker","slug":"FreeMarker","permalink":"https://guoshunfa.com/tags/FreeMarker/"},{"name":"模版引擎","slug":"模版引擎","permalink":"https://guoshunfa.com/tags/%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"}]},{"title":"搭建单体SpringBoot项目 集成TestNG服务测试框架","slug":"软件开发/场景/搭建单体SpringBoot项目/31集成测试框架/搭建单体SpringBoot项目-集成TestNG服务测试框架","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成TestNG服务测试框架/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90TestNG%E6%9C%8D%E5%8A%A1%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1. maven12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.8.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2. 概念 TestNG按照官方的定义： TestNG是一个测试框架，其灵感来自JUnit和NUnit，但引入了一些新的功能，使其功能更强大，使用更方便。 TestNG是一个开源自动化测试框架;TestNG表示下一代(Next Generation的首字母)。 TestNG类似于JUnit(特别是JUnit 4)，但它不是JUnit框架的扩展。它的灵感来源于JUnit。它的目的是优于JUnit，尤其是在用于测试集成多类时。 TestNG的创始人是Cedric Beust(塞德里克·博伊斯特)。 TestNG消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。 因为它在很大程度上借鉴了Java注解(JDK5.0引入的)来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。 TestNG的特点 注解 TestNG使用Java和面向对象的功能 支持综合类测试(例如，默认情况下，不用创建一个新的测试每个测试方法的类的实例) 独立的编译时测试代码和运行时配置&#x2F;数据信息 灵活的运行时配置 主要介绍“测试组”。当编译测试，只要要求TestNG运行所有的“前端”的测试，或“快”，“慢”，“数据库”等 支持依赖测试方法，并行测试，负载测试，局部故障 灵活的插件API 支持多线程测试 3. TestNG 基本注解3.1. 注解列表以下是TestNG支持的注释列表： 注解 描述 @BeforeSuite 在该套件的所有测试都运行在注释的方法之前，仅运行一次。 @AfterSuite 在该套件的所有测试都运行在注释方法之后，仅运行一次。 @BeforeClass 在调用当前类的第一个测试方法之前运行，注释方法仅运行一次。 @AfterClass 在调用当前类的第一个测试方法之后运行，注释方法仅运行一次 @BeforeTest 注释的方法将在属于&lt;test&gt;标签内的类的所有测试方法运行之前运行。 @AfterTest 注释的方法将在属于&lt;test&gt;标签内的类的所有测试方法运行之后运行。 @BeforeGroups 配置方法将在之前运行组列表。 此方法保证在调用属于这些组中的任何一个的第一个测试方法之前不久运行。 @AfterGroups 此配置方法将在之后运行组列表。该方法保证在调用属于任何这些组的最后一个测试方法之后不久运行。 @BeforeMethod 注释方法将在每个测试方法之前运行。 @AfterMethod 注释方法将在每个测试方法之后运行。 @DataProvider 标记一种方法来提供测试方法的数据。 注释方法必须返回一个Object [] []，其中每个Object []可以被分配给测试方法的参数列表。 要从该DataProvider接收数据的@Test方法需要使用与此注释名称相等的dataProvider名称。 @Factory 将一个方法标记为工厂，返回TestNG将被用作测试类的对象。 该方法必须返回Object []。 @Listeners 定义测试类上的侦听器。 @Parameters 描述如何将参数传递给@Test方法。 @Test 将类或方法标记为测试的一部分。 3.2. 忽略测试 默认enabled为true。默认测试用例是开启状态。 1@Test(enabled = false) 3.3. 超时处理 超时处理，常用来做性能测试，超过时间会报错。单位：毫秒。 1@Test(timeOut = 5000) 3.4. 使用注释&#x2F;注解的好处以下是使用注释&#x2F;注解的一些好处： TestNG通过查找注释&#x2F;注解来识别它感兴趣的方法。 因此，方法名称不限于任何模式或格式。 可以将其他参数传递给注释。 注释是强类型的，所以编译器会马上标记任何错误。 测试类不再需要扩展任何东西(如TestCase，对于JUnit3)。 4. TestNG - DataProvider（注解）数据提供者 测试参数化能让测试大量的数据集变为可能，也大大方便数据的修改和测试脚本的编写，测试参数化让数据和脚本分离开来，方便后续的维护。这一篇先来说说数据提供者DataProvider 数据提供者@DataProvider注解@DataProvider在参数化测试中起到重要的作用，该注解下的函数返回数据类型需要时Object[][]，看例子如何实现： 4.1. 使用@DataProvider函数，需要定义属性name 123456789@DataProvider(name = &quot;testcase&quot;)public Object[][] dataProvider()&#123; return new Object[][]&#123; &#123;&quot;小李&quot;&#125;, &#123;&quot;小赵&quot;&#125;, &#123;&quot;小明&quot;&#125;, &#123;&quot;小周&quot;&#125; &#125;;&#125; 123456// @Test测试用例，属性dataProvider需要指定对应的数据提供者名称@Test(dataProvider = &quot;testcase&quot;)public void testcase(String name)&#123; System.out.println(name);&#125; 执行结果 1234567create test :com.testproj.Demo.TestDataProvider@38bc8ab5[TestNG] Running: E:\\OPPO\\JavaProject\\TestNGProj\\res\\testNG.xml小李小赵小明小周 4.2. 备注4.2.1. 注解使用 DataProvider注解name属性和Test对应dataProvider属性可以进行绑定。 4.2.2. 返回结构Object[][] Object[][]每层都会调用一次测试用例。上面的例子，会调用四次对应的testcase测试用例。 Object[][]一层可以放入多个属性，例： 12345678910111213@DataProvider(name = &quot;testcase&quot;)public Object[][] dataProvider()&#123; return new Object[][]&#123; &#123;&quot;小李&quot;, 19, &quot;男&quot;, 187&#125;, &#123;&quot;小王&quot;, 19, &quot;女&quot;, 167&#125;, &#123;&quot;小组&quot;, 19, &quot;男&quot;, 174&#125;, &#123;&quot;小六&quot;, 19, &quot;男&quot;, 179&#125; &#125;;&#125;@Test(dataProvider = &quot;testcase&quot;)public void testcase(String name, long age, String sex, long height)&#123; System.out.println(&quot;姓名：&quot;+name+&quot;；年龄：&quot;+age+&quot;；性别：&quot;+sex+&quot;；身高：&quot;+height);&#125; Object[][]每层的参数数量和参数类型必须相同。 4.3. 提供数据方式 硬编码在Java源码上。 txt文本文件。 配置文件properties。 excel文档。 数据库。 网络中。","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"TestNG","slug":"TestNG","permalink":"https://guoshunfa.com/tags/TestNG/"},{"name":"测试","slug":"测试","permalink":"https://guoshunfa.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"搭建单体SpringBoot项目 引入Hutool全能工具包","slug":"软件开发/场景/搭建单体SpringBoot项目/60集成工具箱/搭建单体SpringBoot项目-引入Hutool全能工具包","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-引入Hutool全能工具包/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E5%BC%95%E5%85%A5Hutool%E5%85%A8%E8%83%BD%E5%B7%A5%E5%85%B7%E5%8C%85/","excerpt":"","text":"Hutool 官方文档 1. Maven12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.6&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Hutool","slug":"Hutool","permalink":"https://guoshunfa.com/tags/Hutool/"}]},{"title":"搭建单体SpringBoot项目 集成FastJson json数据处理","slug":"软件开发/场景/搭建单体SpringBoot项目/60集成工具箱/搭建单体SpringBoot项目-集成FastJson-json数据处理","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成FastJson-json数据处理/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90FastJson-json%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/","excerpt":"","text":"1. 集成 Fastjson简单使用 通过maven引入相应的json包 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.49&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. fastjson - 自定义序列化 序列化时需要进行特殊处理的类型，可以进行特殊配置。 2.1. 自定义反序列化解析器 - ObjectSerializer123456789101112131415161718192021222324package com.ivan.json.converter;import java.io.IOException;import java.lang.reflect.Type;import com.alibaba.fastjson.serializer.JSONSerializer;import com.alibaba.fastjson.serializer.ObjectSerializer;public class SexSerializer implements ObjectSerializer &#123; public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException &#123; /** * 处理过程 */ // text为处理结果 serializer.write(text); &#125;&#125; 2.2. 使用解析器有三种方法，按情况决定使用哪种。 定义的字段上加解析器注解 123456@Setter@Getterprivate static class ResultData &#123; @JSONField(serializeUsing = SexSerializer.class) private Sex sex;&#125; 框架统一配置，序列化时会根据类型进行匹配。 在WebAppConfigurer#configureMessageConverters中加入。 1SerializeConfig.getGlobalInstance().put(AlarmString.class,AlarmStringSerializer.instance); 系列化时使用。 123SerializeConfig config = new SerializeConfig();config.put(AlarmString.class,AlarmStringSerializer.instance);String jsonStr = JSON.toJsonString(alarm, config); 2.3. 序列化相关的概念 SerializeConfig：内部是个map容器主要功能是配置并记录每种Java类型对应的序列化类。 SerializeWriter 继承自Java的Writer，其实就是个转为FastJSON而生的StringBuilder，完成高性能的字符串拼接。 SerializeFilter: 用于对对象的序列化实现各种定制化的需求。 SerializerFeature：对于对输出的json做各种格式化的需求。 JSONSerializer：相当于一个序列化组合器，集成了SerializeConfig， SerializeWriter ， SerializeFilter与SerializerFeature。 序列化的入口代码如下，上面提到的各种概念都包含了 1234567891011121314151617181920212223242526272829public static String toJSONString(Object object, // SerializeConfig config, // SerializeFilter[] filters, // String dateFormat, // int defaultFeatures, // SerializerFeature... features) &#123; SerializeWriter out = new SerializeWriter(null, defaultFeatures, features); try &#123; JSONSerializer serializer = new JSONSerializer(out, config); if (dateFormat != null &amp;&amp; dateFormat.length() != 0) &#123; serializer.setDateFormat(dateFormat); serializer.config(SerializerFeature.WriteDateUseDateFormat, true); &#125; if (filters != null) &#123; for (SerializeFilter filter : filters) &#123; serializer.addFilter(filter); &#125; &#125; serializer.write(object); return out.toString(); &#125; finally &#123; out.close(); &#125;&#125; 3. fastjson - 自定义反序列化 反序列化时需要进行特殊处理的类型，可以进行特殊配置。 3.1. 自定义反序列化解析器 - ObjectDeserializer12345678910111213141516171819public class PersonDeserializer implements ObjectDeserializer &#123; @Override public Person deserialze(DefaultJSONParser parser, Type type, Object fieldName) &#123; /* * 处理过程 */ // 处理之后的返回结果 return null; &#125; @Override public int getFastMatchToken() &#123; return 0; &#125;&#125; 3.2. 使用解析器有三种方法，按情况决定使用哪种。 定义的字段上加解析器注解 123456@Setter@Getterprivate static class ResultData &#123; @JSONField(deserializeUsing = PersonDeserializer.class) private Person personInfo;&#125; 框架统一配置，反序列化时会根据类型进行匹配。 在WebAppConfigurer#configureMessageConverters中加入。 1ParserConfig.getGlobalInstance().putDeserializer(AlarmString.class,AlarmStringDeserializer.instance); 反系列化时使用。 123ParserConfig parserConfig = new ParserConfig();parserConfig.putDeserializer(AlarmString.class, AlarmStringDeserializer.instance);Alarm alarm = JSON.parseObject(jsonStr, Alarm.class, parserConfig); 3.2.1. 反序列化相关的概念 ParserConfig：内部通过一个map保存各种ObjectDeserializer。 JSONLexer : 与SerializeWriter相对应，用于解析json字符串。 JSONToken：定义了一系统的特殊字符，这些称为token。 ParseProcess ：定制反序列化，类似于SerializeFilter。 Feature：用于定制各种反序列化的特性。 DefaultJSONParser：相当于反序列化组合器，集成了ParserConfig，Feature， JSONLexer 与ParseProcess。 反序列化的入口代码如下，上面的概念基本都包含了： 12345678910111213141516171819202122232425262728293031323334353637@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; T parseObject(String input, Type clazz, ParserConfig config, ParseProcess processor, int featureValues, Feature... features) &#123; if (input == null) &#123; return null; &#125; if (features != null) &#123; for (Feature feature : features) &#123; featureValues |= feature.mask; &#125; &#125; DefaultJSONParser parser = new DefaultJSONParser(input, config, featureValues); if (processor != null) &#123; if (processor instanceof ExtraTypeProvider) &#123; parser.getExtraTypeProviders().add((ExtraTypeProvider) processor); &#125; if (processor instanceof ExtraProcessor) &#123; parser.getExtraProcessors().add((ExtraProcessor) processor); &#125; if (processor instanceof FieldTypeResolver) &#123; parser.setFieldTypeResolver((FieldTypeResolver) processor); &#125; &#125; T value = (T) parser.parseObject(clazz, null); parser.handleResovleTask(value); parser.close(); return (T) value;&#125; 4. JSONField与JSONType注解的使用4.1. @JSONField​ fastjson提供了JSONField对序列化与反序列化进行定制，比如可以指定字段的名称，序列化的顺序。JSONField用于属性，方法方法参数上。JSONField的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.alibaba.fastjson.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.serializer.SerializerFeature;@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER &#125;)public @interface JSONField &#123;// 配置序列化和反序列化的顺序 int ordinal() default 0;// 指定字段的名称 String name() default &quot;&quot;;// 指定字段的格式，对日期格式有用 String format() default &quot;&quot;; // 是否序列化 boolean serialize() default true;// 是否反序列化 boolean deserialize() default true;//字段级别的SerializerFeature SerializerFeature[] serialzeFeatures() default &#123;&#125;;// Feature[] parseFeatures() default &#123;&#125;; //给属性打上标签， 相当于给属性进行了分组 String label() default &quot;&quot;; boolean jsonDirect() default false; //制定属性的序列化类 Class&lt;?&gt; serializeUsing() default Void.class; //制定属性的反序列化类 Class&lt;?&gt; deserializeUsing() default Void.class; String[] alternateNames() default &#123;&#125;; boolean unwrapped() default false;&#125; 4.2. @JSONType​ fastjosn提供了JSONType用于类级别的定制化, JSONType的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.alibaba.fastjson.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import com.alibaba.fastjson.PropertyNamingStrategy;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.serializer.SerializeFilter;import com.alibaba.fastjson.serializer.SerializerFeature;@Retention(RetentionPolicy.RUNTIME)//需要标注在类上@Target(&#123; ElementType.TYPE &#125;)public @interface JSONType &#123; boolean asm() default true;//这里可以定义输出json的字段顺序 String[] orders() default &#123;&#125;;//包含的字段 String[] includes() default &#123;&#125;;//不包含的字段 String[] ignores() default &#123;&#125;;//类级别的序列化特性定义 SerializerFeature[] serialzeFeatures() default &#123;&#125;; Feature[] parseFeatures() default &#123;&#125;; //按字母顺序进行输出 boolean alphabetic() default true; Class&lt;?&gt; mappingTo() default Void.class; Class&lt;?&gt; builder() default Void.class; String typeName() default &quot;&quot;; String typeKey() default &quot;&quot;; Class&lt;?&gt;[] seeAlso() default&#123;&#125;; //序列化类 Class&lt;?&gt; serializer() default Void.class; //反序列化类 Class&lt;?&gt; deserializer() default Void.class; boolean serializeEnumAsJavaBean() default false; PropertyNamingStrategy naming() default PropertyNamingStrategy.CamelCase; Class&lt;? extends SerializeFilter&gt;[] serialzeFilters() default &#123;&#125;;&#125; 5. SerializeFilter​ fastjson通过SerializeFilter编程扩展的方式定制序列化fastjson支持以下SerializeFilter用于不同常景的定制序列化： PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化,接口定义如下： 12345678910111213141516package com.alibaba.fastjson.serializer;/** * @author wenshao[szujobs@hotmail.com] */public interface PropertyFilter extends SerializeFilter &#123; /** * @param object the owner of the property * @param name the name of the property * @param value the value of the property * @return true if the property will be included, false if to be filtered out * 根据 属性的name与value判断是否进行序列化 */ boolean apply(Object object, String name, Object value);&#125; PropertyPreFilter根据PropertyName判断是否序列化 1234567package com.alibaba.fastjson.serializer;public interface PropertyPreFilter extends SerializeFilter &#123;//根据 object与name判断是否进行序列化 boolean apply(JSONSerializer serializer, Object object, String name);&#125; NameFilter 序列化时修改Key 123456package com.alibaba.fastjson.serializer;public interface NameFilter extends SerializeFilter &#123;//根据 name与value的值，返回json字段key的值 String process(Object object, String name, Object value);&#125; ValueFilter 序列化时修改Value 123456package com.alibaba.fastjson.serializer;public interface ValueFilter extends SerializeFilter &#123; //根据name与value定制输出json的value Object process(Object object, String name, Object value);&#125; BeforeFilter 在序列化对象的所有属性之前执行某些操作 12345678910111213141516171819202122232425262728package com.alibaba.fastjson.serializer;public abstract class BeforeFilter implements SerializeFilter &#123; private static final ThreadLocal&lt;JSONSerializer&gt; serializerLocal = new ThreadLocal&lt;JSONSerializer&gt;(); private static final ThreadLocal&lt;Character&gt; seperatorLocal = new ThreadLocal&lt;Character&gt;(); private final static Character COMMA = Character.valueOf(&#x27;,&#x27;); final char writeBefore(JSONSerializer serializer, Object object, char seperator) &#123; serializerLocal.set(serializer); seperatorLocal.set(seperator); writeBefore(object); serializerLocal.set(null); return seperatorLocal.get(); &#125; protected final void writeKeyValue(String key, Object value) &#123; JSONSerializer serializer = serializerLocal.get(); char seperator = seperatorLocal.get(); serializer.writeKeyValue(seperator, key, value); if (seperator != &#x27;,&#x27;) &#123; seperatorLocal.set(COMMA); &#125; &#125;//需要实现的方法，在实际实现中可以调用writeKeyValue增加json的内容 public abstract void writeBefore(Object object);&#125; AfterFilter 在序列化对象的所有属性之后执行某些操作 12345678910111213141516171819202122232425262728293031package com.alibaba.fastjson.serializer;/** * @since 1.1.35 */public abstract class AfterFilter implements SerializeFilter &#123; private static final ThreadLocal&lt;JSONSerializer&gt; serializerLocal = new ThreadLocal&lt;JSONSerializer&gt;(); private static final ThreadLocal&lt;Character&gt; seperatorLocal = new ThreadLocal&lt;Character&gt;(); private final static Character COMMA = Character.valueOf(&#x27;,&#x27;); final char writeAfter(JSONSerializer serializer, Object object, char seperator) &#123; serializerLocal.set(serializer); seperatorLocal.set(seperator); writeAfter(object); serializerLocal.set(null); return seperatorLocal.get(); &#125; protected final void writeKeyValue(String key, Object value) &#123; JSONSerializer serializer = serializerLocal.get(); char seperator = seperatorLocal.get(); serializer.writeKeyValue(seperator, key, value); if (seperator != &#x27;,&#x27;) &#123; seperatorLocal.set(COMMA); &#125; &#125;//子类需要实现的方法，实际使用的时候可以调用writeKeyValue增加内容 public abstract void writeAfter(Object object);&#125; LabelFilter根据 JsonField配置的label来判断是否进行输出 123456package com.alibaba.fastjson.serializer;//根据 JsonField配置的label来判断是否进行输出public interface LabelFilter extends SerializeFilter &#123; boolean apply(String label);&#125; 6. Fastjson - SerializerFeature特性的使用fastjson通过SerializerFeature对生成的json格式的数据进行一些定制，比如可以输入的格式更好看，使用单引号而非双引号等。例子程序如下： 1234567891011121314151617181920package com.ivan.json;import java.util.Date;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.ivan.json.entity.User;public class SerializerFeatureTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setId(11L); user.setCreateTime(new Date()); String jsonString = JSON.toJSONString(user, SerializerFeature.PrettyFormat, SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.UseSingleQuotes); System.out.println(jsonString); &#125;&#125; ​ 输出的结果如下： 12345&#123; &#x27;createTime&#x27;:&#x27;2021-06-23 15:17:48&#x27;, &#x27;id&#x27;: 123 &#x27;name&#x27;: &#x27;&#x27;&#125; SerializerFeature常用属性 名称 含义 QuoteFieldNames 输出key时是否使用双引号,默认为true UseSingleQuotes 使用单引号而不是双引号,默认为false WriteMapNullValue 是否输出值为null的字段,默认为false WriteEnumUsingToString Enum输出name()或者original,默认为false UseISO8601DateFormat Date使用ISO8601格式输出，默认为false WriteNullListAsEmpty List字段如果为null,输出为[],而非null WriteNullStringAsEmpty 字符类型字段如果为null,输出为”“,而非null WriteNullNumberAsZero 数值字段如果为null,输出为0,而非null WriteNullBooleanAsFalse Boolean字段如果为null,输出为false,而非null SkipTransientField 如果是true，类中的Get方法对应的Field是transient，序列化时将会被忽略。默认为true SortField 按字段名称排序后输出。默认为false WriteTabAsSpecial 把\\t做转义输出，默认为false不推荐设为true PrettyFormat 结果是否格式化,默认为false WriteClassName 序列化时写入类型信息，默认为false。反序列化是需用到 DisableCircularReferenceDetect 消除对同一对象循环引用的问题，默认为false WriteSlashAsSpecial 对斜杠’&#x2F;’进行转义 BrowserCompatible 将中文都会序列化为\\uXXXX格式，字节数会多一些，但是能兼容IE 6，默认为false WriteDateUseDateFormat 全局修改日期格式,默认为false。 DisableCheckSpecialChar 一个对象的字符串属性中如果有特殊字符如双引号，将会在转成json时带有反斜杠转移符。如果不需要转义，可以使用这个属性。默认为false BeanToArray 将对象转为array输出","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"FastJson","slug":"FastJson","permalink":"https://guoshunfa.com/tags/FastJson/"},{"name":"Json","slug":"Json","permalink":"https://guoshunfa.com/tags/Json/"}]},{"title":"搭建单体SpringBoot项目 集成Profile项目环境管理","slug":"软件开发/场景/搭建单体SpringBoot项目/70项目环境管理配置/搭建单体SpringBoot项目-集成Profile项目环境管理","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Profile项目环境管理/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Profile%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/","excerpt":"","text":"项目多环境管理 1. Spring ProfileSpring Profile 是 Spring 提供的多环境管理方案。 如图，每种环境都对应一个 properties 文件，然后在application.properties中配置一下要使用的环境 1spring.profiles.active=dev 上面配置匹配的是 application-dev.properties,如果写的是test，则匹配 application-test.properties。也就是说，Spring Profile 对配置文件的命名有要求，必须是 application- 开头 除了配置环境外，一些不随环境而变化的配置也应该放到 application.properties中，application-.properties最好只存放与环境相关的配置项以上就是 Spring Profile 给出的多环境管理方案。 通过改变 spring.profiles.active的值来切换不同的环境。 这种方法简单易懂，但有两个问题。 每次切换环境要手动修改 spring.profiles.active 的值 打包的时候，要手动删除其它环境的配置文件，不然其它环境的敏感信息就都打包进去了 2. maven profilemaven 的 profile 可以让我们定义多套配置信息，并指定其激活条件，然后在不同的环境下使用不同的profile配置。 2.1. profile 的定义位置在maven中有两个地方可以配置 profile pom.xml中：这里面定义的 profile 作用范围是当前项目{user}&#x2F;.m2&#x2F;settings.xml中：这里面定义的 profile 作用范围是所有使用了该配置文件的项目 2.2. settings.xml中的 profile不同的地方 profile 中能定义的信息也不相同 由于settings.xml作用范围宽泛， profile 中只能定义一些公共信息，如下 1234567891011121314&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;... &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;...&lt;/id&gt; &lt;activation&gt;...&lt;/activation&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt;...&lt;/settings&gt; id：该 profile 的唯一标识activation：在哪些情况下激活 profile,这里面有多种策略可供选择,只要满足其中一个条件就激活repositories：远程仓库 由于能配置的东西有限，一般都会将 maven profile 配置在pom.xml 2.3. pom.xml中 的profile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.panda&lt;/groupId&gt; &lt;artifactId&gt;test-mongodb&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;test-mongodb&lt;/name&gt; &lt;description&gt;test-mongodb&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;build&gt; &lt;filters&gt; &lt;!-- 指定使用的 filter,会在每个module中使用，所以文件目录需要指向到顶层，否则会在每个module中查找文件 --&gt; &lt;!-- 文件按顺序加载，后面的相同key覆盖前面的，base用于默认配置 --&gt; &lt;filter&gt;profile/base.pro&lt;/filter&gt; &lt;filter&gt;profile/$&#123;env&#125;.pro&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;defaultGoal&gt;clean compile package deploy&lt;/defaultGoal&gt; &lt;/build&gt; &lt;profiles&gt; &lt;!-- 开发环境 --&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- 测试环境 --&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;env&gt;test&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt; 2.4. 按环境打包12# -P 环境mvn clean package -P test","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Profile","slug":"Profile","permalink":"https://guoshunfa.com/tags/Profile/"}]},{"title":"搭建单体SpringBoot项目 集成Jsoup爬虫","slug":"软件开发/场景/搭建单体SpringBoot项目/99其他/搭建单体SpringBoot项目-集成Jsoup爬虫","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/搭建单体SpringBoot项目-集成Jsoup爬虫/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE-%E9%9B%86%E6%88%90Jsoup%E7%88%AC%E8%99%AB/","excerpt":"","text":"1. maven12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt;&lt;/dependency&gt; 2. demo12345678910111213141516public static void main(String[] args) throws IOException &#123; String url = &quot;https://www.baidu.com/s?wd=a&amp;rsv_spt=1&amp;rsv_iqid=0xf26984b00030eeb8&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=1&amp;rsv_sug1=1&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=995&amp;rsv_sug4=995&quot;; Document document = Jsoup.parse(new URL(url), 100000); Element elementByClass = document.getElementsByClass(&quot;c-table opr-toplist1-table&quot;).get(0); Elements trElements = elementByClass.getElementsByTag(&quot;tr&quot;); for (Element trElement : trElements) &#123; Elements tdElements = trElement.getElementsByTag(&quot;td&quot;); String index = tdElements.get(0).getElementsByTag(&quot;span&quot;).get(0).text(); String note = tdElements.get(0).getElementsByTag(&quot;a&quot;).get(0).text(); String num = tdElements.get(1).text(); System.out.println(index + &quot;---&quot; + note + &quot;---&quot; + num); &#125; System.out.println();&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"Jsoup","slug":"Jsoup","permalink":"https://guoshunfa.com/tags/Jsoup/"},{"name":"爬虫","slug":"爬虫","permalink":"https://guoshunfa.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Arthas 介绍","slug":"软件开发/技术/服务&组件/arthas/Arthas-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Arthas-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Arthas-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Arthas 介绍Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://guoshunfa.com/tags/Arthas/"}]},{"title":"Git 命令记录","slug":"软件开发/技术/服务&组件/git/Git-命令记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Git-命令记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Git-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","excerpt":"","text":"git clone http://userName:password@链接 1. Git更换远程仓库地址123456#查看远端地址git remote -v#查看远端仓库名git remote git remote set-url origin https://gitee.com/xx/xx.git (新地址) 2. Git提交&#x2F;拉取代码2.1. 拉取代码1234# 拉取当前分支的代码git pull# 拉取dev分支的代码（origin后衔接指定分支）git pull origin dev 2.2. 查看代码调整情况1git status 具体状态如下： Untracked: 未跟踪,一般为新增文件，此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. deleted： 文件已删除，本地删除，服务器上还没有删除. renamed： 2.3. 将状态改变的代码提交至缓存12345678# 将所有的修改的文件提交到缓存区git add .# 将指定修改的文件提交到缓存区git add 文件# 将目录下所有修改过的被跟踪代码提交到缓存区git add -u 目录# 将目录下所有修改过的未被跟踪的代码提交到缓存区git add -A 目录 2.4. 将代码提交到本地仓库中12# -m 标注提交信息git commit -m &quot;修改项目代码&quot; 2.5. 将缓存区代码推送到远程仓库1234# 推送到当前分支git push# 推送到dev分支（origin后衔接指定分支）git push origin dev 3. Git切换分支3.1. 查看远程分支1git branch -a 例子： 1234567~/panda$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/master remotes/origin/nnvm remotes/origin/piiswrong-patch-1 remotes/origin/v0.9rc1 3.2. 查看本地分支12~/panda$ git branch* master 3.3. 切换分支12345678910111213$ git checkout -b dev origin/devBranch dev set up to track remote branch v0.9rc1 from origin.Switched to a new branch &#x27;dev&#x27;＃已经切换到dev分支了$ git branch master* dev＃切换回master分支$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is up-to-date with &#x27;origin/master&#x27;. 命令行指引您还可以按照以下说明从计算机中上传现有文件。 Git 全局设置12git config --global user.name &quot;panda&quot;git config --global user.email &quot;pandacode_cn@163.com&quot; 创建一个新仓库1234567git clone http://8.141.66.12:8099/pandacode/panda-doc.gitcd panda-docgit switch -c maintouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin main 推送现有文件夹123456cd existing_foldergit init --initial-branch=maingit remote add origin http://8.141.66.12:8099/pandacode/panda-doc.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin main 推送现有的 Git 仓库1234cd existing_repogit remote rename origin old-origingit remote add origin http://8.141.66.12:8099/pandacode/panda-doc.gitgit push -u origin --all 参考文档 git命令－切换分支 Git | 利用 git 命令行提交代码步骤","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://guoshunfa.com/tags/Git/"}]},{"title":"Git 错误记录","slug":"软件开发/技术/服务&组件/git/Git-错误记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Git-错误记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Git-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"host key for (ip地址) has changed and you have requested strict checking.ssh\\known_hosts 文件删掉就好了 参考文档 https://blog.csdn.net/cssxn/article/details/105952399","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://guoshunfa.com/tags/Git/"}]},{"title":"Gitlab Docker方式部署","slug":"软件开发/技术/服务&组件/git/Gitlab-Docker方式部署","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Gitlab-Docker方式部署/","link":"","permalink":"https://guoshunfa.com/2022/07/Gitlab-Docker%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/","excerpt":"","text":"转发自：使用Docker部署GitLab｜8月更文挑战 1. docker拉取gitlab社区版1docker pull gitlab/gitlab-ce:latest 查看是否拉取成功 123[root@test gitlab] docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgitlab/gitlab-ce latest 75d591b81fd7 4 days ago 2.23GB 2. 使用容器卷将数据映射到本地并运行 宿主机位置 容器位置 作用 &#x2F;usr&#x2F;local&#x2F;gitlab&#x2F;config &#x2F;etc&#x2F;gitlab 用于存储 GitLab 配置文件 &#x2F;usr&#x2F;local&#x2F;gitlab&#x2F;logs &#x2F;var&#x2F;log&#x2F;gitlab 用于存储日志 &#x2F;usr&#x2F;local&#x2F;gitlab&#x2F;data &#x2F;var&#x2F;opt&#x2F;gitlab 用于存储应用数据 2.1. 在宿主机创建映射目录123456[root@test ~] mkdir -p /usr/local/gitlab/config #递归创建目录，即使上级目录不存在，会按目录层级自动创建目录[root@test ~] mkdir -p /usr/local/gitlab/logs[root@test ~] mkdir -p /usr/local/gitlab/data[root@test ~] cd /usr/local/gitlab[root@test gitlab] lsconfig data logs 3. 创建方法3.1 创建方法一3.1.1. 创建gitlab_start.sh文件12[root@test gitlab] touch gitlab_start.sh[root@test gitlab] vim gitlab_start.sh 编写内容 1234567891011#!/bin/shGITLAB_HOME=/usr/local/gitlabsudo docker run --detach \\ --hostname 你的服务ip \\ --publish 443:443 --publish 8090:80 --publish 10080:22 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab \\ --volume $GITLAB_HOME/logs:/var/log/gitlab \\ --volume $GITLAB_HOME/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 参数说明： –detach: 设置容器后台运行–hostname: 设置容器的 hostname,如果是本地localhost ，否则使用外网ip–publish: 端口转发规则（80：Http 访问端口，443：Https 访问端口，10080：主机的 ssh 访问端口，22：Docker 容器中 ssh 访问端口）–name：容器名称–restart always：每次启动容器就重启GitLab–volume: 共享目录挂载，即 docker 容器内外数据共享–e：配置 Gitlab 运行的环境变量 在该文件目录下,授予gitlab_start.sh执行权限 12chmod +x gitlab_start.sh ./gitlab_start.sh #执行脚本 3.1.2. 可能遇到的错误123[root@test gitlab] ./gitlab_start.sh000dc7b1b6e35d94171be203c49ef7a57a1ffb8ea76c72b6765cbed9b5de347bdocker: Error response from daemon: driver failed programming external connectivity on endpoint gitlab (757b5ee12c5202b00ff312c9a927621ebb63e3e5272c827ba36baf19614ee7d7): Error starting userland proxy: listen tcp4 0.0.0.0:80: bind: address already in use. 要注意端口是否被占用 123[root@test gitlab] netstat -ntulp | grep 8090 #查看所有80端口使用情况tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 13389/nginx: mastertcp6 0 0 :::8080 :::* LISTEN 5233/oracle-java 修改gitlab_start.sh文件,将映射到宿主机的端口改为8088，或者其它没被占用的端口 1--publish 443:443 --publish 8088:80 --publish 10080:22 \\ 重新运行./gitlab_start.sh文件，报错如下 123[root@test gitlab] ./gitlab_start.shdocker: Error response from daemon: Conflict. The container name &quot;/gitlab&quot; is already in use by container &quot;000dc7b1b6e35d94171be203c49ef7a57a1ffb8ea76c72b6765cbed9b5de347b&quot;. You have to remove (or rename) that container to be able to reuse that name.See &#x27;docker run --help&#x27;. 这是因为之前的容器虽然没有运行起来，但是已经创建了，把它删除掉 1234567[root@test gitlab] docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES000dc7b1b6e3 gitlab/gitlab-ce:latest &quot;/assets/wrapper&quot; 7 minutes ago Created gitlab[root@test gitlab] docker rm 000d000d[root@test gitlab] docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 重新运行gitlab_start.sh文件 12345[root@test gitlab] ./gitlab_start.sh70b9da8332b287b9c154988e03eb6b92ba6c360f985d704b1b703367ffe30732[root@test gitlab] docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES70b9da8332b2 gitlab/gitlab-ce:latest &quot;/assets/wrapper&quot; 4 seconds ago Up 3 seconds (health: starting) 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp, 0.0.0.0:10080-&gt;22/tcp, :::10080-&gt;22/tcp, 0.0.0.0:8088-&gt;80/tcp, :::8088-&gt;80/tcp gitlab 可以看到容器成功启动 3.2创建方法二创建docker-compose.yml文件，并在该文件所在的文件夹目录下运行docker-compose up -d需要事先安装docker-compose安装docker-compose 123456789101112131415161718192021version: &#x27;2&#x27;services: gitlab: image: &#x27;gitlab/gitlab-ce:latest&#x27; container_name: &quot;gitlab&quot; restart: always hostname: &#x27;39.105.15.40&#x27; environment: TZ: &#x27;Asia/Shanghai&#x27; GITLAB_OMNIBUS_CONFIG: | external_url &#x27;http://39.105.15.40:8088&#x27; gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 10080 gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27; ports: - &#x27;8088:8088&#x27; - &#x27;10080:22&#x27; - &#x27;443:443&#x27; volumes: - /usr/local/gitlab/config:/etc/gitlab - /usr/local/gitlab/logs:/var/log/gitlab - /usr/local/gitlab/data:/var/opt/gitlab 注：端口和映射目录可根据需要修改 若开放访问端口为80，external_url可不加端口号，默认80 4. 修改gitlab配置文件（方法一需要）若以3.1方法创建，需要修改相关配置文件 12345678910vim /usr/local/gitlab/config/gitlab.rb# 改SSH端口为10080，以便不和宿主机22端口冲突gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 10080# 配置外部访问地址# 旧版本 # external_url &#x27;ip地址&#x27; # 新版本 external_url &#x27;http://ip地址&#x27; 4.1 应用配置，重启服务在Gitlab容器运行状态时，重启服务，并远程访问网站测试 12345678# 进入gitlab bashdocker exec -it gitlab bash # 重新应用gitlab的配置gitlab-ctl reconfigure# 重启gitlab服务gitlab-ctl restart# 查看gitlab运行状态gitlab-ctl status 若访问Gitlab出现502等错误，使用命令检查错误原因 1gitlab-rake gitlab:check e.g. 12345Try fixing it: Make sure GitLab is running; Check the gitlab-shell configuration file: sudo -u git -H editor /opt/gitlab/embedded/service/gitlab-shell/config.yml Please fix the error above and rerun the checks. 查看上述配置文件，查找错误原因 访问GitLab失败错误虽然容器启动成功，但是却没办法根据ip:port访问gitlab 启动一个tomcat容器测试端口拉取tomcat镜像 1docker pull tomcat:jdk8-openjdk 为了测试8088端口是否可用，先把gitlab的容器暂停 1docker stop gitlab 启动tomcat容器，并将tomcat容器的8080端口映射到宿主机的8088端口 12345678910[root@test ~] docker run -d --name tomcat -p 8088:8080 tomcat:jdk8-openjdkaa29b816196ae32f12915a74e447f01bedae64cd200aaa5cab0dedcc383710f7[root@test ~] docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESaa29b816196a tomcat:jdk8-openjdk &quot;catalina.sh run&quot; 3 seconds ago Up 3 seconds 0.0.0.0:8088-&gt;8080/tcp, :::8088-&gt;8080/tcp tomcat[root@test ~] lsof -i:8088COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 2257 root 4u IPv4 2690446 0t0 TCP *:radan-http (LISTEN)docker-pr 2262 root 4u IPv6 2689770 0t0 TCP *:radan-http (LISTEN) 一切正常，访问ip:8088，还是和以前一样访问不了 开启防火墙并打开端口因为之前系统的防火墙一直是关闭的并且其它的服务能正常访问，所以没有怀疑是防火墙的问题 1234[root@test ~] firewall-cmd --statenot running[root@test ~] firewall-cmd --permanent --add-port=8088/tcpFirewallD is not running 把防火墙打开 1[root@test ~] systemctl start firewalld.service 访问之前能正常访问的服务，果然没法正常访问。 把该服务的端口开发，正常访问。 打开8088端口 1234[root@test ~] firewall-cmd --permanent --add-port=8088/tcpsuccess[root@test ~] firewall-cmd --reloadsuccess 再次访问 返回tomcat的404页面：HTTP Status 404 – Not Found 虽然是404页面，但是说明此时的端口是能正常访问的 再次启动gitlab服务把tomcat的容器停止运行，重新运行gitlab容器 12345678[root@test ~] docker stop tomcattomcat[root@test ~] docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@test ~] docker start gitlabError response from daemon: driver failed programming external connectivity on endpoint gitlab (1d8b474e20fe113724f1c429c75b6ac3ece200e9c0beacb980907c15470c7d3e): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 10080 -j DNAT --to-destination 172.18.0.2:22 ! -i br-12aa369ee4a6: iptables: No chain/target/match by that name. (exit status 1))Error: failed to start containers: gitlab 虽然没启动成功，但离成功更进一步了:) 尝试把这个容器删除掉，再创建一次后还是得到这个错误。 123456[root@test gitlab] systemctl restart docker[root@test gitlab] docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@test gitlab] docker-compose up -dStarting gitlab ... done[root@test gitlab] 还是访问不了，检查一下GitLab内部是否有问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990[root@test gitlab] docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7528489258e0 gitlab/gitlab-ce:latest &quot;/assets/wrapper&quot; 18 minutes ago Up 2 minutes (healthy) 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp, 80/tcp, 0.0.0.0:8088-&gt;8088/tcp, :::8088-&gt;8088/tcp, 0.0.0.0:10080-&gt;22/tcp, :::10080-&gt;22/tcp gitlab[root@test gitlab] docker exec -it gitlab bashroot@8:/ gitlab-ctl statusrun: alertmanager: (pid 769) 250s; run: log: (pid 621) 281srun: gitaly: (pid 281) 339s; run: log: (pid 316) 337srun: gitlab-exporter: (pid 746) 251s; run: log: (pid 564) 302srun: gitlab-workhorse: (pid 737) 251s; run: log: (pid 525) 314srun: grafana: (pid 784) 249s; run: log: (pid 677) 270srun: logrotate: (pid 253) 351s; run: log: (pid 261) 350srun: nginx: (pid 539) 309s; run: log: (pid 548) 308srun: postgres-exporter: (pid 777) 249s; run: log: (pid 636) 278srun: postgresql: (pid 396) 333s; run: log: (pid 484) 330srun: prometheus: (pid 759) 250s; run: log: (pid 607) 288srun: puma: (pid 487) 327s; run: log: (pid 495) 324srun: redis: (pid 265) 345s; run: log: (pid 273) 344srun: redis-exporter: (pid 748) 251s; run: log: (pid 587) 294srun: sidekiq: (pid 500) 321s; run: log: (pid 511) 318srun: sshd: (pid 31) 361s; run: log: (pid 30) 361sroot@8:/ gitlab-rake gitlab:checkChecking GitLab subtasks ...Checking GitLab Shell ...GitLab Shell: ... GitLab Shell version &gt;= 13.19.0 ? ... OK (13.19.0)Running /opt/gitlab/embedded/service/gitlab-shell/bin/checkInternal API available: OKRedis available via internal API: OKgitlab-shell self-check successfulChecking GitLab Shell ... FinishedChecking Gitaly ...Gitaly: ... default ... OKChecking Gitaly ... FinishedChecking Sidekiq ...Sidekiq: ... Running? ... yesNumber of Sidekiq processes (cluster/worker) ... 1/1Checking Sidekiq ... FinishedChecking Incoming Email ...Incoming Email: ... Reply by email is disabled in config/gitlab.ymlChecking Incoming Email ... FinishedChecking LDAP ...LDAP: ... LDAP is disabled in config/gitlab.ymlChecking LDAP ... FinishedChecking GitLab App ...Git configured correctly? ... yesDatabase config exists? ... yesAll migrations up? ... yesDatabase contains orphaned GroupMembers? ... noGitLab config exists? ... yesGitLab config up to date? ... yesLog directory writable? ... yesTmp directory writable? ... yesUploads directory exists? ... yesUploads directory has correct permissions? ... yesUploads directory tmp has correct permissions? ... skipped (no tmp uploads folder yet)Init script exists? ... skipped (omnibus-gitlab has no init script)Init script up-to-date? ... skipped (omnibus-gitlab has no init script)Projects have namespace: ...GitLab Instance / Monitoring ... yesRedis version &gt;= 5.0.0? ... yesRuby version &gt;= 2.7.2 ? ... yes (2.7.2)Git version &gt;= 2.31.0 ? ... yes (2.32.0)Git user has default SSH configuration? ... yesActive users: ... 1Is authorized keys file accessible? ... yesGitLab configured to store new projects in hashed storage? ... yesAll projects are in hashed storage? ... yesChecking GitLab App ... FinishedChecking GitLab subtasks ... Finished 一切正常 我再次换成tomcat容器进行测试，发现8088端口访问不了了。 但是在宿主机内ping本机是可以的 12[root@test tomcat] curl localhost:8088&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;HTTP Status 404 – Not Found&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;font-family:Tahoma,Arial,sans-serif;&#125; h1, h2, h3, b &#123;color:white;background-color:#525D76;&#125; h1 &#123;font-size:22px;&#125; h2 &#123;font-size:16px;&#125; h3 &#123;font-size:14px;&#125; p &#123;font-size:12px;&#125; a &#123;color:black;&#125; .line &#123;height:1px;background-color:#525D76;border:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HTTP Status 404 – Not Found&lt;/h1&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.&lt;/p&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;h3&gt;Apache Tomcat/9.0.50&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 但是，换成ip:8088则不行 问题转移：为什么访问不了容器内的服务 参考 解决Docker端口映射无法访问问题 阿里云 ECS 的Docker为什么无法端口映射? 根据以上两篇文章，提出阿里云的内网eth0 网段正好跟Docker 的虚拟网卡都是 172 网段,有冲突 观察发现我使用的云服务器也是阿里云，并且通过ifconfig查看 1234567891011121314151617181920212223242526[root@test config] ifconfigbr-12aa369ee4a6: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.18.0.1 netmask 255.255.0.0 broadcast 172.18.255.255 inet6 fe80::42:61ff:fedf:d41f prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:61:df:d4:1f txqueuelen 0 (Ethernet) RX packets 6 bytes 1174 (1.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 22 bytes 1682 (1.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:5dff:fe6c:be47 prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:5d:6c:be:47 txqueuelen 0 (Ethernet) RX packets 283 bytes 18925 (18.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 254 bytes 19725 (19.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.xx.x.xxx netmask 255.255.240.0 broadcast 172.16.15.255 inet6 fe80::216:3eff:fe01:2f48 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:16:3e:01:2f:48 txqueuelen 1000 (Ethernet) RX packets 504273 bytes 329083359 (313.8 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 273686 bytes 220530043 (210.3 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 并且查看阿里云的内网ip确实也是172开头。 编辑配置文件/etc/docker/daemon.json ,若daemon.json文件不存在新建即可。 123&#123; &quot;bip&quot;: &quot;192.168.1.5/24&quot;&#125; 重新启动docker服务 1234567891011121314151617181920212223242526272829systemctl restart docker复制代码[root@test docker]# ifconfigbr-12aa369ee4a6: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.18.0.1 netmask 255.255.0.0 broadcast 172.18.255.255 inet6 fe80::42:61ff:fedf:d41f prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:61:df:d4:1f txqueuelen 0 (Ethernet) RX packets 508550 bytes 329587116 (314.3 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 276951 bytes 223924395 (213.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.5 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::42:5dff:fe6c:be47 prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:5d:6c:be:47 txqueuelen 0 (Ethernet) RX packets 283 bytes 18925 (18.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 258 bytes 20085 (19.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.xx.x.xxx netmask 255.255.240.0 broadcast 172.16.15.255 inet6 fe80::216:3eff:fe01:2f48 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:16:3e:01:2f:48 txqueuelen 1000 (Ethernet) RX packets 508550 bytes 329587116 (314.3 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 276958 bytes 223925673 (213.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 可以看到docker0 的地址变了。 但是要注意，使用docker启动的服务会默认使用docker0，如果是用docker-compose启动的服务则不会。上面的br-12aa369ee4a6对应的是docker-compose启动的服务，可以看到还是172的网段。 docker-compose up使用自定义的网段的两种方式（从其根源指定） 根据该文使用方法2，即修改daemon.json。但并不能成功访问,我的环境是：docker:20.10.7,docker-compose:1.24.1 12345678910&#123; &quot;bip&quot;: &quot;192.168.1.5/24&quot;, &quot;debug&quot;: true, &quot;default-address-pools&quot; : [ &#123; &quot;base&quot; : &quot;192.168.1.5/16&quot;, &quot;size&quot; : 24 &#125; ]&#125; 后面发现访问不成功的原因在于docker与防火墙之间的关系，可以关掉防火墙，开启docker，不能访问则打开防火墙。在它们之间来回试探 &#x3D; &#x3D;。后面尝试过关闭firewalld，打开iptables。 在启用iptables时，一般关掉iptables可以正常访问，打开则不能正常访问。在启用firewalld时，按照docker和firewalld之间启动关闭的顺序不同，有时是开着防火墙能访问，有时是关了防火墙能访问。 但是容器内不能访问外部网络，该问题现在还未解决。 有一种迂回的解决方法就是容器使用host网络模式 问题：怀疑是docker，firewalld与iptables之间的设置问题 Docker与IPtables docker 端口映射 及外部无法访问问题 Docker and IPtables 还有一种访问不了GitLab的情况是端口映射和配置文件有误。 快速的解决方法：将宿主机端口号和容器号设置相同，可参考下面的博客。 利用GitLab Docker images安装GitLab（填坑） 总结​ 如果系统环境正常，安装会十分顺利，一般不会有奇怪的问题。我在不同的服务器安装过​ 阿里云 CentOS 7.6: 访问正常，但是因内存不够出现502错误，容器内可正常连接外部网络​ 阿里云 Alibaba Cloud Linux 2: 可能不能正常访问容器，容器内不能正常连接外部网络。怀疑是防火墙与docker的问题。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Gitlab","slug":"Gitlab","permalink":"https://guoshunfa.com/tags/Gitlab/"},{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"}]},{"title":"Gitlab GitlabRunner如何更改执行用户","slug":"软件开发/技术/服务&组件/git/Gitlab-GitlabRunner如何更改执行用户","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Gitlab-GitlabRunner如何更改执行用户/","link":"","permalink":"https://guoshunfa.com/2022/07/Gitlab-GitlabRunner%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%89%A7%E8%A1%8C%E7%94%A8%E6%88%B7/","excerpt":"","text":"Gitlab - GitlabRunner如何更改执行用户转载自：http://www.fidding.me/article/111 gitlab-ci的runner默认使用gitlab-runner用户执行操作； 通过指令ps aux|grep gitlab-runner可以看到： 1/usr/bin/gitlab-ci-multi-runner run --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --service gitlab-runner --syslog --user gitlab-runner 其中： --working-directory：设置工作目录, 默认是**&#x2F;home&#x2F;{执行user}** --config：设置配置文件目录，默认是**&#x2F;etc&#x2F;gitlab-runner&#x2F;config.toml** --user：设置执行用户名，默认是gitlab-runner 因此想要更改user为root只需要重新设置--user属性即可，步骤如下： 删除gitlab-runner 1sudo gitlab-runner uninstall 安装并设置--user(例如我想设置为root) 1gitlab-runner install --working-directory /home/gitlab-runner --user root 重启gitlab-runner 1sudo service gitlab-runner restart 验证一下： 再次执行ps aux|grep gitlab-runner会发现--user的用户名已经更换成root了 1/usr/bin/gitlab-ci-multi-runner run --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --service gitlab-runner --syslog --user root 至此gitlab-runner执行.gitlab-cli.yaml时候便是以root用户去执行操作，再也没有繁琐的权限问题了 来自root的温馨提示：能力越大责任越大! happy coding!","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Gitlab","slug":"Gitlab","permalink":"https://guoshunfa.com/tags/Gitlab/"},{"name":"GitlabRunner","slug":"GitlabRunner","permalink":"https://guoshunfa.com/tags/GitlabRunner/"}]},{"title":"Gitlab GitlabRunner注册","slug":"软件开发/技术/服务&组件/git/Gitlab-GitlabRunner注册","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Gitlab-GitlabRunner注册/","link":"","permalink":"https://guoshunfa.com/2022/07/Gitlab-GitlabRunner%E6%B3%A8%E5%86%8C/","excerpt":"","text":"Gitlab - GitlabRunner注册 官方地址：https://docs.gitlab.com/runner/register/ 注册运行器是将运行器与一个或多个GitLab实例绑定的过程。 您可以通过重复register命令在同一台主机上注册多个运行器，每个运行器配置不同。 要求在注册跑步者之前，您必须首先： 在与安装GitLab的位置分开的服务器上安装它 获取令牌： 对于共享运行器，请管理员转到GitLab管理区域，然后单击概述&gt;运行器 对于小组跑步者，请转到设置&gt;CI&#x2F;CD并展开跑步者部分 对于特定于项目的运行器，请转到设置&gt;CI&#x2F;CD并展开运行器部分 在GitLab.com上注册跑步者时，gitlab-ci coordinator URL是https://gitlab.com。 Docker本节中的说明适用于您在容器中安装GitLab Runner后。 以下步骤描述了启动一个短寿命的gitlab-runner容器来注册您在安装期间创建的容器。完成注册后，生成的配置将写入您选择的配置卷（例如，/srv/gitlab-runner/config），并由运行器使用该配置卷加载。 要使用Docker容器注册运行器： 根据挂载类型运行register命令： 对于本地系统卷装载： 1docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register 如果您在安装过程中使用了/srv/gitlab-runner/config以外的配置卷，请务必使用正确的卷更新命令。 对于Docker卷挂载： 1docker run --rm -it -v gitlab-runner-config:/etc/gitlab-runner gitlab/gitlab-runner:latest register 输入您的GitLab实例URL（也称为gitlab-ci coordinator URL）。 输入您获得的令牌以注册跑步者。 输入跑步者的描述。您可以稍后在GitLab用户界面中更改此值。 输入与运行器关联的标签，用逗号分隔。您可以稍后在GitLab用户界面中更改此值。 输入跑步者的任何可选维护备注。 提供运行器执行器。对于大多数用例，请输入docker。 如果您输入docker作为执行人，系统会要求您将默认映像用于未在.gitlab-ci.yml中定义一个的项目。 Linux要在Linux下注册运行器： 运行以下命令： 1sudo gitlab-runner register 如果您在代理后面，请添加环境变量，然后运行注册命令： 1234export HTTP_PROXY=http://yourproxyurl:3128export HTTPS_PROXY=http://yourproxyurl:3128sudo -E gitlab-runner register 输入您的GitLab实例URL（也称为gitlab-ci coordinator URL）。 输入您获得的令牌以注册跑步者。 输入跑步者的描述。您可以稍后在GitLab用户界面中更改此值。 输入与运行器关联的标签，用逗号分隔。您可以稍后在GitLab用户界面中更改此值。 输入跑步者的任何可选维护备注。 提供运行器执行器。对于大多数用例，请输入docker。 如果您输入docker作为执行人，系统会要求您将默认映像用于未在.gitlab-ci.yml中定义一个的项目。 macOS在macOS下注册运行器之前，请先安装Docker.app。 要在macOS下注册运行器： 运行以下命令： 1gitlab-runner register 输入您的GitLab实例URL（也称为gitlab-ci coordinator URL）。 输入您获得的令牌以注册跑步者。 输入跑步者的描述。您可以稍后在GitLab用户界面中更改此值。 输入与运行器关联的标签，用逗号分隔。您可以稍后在GitLab用户界面中更改此值。 输入跑步者的任何可选维护备注。 提供运行器执行器。对于大多数用例，请输入docker。 如果您输入docker作为执行人，系统将要求您将默认映像用于未定义.gitlab-ci.yml的项目。 窗户要在Windows下注册运行器： 运行以下命令： 1.\\gitlab-runner.exe register 输入您的GitLab实例URL（也称为gitlab-ci coordinator URL）。 输入您获得的令牌以注册跑步者。 输入跑步者的描述。您可以稍后在GitLab用户界面中更改此值。 输入与运行器关联的标签，用逗号分隔。您可以稍后在GitLab用户界面中更改此值。 输入跑步者的任何可选维护备注。 提供运行器执行器。对于大多数用例，请输入docker。 如果您输入docker作为执行人，系统会要求您将默认映像用于未在.gitlab-ci.yml中定义一个的项目。 FreeBSD要在FreeBSD下注册跑步者： 运行以下命令： 1sudo -u gitlab-runner -H /usr/local/bin/gitlab-runner register 输入您的GitLab实例URL（也称为gitlab-ci coordinator URL）。 输入您获得的令牌以注册跑步者。 输入跑步者的描述。您可以稍后在GitLab用户界面中更改此值。 输入与运行器关联的标签，用逗号分隔。您可以稍后在GitLab用户界面中更改此值。 输入跑步者的任何可选维护备注。 提供运行器执行器。对于大多数用例，请输入docker。 如果您输入docker作为执行人，系统会要求您将默认映像用于未在.gitlab-ci.yml中定义一个的项目。 一行注册命令如果您想使用非交互式模式注册运行器，您可以使用register子命令或使用其等效的环境变量。 要显示所有register子命令的列表，请运行以下命令： 1gitlab-runner register -h 要使用最常见的选项注册跑步者，您将执行以下操作： 123456789101112sudo gitlab-runner register \\ --non-interactive \\ --url &quot;https://gitlab.com/&quot; \\ --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \\ --executor &quot;docker&quot; \\ --docker-image alpine:latest \\ --description &quot;docker-runner&quot; \\ --maintenance-note &quot;Free-form maintainer notes about this runner&quot; \\ --tag-list &quot;docker,aws&quot; \\ --run-untagged=&quot;true&quot; \\ --locked=&quot;false&quot; \\ --access-level=&quot;not_protected&quot; 如果您在Docker容器中运行运行器，则register命令的结构类似于以下内容： 123456789101112docker run --rm -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \\ --non-interactive \\ --executor &quot;docker&quot; \\ --docker-image alpine:latest \\ --url &quot;https://gitlab.com/&quot; \\ --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \\ --description &quot;docker-runner&quot; \\ --maintenance-note &quot;Free-form maintainer notes about this runner&quot; \\ --tag-list &quot;docker,aws&quot; \\ --run-untagged=&quot;true&quot; \\ --locked=&quot;false&quot; \\ --access-level=&quot;not_protected&quot; --access-level参数已在GitLab Runner 12.0中添加。它使用GitLab 11.11中引入的注册API参数。在注册期间使用此参数创建受保护的运行器。对于受保护的运行器，请使用--access-level=&quot;ref_protected&quot;参数。对于不受保护的运行器，请使用--access-level=&quot;not_protected&quot;或者不定义该值。此值稍后可以在项目的设置&gt;CI&#x2F;CD菜单中打开或关闭。 --maintenance-note参数已在GitLab Runner 14.8中添加。您可以使用它来添加与运行器维护相关的信息。允许的最大长度为255个字符。 Check registration token错误当GitLab实例无法识别输入的注册令牌时，将显示check registration token注册令牌错误消息。当实例组或项目注册令牌在GitLab中更改或用户未正确输入注册令牌时，可能会出现此问题。 发生此错误时，第一步是要求GitLab管理员验证注册令牌是否有效。 [[runners]]配置模板文件在GitLab Runner 12.2中介绍。 某些运行器配置设置无法使用环境变量或命令行选项进行设置。 例如： 环境变量不支持切片。 命令行选项支持故意不适用于整个Kubernetes执行器卷树的设置。 对于由任何类型的自动化处理的环境来说，这是一个问题，例如GitLab Runner官方Helm图表。在此类情况下，唯一的解决方案是在运行器注册后手动更新config.toml文件。这不太理想，容易出错，也不可靠。特别是当为同一GitLab Runner安装完成多个注册时。 这个问题可以通过使用配置模板文件来解决。 要使用配置文件模板文件，请传递文件的路径以register： --template-config命令行选项。 TEMPLATE_CONFIG_FILE环境变量。 配置模板文件支持： 只有单个[[runners]]部分。 没有全局选项。 当使用--template-config或TEMPLATE_CONFIG_FILE时，[[runners]]条目的配置将合并到常规config.toml文件中新创建的[[runners]]条目的配置中。 合并仅适用于空的选项。那就是： 空的绳子。 无效或&#x2F;不存在条目。 零。 有了这个： register命令调用期间，所有配备命令行选项和&#x2F;或环境变量的配置都优先。 该模板填补了空白，并添加了其他设置。 例子我们将基于Kubernetes执行器的运行器注册到一些测试项目，并查看config.toml文件的样子： 12345678910111213141516$ sudo gitlab-runner register \\ --config /tmp/test-config.toml \\ --non-interactive \\ --url https://gitlab.com \\ --registration-token __REDACTED__ \\ --name test-runner \\ --tag-list kubernetes,test \\ --locked \\ --paused \\ --executor kubernetes \\ --kubernetes-host http://localhost:9876/Runtime platform arch=amd64 os=linux pid=1684 revision=88310882 version=11.10.0~beta.1251.g88310882Registering runner... succeeded runner=__REDACTED__Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! 上面的命令创建以下config.toml文件： 123456789101112131415161718192021222324concurrent = 1check_interval = 0[session_server] session_timeout = 1800[[runners]] name = &quot;test-runner&quot; url = &quot;https://gitlab.com&quot; token = &quot;__REDACTED__&quot; executor = &quot;kubernetes&quot; [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.kubernetes] host = &quot;http://localhost:9876/&quot; bearer_token_overwrite_allowed = false image = &quot;&quot; namespace = &quot;&quot; namespace_overwrite_allowed = &quot;&quot; privileged = false service_account_overwrite_allowed = &quot;&quot; pod_annotations_overwrite_allowed = &quot;&quot; [runners.kubernetes.volumes] 我们可以看到从提供的命令行选项创建的基本配置： 运行器凭据（URL和令牌）。 指定了遗嘱执行人。 默认的空部分runners.kubernetes，在注册期间只提供了一个选项。 通常，人们必须再设置几个选项才能使Kubernetes执行器可用，但上述内容就足以让我们的例子而言。 现在假设我们必须为我们的Kubernetes执行器配置一个emptyDir卷。在注册环境变量或命令行选项时，无法添加此内容。我们必须手动将这样的东西附加到文件的末尾： 1234[[runners.kubernetes.volumes.empty_dir]] name = &quot;empty_dir&quot; mount_path = &quot;/path/to/empty_dir&quot; medium = &quot;Memory&quot; 由于TOML不需要适当的缩进（它依赖于条目排序），我们只需将所需的更改附加到文件末尾即可。然而，当更多[[runners]]部分在 oneconfigconfig.toml文件中注册时，这会变得棘手。假设新的总是在最后是有风险的。 使用GitLab Runner 12.2，使用--template-config标志会容易得多。 123456789$ cat &gt; /tmp/test-config.template.toml &lt;&lt; EOF[[runners]] [runners.kubernetes] [runners.kubernetes.volumes] [[runners.kubernetes.volumes.empty_dir]] name = &quot;empty_dir&quot; mount_path = &quot;/path/to/empty_dir&quot; medium = &quot;Memory&quot;EOF 有了这个文件，我们现在可以尝试再次注册运行器，但这次添加了--template-config /tmp/test-config.template.toml选项。除了此更改外，注册命令的其余部分完全相同： 123456789101112131415161718$ sudo gitlab-runner register \\ --config /tmp/test-config.toml \\ --template-config /tmp/test-config.template.toml \\ --non-interactive \\ --url https://gitlab.com \\ --registration-token __REDACTED__ \\ --name test-runner \\ --tag-list kubernetes,test \\ --locked \\ --paused \\ --executor kubernetes \\ --kubernetes-host http://localhost:9876/Runtime platform arch=amd64 os=linux pid=8798 revision=88310882 version=11.10.0~beta.1251.g88310882Registering runner... succeeded runner=__REDACTED__Merging configuration from template fileRunner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! As we can see, there is a little change in the output of the registration command. We can see a Merging configuration from template file line. 现在让我们看看使用模板后配置文件是什么样子的： 1234567891011121314151617181920212223242526272829concurrent = 1check_interval = 0[session_server] session_timeout = 1800[[runners]] name = &quot;test-runner&quot; url = &quot;https://gitlab.com&quot; token = &quot;__REDACTED__&quot; executor = &quot;kubernetes&quot; [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.kubernetes] host = &quot;http://localhost:9876/&quot; bearer_token_overwrite_allowed = false image = &quot;&quot; namespace = &quot;&quot; namespace_overwrite_allowed = &quot;&quot; privileged = false service_account_overwrite_allowed = &quot;&quot; pod_annotations_overwrite_allowed = &quot;&quot; [runners.kubernetes.volumes] [[runners.kubernetes.volumes.empty_dir]] name = &quot;empty_dir&quot; mount_path = &quot;/path/to/empty_dir&quot; medium = &quot;Memory&quot; 我们可以看到，配置几乎和以前一样。唯一的变化是，它现在有[[runners.kubernetes.volumes.empty_dir]]条目，其选项位于文件末尾。它被添加到注册创建的[[runners]]条目中。由于整个文件是用相同的机制保存的，所以我们也有适当的缩进。 如果配置模板包含设置，并且将相同的设置传递给register命令，则传递给register命令的设置优先于配置模板中指定的设置。 12345678910111213141516171819202122$ cat &gt; /tmp/test-config.template.toml &lt;&lt; EOF[[runners]] executor = &quot;docker&quot;EOF$ sudo gitlab-runner register \\ --config /tmp/test-config.toml \\ --template-config /tmp/test-config.template.toml \\ --non-interactive \\ --url https://gitlab.com \\ --registration-token __REDACTED__ \\ --name test-runner \\ --tag-list shell,test \\ --locked \\ --paused \\ --executor shellRuntime platform arch=amd64 os=linux pid=12359 revision=88310882 version=11.10.0~beta.1251.g88310882Registering runner... succeeded runner=__REDACTED__Merging configuration from template fileRunner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! 正如我们所看到的，注册命令指定了shell执行器，而模板包含docker一个。让我们看看最终配置内容是什么： 1234567891011121314concurrent = 1check_interval = 0[session_server] session_timeout = 1800[[runners]] name = &quot;test-runner&quot; url = &quot;https://gitlab.com&quot; token = &quot;__REDACTED__&quot; executor = &quot;shell&quot; [runners.cache] [runners.cache.s3] [runners.cache.gcs] 带有register命令选项的配置集优先，并被选择放置在最终配置中。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"GitlabRunner","slug":"GitlabRunner","permalink":"https://guoshunfa.com/tags/GitlabRunner/"},{"name":"gitlab","slug":"gitlab","permalink":"https://guoshunfa.com/tags/gitlab/"}]},{"title":"Gitlab 更改默认端口","slug":"软件开发/技术/服务&组件/git/Gitlab更改默认端口","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Gitlab更改默认端口/","link":"","permalink":"https://guoshunfa.com/2022/07/Gitlab%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"转载自：https://www.cnblogs.com/hero123/p/10559116.html 若linux服务器的80和8080端口都已经被使用，则需修改gitlab监听的端口 修改路径文件：vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb 1、修改external_url ‘http://ip:端口号‘ （将前面的#注释符号去掉）,我改成了8099 2、找到Advanced settings 下的8080端口 将端口改成自己备用端口号（不能和上面url端口号相同，会冲突占用！），我改的28080 3、运行下面命令 123456# 停止服务sudo gitlab-ctl stop# 启动服务sudo gitlab-ctl reconfigure# 启动所有gitlab组件sudo gitlab-ctl start 启动需要一段时间，上边启动完基本就可以了。 期间可以查看端口进程： 4、若访问不了gitlab，尝试关闭或开放防火墙","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Gitlab","slug":"Gitlab","permalink":"https://guoshunfa.com/tags/Gitlab/"}]},{"title":"Gitlab 默认密码查看和重制密码","slug":"软件开发/技术/服务&组件/git/Gitlab默认密码查看和重制密码","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Gitlab默认密码查看和重制密码/","link":"","permalink":"https://guoshunfa.com/2022/07/Gitlab%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%92%8C%E9%87%8D%E5%88%B6%E5%AF%86%E7%A0%81/","excerpt":"","text":"转发自：https://blog.csdn.net/timonium/article/details/119451755 1. GitLab默认密码 初次安装Gitlab时，密码放在了一个临时文件中了 1/etc/gitlab/initial_root_password 这个文件将在首次执行reconfigure后24小时自动删除 123456789101112131415161718192021222324Notes:Default admin account has been configured with following details:Username: rootPassword: You didn&#x27;t opt-in to print initial root password to STDOUT.Password stored to /etc/gitlab/initial_root_password. This file will be cleaned up in first reconfigure run after 24 hours.NOTE: Because these credentials might be present in your log files in plain text, it is highly recommended to reset the password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password.gitlab Reconfigured![root@c7-192 src]# cat /etc/gitlab/initial_root_password# WARNING: This value is valid only in the following conditions# 1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails[&#x27;initial_root_password&#x27;]` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run).# 2. Password hasn&#x27;t been changed manually, either via UI or via command line.## If the password shown here doesn&#x27;t work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password.Password: thAXLJhVoo6V9sRvRH5HrLrD5rg88C7gccEGZDT4Lq0=# NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours. 2. 登录并修改密码 拿到这个密码后需要尽快登录web界面进行密码修改 进去修改密码 重置密码","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Gitlab","slug":"Gitlab","permalink":"https://guoshunfa.com/tags/Gitlab/"}]},{"title":"Docker 介绍","slug":"软件开发/技术/服务&组件/docker/Docker-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Docker-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Docker-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"docker 库 | docker 官方文档 1. 简介Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、 bare metal、OpenStack 集群和其他的基础应用平台。 2. 适用场景Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 3. 安装3.1. 使用yum安装123456yum update # 更新yumyum install docker # 安装dockersystemctl start docker.service # 启动dockerdocker version # 查看docker版本，验证是否安装成功sudo systemctl enable docker # 设置开机自启动# 结束 3.2. 使用brew安装1brew install --cask --appdir=/Applications docker mac的安装，执行完命令后需要打开docker的App，授权后才能使用。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"}]},{"title":"Docker 命令记录","slug":"软件开发/技术/服务&组件/docker/Docker-命令记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Docker-命令记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Docker-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","excerpt":"","text":"docker 命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 查看docker版本。docker -vdocker version# 查看docker系统信息docker info# 搜索镜像docker search 镜像# 获取镜像docker pull 镜像仓库地址# 上传镜像docker push 镜像仓库地址# 查看镜像的创建历史docker history 镜像仓库地址# 运行容器# -name 定义一个容器的名字# -d 标识是让 docker 容器的后台运行。# -p 标识通知 docker 将容器内部使用的网络端口映射到我们使用的主机上。docker run --name nginx -p 8080:80 nginx# 查询容器内部ip地址docker inspect 容器ID/容器名 | grep IPAddress# 列出容器 -- 仅运行的容器docker ps# 列出容器 -- 包含停止的容器docker ps -a# 查看当前本地所有的镜像docker images# 停止容器docker stop 容器ID/容器名# 开始容器docker start 容器ID/容器名# 重启容器docker restart 容器ID/容器名# 杀掉一个运行中的容器docker kill -s KILL 容器ID/容器名# 删除容器docker rm 容器ID/容器名# 删除一个或多个容器docker rm -f xx,xx2# 删除镜像【顺序：停止镜像里的容器，再删除容器，最后再删除镜像】docker rmi 镜像id/镜像名# 列出所有的容器 IDdocker ps -aq# 停止所有的容器docker stop $(docker ps -aq)# 删除所有的容器docker rm $(docker ps -aq)# 删除所有的镜像docker rmi $(docker images -q)# 停止并删除指定容器docker ps -a | grep 容器ID/容器名 | awk &#x27;&#123;print $1&#125;&#x27; \\ | xargs -i docker stop &#123;&#125; | xargs -i docker rm &#123;&#125;# 删除镜像docker images | grep -E &#x27;镜像id/镜像名&#x27; | awk &#x27;&#123;print $3&#125;&#x27; \\ | uniq | xargs -I &#123;&#125; docker rmi --force &#123;&#125;# ex: 删除镜像 `nginx:latest`docker images | grep -E &#x27;nginx&#x27; | grep &#x27;latest&#x27; | awk &#x27;&#123;print $3&#125;&#x27; \\ | uniq | xargs -I &#123;&#125; docker rmi --force &#123;&#125;# 删除所有停止的容器docker container prune# 删除所有部使用的镜像docker image prune --force --alldocker image prune --f --a# 限制容器内存 -mdocker run --name nginx -d -p 8080:80 -m 100m nginx# 查看容器运行内存信息docker stats nginx# 进入容器docker exec -it 容器ID/容器名 /bin/bash# 以交互模式启动一个容器，在容器内执行/bin/bash命令docker run -i -t 容器ID/容器名 /bin/bash# 查看容器日志 -t: 显示时间戳docker logs -f -t 容器ID/容器名docker logs -fn10 -t 容器ID/容器名# 构建镜像# 用法：docker build -t 镜像名称 .docker build -t docker_demo . 2. docker 启动jar包2.1. 编写dockerFile文件1234567891011121314151617181920212223# 引用哪个镜像，没有镜像则pullFROM centos:7# 为Dockerfile中所有RUN、CMD、ENTRYPOINT、COPY和ADD指令设定工作目录WORKDIR /usr# 执行命令(这里创建了一个目录)RUN mkdir /usr/local/java# 和copy一样，复制文件到指定目录，但是copy不能解压，add自动解压ADD jdk-8u111-linux-x64.tar.gz /usr/local/java# 重命名(不知道文件名可以现在宿主机解压后看一下)RUN ln -s /usr/local/java/jdk1.8.0_111 /usr/local/java/jdk # 设置环境变量 ENV JAVA_HOME /usr/local/java/jdk ENV JRE_HOME $&#123;JAVA_HOME&#125;/jre ENV CLASSPATH .:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib ENV PATH $&#123;JAVA_HOME&#125;/bin:$PATH # 创建一个目录RUN mkdir /demo# 将jar包copy到指定目录ADD job.jar /demo/app.jar# 启动命令ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;-Xmx512m&quot;,&quot;-Xms512m&quot;,&quot;/demo/app.jar&quot;] 2.2. 下载需要的外部包​ 这个场景我只用到了jdk。 2.3. 执行dockerFile文件，构建镜像1docker build -t my/demo . 注意最后的 . 表示 Dockerfile 文件在当前目录下 my&#x2F;demo 构建之后镜像名称 2.4. 运行容器1docker run -d --name demo -p 8080:8080 my/demo 关于 Docker 镜像的更多信息： Docker 镜像指南 Docker 镜像存储在哪里 关于 Docker 容器的更多信息： 如何自动化部署 Docker 容器 如何修复 Docker 容器 关于 Docker 的更多信息： Docker 入门指南 Docker DevOps 课程（视频） Docker 101：从创建到部署 参考文档 如何删除 Docker 镜像和容器","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"}]},{"title":"Docker 问题记录","slug":"软件开发/技术/服务&组件/docker/Docker-问题记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Docker-问题记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Docker-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"记录遇见过的bug 1. docker容器自动退出的问题容器经常用了一段时间就自动退出了，docker ps已经找不到了，在docker ps -a里面了。 问题思路：docker run指定的命令如果不是那些一直挂起的命令（比如运行top，不断echo），就是会自动退出的。-d命令是设置detach为true，根据官方的文档，意思是让这个命令在后台运行，但并不是一直运行，Docker容器后台运行,就必须有一个前台进程。主线程结束，容器会退出。 我们启动容器的时候不要-d命令启动，用-dit就好了 例如： docker run -d hello-world(不要这么做) docker run -dit hello-world(推荐)","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"}]},{"title":"Docker 容器启动后修改或添加端口","slug":"软件开发/技术/服务&组件/docker/Docker容器启动后修改或添加端口","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Docker容器启动后修改或添加端口/","link":"","permalink":"https://guoshunfa.com/2022/07/Docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%90%8E%E4%BF%AE%E6%94%B9%E6%88%96%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"转载自：https://cloud.tencent.com/developer/article/1833131 docker容器启动后怎么修改端口映射？在docker run创建并运行容器的时候，可以通过-p指定端口映射规则。但是，也会遇到刚开始忘记设置端口映射或者设置错了需要修改的情况。当docker start运行容器后，并没有提供一个-p选项或设置，让你修改指定端口映射规则。 通常间接的办法是，保存镜像，再创建一个新的容器，在创建时指定新的端口映射。 方法一：删除原有容器，重新建新容器这个解决方案最为简单，把原来的容器删掉，重新建一个。当然这次不要忘记加上端口映射。优点是简单快捷，在测试环境使用较多。缺点是如果是数据库镜像，那重新建一个又要重新配置一次，就比较麻烦了。 方法二：利用docker commit新构镜像docker commit：把一个容器的文件改动和配置信息commit到一个新的镜像。这个在测试的时候会非常有用，把容器所有的文件改动和配置信息导入成一个新的docker镜像，然后用这个新的镜像重起一个容器，这对之前的容器不会有任何影响。 1、停止docker容器 1docker stop container01 2、commit该docker容器 1docker commit container01 new_image:tag 3、用前一步新生成的镜像重新起一个容器 1docker run --name container02 -p 80:80 new_image:tag 这种方式的优点是不会影响统一宿主机上的其他容器，缺点是管理起来显得比较乱。 方法三：修改文件端口，重启docker服务 停止docker(一定要先停止dokcer，不然直接修改配置文件不会生效) 1systemctl stop docker 2.修改这个容器的hostconfig.json文件中的端口（如果config.v2.json里面也记录了端口，也要修改） 注：以下是我个人操作 363ff2d977f8是CONTAINER ID 此次操作想让宿主机8080端口映射容器内的80端口 配置文件路径/var/lib/docker/containers/363ff2d* 先修改hostconfig.json； 如果之前没有端口映射, 应该有这样的一段: “PortBindings”:{} 增加一个映射, 这样写: “PortBindings”:{“8080&#x2F;tcp”:[{“HostIp”:””,“HostPort”:“60000”}]} 前一个数字是容器端口, 后一个是宿主机端口。将宿主机的60000端口映射到容器的8080端口 而修改现有端口映射更简单, 把端口号改掉就行。 修改前 修改后 3.在修改config.v2.json文件； 修改前 修改后 由于此次实验目的宿主机8080端口映射docker指定容器内的80端口 并且config.v2.json原文件已经带有80端口我就不用做新的更改了 如果添加新的其他映射端口，此文件需要进行填写容器内的映射端口， 123456举例：&quot;ExposedPorts&quot;:&#123; &quot;80/tcp&quot;:&#123; &#125;,&quot;3306/tcp&quot;:&#123; &#125;，&quot;XXXX/tcp&quot;:&#123; &#125;&#125; #注：这里写的都是容器内的端口 4、重启 docker服务 1systemctl restart docker 5、查看配置项已经修改成功 1docker inspect CONTAINER ID","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"}]},{"title":"Docker 容器添加新的端口映射","slug":"软件开发/技术/服务&组件/docker/Docker容器添加新的端口映射","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Docker容器添加新的端口映射/","link":"","permalink":"https://guoshunfa.com/2022/07/Docker%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/","excerpt":"","text":"转载自：https://blog.51cto.com/u_15228753/2818167 step 1: 查看容器哈希编码1docker inspect centos-desktop-vnc | grep Id 1&quot;Id&quot;: &quot;22132e73736a5700dd5b4215a122310220fc3192b19754917caa1b83ecb89dd3&quot;, step 2: 停止目标容器1docker stop centos-desktop-vnc step 3: 修改配置文件1sudo vim /var/lib/docker/containers/&lt;容器Id&gt;/hostconfig.json 加入映射配置 1234567891011&#123; &quot;PortBindings&quot;:&#123; &quot;22/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10112&quot;&#125;], &quot;5901/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10113&quot;&#125;], &quot;3306/tcp&quot;: [&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10114&quot;&#125;], &quot;5672/tcp&quot;: [&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10115&quot;&#125;], &quot;6379/tcp&quot;: [&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10116&quot;&#125;], &quot;8080/tcp&quot;: [&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10117&quot;&#125;], &quot;80/tcp&quot;: [&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10118&quot;&#125;], &#125;,&#125; 修改下一个配置： 1sudo vim /var/lib/docker/containers/&lt;容器Id&gt;/config.v2.json 补齐配置： 1234567891011&#123; &quot;ExposedPorts&quot;:&#123; &quot;22/tcp&quot;:&#123;&#125;, &quot;5901/tcp&quot;:&#123;&#125;, &quot;3306/tcp&quot;:&#123;&#125;, &quot;5672/tcp&quot;:&#123;&#125;, &quot;6379/tcp&quot;:&#123;&#125;, &quot;8080/tcp&quot;:&#123;&#125;, &quot;80/tcp&quot;:&#123;&#125; &#125;&#125; step 4: 重启docker服务 1service docker restart step 5: 重启容器1docker start centos-desktop-vnc 访问响应的端口，查看是否映射成功。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"}]},{"title":"Jenkins 介绍","slug":"软件开发/技术/服务&组件/jenkins/Jenkins-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Jenkins-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Jenkins-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Jenkins是一个独立的开源自动化服务器，可用于自动化各种任务，如构建，测试和部署软件。Jenkins可以通过本机系统包Docker安装，甚至可以通过安装Java Runtime Environment的任何机器独立运行。 Jenkins持续集成从入门到精通 1. Jenkins 服务安装&#x2F;启动1.1. 前提需要有JDK环境。 1.2. Linux 系统 Jenkins服务安装&#x2F;启动1234567891011121314# 更新库sudo apt-get update# 安装jenkinssudo apt-get install jenkins# 注册jenkins服务sudo systemctl daemon-reload# 启动jenkins服务sudo systemctl start jenkins# 查看jenkins服务状态sudo systemctl status jenkins# 重启jenkins服务sudo systemctl restart jenkins# 关闭jenkins服务sudo systemctl stop jenkins 1.2.1. Linux 系统 Jenkins服务卸载123456# 卸载服务sudo apt-get remove jenkins# 卸载安装包，注意这里如果不是ubuntu那就yumsudo apt-get remove --auto-remove jenkins# 卸载配置和数据sudo apt-get purge jenkinssudo apt-get purge --auto-remove jenkins 2. 任务创建2.1. 只是将jenkins作为一个部署平台 只是将jenkins作为一个部署平台，内部还是调用的shell脚本。 1). 新建任务 2). 选择构建 -&gt; 点击执行shell 3). 输入准备执行的脚本。点击保存。 4). 保存后在首页能看到panda-doc任务，点击最右的运行按钮。 5). 点击名称(panda-doc)进入详情，再点击左下角的任务进度区域，查看任务进度。 6). 点击控制台输出即可查看shell脚本的运行情况。 7). 脚本执行完后可以在首页查看脚本运行情况。 参考文档 Jenkins 官网","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://guoshunfa.com/tags/Jenkins/"}]},{"title":"Kafka 介绍","slug":"软件开发/技术/服务&组件/kafka/Kafka-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Kafka-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Kafka-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Kafka 简介 1. Kafka 服务准备1.1. Kafka 服务下载安装12345678# 下载kafka服务包wget https://archive.apache.org/dist/kafka/0.10.2.1/kafka_2.10-0.10.2.1.tgz# 解压tar -zxvf kafka_2.10-0.10.2.1.tgz# 进入kafka目录cd kafka_2.10-0.10.2.1# 修改配置文件server.propertiesvi config/server.properties server.properties demo 123456789101112131415161718192021broker.id=0# ip可以是公网ipadvertised.listeners=PLAINTEXT://ip:9092# ip最好使用内网ip，否则会出现错误：Socket server failed to bind to ip:9092: 无法指定被请求的地址listeners=PLAINTEXT://ip:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=/pandas/service/log/kafkanum.partitions=1num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000############################# Zookeeper ############################## 最好使用内网ip，否则会出现错误：Socket server failed to bind to ip:9092: 无法指定被请求的地址zookeeper.connect=ip:2181zookeeper.connection.timeout.ms=6000 1.2. Kafka服务启动与关闭Kafka服务启动 123456#启动zookeeper/&lt;kafka目录&gt;/bin/zookeeper-server-start.sh /&lt;kafka目录&gt;/config/zookeeper.properties &amp;#等3秒后执行sleep 3 #启动kafka/&lt;kafka目录&gt;/bin/kafka-server-start.sh /&lt;kafka目录&gt;/config/server.properties &amp; Kafka服务关闭 123456#关闭zookeeper/&lt;kafka目录&gt;/bin/zookeeper-server-stop.sh /&lt;kafka目录&gt;/config/zookeeper.properties &amp;#等3秒后执行sleep 3 #关闭kafka/&lt;kafka目录&gt;/bin/kafka-server-stop.sh /&lt;kafka目录&gt;/config/server.properties &amp; 2. Kafka 基本术语描述 术语 说明 Topic 主题，用于划分消息类型，类似于分类标签，是个逻辑概念 Partition 分区，topic中的消息被分割为一个或多个partition，是一个物理概念，对应到系统上的是一个或者多个目录 Segment 段，将partition进一步细分为若干个段，每个segment文件的最大大小相等 Broker Kafka集群包含一个或多个服务器，每个服务器节点称为一个Broker，一个topic中设置partition的数量是broker的整数倍 Producer 生产者，即消息发送者，会将消息发送到相应的partition中 Consumer Group 消费组，一个partition中的消息只能被同一个消费组中的一个消费者进行消费；而一个消费组内的消费者只会消费一个或者几个特定的partition Replication of partition 分区副本，副本是一个分区的备份，是为了防止消息丢失而创建的分区备份 Partition Leader 每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责读写的partition，即所有读写操作只能发生于Leader分区上 Partition Follower 所有Follower都要从Leader上同步消息，Follower与Leader始终保持消息同步；partition leader与partition follower之间是主备关系而非主从关系 ISR ISR：In-Sync Replicas，是指副本同步列表；AR：Assiged Replicas，指所有副本；OSR：Outof-Sync Replicas；AR&#x3D;ISR+OSR offset 偏移量，每个消息都有一个当前Partition下唯一的64字节的offset，他是相当于当前分区第一条消息的偏移量 offset commit 当consumer从partition中消费了消息后，consumer会将其消费消息的offset提交给broker，表示当前partition已经消费到了该offset所标识的消息。 Rebalance 当消费者组中消费者数量发生变化或者topic中partition数量发生变化，partition的所有权会在消费者间转移，即partition会重新分配。 __commit_offsets 消费者提交的offset被封装为了一种特殊的消息被写入到一个由系统创建的、名称为__commit_offstes的特殊topic的partition中，该topic默认包含50个partition，这些offset的默认有效期为一天 Broker Controller Kafka集群的多个broker中，会有一个被选举为controller，负责管理集群中partition和副本replicas的状态。 Zookeeper 负责维护和协调Broker，负责Broker Controller的选举；这里要说明一下，Broker Controller是由Zookeeper选举出来的，而Partition Leader是由Broker Controller选举出来的。 Group Coordinator group coordinator是运行在broker上的线程，主要用于consumer group中各个成员的offset位移管理和Rebalance；Group Coordinator同时管理着当前broker的所有消费者组。当Consumer需要消费数据时，并不是直接中__comsumer_offset的partition中获取的，而是从当前broker的Coordinator的缓存中获取的。而缓存中的数据是在consumer消费完提交offset时，同时提交到coordinator的缓存以及__consumer_offset的partition中的。 2.1. topic、partition、segment、broker的关系topic是一个主题，是一个逻辑概念，而partition是一个一个先进先出的队列，而消息信息就存在partition队列中，但是由于一个topic对应的partition中消息内容太大，因此将其分为多个segment用于存储。segment文件的最大大小是一致的。 举个例子，如果一个segment的最大大小为10个字节，当写够10个字节后，就会重新再生成一个segment，segment对应的就是实际的内容文件，而内容文件又分为后缀名为log的具体消息文件和后缀名为index的消息索引文件。 切换到kafka的日至目录文件，查看即可： 这里因为是我自己的测试，没有那么大的数据量，所以文件都是0，文件的命名方式是以上一个文件的结尾偏移量得来的，第一个文件前面没有文件，所以偏移量为0。 而broker是kafka的服务器，假设某topic中有N个partiton，集群中有M个broker，则partiton与broker的关系为： 若N&gt;M，且N%M &#x3D;0 ，则每个broker会平均存储该topic的多个partiton 若N&gt;M，且N%M!&#x3D;0，则每个broker中的partion数量不是不平均的。应尽量避免这种情况，容易导致Kafka 集群消息不均衡，各个 broker 的任务压⼒不均衡。 若N&lt;M，则会有N个broker中都存放了⼀个partition，⽽有M-N个broker是没有partition的。 总而言之一句话：⼀个 Topic 的消息可以被存放到多个 Broker 中，⼀个 Broker 中可以存放⼀个 Topic 的多 个Partition，⽽⼀个 Partition 中可以存放很多的 Segment，⼀个 Segment 中可以存放很多的消息。 2.2. consumer、consumer group与partition的关系consumer是消费者，一个消费者可以订阅多个topic消息，也可以订阅同一个topic中多个partition的消息。 consumer group是消费者组，每一条消息只能被组内一个实例进行消费，不同的消费组可以消费同一条消息。 consumer与partition的关系：一个consumer可以消费一个或多个partition的消息，但是一个partition的消息不能被多个消费者消费，其主要目有两个，一个是为了正确的回写消费进度，另一个是为了保证同一个partition的消息顺序写、顺序读；但是这样就会造成一个问题，就是如果消费者的数量多于partition的数量的时候，就一定有消费者是处于空闲。而如果partition不是消费者的整数倍，那么也会存在有的消费者消费的partition比其他消费者多的情况，因此一般情况下，都会将partition的数量设置为消费者的整数倍，这样所有的消费者消费的partition数量一致，不会产生压力不均的问题。 2.3. Replicas of partition、Partition Leader、Partition FollowerReplicas of partition就是partition的副本数量，主要是为了解决单点问题导致的broker宕机后partition不可用，如果副本为3，那么看有几个broker，如果有一个，那么在当前的broker上会有相同的三个partition，如果有两个broker，那么会存在一个broker上有一个partition另外一个broker上有两个partition的情况，如果有三个broker，那么每一个broker上都会有一个partition。 而Partition是存在Partition Leader和Partition Follower的，每一个partition在创建的时候，都会使用Zookeeper的临时节点来确定哪一个partition是Leader，那么其余的Partition则都是Follower，只有Leader会处理客户端的读写请求，而Follower只会将Leader中的数据同步到自己的日志中，而不向外部客户端提供任何服务，它的作用就是当Leader所在的broker宕机后，其所链接的Zookeeper就是重新选举一个Leader，这是其中一个Follower会被选举为Leader，其同步的数据也就派上了用场。 创建一个topic的命令如下所示： 1bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication\u0002factor 1 --partitions 1 --topic test 其中partition表示该topic下面有多少个partition，factor是复制因子，表示每个partition需要复制几份进行保存，这里的复制因子数量不能超过broker的数量，因为超过了，一个broker中存在同一个partition的数量就大于一，没有任何意义，返回会增加数据同步和数据存储的压力。 2.4. offset、offset commit、_consumer offsetsoffset就是偏移量，consumer消费消息时，是通过指定的offset来定位下一条要读取消息的位置，offset的维护是由consumer进行维护的。在kafka0.8之后，offset保存在kafka集群上，在0.8版本之前，是保存在zookeeper上的。在新版本中，consumer的offset其实是作为一条普通的消息发送到kafka的，消息的默认主题是_consumer_offsets，其默认有50个partition。 当consumer消费完消息后，会将消费消息的offset提交给broker，表示这些消息已经被消费。 consumer提交消费offset的方式有自动提交、手动异步提交、手动同步提交、手动同步异步混合提交这几种方案： 自动提交：自动提交只需要设置使用时只需要设置enable.auto.commit为true即可。其优点就是比较简单，但是缺点是会产生重复消息。因为自动提交默认的是5秒提交一次，提交的内容是上一次被消费的数据，那么如果在第三秒的时候出现了Rebalance，在Rebalance后，consumer需要重新从上一次确认过的offset处消费，就会造成之前三秒的数据再一次被消费。 手动提交：手动同步提交需要使用commitSync()，而手动异步提交需要使用commitAsync()，同步提交的优点是比较灵活，但缺点也很明显，就是会阻塞；而异步提交的优点就是相对于同步来说，不会阻塞；那么一般我们会使用同步和异步组合使用，就是进行异步提交offset，但是需要监听broker的响应结果，如果相应结果是提交失败，则再以同步的方式进行提交。 还有一种更为精致的提交方式，commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt;)和commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt;)。它们的参数是⼀个 Map 对象，键就是 TopicPartition，即消费的分区，⽽值是⼀个 OffsetAndMetadata 对象，保存的主要是位移数据。 上面提到的_consumer_offsets，该topic的partition默认为50个，使用哪个partition使用的是consumer groupID的hash值与partition数量取模处理，该topic中数据的有效期为1天，其key&#x3D;groupid+topic+分区号，value就是当前offset的值。写⼊到__consumer_offsets主题的partition中的offset消息格式为：[Group, Topic, Partition]::[OffsetMetadata[Offset, Metadata], CommitTime, ExpirationTime]。当 Kafka 集群中的第⼀个 Consumer 程序启动时，Kafka 会⾃动创建位移主题。 参考资料 Kafka基本术语及描述","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://guoshunfa.com/tags/Kafka/"}]},{"title":"Kafka 错误记录","slug":"软件开发/技术/服务&组件/kafka/Kafka-错误记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Kafka-错误记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Kafka-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Kafka - 错误记录cannot allocate memory日志描述： 1234// Java运行时环境的内存不足，无法继续运行。## There is insufficient memory for the Java Runtime Environment to continue. // 1073741824刚好是1G, 这句话的意思是本机内存分配未能为提交保留内存分配1G内存。# Native memory allocation (malloc) failed to allocate 1073741824 bytes for committing reserved memory. 解决方案： 从这两行提示信息来看，应该是内存不够，经过百度，发现是kafka默认启动内存是1G, 而JVM默认内存也是1G, JVM自然不能所有内存都分配给kafka， 所以kafka就启动不了，解决方法是把kafka的最小启动内存设置为小于1G的值，即把kafka-server-start.sh中把’export KAFKA_HEAP_OPTS&#x3D;”-Xmx1G -Xms1G”‘中的Xms设置为256M, 这样，kafka最小只需要256M即可启动。 重启kafka服务。 Executing consumer group command failed due to Request METADATA failed on brokers List(ubuntu:9092 (id: -1 rack: null))日志描述： 运行bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list触发的错误日志。消费者团体执行命令失败由于请求元数据失败的经纪人名单上。 解决方案： 查看server.properties zookeeper的配置信息。调整成正确的YOUR_IP_ADDRESS即可。bin/kafka-consumer-groups.sh --bootstrap-server YOUR_IP_ADDRESS:9092 --list 参考资料 启动kafka提示OOM异常，cannot allocate memory KafkaConsumer 长时间地在poll(long )方法中阻塞","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://guoshunfa.com/tags/Kafka/"}]},{"title":"Kafka 命令记录","slug":"软件开发/技术/服务&组件/kafka/Kafka命令记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Kafka命令记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Kafka%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 服务管理前台启动broker bin/kafka-server-start.sh &lt;path&gt;/server.propertiesCtrl + C 关闭 后台启动broker bin/kafka-server-start.sh -daemon &lt;path&gt;/server.properties 关闭broker bin/kafka-server-stop.sh 2. Topic管理创建topic bin/kafka-topics.sh --create --zookeeper localhost:2181 --partitions 3 --replication-factor 3 --topic topicname 删除topic bin/kafka-topics.sh --delete --zookeeper localhost:2181 --topic topicname 查询topic列表 bin/kafka-topics.sh --zookeeper localhost:2181 --list 查询topic详情 bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic topicname 修改topic bin/kafka-topics.sh --alter --zookeeper localhost:2181 --partitions 6 --topic topicname 相关可选参数 参数 描述 例子 --bootstrap-server指定kafka服务 指定连接到的kafka服务; 如果有这个参数,则--zookeeper可以不需要 –bootstrap-server localhost:9092 --zookeeper 弃用, 通过zk的连接方式连接到kafka集群; –zookeeper localhost:2181 或者localhost:2181&#x2F;kafka --replication-factor 副本数量,注意不能大于broker数量;如果不提供,则会用集群中默认配置 –replication-factor 3 --partitions 分区数量,当创建或者修改topic的时候,用这个来指定分区数;如果创建的时候没有提供参数,则用集群中默认值; 注意如果是修改的时候,分区比之前小会有问题 –partitions 3 --replica-assignment 副本分区分配方式;创建topic的时候可以自己指定副本分配情况; --replica-assignmentBrokerId-0:BrokerId-1:BrokerId-2,BrokerId-1:BrokerId-2:BrokerId-0,BrokerId-2:BrokerId-1:BrokerId-0 ; 这个意思是有三个分区和三个副本,对应分配的Broker; 逗号隔开标识分区;冒号隔开表示副本 --config&lt;String: name&#x3D;value&gt; 用来设置topic级别的配置以覆盖默认配置;只在–create 和–bootstrap-server 同时使用时候生效 ; 可以配置的参数列表请看文末附件 例如覆盖两个配置--config retention.bytes=123455 --config retention.ms=600001 --command-config&lt;String: command 文件路径&gt; 用来配置客户端Admin Client启动配置,只在–bootstrap-server 同时使用时候生效 ; 例如:设置请求的超时时间--command-config config/producer.proterties; 然后在文件中配置 request.timeout.ms&#x3D;300000 3. Consumer-Groups管理查询消费者组 bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list 查询消费者组详情 bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group groupname 重设消费者组位移 12345678# 最早处bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group groupname --reset-offsets --all-topics --to-earliest --execute# 最新处bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group groupname --reset-offsets --all-topics --to-latest --execute# 某个位置bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group groupname --reset-offsets --all-topics --to-offset 2000 --execute# 调整到某个时间之后得最早位移bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group groupname --reset-offsets --all-topics --to-datetime 2019-09-15T00:00:00.000 删除消费者组 bin/kafka-consumer-groups.sh --zookeeper localhost:2181 --delete --group groupname 4. 消息管理实时接收消息 bin/kafka-console-consumer.sh --topic topin --bootstrap-server ip:port 参考资料 Kafka运维命令大全","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://guoshunfa.com/tags/Kafka/"}]},{"title":"Nexus 介绍","slug":"软件开发/技术/服务&组件/nexus/Nexus-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Nexus-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Nexus-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"注意：Nexus 3.X要求JDK的版本在1.8以上 1. 安装、运行1.1. 下载对应安装包前往官方下载地址 mac系统提供百度网盘，提取码：5fsw 1.2. 运行Nexus进入对应的bin目录下启动nexus 1./nexus start 出现Starting Nexus OSS... Started Nexus OSS.，即启动成功。 1.3. 访问地址 3.x默认是127.0.0.1:8081，默认的登陆账户密码为admin&#x2F;admin123。 2.x默认是127.0.0.1:8081&#x2F;nexus，默认的登陆账户密码为admin&#x2F;admin123。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Nexus","slug":"Nexus","permalink":"https://guoshunfa.com/tags/Nexus/"}]},{"title":"Nginx 介绍","slug":"软件开发/技术/服务&组件/nginx/Nginx-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.263Z","comments":true,"path":"2022/07/Nginx-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Nginx-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"官方文档 | 中文文档 1. Nginx 服务安装1.1. mac系统123456# 安装nginxbrew install nginx# 启动nginxbrew services start nginx# brew安装的nginx默认配置文件位置：/usr/local/etc/nginx/nginx.conf# 实在找不着nginx.conf就使用命令：nginx -t 2. Nginx 详细讲解2.1. Nginx 命令 命令 描述 nginx -?,-h,-help 查看nginx 所有命令。 nginx -v 显示nginx版本。 nginx -V 显示nginx版本和具体nginx配置选项。 nginx -t 测试配置文件是否可行。 nginx -T 测试配置文件是否可行，并且展示配置文件内容。 nginx -q 在配置测试期间抑制非错误消息。 nginx -s signal 向主进程发送信号:停止(stop)、退出(quit)、重新打开(reopen)、重新加载(reload)。（配置文件内必须标注pid信息，如在main层加一行：pid filename） nginx -p prefix 设置前缀路径。 nginx -e filename 设置错误日志文件地址。 nginx -c filename 设置配置文件地址。 nginx -g directives 在配置文件外设置全局指令，需要替代directives。 2.2. Nginx 配置文件详解 转载于Nginx配置文件 nginx.conf详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393# 定义Nginx运行的用户和用户组# user nobady nobady;# nginx进程数，建议设置为等于CPU总核心数,默认为1。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件,指定nginx进程运行文件存放地址pid /usr/local/nginx/logs/nginx.pid;# 指定进程可以打开的最大描述符：数目# 工作模式与连接数上限# 这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。# 现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4 万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间，默认是60s，切记这个参数也不能设置过大！否则会导致许多无效的http连接占据着nginx的连接数，终nginx崩溃！ keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 60s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on; &#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http&#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用,告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。就是说数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞 tcp_nopush on; #告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值 tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 #这个指令为FastCGI缓存指定一个路径，目录结构等级，关键字区域存储时间和非活动删除时间 fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10m inactive=5m; #指定连接到后端FastCGI的超时时间 fastcgi_connect_timeout 300; #向FastCGI传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI传送请求的超时时间 fastcgi_send_timeout 300; #接收FastCGI应答的超时时间，这个值是指已经完成两次握手后接收FastCGI应答的超时时间 fastcgi_read_timeout 300; #指定读取FastCGI应答第一部分 需要用多大的缓冲区,这里可以设置为fastcgi_buffers指令指定的缓冲区大小，上面的指令指定它将使用1个 16k的缓冲区去读取应答的第一部分，即应答头，其实这个应答头一般情况下都很小（不会超过1k），但是你如果在fastcgi_buffers指令中指定了缓冲区的大小，那么它也会分配一个fastcgi_buffers指定的缓冲区大小去缓存 fastcgi_buffer_size 64k; #指定本地需要用多少和多大的缓冲区来 缓冲FastCGI的应答，如上所示，如果一个php脚本所产生的页面大小为256k，则会为其分配16个16k的缓冲区来缓存，如果大于256k，增大 于256k的部分会缓存到fastcgi_temp指定的路径中， 当然这对服务器负载来说是不明智的方案，因为内存中处理数据速度要快于硬盘，通常这个值 的设置应该选择一个你的站点中的php脚本所产生的页面大小的中间值，比如你的站点大部分脚本所产生的页面大小为 256k就可以把这个值设置为16 16k，或者464k 或者64 4k，但很显然，后两种并不是好的设置方法，因为如果产生的页面只有32k，如果用464k它会分配1个64k的缓冲区去缓存，而如果使用64 4k它会分配8个4k的缓冲区去缓存，而如果使用16 16k则它会分配2个16k去缓存页面，这样看起来似乎更加合理• fastcgi_buffers 4 64k; #这个指令我也不知道是做什么用，只知道默认值是fastcgi_buffers的两倍 fastcgi_busy_buffers_size 128k; #在写入fastcgi_temp_path时将用多大的数据块，默认值是fastcgi_buffers的两倍 fastcgi_temp_file_write_size 128k; #开启FastCGI缓存并且为其制定一个名称。个人感觉开启缓存非常有用，可以有效降低CPU负载，并且防止502错误。但是这个缓存会引起很多问题，因为它缓存的是动态页面。具体使用还需根据自己的需求 fastcgi_cache TEST #为指定的应答代码指定缓存时间，如上例中将200，302应答缓存一小时，301应答缓存1天，其他为1分钟 fastcgi_cache_valid 200 302 1h; fastcgi_cache_valid 301 1d; fastcgi_cache_valid any 1m; #缓存在fastcgi_cache_path指令inactive参数值时间内的最少使用次数，如上例，如果在5分钟内某文件1次也没有被使用，那么这个文件将被移除 fastcgi_cache_min_uses 1; #gzip模块设置 #开启压缩 gzip on; # 设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于2k的字节数，小于2k可能会越压越大。 gzip_min_length 2k; # 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。 # 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。 gzip_buffers 4 16k; #压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间 gzip_comp_level 5; # 默认值: gzip_types text/html (默认不对js/css文件进行压缩) # 压缩类型，匹配MIME类型进行压缩 # 不能用通配符 text/* # (无论是否指定)text/html默认已经压缩 # 设置哪压缩种文本文件可参考 conf/mime.types gzip_types text/plain application/x- javascript text/css application/xml; # 值为1.0和1.1 代表是否压缩http协议1.0，选择1.0则1.0和1.1都可以压缩 gzip_http_version 1.0; # IE6及以下禁止压缩 gzip_disable &quot;MSIE [1-6]\\.&quot;; # 默认值：off # Nginx作为反向代理的时候启用，开启或者关闭后端服务器返回的结果，匹配的前提是后端服务器必须要返回包含&quot;Via&quot;的 header头。 # off - 关闭所有的代理结果数据的压缩 # expired - 启用压缩，如果header头中包含 &quot;Expires&quot; 头信息 # no-cache - 启用压缩，如果header头中包含 &quot;Cache-Control:no-cache&quot; 头信息 # no-store - 启用压缩，如果header头中包含 &quot;Cache-Control:no-store&quot; 头信息 # private - 启用压缩，如果header头中包含 &quot;Cache-Control:private&quot; 头信息 # no_last_modified - 启用压缩,如果header头中不包含 &quot;Last-Modified&quot; 头信息 # no_etag - 启用压缩 ,如果header头中不包含 &quot;ETag&quot; 头信息 # auth - 启用压缩 , 如果header头中包含 &quot;Authorization&quot; 头信息 # any - 无条件启用压缩 gzip_proxied expired no-cache no-store private auth; # 给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream www.xx.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.xx.com xx.com; #默认访问文件 index index.html index.htm index.php; #文件根目录，会根据根目录查找默认访问文件。 root /data/www/xx; #对******进行负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。 #反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回 500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*. (htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125; 3. 可支持的需求 以下内容皆是对于nginx.conf http标签内的调整。 都只是最简单的demo，如果想要查看详细内容，请移步到本目录的其他文件。 3.1. 部署静态文件123456server &#123; listen 8991; server_name pandacode.cn; index index.html; root /Users/guoshunfa/workspace/my/git-project/panda-doc/docs/.vuepress/dist;&#125; 3.2. 负载均衡1234567891011121314# 负载均衡：设置domainupstream domain &#123; server 127.0.0.1:8551; server 127.0.0.1:8552;&#125;server &#123; listen 8992; server_name 127.0.0.1; location / &#123; # 负载均衡配置，请求会被平均分配到8000和8001端口 proxy_pass http://domain; proxy_set_header Host $host:$server_port; &#125;&#125; 3.3. 反向代理1234567server &#123; listen 8993; server_name 127.0.0.1; location / &#123; proxy_pass http://127.0.0.1:8552; &#125;&#125; 参考文档 连前端都看得懂的《Nginx 入门指南》 8分钟带你深入浅出搞懂Nginx Nginx配置文件 nginx.conf详解","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://guoshunfa.com/tags/Nginx/"}]},{"title":"Nginx 部署静态文件","slug":"软件开发/技术/服务&组件/nginx/Nginx部署静态文件","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.263Z","comments":true,"path":"2022/07/Nginx部署静态文件/","link":"","permalink":"https://guoshunfa.com/2022/07/Nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/","excerpt":"","text":"以需求为导向，进行配置。 这里已经默认安装过了Nginx。 1. 简单部署123456server &#123; listen 8991; server_name 127.0.0.1; index index.html; root /Users/guoshunfa/workspace/my/git-project/panda-doc/docs/.vuepress/dist;&#125; 2. 绑定域名(可多个)123456server &#123; listen 80; server_name guoshunfa.cn pandacode.cn blog.pandacode.cn; index index.html; root /Users/guoshunfa/workspace/my/git-project/panda-doc/docs/.vuepress/dist;&#125; 3. 域名配置ssl 阿里云官方介绍文档。 TODO：没有进行验证 3.1. 准备工作3.1.1. Nginx 的 SSL 模块安装配置查看 nginx 是否安装 http_ssl_module 模块。 1/usr/local/nginx/sbin/nginx -V 如果出现 configure arguments: –with-http_ssl_module, 则已安装（下面的步骤可以跳过，进入 [准备SSL证书](#3.1.2. 准备SSL 证书)）。 配置ssl模块 123# 配置ssl模块cd nginx-1.15.9 # nginx目录./configure --prefix=/usr/local/nginx --with-http_ssl_module 使用 make 命令编译（使用make install会重新安装nginx），此时当前目录会出现 objs 文件夹。 用新的 nginx 文件覆盖当前的 nginx 文件。 1cp ./objs/nginx /usr/local/nginx/sbin/ 再次查看安装的模块（configure arguments: –with-http_ssl_module说明ssl模块已安装）。 12/usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.15.9...configure arguments: --with-http_ssl_module 3.1.2. 准备SSL 证书下载申请好的 ssl 证书文件压缩包到本地并解压（这里是用的 pem 与 key 文件，文件名可以更改）。 在 nginx 目录新建 cert 文件夹存放证书文件。 12cd /usr/local/nginxmkdir cert 将这两个文件上传至服务器的 cert 目录里。这里使用 mac 终端上传至服务器的 scp 命令（这里需要新开一个终端，不要使用连接服务器的窗口）: 12scp /Users/yourname/Downloads/ssl.pem root@xxx.xx.xxx.xx:/usr/local/nginx/cert/scp /Users/yourname/Downloads/ssl.key root@xxx.xx.xxx.xx:/usr/local/nginx/cert/ 3.1.3. 放行ssl默认端口服务器放行443端口，避免拦截。 4. Nginx.conf 配置编辑 nginx.conf 配置文件： 配置 https server： 123456789101112131415161718192021server &#123;# 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块listen 443 ssl;# 域名，多个以空格分开server_name &lt;a href=&quot;https://www.aliyun.com/minisite/goods?userCode=veyumm2k&quot; target=&quot;_blank&quot;&gt;hack520.com&lt;/a&gt; &lt;a href=&quot;https://www.aliyun.com/minisite/goods?userCode=veyumm2k&quot; target=&quot;_blank&quot;&gt;www.hack520.com&lt;/a&gt;;# ssl证书地址ssl_certificate /usr/local/nginx/cert/ssl.pem; # pem文件的路径ssl_certificate_key /usr/local/nginx/cert/ssl.key; # key文件的路径# ssl验证相关配置ssl_session_timeout 5m; #缓存有效期ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议ssl_prefer_server_ciphers on; #使用服务器端的首选算法location / &#123; root html; index index.html index.htm; &#125;&#125; 将 http 重定向 https。 12345server &#123; listen 80; server_name &lt;a href=&quot;https://www.aliyun.com/minisite/goods?userCode=veyumm2k&quot; target=&quot;_blank&quot;&gt;hack520.com&lt;/a&gt; &lt;a href=&quot;https://www.aliyun.com/minisite/goods?userCode=veyumm2k&quot; target=&quot;_blank&quot;&gt;www.hack520.com&lt;/a&gt;; return 301 https://$server_name$request_uri;&#125;","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://guoshunfa.com/tags/Nginx/"},{"name":"部署","slug":"部署","permalink":"https://guoshunfa.com/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"Opengrok 代码阅读工具","slug":"软件开发/技术/服务&组件/opengrok/Opengrok代码阅读工具","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.263Z","comments":true,"path":"2022/07/Opengrok代码阅读工具/","link":"","permalink":"https://guoshunfa.com/2022/07/Opengrok%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Opengrok 在线代码阅读工具，支持代码浏览，文件名搜索等功能。 API | Github | Docker API 最终效果： 1. 安装使用我是用Docker镜像的形式安装的，奉上官方API，根据API可以更高效的完成安装，这里也简单的做一下介绍。 1.1. 拉取docker镜像1docker pull opengrok/docker 1.2. 运行1docker run -d -v &lt;path/to/your/src&gt;:/opengrok/src -p 8080:8080 opengrok/docker:latest 容器为 OpenGrok 导出端口 8080。 安装到的卷/opengrok/src应包含您想要搜索的项目（在子目录中）。您可以使用常见的修订控制检出（git、svn 等），而 OpenGrok 将提供历史和责任信息。 运行成功后就可以直接访问到服务了。localhost:8080 2. 进阶2.1. 目录该图像包含以下目录： 目录 描述 /opengrok/etc 存储 Web 应用程序和索引器的配置 /opengrok/data 数据根 - 索引数据 /opengrok/src 源根 - 输入数据 /scripts 启动脚本和顶级配置。除非调试，否则不要覆盖。 2.2. 环境变量 Docker 环境变量 默认值 描述 SYNC_PERIOD_MINUTES 10 以分钟为单位的自动同步（即镜像 + 重新索引）的时间段。设置为0将禁用定期同步（容器启动后的同步仍将完成）。 INDEXER_OPT 空的 将额外的选项传递给 OpenGrok Indexer。默认的索引器选项集是：--remote on -P -H -W。例如，-i d:vendor将从*/vendor/*索引中删除所有文件。您可以在https://github.com/oracle/opengrok/wiki/Python-scripts-transition-guide上检查索引器选项 NOMIRROR 空的 为避免镜像步骤，请将变量设置为非空值。 URL_ROOT / 覆盖 OpenGrok 应该运行的子 URL。 WORKERS 容器中的 CPU 数量 用于同步的工作人员数量（仅适用于启用项目的设置） AVOID_PROJECTS 空的 在项目较少的配置中运行。设置为非空值会禁用项目。还禁用存储库同步。 REST_PORT 5000 简单 REST 应用程序侦听 GET 请求/reindex以触发手动重新索引的TCP 端口。 REST_TOKEN 没有任何 如果设置，REST 应用程序将需要此令牌作为不记名令牌以触发重新索引。 READONLY_CONFIG_FILE 没有任何 如果设置，配置将与此文件中的配置合并。这是在容器启动时运行的。 CHECK_INDEX 没有任何 如果设置，将首先检查索引的格式。如果索引与当前运行的版本不兼容，数据根将被清除并从头开始重新索引。 要为 指定环境变量docker run，请使用该-e选项，例如-e SYNC_PERIOD_MINUTES=30","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Opengrok","slug":"Opengrok","permalink":"https://guoshunfa.com/tags/Opengrok/"}]},{"title":"SVN 错误记录","slug":"软件开发/技术/服务&组件/svn/SVN-错误记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.263Z","comments":true,"path":"2022/07/SVN-错误记录/","link":"","permalink":"https://guoshunfa.com/2022/07/SVN-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"SVN提交失败：Changing file ‘XXX’ is forbidden by the server;Access to ‘XXX’ forbidden 转载自：https://blog.csdn.net/diaozhu8194/article/details/102126521 权限不够，找管理人员提高你的权限。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"https://guoshunfa.com/tags/SVN/"}]},{"title":"Tomcat 介绍","slug":"软件开发/技术/服务&组件/tomcat/Tomcat-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.263Z","comments":true,"path":"2022/07/Tomcat-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Tomcat-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1. Tomcat 安装&#x2F;服务启动与关闭1.1. Linux ContOS7 安装 Tomcat9为防止操作权限不足，建议切换root用户，当然如果你对Linux命令熟悉，能够自主完成权限更新操作，可以不考虑此推荐。 更多命令学习推荐： 1.1.1. 下载Linux版Tomcat包 tar.gz：Linux环境下的压缩包，免安装！ 1、手动在Tomcat官网下载，并使用XFTP将文件上传至Linux指定目录下（为便于管理建议放在当前用户&#x2F;home&#x2F;XXX目录下）。 2、使用命令下载。（默认文件保存在当前登录用户所在目录） 1wget https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.39/bin/apache-tomcat-9.0.39.tar.gz 1.1.2. 解压安装Tomcat9 1、在&#x2F;usr&#x2F;local目录下新建目录Apache。（用于存放Tomcat的安装位置）。 2、进入下载好的Tomcat压缩包地址路径，解压Tomcat至&#x2F;usr&#x2F;local&#x2F;Apache目录中。 1234567########进入目录查看下载的文件（Tomcat包）[root@localhost Apache]# cd /home/xsge/downfiles/[root@localhost downfiles]# lsapache-tomcat-9.0.39.tar.gz jdk-8u261-linux-x64.tar.gz########解压Tomcat包到指定目录[root@localhost downfiles]# tar -xvf apache-tomcat-9.0.39.tar.gz -C /usr/local/Apache 3、进入解压目录检查 123[root@localhost downfiles]# cd /usr/local/Apache[root@localhost Apache]# lsapache-tomcat-9.0.39 1.1.3. 启动Tomcat程序 1、进入Tomcat安装目录。命令启动（默认绿色后缀为.sh的便是Linux的可执行脚本） 123456######进入Tomcat安装目录bin目录下[root@localhost bin]# cd /usr/local/Apache/apache-tomcat-9.0.39/bin######启动或关闭Tomcat[root@localhost bin]# ./startup.sh[root@localhost bin]# ./shutdown.sh 说明：在window系统中启动脚本是.bat文件，在Linux系统中使用的是.sh文件。执行格式为： .&#x2F;脚本 注意：如果.sh文件显示为灰色，且无法执行，则是因为权限不足，使用命令给脚本文件增加执行权限。 [root@localhost bin]# chmod +x *.sh #给所有脚本文件增加执行权限 启动信息如下： 123456789[root@localhost bin]# ./startup.shUsing CATALINA_BASE: /usr/local/Apache/apache-tomcat-9.0.39Using CATALINA_HOME: /usr/local/Apache/apache-tomcat-9.0.39Using CATALINA_TMPDIR: /usr/local/Apache/apache-tomcat-9.0.39/tempUsing JRE_HOME: /usr/lib/jvm/jdk1.8.0_261Using CLASSPATH: /usr/local/Apache/apache-tomcat-9.0.39/bin/bootstrap.jar:/usr/local/Apacheapache-tomcat-9.0.39/bin/tomcat-juli.jarUsing CATALINA_OPTS: Tomcat started.[root@localhost bin]# 如果希望查看启动详情，可以进入Tomcat的log目录查看显示日志信息 1234567891011121314####进入Tomcat日志目录[root@localhost ~]# cd /usr/local/Apache/apache-tomcat-9.0.39/logs####查看日志信息[root@localhost logs]# tail -f catalina.out 15-Oct-2020 13:49:22.162 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory 把web 应用程序部署到目录 [/usr/local/Apache/apache-tomcat-9.0.39/webapps/docs]15-Oct-2020 13:49:22.232 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory Web应用程序目录[/usr/local/Apache/apache-tomcat-9.0.39/webapps/docs]的部署已在[69]毫秒内完成15-Oct-2020 13:49:22.232 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory 把web 应用程序部署到目录 [/usr/local/Apache/apache-tomcat-9.0.39/webapps/examples]15-Oct-2020 13:49:23.294 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory Web应用程序目录[/usr/local/Apache/apache-tomcat-9.0.39/webapps/examples]的部署已在[1,062]毫秒内完成15-Oct-2020 13:49:23.295 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory 把web 应用程序部署到目录 [/usr/local/Apache/apache-tomcat-9.0.39/webapps/host-manager]15-Oct-2020 13:49:23.347 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory Web应用程序目录[/usr/local/Apache/apache-tomcat-9.0.39/webapps/host-manager]的部署已在[52]毫秒内完成15-Oct-2020 13:49:23.348 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory 把web 应用程序部署到目录 [/usr/local/Apache/apache-tomcat-9.0.39/webapps/manager]15-Oct-2020 13:49:23.410 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory Web应用程序目录[/usr/local/Apache/apache-tomcat-9.0.39/webapps/manager]的部署已在[63]毫秒内完成15-Oct-2020 13:49:23.429 信息 [main] org.apache.coyote.AbstractProtocol.start 开始协议处理句柄[&quot;http-nio-8080&quot;]15-Oct-2020 13:49:23.456 信息 [main] org.apache.catalina.startup.Catalina.start [2211]毫秒后服务器启动 1.1.4. 测试访问 1、如果你的CentOS安装了Linux界面，那么可以在Linux界面系统中打开浏览器输入访问地址 http:&#x2F;&#x2F;虚拟机ip地址或者localhost:8080&#x2F; （如果不知道自己虚拟机IP是多少，可以通过命令ifconfig查看） 访问举例：http://192.168.6.88:8080/ http://localhost:8080/ 2、外部实体测试访问。 如果是外部主机想要访问Linux部署的Tomcat，必须使用ip访问，且需要直接关闭Linux防火墙。 123####关闭防火墙[root@localhost bin]# service firewalld stopRedirecting to /bin/systemctl stop firewalld.service 测试访问：http://192.168.6.88:8080/ 问题：防火墙是拦截规则加强系统安全的，Linux作为服务器主机使用，我们不建议关闭防火墙。可以通过为防火墙加设开放端口，实现允许外部访问。 如果是阿里云服务器，则需要保证阿里云的安全组策略是开放的！ （阿里云服务器部署问题，请参考：） 配置防火墙加设开放端口，开启Linux的防火墙服务： 12345678910111213141516171819#查看firewall(防火墙)服务状态systemctl status firewall #开启、重启、关闭、firewalld.service服务#开启防火墙service firewalld start#重启防火墙service firewalld restart#关闭防火墙service firewalld stop#########查看防火墙规则firewall-cmd --list-all #查看全部信息firewall-cmd --list-ports #只看端口信息#########添加防火墙开放端口开端口命令: firewall-cmd --zone=public --add-port=8080/tcp --permanent重启防火墙: systemctl restart firewalld.service命令含义: --zone #作用域（public标识公共的） --add-port=80/tcp #添加端口， 格式为:端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 注意：加设防火墙开放端口中firewall-cmd是一个完整的命令，中间没有空格！（温馨提示，上面的命令中没有数字，如果你怕手敲错误，建议复制！） 3、加设防火墙开放端口后，测试访问 访问地址举例：http://192.168.6.88:8080/ 1.1.5. 附录（Tomcat自启配置） 1、Tomcat配置服务 新建服务脚本： 11 [root@localhost ~]# vim /etc/init.d/tomcat 输入i、I、a等任意一个进入编辑模式，添加脚本内容： 1234567891011121314151617181920212223#!/bin/bash# description: Tomcat7 Start Stop Restart# processname: tomcat7# chkconfig: 234 20 80CATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.11case $1 in start) sh $CATALINA_HOME/bin/startup.sh ;; stop) sh $CATALINA_HOME/bin/shutdown.sh ;; restart) sh $CATALINA_HOME/bin/shutdown.sh sh $CATALINA_HOME/bin/startup.sh ;; *) echo &#x27;please use : tomcat &#123;start | stop | restart&#125;&#x27; ;;esacexit 0 按ESC退出编辑输入命令 :wq 保存脚本。 执行脚本，启动、停止 和 重启服务。 启动：service tomcat start 停止：service tomcat stop 重启：service tomcat restart 2、Tomcat配置开机自启动 向chkconfig添加 tomcat 服务的管理 1[root@localhost ~]# chkconfig --add tomcat 设置tomcat服务自启动 1[root@localhost ~]# chkconfig tomcat on 查看tomcat的启动状态 123456[root@localhost ~]# chkconfig --list | grep tomcat状态如下：[root@localhost ~]# chkconfig --list | grep tomcattomcat 0:off 1:off 2:on 3:on 4:on 5:on 6:off 关闭tomcat服务自启动：chkconfig tomcat off 删除tomcat服务在chkconfig上的管理：chkconfig –del tomcat 2. Tomcat 启动web项目使用说明2.1. 引入War包1、将War包拷贝到tomact&#x2F;webapps目录下； 2、运行tomact,会自动解压war包； 3、地址栏访问。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://guoshunfa.com/tags/Tomcat/"}]},{"title":"Web组件库 JS组件方法记录","slug":"软件开发/技术/服务&组件/web组件库/Web组件库JS组件方法记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.264Z","comments":true,"path":"2022/07/Web组件库JS组件方法记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Web%E7%BB%84%E4%BB%B6%E5%BA%93JS%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/","excerpt":"","text":"以折叠面板的形式进行组件描述，点击对应的面板会展示对应信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * @description 将扁平化数据 转换成 树状结构 * @param &#123;Array&#125; arrayList 扁平化的数据 * @param &#123;String&#125; pidStr parentId的key名 * @param &#123;String&#125; idStr id的key名 * @param &#123;String&#125; childrenStr children的key名 */ function fommat(&#123;arrayList, pidStr = &#x27;pid&#x27;, idStr = &#x27;id&#x27;, childrenStr = &#x27;children&#x27;&#125;) &#123; let listOjb = &#123;&#125;; // 用来储存&#123;key: obj&#125;格式的对象 let treeList = []; // 用来储存最终树形结构数据的数组 // 将数据变换成&#123;key: obj&#125;格式，方便下面处理数据 for (let i = 0; i &lt; arrayList.length; i++) &#123; listOjb[arrayList[i][idStr]] = arrayList[i] &#125; // 根据pid来将数据进行格式化 for (let j = 0; j &lt; arrayList.length; j++) &#123; // 判断父级是否存在 let haveParent = listOjb[arrayList[j][pidStr]] if (haveParent) &#123; // 如果有没有父级children字段，就创建一个children字段 !haveParent[childrenStr] &amp;&amp; (haveParent[childrenStr] = []) // 在父级里插入子项 haveParent[childrenStr].push(arrayList[j]) &#125; else &#123; // 如果没有父级直接插入到最外层 treeList.push(arrayList[j]) &#125; &#125; return treeList &#125; // 测试数据 var menu_list = [&#123; id: &#x27;1&#x27;, menu_name: &#x27;设置&#x27;, menu_url: &#x27;setting&#x27;, parent_id: 0 &#125;, &#123; id: &#x27;1-1&#x27;, menu_name: &#x27;权限设置&#x27;, menu_url: &#x27;setting.permission&#x27;, parent_id: &#x27;1&#x27; &#125;, &#123; id: &#x27;1-1-1&#x27;, menu_name: &#x27;用户管理列表&#x27;, menu_url: &#x27;setting.permission.user_list&#x27;, parent_id: &#x27;1-1&#x27; &#125;, &#123; id: &#x27;1-1-2&#x27;, menu_name: &#x27;用户管理新增&#x27;, menu_url: &#x27;setting.permission.user_add&#x27;, parent_id: &#x27;1-1&#x27; &#125;, &#123; id: &#x27;1-1-3&#x27;, menu_name: &#x27;角色管理列表&#x27;, menu_url: &#x27;setting.permission.role_list&#x27;, parent_id: &#x27;1-1&#x27; &#125;, &#123; id: &#x27;1-2&#x27;, menu_name: &#x27;菜单设置&#x27;, menu_url: &#x27;setting.menu&#x27;, parent_id: &#x27;1&#x27; &#125;, &#123; id: &#x27;1-2-1&#x27;, menu_name: &#x27;菜单列表&#x27;, menu_url: &#x27;setting.menu.menu_list&#x27;, parent_id: &#x27;1-2&#x27; &#125;, &#123; id: &#x27;1-2-2&#x27;, menu_name: &#x27;菜单添加&#x27;, menu_url: &#x27;setting.menu.menu_add&#x27;, parent_id: &#x27;1-2&#x27; &#125;, &#123; id: &#x27;2&#x27;, menu_name: &#x27;订单&#x27;, menu_url: &#x27;order&#x27;, parent_id: 0 &#125;, &#123; id: &#x27;2-1&#x27;, menu_name: &#x27;报单审核&#x27;, menu_url: &#x27;order.orderreview&#x27;, parent_id: &#x27;2&#x27; &#125;, &#123; id: &#x27;2-2&#x27;, menu_name: &#x27;退款管理&#x27;, menu_url: &#x27;order.refundmanagement&#x27;, parent_id: &#x27;2&#x27; &#125;, &#123; id: &#x27;2-2-1&#x27;, menu_name: &#x27;退款管理2-1&#x27;, menu_url: &#x27;order.refundmanagement&#x27;, parent_id: &#x27;2-2&#x27; &#125; ] // 输出 console.log( fommat(&#123; arrayList: menu_list, pidStr: &#x27;parent_id&#x27; &#125;) )","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/tags/HTML-CSS-JavaScript/"},{"name":"组件库","slug":"组件库","permalink":"https://guoshunfa.com/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"Web组件库 PubSubJS 消息发布订阅","slug":"软件开发/技术/服务&组件/web组件库/Web组件库PubSubJS消息发布订阅","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.264Z","comments":true,"path":"2022/07/Web组件库PubSubJS消息发布订阅/","link":"","permalink":"https://guoshunfa.com/2022/07/Web%E7%BB%84%E4%BB%B6%E5%BA%93PubSubJS%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"前往 Github 1. PubSubJS 介绍PubSubJS是一个用JavaScript编写的基于主题的发布&#x2F;订阅库。 PubSubJS具有同步解耦，因此主题是异步发布的。这有助于保持程序的可预测性，因为在消费者处理主题时，主题的发起者不会被阻止。 对于冒险家来说，PubSubJS还支持同步主题发布。这可能会在某些环境中（浏览器，不是所有环境）加快速度，但也可能导致一些非常难以推理的程序，即一个主题触发同一执行链中另一个主题的发布。 单一流程PubSubJS旨在用于单个进程，不是多进程应用程序（如Node.js – 具有许多子进程的集群）的好候选程序。如果您的Node.js应用程序是一个单一的进程应用程序，那么您就很好。如果它是（或将要）一个多进程应用程序，您可能最好使用redis Pub&#x2F;Sub或类似 主要功能 无依赖项 同步解耦 ES3兼容。PubSubJS应该能够在可以执行JavaScript的任何地方运行。浏览器、服务器、电子书阅读器、旧手机、游戏机。 AMD&#x2F;CommonJS模块支持 不修改订阅者（jQuery自定义事件修改订阅者） 易于理解和使用（感谢同步解耦） 小（略号），小于1kb的缩小和gzipped 2. 安装}}有几种方法可以获取PubSubJS 通过npm安装（npm install pubsub-js） 通过yarn安装（yarn add pubsub-js） 直接从CDN使用 http://www.jsdelivr.com/#!pubsubjs https://cdnjs.com/libraries/pubsub-js https://unpkg.com/pubsub-js 从GitHub下载标记版本 3. 导入1234import PubSub from &#x27;pubsub-js&#x27;// or when using CommonJSconst PubSub = require(&#x27;pubsub-js&#x27;); 4. API 使用4.1. 基本示例12345678910111213141516//创建一个订阅主题的函数var mySubscriber = (msg,data)=&gt;&#123;console.log(msg,data)&#125;// 将该功能添加到特定主题的订阅者列表中// 我们保留了返回的令牌，以便能够取消订阅// 从后面的主题开始var token = PubSub.subscribe(&#x27;MY TOPIC&#x27;, mySubscriber);//异步发布主题PubSub.publish(&quot;MY TOPIC&quot;, &quot;你好，世界！&quot;);//同步发布主题，这在某些环境中更快，// 但当一个主题触发了// 相同的执行链// 小心使用，这是龙！！！PubSub.publishSync(&quot;MY TOPIC&quot;,&quot;你好，世界！&quot;); 4.2. 取消特定订阅12345678910//创建一个函数来接收主题var mySubscriber = (msg,data)=&gt;&#123;console.log(msg,data)&#125;//将该函数添加到特定主题的订阅者列表中// 我们保留了返回的令牌，以便能够取消订阅// 从后面的主题开始var token = PubSub.subscribe(&#x27;MY TOPIC&#x27;, mySubscriber);//取消订阅此订阅者此主题PubSub.unsubscribe(token); 4.3. 取消功能的所有订阅12345//创建一个函数来接收主题var mySubscriber = (msg,data)=&gt;&#123;console.log(msg,data)&#125;//取消订阅mySubscriber的所有主题PubSub.unsubscribe(mySubscriber); 4.4. 清除主题的所有订阅1234567PubSub.subscribe(&#x27;a&#x27;, myFunc1);PubSub.subscribe(&#x27;a.b&#x27;, myFunc2);PubSub.subscribe(&#x27;a.b.c&#x27;, myFunc3);PubSub.unsubscribe(&#x27;a.b&#x27;);// 没有关于“a.b”和“a.b.c”主题的进一步通知//“a”的通知仍将发布 4.5. 清除所有订阅12PubSub.clearAllSubscriptions();// 所有订阅均已删除 4.6. 获取订阅12PubSub.getSubscriptions(&#x27;token&#x27;);// 按代币从所有主题订阅 4.7. 计数订阅12PubSub.countSubscriptions(&#x27;token&#x27;);// 按所有主题的令牌计数 4.8. 错误处理12345// isPublished是一个布尔值，表示是否有订阅者注册了此主题var isPublished = PubSub.publish(&#x27;a&#x27;);// 如果出现问题，且订阅者未注册，令牌将是假的var token = PubSub.subscribe(&#x27;MY TOPIC&#x27;, mySubscriber); 4.9. 分层寻址12345678910111213141516171819202122232425//创建一个订阅者，从主题层次结构中接收所有主题var myToplevelSubscriber = 函数（msg，数据）&#123; console.log（&#x27;顶层：&#x27;，msg，数据）；&#125;//订阅“汽车”层次结构中的所有主题PubSub.subscribe（“car”，myToplevelSubscriber）；//创建一个订阅者，仅接收来自层次结构操作主题的叶子主题var mySpecificSubscriber = function（msg，数据）&#123; console.log(&#x27;specific: &#x27;, msg, data);&#125;// 仅订阅“car.drive”主题PubSub.subscribe(&#x27;car.drive&#x27;, mySpecificSubscriber);// 发布一些主题PubSub.publish(&#x27;car.purchase&#x27;, &#123;name: &#x27;我的新车&#x27;&#125;);PubSub.publish(&#x27;car.drive&#x27;, &#123;speed: &#x27;14&#x27;&#125;);PubSub.publish(&#x27;car.sell&#x27;, &#123;newOwner: &#x27;其他人&#x27;&#125;);// 在这种情况下，将调用myToplevelSubscriber for all//主题，总共三次// 但是，mySpecificSubscriber只会被调用一次，因为它只//订阅“car.drive”主题 5. 提示对主题使用“常量”，而不是字符串文本。PubSubJS使用字符串作为主题，并将很高兴尝试将您的主题与任何主题一起交付。因此，当您进行错别字时，让JavaScript引擎抱怨，从而避免沮丧的调试。 5.1. 使用“常量”的示例1234567891011121314// 👎 坏的使用PubSub.subscribe(&#x27;hello&#x27;, function (msg, data) &#123; console.log(data)&#125;);PubSub.publish(&#x27;hello&#x27;, &#x27;world&#x27;);// 👍 就得这么用var MY_TOPIC = &#x27;hello&#x27;;PubSub.subscribe(MY_TOPIC, function (msg, data) &#123; console.log(data)&#125;);PubSub.publish(MY_TOPIC, &#x27;world&#x27;); 5.2. 使用ES6&#x2F;7语法的“符号常数”示例12345678910// event-types.jsexport const MY_TOPIC = Symbol(&#x27;MY_TOPIC&#x27;)// somefile.jsimport &#123; MY_TOPIC &#125; from &#x27;./event-types.js&#x27;PubSub.subscribe(MY_TOPIC, function (msg, data) &#123; console.log(data)&#125;);PubSub.publish(MY_TOPIC, &#x27;world&#x27;); 5.3. 开发者工具中堆栈跟踪的即时例外从1.3.2版本开始，您可以强制立即异常（而不是延迟异常），这的好处是在开发工具中查看时保持堆栈跟踪。 这应该被视为仅开发选项，因为PubSubJS旨在尝试将您的主题交付给所有订阅者，即使有些订阅者失败。 在开发中设置即时异常很容易，只需在加载后告诉PubSubJS。 1PubSub.immediateExceptions = true; 6. 替代方案这些是几个替代项目，也在JavaScript中实现基于主题的发布订阅。 http://www.joezimjs.com/projects/publish-subscribe-jquery-plugin/ http://amplifyjs.com/api/pubsub/ http://radio.uxder.com/ — 面向“渠道”，没有依赖性 https://github.com/pmelander/Subtopic - 支持香草、下划线、jQuery，甚至可以在NuGet中提供 参考文档 PubSubJS github readme文档直译","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/tags/HTML-CSS-JavaScript/"},{"name":"PubSubJS","slug":"PubSubJS","permalink":"https://guoshunfa.com/tags/PubSubJS/"}]},{"title":"Web组件库 iframe引入各平台视频","slug":"软件开发/技术/服务&组件/web组件库/Web组件库iframe引入各平台视频","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.265Z","comments":true,"path":"2022/07/Web组件库iframe引入各平台视频/","link":"","permalink":"https://guoshunfa.com/2022/07/Web%E7%BB%84%E4%BB%B6%E5%BA%93iframe%E5%BC%95%E5%85%A5%E5%90%84%E5%B9%B3%E5%8F%B0%E8%A7%86%E9%A2%91/","excerpt":"","text":"1. 引入B站视频1.1. 效果 代码： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=420367466&amp;bvid=BV1N3411q7z7&amp;cid=401728312&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;width: 100%;height: 500px;max-width: 100%;align: center;padding: 20px 0;&quot;&gt; &lt;/iframe&gt; 1.2. 实现找到B站视频下方分享，将嵌入代码放入源代码中即可展示B站视频。 例： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=420367466&amp;bvid=BV1N3411q7z7&amp;cid=401728312&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 1.2.1. 参数描述（src） key 说明 aid 之前 B 站使用的 AV 号 bvid 目前的 BV 号 page 第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频 as_wide 是否宽屏 【1: 宽屏, 0: 小屏】 high_quality 是否高清 【1: 高清(最高1080p) &#x2F; 0: 最低视频质量(默认)】 danmaku 是否开启弹幕 【1: 开启(默认), 0: 关闭】 1.2.2. 调整样式123456789&lt;style scoped lang=&#x27;stylus&#x27;&gt;iframe &#123; width: 100%; height: 500px; max-width: 100%; align: center; padding: 20px 0;&#125;&lt;/style&gt; 最终效果： 2. 引入腾讯视频 与B站视频同理，引入内嵌代码即可查看视频。 2.1. 效果 代码： 1&lt;iframe frameborder=&quot;0&quot; src=&quot;https://v.qq.com/iframe/player.html?vid=v3270e4uem9&quot; allowFullScreen=&quot;true&quot; style=&quot;width: 100%;height: 500px;max-width: 100%;align: center;padding: 20px 0;&quot;&gt;&lt;/iframe&gt; 2.2. 实现2.2.1. 参数描述 key 说明 vid 视频唯一值 2.2.1.1. 去广告有广告： 1&lt;center&gt;&lt;iframe frameborder=&quot;0&quot; src=&quot;https://v.qq.com/txp/iframe/player.html?vid=h30676epxvg&quot; width=&quot;100%&quot; height=&quot;240&quot;&gt;&lt;/iframe&gt;&lt;/center&gt; 无广告： 1&lt;center&gt;&lt;iframe frameborder=&quot;0&quot; src=&quot;https://v.qq.com/iframe/player.html?vid=h30676epxvg&quot; width=&quot;100%&quot; height=&quot;240&quot;&gt;&lt;/iframe&gt;&lt;/center&gt; 地址去掉&#x2F;txp，可关闭广告。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"iframe","slug":"iframe","permalink":"https://guoshunfa.com/tags/iframe/"}]},{"title":"RSA 算法","slug":"软件开发/技术/理论/加密/RSA算法","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/RSA算法/","link":"","permalink":"https://guoshunfa.com/2022/07/RSA%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. RSA 算法介绍 非对称加密，即：PK（PUBLIC_KEY 公钥） 与 SK（ SECRET_KEY 密钥） 不是同一个。 PK 加密时，必须用 SK 解密、反之 SK 加密时，必须用 PK 解密。 PK 决定 SK，但是 PK 很难算出 SK（数学原理：两个大质数相乘，积很难因式分解）。 速度慢，适合对少量数据加密。 2. Java 使用RSA算法 这里的例子 公钥私钥中使用了外在key，获取&#x2F;生成公钥私钥时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185import org.apache.tomcat.util.codec.binary.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import javax.crypto.Cipher;import java.security.*;import java.security.spec.EncodedKeySpec;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;/** * RSA 非对称加密工具类。 * 1、公钥（PUBLIC_KEY）、私钥：PRIVATE_KEY 必须分开使用，比如公钥加密时，必须是私钥解密，反之私钥加密时，必须是公钥解密 */public class CipherRsaUtils &#123; /** * CIPHER_TRANSFORMS : cipher 实例化时的 加密算法/反馈模式/填充方案。ECB 表示无向量模式 * ALGORITHM: 创建密钥时使用的算法 * KEY_PAIR_LENGTH: 秘钥对长度。数值越大，能加密的内容就越大。 * &lt;p&gt; * 如 KEY_PAIR_LENGTH 为 1024 时加密数据的长度不能超过 117 字节 * 如 KEY_PAIR_LENGTH 为 2048 时加密数据的长度不能超过 245 字节 * 依次类推 * &lt;/p&gt; */ private static final String CIPHER_TRANSFORMS = &quot;RSA/ECB/PKCS1Padding&quot;; private static final int KEY_PAIR_LENGTH = 1024; /** * 生成 RSA 密钥对：公钥（PUBLIC_KEY）、私钥：PRIVATE_KEY * * @param secureRandomSeed ：SecureRandom 随机数生成器的种子，只要种子相同，则生成的公钥、私钥就是同一对. * &lt;p&gt;randomSeed 长度可以自定义，加/解密必须是同一个.&lt;/p&gt; * @return */ public static KeyPair generateRsaKeyPair(String secureRandomSeed) &#123; //KeyPair 是密钥对（公钥和私钥）的简单持有者。加密、解密都需要使用. KeyPair keyPair = null; try &#123; //获取生成 RSA 加密算法的公钥/私钥对 KeyPairGenerator 对象 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //获取实现指定算法（SHA1PRNG）的随机数生成器（RNG）对象. SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); //重新设定此随机对象的种子. secureRandom.setSeed(secureRandomSeed.getBytes()); /** * initialize(int keySize, SecureRandom random):使用给定的随机源（random）初始化特定密钥大小的密钥对生成器。 * keySize: 健的大小值，这是一个特定于算法的度量。值越大，能加密的内容就越多，否则会抛异常：javax.crypto.IllegalBlockSizeException: Data must not be longer than xxx bytes * 如 keySize 为 2048 时加密数据的长度不能超过 245 字节。 */ keyPairGenerator.initialize(KEY_PAIR_LENGTH, secureRandom); //genKeyPair(): 生成密钥对 keyPair = keyPairGenerator.genKeyPair(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return keyPair; &#125; /** * 使用私钥（PrivateKey）对数据进行加密 或 解密 * * @param content :待加/解密的数据。如果待解密的数据，则是 Base64 编码后的可视字符串. * @param model ：1 表示加密模式（Cipher.ENCRYPT_MODE），2 表示解密模式（Cipher.DECRYPT_MODE） * @param secureRandomSeed ：SecureRandom 随机数生成器的种子，只要种子相同，则生成的公钥、私钥就是同一对. * 加解密必须是同一个. * @return ：返回加/解密后的数据，如果是加密，则将字节数组使用 Base64 转为可视字符串. */ public static String cipherByPrivateKey(String content, int model, String secureRandomSeed) &#123; String result = &quot;&quot;; try &#123; //获取 RSA 密钥对 KeyPair keyPair = generateRsaKeyPair(secureRandomSeed); /**getPrivate()：获取密钥对的私钥。 * getEncoded(): 返回已编码的密钥，如果密钥不支持编码，则返回 null*/ byte[] privateEncoded = keyPair.getPrivate().getEncoded(); /**PKCS8EncodedKeySpec(byte[] encodedKey): 使用给定的编码密钥创建新的 PKCS8EncodedKeySpec * PKCS8EncodedKeySpec 表示 ASN.1 号私钥的编码*/ EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(privateEncoded); //创建 KeyFactory 对象，用于转换指定算法(RSA)的公钥/私钥。 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //从提供的密钥规范生成私钥对象 PrivateKey keyPrivate = keyFactory.generatePrivate(encodedKeySpec); //实例化 Cipher 对象。 result = encryptionDecryption(content, model, keyPrivate); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 使用公钥（PublicKey）对数据进行加密 或 解解 * * @param content :待加解密的数据 * @param model ：1 表示加密模式（Cipher.ENCRYPT_MODE），2 表示解密模式（Cipher.DECRYPT_MODE） * @param secureRandomSeed ：SecureRandom 随机数生成器的种子，只要种子相同，则生成的公钥、私钥就是同一对. * 加解密必须是同一个. * @return :返回加密 或者 解密后的数据 */ public static String cipherByPublicKey(String content, int model, String secureRandomSeed) &#123; String result = &quot;&quot;; try &#123; // 得到公钥 KeyPair keyPair = generateRsaKeyPair(secureRandomSeed); EncodedKeySpec keySpec = new X509EncodedKeySpec(keyPair.getPublic().getEncoded()); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PublicKey keyPublic = keyFactory.generatePublic(keySpec); // 数据加/解密 result = encryptionDecryption(content, model, keyPublic); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 加密或解密 * * @param content :待加解密的数据 * @param model ：1 表示加密模式（Cipher.ENCRYPT_MODE），2 表示解密模式（Cipher.DECRYPT_MODE） * @param key ：公钥（PUBLIC_KEY）或 私钥（PRIVATE_KEY）的 key * @return */ private static String encryptionDecryption(String content, int model, Key key) &#123; String result = &quot;&quot;; try &#123; Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMS); //init(int opMode, Key key)：初始化 Cipher. cipher.init(model, key); //如果是解密模式，则需要使用 Base64 进行解码. byte[] contentBytes = content.getBytes(); if (model == Cipher.DECRYPT_MODE) &#123; contentBytes = new BASE64Decoder().decodeBuffer(content); &#125; /**执行加密 或 解密操作。如果 contentBytes 内容过长，则 doFinal 可能会抛出异常. *javax.crypto.IllegalBlockSizeException: Data must not be longer than 245 bytes ：数据不能超过xxx字节 * 此时需要调大 KEY_PAIR_LENGTH 的值*/ byte[] finalBytes = cipher.doFinal(contentBytes); //如果是加密，则将加密后的字节数组使用 Base64 转成可视化的字符串。否则是解密时，直接 new String 字符串. if (model == Cipher.ENCRYPT_MODE) &#123; result = new BASE64Encoder().encode(finalBytes); &#125; else if (model == Cipher.DECRYPT_MODE) &#123; result = new String(finalBytes); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; public static void main(String[] args) &#123; String content = &quot;panda&quot;; String secureRandomSeed = &quot;1646894592726&quot;; System.out.println(&quot;被加密数据字节大小：&quot; + content.getBytes().length + &quot; 字节，&quot; + content.length() + &quot; 个字符&quot;); System.out.println(&quot;源内容：\\n&quot; + content); KeyPair keyPair = generateRsaKeyPair(secureRandomSeed); String publicKey = new String(keyPair.getPublic().getEncoded()); System.out.println(&quot;publicKey:\\n&quot; + publicKey); String publicKeyBase64 = new String(Base64.encodeBase64(keyPair.getPublic().getEncoded())); System.out.println(&quot;publicKeyBase64:\\n&quot; + publicKeyBase64); String privateKeyBase64 = new String(Base64.encodeBase64(keyPair.getPrivate().getEncoded())); System.out.println(&quot;privateKeyBase64:\\n&quot; + privateKeyBase64); try &#123; //公钥、私钥必须分开使用，公钥解密时，必须是私钥解密，反之亦然. String encrypted = CipherRsaUtils.cipherByPublicKey(content, 1, secureRandomSeed); String decrypted = CipherRsaUtils.cipherByPrivateKey(encrypted, 2, secureRandomSeed); System.out.println(&quot;加密后：\\n&quot; + encrypted); System.out.println(&quot;解密后：\\n&quot; + decrypted); String decrypted2 = CipherRsaUtils.cipherByPrivateKey(&quot;j1Jg10GQDqD2G5JQQ/0iuITz60XbIZarXT8SckLwqjy6vwOVzM7U0kDBcSP8cpnJIQnz3zQt/6Igi2GejhCfhuFOB3zD9eJb8qCRwG7xRSadnGyi9gD6RJFQAOHd8hde4ra7XuPL7v7JylM2QzYq2GdZDhRkTiNVEeyPn/+aOJE=&quot;, 2, secureRandomSeed); System.out.println(&quot;over:\\n&quot; + decrypted2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3. H5 使用RSA算法 使用JSEncrypt加密解密 3.1. 导入JSEncrypt包1&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.0.0-rc.1/jsencrypt.min.js&quot;&gt;&lt;/script&gt; 这里也加了npm 加入的方式。 安装 npm i jsencrypt –save 引用 import {JSEncrypt} from ‘jsencrypt’ 3.2. 默认值和方法 3.3. demo12345678910111213141516171819202122232425262728293031// 公钥const publicKey = &#x27;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQChJ0KXUmAiLImRWXlqxwKNDjYxRqKHNzMIHNSISsYAERxuK7T9NsJezONsOFeao4gIpTlvtuTnF8/L+d17GNGeIp4cJLO+NMj6RO6N+YJPKMsST/8beVu3sY6kNKy74QzkRXNfyOk/bWXnAPUxO/HjzqYtxetOpQL2pzYxGIysyQIDAQAB&#x27;;// 私钥const privateKey = &#x27;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKEnQpdSYCIsiZFZeWrHAo0ONjFGooc3Mwgc1IhKxgARHG4rtP02wl7M42w4V5qjiAilOW+25OcXz8v53XsY0Z4inhwks740yPpE7o35gk8oyxJP/xt5W7exjqQ0rLvhDORFc1/I6T9tZecA9TE78ePOpi3F606lAvanNjEYjKzJAgMBAAECgYBjIDsdyVXIr4yPE3JT88Xl7e/3r3MZqSKCwvkYPKY+NEhAnDHf72bv2Seq0Z1RSXXLm5YQ2XdDjqoK1c8egM2uc44eeLGQzygB7IseA1I1wRcuaUVt59KhbRvcWTaK5fLaZ6lad+l/TXfk9Bq5tQEs11lLt1UdRXdDW41pH6OvgQJBAOg4IG4A96aU71TAs1GiGDuLq+pbXD41cn63V2v0Pawli8Kn7wBGgl4l3m3bb+iHJH/IlgQUpD1dtIyhU2zGux0CQQCxqBDoB02wVpUYbzjoFyBmVRiqGULhhz8nlG7XVXNOXuJ6VmAPr1fDdMCcc1YHs3yMc5jE7qqkesf0K0QcK9ydAkBysMXTjsbBj21k/oeSGey9/A28gcLdNqiFzSdwOgD7tM+CJE72Y9yfgzSILYjn31c3hWoSOd+kL1Os4UDCyKRBAkAUrYcqOo9kUu+PpIJvISH4RzdTtRT/wwoqxTARiDSfjpO1wY/0w2fnrBMvIo2E3/NDNcE2SsE528CiPtbyoHhRAkEArzj8fy2T927A08bXv2pmbI7/joQ2GqcIiOA940Cl8B+dTg+GxKuHqJisy4hYJ+3LyWmSVbIGahRoAUKv7yssRg==&#x27;;// 密码const password = &quot;pandacode&quot;;// 加密后的密码const encryptPwd = encrypt(password);// 解密后的密码const decryptPwd = decrypt(encryptPwd);console.log(&quot;公钥：&quot; + publicKey);console.log(&quot;私钥：&quot; + privateKey);console.log(&quot;原密码：&quot; + password);console.log(&quot;密码加密后：&quot; + encryptPwd);console.log(&quot;密码解密后：&quot; + decryptPwd);// 加密function encrypt(msg) &#123; let jsencrypt = new JSEncrypt() jsencrypt.setPublicKey(publicKey) return jsencrypt.encrypt(msg)&#125;// 解密function decrypt(msg) &#123; let jsencrypt = new JSEncrypt() jsencrypt.setPrivateKey(privateKey) const decryptMsg = jsencrypt.decrypt(msg) return decryptMsg&#125; 参考文档 Java 加密扩展（JCE）框架 之 Cipher 加密与解密","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"加密","slug":"加密","permalink":"https://guoshunfa.com/tags/%E5%8A%A0%E5%AF%86/"}]},{"title":"加密算法介绍","slug":"软件开发/技术/理论/加密/加密算法介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/加密算法介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"加密算法介绍1. 数字签名数字签名，简单来说就是通过提供 可鉴别 的 数字信息 验证 自身身份 的一种方式。一套 数字签名 通常定义两种 互补 的运算，一个用于 签名，另一个用于 验证。分别由 发送者 持有能够 代表自己身份 的 私钥 (私钥不可泄露),由 接受者 持有与私钥对应的 公钥 ，能够在 接受 到来自发送者信息时用于 验证 其身份。 注意：图中 加密过程 有别于 公钥加密，更多 介绍戳这里。签名 最根本的用途是要能够唯一 证明发送方的身份，防止 中间人攻击、CSRF 跨域身份伪造。基于这一点在诸如 设备认证、用户认证、第三方认证 等认证体系中都会使用到 签名算法 (彼此的实现方式可能会有差异)。 2. 加密和解密2.1. 加密数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为 “密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。 2.2. 解密加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。 3. 对称加密和非对称加密加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 不需要密钥 的 散列算法。 常见的 对称加密 算法主要有 DES、3DES、AES 等，常见的 非对称算法 主要有 RSA、DSA 等，散列算法 主要有 SHA-1、MD5 等。 3.1. 对称加密对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。 数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。 数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。 3.2. 非对称加密非对称加密算法，又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。 因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。 如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。 如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。 例子：甲方生成 一对密钥 并将其中的一把作为 公钥 向其它人公开，得到该公钥的 乙方 使用该密钥对机密信息 进行加密 后再发送给甲方，甲方再使用自己保存的另一把 **专用密钥 (私钥)**，对 加密 后的信息 进行解密。 4. 常用加密算法4.1. 常用算法描述 加密算法 描述 SHA1 SHA1 是 消息摘要算法，SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。 BASE64 1、BASE64 有自己的编码表，可编码，也可解码；解码后能得到源内容。2、BASE64 编码的长度是不固定的，随着源字符串的增加而增加。3、在某些不方便使用中文的地方，可以通过 BASE64 编码成可见字符，需要中文时再解码回来即可，比如 url 地址，或者 Cookie. MD5 信息摘要是安全的单向哈希函数，对大小的信息输出固定长度的哈希值，单向加密、数据不可逆。摘要好比指纹，每个人都是唯一的，相同的源数据，摘要也一样，不同的数据，摘要则不一样。摘要只是源数据的局部，所以想要解码回去恢复整个源数据是不行的，因为是不完整的。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。 DES Data Encrytion Standard（数据加密标准) , 特点：1. 对称加密 2. 同一个 SECRET_KEY（密钥） AES Advanced Encrytion Standard（高级加密标准），特点：1. 对称加密 2. 一个 SECRET_KEY（密钥）扩展成多个子 SK，轮加密 RSA RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。1. 非对称加密，即：PK（PUBLIC_KEY 公钥） 与 SK（ SECRET_KEY 密钥） 不是同一个 2. PK 加密时，必须用 SK 解密、反之 SK 加密时，必须用 PK 解密。3. PK 决定 SK，但是 PK 很难算出 SK（数学原理：两个大质数相乘，积很难因式分解）4. 速度慢，适合对少量数据加密 4.2. 常用算法对比4.2.1. 散列算法比较 名称 安全性 速度 SHA-1 高 慢 MD5 中 快 4.2.2. 对称加密算法比较 名称 密钥名称 运行速度 安全性 资源消耗 DES 56位 较快 低 中 3DES 112位或168位 慢 中 高 AES 128、192、256位 快 高 低 4.2.3. 非对称加密算法比较 名称 成熟度 安全性 运算速度 资源消耗 RSA 高 高 中 中 ECC 高 高 慢 高 4.3. 对称算法与非对称加密算法4.3.1. 对称算法密钥管理：比较难，不适合互联网，一般用于内部系统 安全性：中 加密速度：快好 几个数量级 (软件加解密速度至少快 100 倍，每秒可以加解密数 M 比特 数据)，适合大数据量的加解密处理 4.3.2. 非对称算法密钥管理：密钥容易管理 安全性：高 加密速度：比较慢，适合 小数据量 加解密或数据签名 参考文档 浅谈常见的七种加密算法及实现 Java 加密扩展（JCE）框架 之 Cipher 加密与解密","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"加密","slug":"加密","permalink":"https://guoshunfa.com/tags/%E5%8A%A0%E5%AF%86/"}]},{"title":"Leetcode第1题 两数之和","slug":"软件开发/技术/算法/leetcode/Leetcode第1题-两数之和","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/Leetcode第1题-两数之和/","link":"","permalink":"https://guoshunfa.com/2022/07/Leetcode%E7%AC%AC1%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"🌟题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 🐂 解题方法1⃣️ 方法一： 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0 ; i &lt;= nums.length; i++) &#123; if (map.containsKey(target - nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return new int[]&#123;&#125;; &#125;&#125; 🙏 感谢 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://guoshunfa.com/tags/Leetcode/"}]},{"title":"Leetcode第217题 存在重复元素","slug":"软件开发/技术/算法/leetcode/Leetcode第217题-存在重复元素","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/Leetcode第217题-存在重复元素/","link":"","permalink":"https://guoshunfa.com/2022/07/Leetcode%E7%AC%AC217%E9%A2%98-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"🌟 题目描述给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 示例 1： 12输入：nums = [1,2,3,1]输出：true 示例 2： 12输入：nums = [1,2,3,4]输出：false 示例 3： 12输入：nums = [1,1,1,3,3,4,3,2,4,2]输出：true 提示： 1 &lt;&#x3D; nums.length &lt;&#x3D; 105 -109 &lt;&#x3D; nums[i] &lt;&#x3D; 109 🐂 解题方法1⃣️ 方法一：哈希表对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。 1234567891011class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; datas = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length ; i++) &#123; if (!datas.add(nums[i]))&#123; return true; &#125; &#125; return false; &#125;&#125; 复杂度分析 时间复杂度：O(N)，其中 N 为数组的长度。 空间复杂度：O(N)，其中 N 为数组的长度。 🙏 感谢 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://guoshunfa.com/tags/Leetcode/"}]},{"title":"Leetcode第278题 第一个错误的版本","slug":"软件开发/技术/算法/leetcode/Leetcode第278题-第一个错误的版本","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/Leetcode第278题-第一个错误的版本/","link":"","permalink":"https://guoshunfa.com/2022/07/Leetcode%E7%AC%AC278%E9%A2%98-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/","excerpt":"","text":"🌟 题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 1234567输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 示例 2： 12输入：n = 1, bad = 1输出：1 提示： 1 &lt;= bad &lt;= n &lt;= 231 - 1 🐂 解题方法1⃣️ 方法一：二分查找因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。 注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。 具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。 这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。 12345678910111213141516171819202122/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; if (n == 1) return n; int l = 1; int r = n; while(l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); if (isBadVersion(m)) &#123; r = m; &#125; else &#123; l = m + 1; &#125; &#125; return l; &#125;&#125; 复杂度分析 时间复杂度： O(logn)，其中 n 是给定版本的数量。空间复杂度： O(1)。我们只需要常数的空间保存若干变量。 🙏 感谢 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://guoshunfa.com/tags/Leetcode/"}]},{"title":"Leetcode第35题 搜索插入位置","slug":"软件开发/技术/算法/leetcode/Leetcode第35题-搜索插入位置","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/Leetcode第35题-搜索插入位置/","link":"","permalink":"https://guoshunfa.com/2022/07/Leetcode%E7%AC%AC35%E9%A2%98-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"🌟 题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 示例 4: 12输入: nums = [1,3,5,6], target = 0输出: 0 示例 5: 12输入: nums = [1], target = 0输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 🐂 解题方法1⃣️ 方法一：二分查找假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在O(log n) 的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。考虑这个插入的位置pos，它成立的条件为： nums[pos−1]&lt;target≤nums[pos] 其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。 问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 target 的下标 。下文给出的代码是笔者习惯的二分写法，ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是 target 大于数组中的所有数，此时需要插入到数组长度的位置。 12345678910111213141516class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int n = nums.length; int l = 0, r = n - 1; while (l &lt;= r) &#123; int m = l + ((r - l) &gt;&gt; 1); if (nums[m] &gt;= target) &#123; r = m - 1; &#125; else if (nums[m] &lt; target) &#123; l = m + 1; &#125; &#125; return l; &#125;&#125; 复杂度分析 ​ 时间复杂度： O(logn)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(logn)。 ​ 空间复杂度： O(1)。我们只需要常数空间存放若干变量。 🙏 感谢 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://guoshunfa.com/tags/Leetcode/"}]},{"title":"Leetcode第704题 二分查找","slug":"软件开发/技术/算法/leetcode/Leetcode第704题-二分查找","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/07/Leetcode第704题-二分查找/","link":"","permalink":"https://guoshunfa.com/2022/07/Leetcode%E7%AC%AC704%E9%A2%98-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"Leetcode第704题 - 二分查找🌟 题目描述给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 🐂 解题方法1⃣️ 方法一：二分查找 1234567891011121314151617class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; while(left &lt;= right ) &#123; int mi = left + (right-left) /2; if (nums[mi]== target) &#123; return mi; &#125; else if (nums[mi] &gt; target) &#123; right = mi-1; &#125; else if (nums[mi] &lt; target) &#123; left = mi+1; &#125; &#125; return -1; &#125;&#125; 🙏 感谢 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://guoshunfa.com/tags/Leetcode/"}]},{"title":"CSS less 基础","slug":"软件开发/技术/编程语言/css/CSS-less基础","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2022/07/CSS-less基础/","link":"","permalink":"https://guoshunfa.com/2022/07/CSS-less%E5%9F%BA%E7%A1%80/","excerpt":"","text":"中文官网 | 在线less css编译器 在 Node.js 环境中使用 Less ： 1npm install -g less 在浏览器环境中使用 Less ： 12&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js&quot; &gt;&lt;/script&gt; 1. 概览 Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。这里呈现的是 Less 的官方文档（中文版），包含了 Less 语言以及利用 JavaScript 开发的用于将 Less 样式转换成 CSS 样式的 Less.js 工具。 因为 Less 和 CSS 非常像，因此很容易学习。而且 Less 仅对 CSS 语言增加了少许方便的扩展，这就是 Less 如此易学的原因之一。 有关 Less 语言特性的详细文档，请参阅 Less 语言特性 章节 有关 Less 内置函数的列表，请参阅 Less 函数手册 章节 有关详细的使用说明，请参阅 Less.js 用法 章节 有关第三方工具的详细信息，请参阅 工具 章节 Less 到底为 CSS 添加了什么功能？以下就是这些新加功能的概览。 2. 变量（Variables）无需多说，看代码一目了然： 1234567@width: 10px;@height: @width + 10px;#header &#123; width: @width; height: @height;&#125; 编译为： 1234#header &#123; width: 10px; height: 20px;&#125; 了解关于变量的更多信息 3. 混合（Mixins）混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。假设我们定义了一个类（class）如下： 1234.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125; 如果我们希望在其它规则集中使用这些属性呢？没问题，我们只需像下面这样输入所需属性的类（class）名称即可，如下所示： 123456789#menu a &#123; color: #111; .bordered();&#125;.post a &#123; color: red; .bordered();&#125; .bordered 类所包含的属性就将同时出现在 #menu a 和 .post a 中了。（注意，你也可以使用 #ids 作为 mixin 使用。） 了解关于混合（Mixin）的更多信息 4. 嵌套（Nesting）Less 提供了使用嵌套（nesting）代替层叠或与层叠结合使用的能力。假设我们有以下 CSS 代码： 123456789#header &#123; color: black;&#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px;&#125; 用 Less 语言我们可以这样书写代码： 123456789#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &#125;&#125; 用 Less 书写的代码更加简洁，并且模仿了 HTML 的组织结构。 你还可以使用此方法将伪选择器（pseudo-selectors）与混合（mixins）一同使用。下面是一个经典的 clearfix 技巧，重写为一个混合（mixin） (&amp; 表示当前选择器的父级）： 12345678910111213.clearfix &#123; display: block; zoom: 1; &amp;:after &#123; content: &quot; &quot;; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; &#125;&#125; 了解有关夫选择器的详细信息 5. @规则嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡（bubbling）。 123456789101112.component &#123; width: 300px; @media (min-width: 768px) &#123; width: 600px; @media (min-resolution: 192dpi) &#123; background-image: url(/img/retina2x.png); &#125; &#125; @media (min-width: 1280px) &#123; width: 800px; &#125;&#125; 编译为： 123456789101112131415161718.component &#123; width: 300px;&#125;@media (min-width: 768px) &#123; .component &#123; width: 600px; &#125;&#125;@media (min-width: 768px) and (min-resolution: 192dpi) &#123; .component &#123; background-image: url(/img/retina2x.png); &#125;&#125;@media (min-width: 1280px) &#123; .component &#123; width: 800px; &#125;&#125; 6. 运算（Operations）算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换。 1234567891011// 所有操作数被转换成相同的单位@conversion-1: 5cm + 10mm; // 结果是 6cm@conversion-2: 2 - 3cm - 5mm; // 结果是 -1.5cm// conversion is impossible@incompatible-units: 2 + 5px - 3cm; // 结果是 4px// example with variables@base: 5%;@filler: @base * 2; // 结果是 10%@other: @base + @filler; // 结果是 15% 乘法和除法不作转换。因为这两种运算在大多数情况下都没有意义，一个长度乘以一个长度就得到一个区域，而 CSS 是不支持指定区域的。Less 将按数字的原样进行操作，并将为计算结果指定明确的单位类型。 1@base: 2cm * 3mm; // 结果是 6cm 你还可以对颜色进行算术运算： 12@color: #224488 / 2; //结果是 #112244background-color: #112244 + #111; // 结果是 #223355 不过，Less 提供的 色彩函数 更有使用价值。 7. calc() 特例Released v3.0.0 为了与 CSS 保持兼容，calc() 并不对数学表达式进行计算，但是在嵌套函数中会计算变量和数学公式的值。 12@var: 50vh/2;width: calc(50% + (@var - 20px)); // 结果是 calc(50% + (25vh - 20px)) 8. 转义（Escaping）转义（Escaping）允许你使用任意字符串作为属性或变量值。任何 ~&quot;anything&quot; 或 ~&#39;anything&#39; 形式的内容都将按原样输出，除非 interpolation。 123456@min768: ~&quot;(min-width: 768px)&quot;;.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; 编译为： 12345@media (min-width: 768px) &#123; .element &#123; font-size: 1.2rem; &#125;&#125; 注意，从 Less 3.5 开始，可以简写为： 123456@min768: (min-width: 768px);.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; 在 Less 3.5+ 版本中，许多以前需要“引号转义”的情况就不再需要了。 9. 函数（Functions）Less 内置了多种函数用于转换颜色、处理字符串、算术运算等。这些函数在Less 函数手册中有详细介绍。 函数的用法非常简单。下面这个例子将介绍如何利用 percentage 函数将 0.5 转换为 50%，将颜色饱和度增加 5%，以及颜色亮度降低 25% 并且色相值增加 8 等用法： 12345678@base: #f04615;@width: 0.5;.class &#123; width: percentage(@width); // returns `50%` color: saturate(@base, 5%); background-color: spin(lighten(@base, 25%), 8);&#125; 参见：函数手册 10. 命名空间和访问符(不要和 CSS @namespace 或 namespace selectors 混淆了)。 有时，出于组织结构或仅仅是为了提供一些封装的目的，你希望对混合（mixins）进行分组。你可以用 Less 更直观地实现这一需求。假设你希望将一些混合（mixins）和变量置于 #bundle 之下，为了以后方便重用或分发： 123456789101112#bundle() &#123; .button &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white; &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 现在，如果我们希望把 .button 类混合到 #header a 中，我们可以这样做： 1234#header a &#123; color: orange; #bundle.button(); // 还可以书写为 #bundle &gt; .button 形式&#125; 注意：如果不希望它们出现在输出的 CSS 中，例如 #bundle .tab，请将 () 附加到命名空间（例如 #bundle()）后面。 11. 映射（Maps）从 Less 3.5 版本开始，你还可以将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用。 123456789#colors() &#123; primary: blue; secondary: green;&#125;.button &#123; color: #colors[primary]; border: 1px solid #colors[secondary];&#125; 输出符合预期： 1234.button &#123; color: blue; border: 1px solid green;&#125; 参见： 映射（Maps） 12. 作用域（Scope）Less 中的作用域与 CSS 中的作用域非常类似。首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承。 12345678@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125; 与 CSS 自定义属性一样，混合（mixin）和变量的定义不必在引用之前事先定义。因此，下面的 Less 代码示例和上面的代码示例是相同的： 12345678@var: red;#page &#123; #header &#123; color: @var; // white &#125; @var: white;&#125; 参见：懒加载 13. 注释（Comments）块注释和行注释都可以使用： 123456/* 一个块注释 * style comment! */@var: red;// 这一行被注释掉了！@var: white; 14. 导入（Importing）“导入”的工作方式和你预期的一样。你可以导入一个 .less 文件，此文件中的所有变量就可以全部使用了。如果导入的文件是 .less 扩展名，则可以将扩展名省略掉： 12@import &quot;library&quot;; // library.less@import &quot;typo.css&quot;; 参考文档 less 中文官网","categories":[{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/categories/HTML-CSS-JavaScript/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://guoshunfa.com/tags/CSS/"},{"name":"less","slug":"less","permalink":"https://guoshunfa.com/tags/less/"}]},{"title":"Oracle Java Numbers和Strings","slug":"软件开发/技术/编程语言/java/Oracle-Java-Numbers和Strings","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.279Z","comments":true,"path":"2022/07/Oracle-Java-Numbers和Strings/","link":"","permalink":"https://guoshunfa.com/2022/07/Oracle-Java-Numbers%E5%92%8CStrings/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/data/index.html Numbers本节首先讨论number类。lang包及其子类，以及使用这些类的实例化而不是原始数字类型的情况。 本节还介绍了PrintStream和DecimalFormat类，提供了编写格式化数字输出的方法。 最后，Math类。讨论了lang。它包含数学函数来补充语言中内置的运算符。这类有三角函数、指数函数等方法。 Numbers Classes在处理数字时，大多数时候都使用代码中的基元类型。例如： 123int i = 500;float gpa = 3.65f;byte mask = 0x7f; 然而，使用对象代替原语是有原因的，Java平台为每种原语数据类型提供了wrapper类。这些类将基本体“包装”在对象中。通常，如果您在需要对象的地方使用原语，编译器会在其包装类中为您包装原语。类似地，如果在需要基元时使用数字对象，编译器将为您打开该对象。有关详细信息，请参见自动装箱和取消装箱 所有数字包装类都是抽象类“Number”的子类： Note: 这里没有讨论“数字”的其他四个子类BigDecimal和BigInteger用于高精度计算AtomicInteger和AtomicLong用于多线程应用程序。 使用“Number”对象而不是基元有三个原因： 作为需要对象的方法的参数（通常在处理数字集合时使用）。 使用类定义的常量，如“MIN_VALUE”和“MAX_VALUE“，它们提供数据类型的上限和下限。 使用类方法将值转换为其他基元类型和从其他基元转换为字符串，以及在数字系统（十进制、八进制、十六进制、二进制）之间转换。 下表列出了“Number”类的所有子类实现的实例方法。 Method Description byte byteValue()short shortValue()int intValue()long longValue()float floatValue()double doubleValue() 将此“Number”对象的值转换为返回的基元数据类型。 int compareTo(Byte anotherByte)int compareTo(Double anotherDouble)int compareTo(Float anotherFloat)int compareTo(Integer anotherInteger)int compareTo(Long anotherLong)int compareTo(Short anotherShort) 将此“数字”对象与参数进行比较。 boolean equals(Object obj) 确定此数字对象是否等于参数。如果参数不是“null”，并且是具有相同类型和数值的对象，则方法返回“true”。Java API文档中对“Double”和“Float”对象有一些额外的要求。 每个“Number”类包含其他方法，这些方法可用于将数字转换为字符串和从字符串转换为字符串，以及在数字系统之间进行转换。下表列出了“Integer”类中的这些方法。其他“Number”子类的方法类似： Method Description static Integer decode(String s) 将字符串解码为整数。可以接受十进制、八进制或十六进制数字的字符串表示形式作为输入。 static int parseInt(String s) 返回整数（仅限十进制）。 static int parseInt(String s, int radix) 返回一个整数，给定十进制、二进制、八进制或十六进制（“基数”分别等于10、2、8或16）数字的字符串表示形式作为输入。 String toString() 返回表示此“Integer”值的“String”对象。 static String toString(int i) 返回表示指定整数的“字符串”对象。 static Integer valueOf(int i) 返回包含指定基元值的“Integer”对象。 static Integer valueOf(String s) 返回包含指定字符串表示形式值的“Integer”对象。 static Integer valueOf(String s, int radix) 返回一个“Integer”对象，该对象包含指定字符串表示形式的整数值，并使用基数值进行分析。例如，如果s&#x3D;“333”且基数&#x3D;8，则该方法返回与八进制数333相等的十进制整数。 格式化数字打印输出前面您看到了使用“print”和“println”方法将字符串打印到标准输出（“System.out”）。由于所有数字都可以转换为字符串（如您将在本课程后面看到的），因此可以使用这些方法打印字符串和数字的任意混合。然而，Java编程语言还有其他方法，允许您在包含数字时对打印输出进行更多控制。 printf和format方法java.io包包含一个“PrintStream”类，该类有两种格式方法，可以用来替换“print”和“println”。这些方法“format”和“printf”彼此等效。熟悉的“系统”。out”恰好是“PrintStream”对象，因此您可以在“System.out”上调用“PrintStream”方法。因此，您可以在代码中以前使用过“print”或“println”的任何地方使用“format”或“print f”。例如 1System.out.format(.....); 这两个java.io.PrintStream的语法方法相同： 1public PrintStream format(String format, Object... args) 其中“format”是指定要使用的格式的字符串，“args”是使用该格式打印的变量列表。一个简单的例子是 123System.out.format(&quot;The value of &quot; + &quot;the float variable is &quot; + &quot;%f, while the value of the &quot; + &quot;integer variable is %d, &quot; + &quot;and the string is %s&quot;, floatVar, intVar, stringVar); 第一个参数“format”是一个格式字符串，指定如何格式化第二个参数“args”中的对象。格式字符串包含纯文本和格式说明符，它们是格式化“Object…args”参数的特殊字符。（符号“Object…args”称为varargs，这意味着参数的数量可能不同。） 格式说明符以百分号（%）开头，以转换器结尾。转换器是一个字符，指示要格式化的参数类型。在百分号（%）和转换器之间可以有可选的标志和说明符。java.util.Formatter中记录了许多转换器、标志和说明符 下面是一个基本示例： 12int i = 461012;System.out.format(&quot;The value of i is: %d%n&quot;, i); “%d”指定单个变量是十进制整数。“%n”是独立于平台的换行符。输出为： 1The value of i is: 461012 “printf”和“format”方法已重载。每个都有一个版本，其语法如下： 1public PrintStream format(Locale l, String format, Object... args) 例如，要以法语系统打印数字（在英文浮点数表示法中使用逗号代替小数点），可以使用： 1234System.out.format(Locale.FRANCE, &quot;The value of the float &quot; + &quot;variable is %f, while the &quot; + &quot;value of the integer variable &quot; + &quot;is %d, and the string is %s%n&quot;, floatVar, intVar, stringVar); 一个🌰下表列出了示例程序“TestFormat”中使用的一些转换器和标志。java&#96;，它跟在表后面。 转换器 Flag 解释 d 十进制整数 f A float. n 适用于运行应用程序的平台的新行字符。您应该始终使用“%n”，而不是“\\n”。 tB 日期和时间转换区域设置特定的月份全名。 td, te 日期和时间转换——每月的两位数。td根据需要有前导零，te没有。 ty, tY 日期和时间转换ty&#x3D;2位年份，ty&#x3D;4位年份。 tl 12小时时钟中的日期和时间转换小时。 tM 日期和时间转换分钟（2位），必要时带前导零。 tp 特定于区域设置的日期和时间转换上午&#x2F;下午（小写）。 tm 日期和时间转换月份（2位），必要时带前导零。 tD 日期和时间转换日期为%tm%td%ty 08 宽度为八个字符，必要时带前导零。 + 包括正负号。 , 包括区域设置特定的分组字符。 - 左对齐。。 .3 小数点后三位。 10.3 宽十个字符，右对齐，小数点后三位。 以下程序显示了可以使用“format”进行的一些格式化。输出显示在嵌入注释中的双引号内： 123456789101112131415161718192021222324252627282930import java.util.Calendar;import java.util.Locale;public class TestFormat &#123; public static void main(String[] args) &#123; long n = 461012; System.out.format(&quot;%d%n&quot;, n); // --&gt; &quot;461012&quot; System.out.format(&quot;%08d%n&quot;, n); // --&gt; &quot;00461012&quot; System.out.format(&quot;%+8d%n&quot;, n); // --&gt; &quot; +461012&quot; System.out.format(&quot;%,8d%n&quot;, n); // --&gt; &quot; 461,012&quot; System.out.format(&quot;%+,8d%n%n&quot;, n); // --&gt; &quot;+461,012&quot; double pi = Math.PI; System.out.format(&quot;%f%n&quot;, pi); // --&gt; &quot;3.141593&quot; System.out.format(&quot;%.3f%n&quot;, pi); // --&gt; &quot;3.142&quot; System.out.format(&quot;%10.3f%n&quot;, pi); // --&gt; &quot; 3.142&quot; System.out.format(&quot;%-10.3f%n&quot;, pi); // --&gt; &quot;3.142&quot; System.out.format(Locale.FRANCE, &quot;%-10.4f%n%n&quot;, pi); // --&gt; &quot;3,1416&quot; Calendar c = Calendar.getInstance(); System.out.format(&quot;%tB %te, %tY%n&quot;, c, c, c); // --&gt; &quot;May 29, 2006&quot; System.out.format(&quot;%tl:%tM %tp%n&quot;, c, c, c); // --&gt; &quot;2:34 am&quot; System.out.format(&quot;%tD%n&quot;, c); // --&gt; &quot;05/29/06&quot; &#125;&#125; Note: 本节中的讨论仅涵盖“format”和“printf”方法的基础知识。有关详细信息，请参见Basic I/O 在“格式化”页面中的Essential trail部分。使用String。格式创建字符串包含在strings中. DecimalFormat类您可以使用java.text.DecimalFormat类来控制前导和尾随零、前缀和后缀、分组（千）分隔符和小数分隔符的显示DecimalFormat在数字格式方面提供了很大的灵活性，但它会使代码更加复杂。 下面的示例通过向“DecimalFormat”构造函数传递模式字符串来创建“DecimalFormat”对象“myFormatter”。“format（）”方法（“DecimalFormat”继承自“NumberFormat”）随后由“myFormatter”调用-它接受“double”值作为参数，并以字符串形式返回格式化的数字： 下面是一个示例程序，说明了“DecimalFormat”的使用： 123456789101112131415161718import java.text.*;public class DecimalFormatDemo &#123; static public void customFormat(String pattern, double value ) &#123; DecimalFormat myFormatter = new DecimalFormat(pattern); String output = myFormatter.format(value); System.out.println(value + &quot; &quot; + pattern + &quot; &quot; + output); &#125; static public void main(String[] args) &#123; customFormat(&quot;###,###.###&quot;, 123456.789); customFormat(&quot;###.##&quot;, 123456.789); customFormat(&quot;000000.000&quot;, 123.78); customFormat(&quot;$###,###.###&quot;, 12345.67); &#125;&#125; The output is: 1234123456.789 ###,###.### 123,456.789123456.789 ###.## 123456.79123.78 000000.000 000123.78012345.67 $###,###.### $12,345.67 下表解释了每一行输出。 Value Pattern Output Explanation 123456.789 ###,###.### 123,456.789 磅号（#）表示数字，逗号是分组分隔符的占位符，句点是小数分隔符的定位器。 123456.789 ###.## 123456.79 “value”在小数点右侧有三位数字，但“pattern”只有两位。“format”方法通过舍入来处理此问题。 123.78 000000.000 000123.780 “pattern”指定前导和尾随零，因为使用的是0字符而不是磅符号（#）。 12345.67 $###,###.### $12,345.67 “pattern”中的第一个字符是美元符号（$）。注意，它紧挨着格式化的“输出”中最左边的数字。 超越基本算术Java编程语言支持基本算术及其算术运算符：+、-、*、&#x2F;和%。Math类。lang包提供了用于进行更高级数学计算的方法和常量。 “Math”类中的方法都是静态的，因此可以直接从类中调用它们，如下所示： 1Math.cos(angle); Note: 使用import static语言功能，您不必在每个数学函数前面写“Math”： 1import static java.lang.Math.*; 这允许您通过简单名称调用“Math”类方法。例如： 1cos(angle); 常量和基本方法“Math”类包含两个常量： Math.E, 这是自然对数的基础，以及 Math.PI, 这是圆的周长与其直径之比。 “Math”类还包括40多个静态方法。下表列出了一些基本方法。 Method Description double abs(double d)float abs(float f)int abs(int i)long abs(long lng) 返回参数的绝对值。 double ceil(double d) 返回大于或等于参数的最小整数。以双精度返回。 double floor(double d) 返回小于或等于参数的最大整数。以双精度返回。 double rint(double d) 返回值最接近参数的整数。以双精度返回。 long round(double d)int round(float f) 返回与参数最接近的long或int，如方法的返回类型所示。 double min(double arg1, double arg2)float min(float arg1, float arg2)int min(int arg1, int arg2)long min(long arg1, long arg2) 返回两个参数中较小的一个。 double max(double arg1, double arg2)float max(float arg1, float arg2)int max(int arg1, int arg2)long max(long arg1, long arg2) 返回两个参数中较大的一个。 以下程序BasicMathDemo，说明了如何使用其中一些方法： 12345678910111213141516171819202122232425public class BasicMathDemo &#123; public static void main(String[] args) &#123; double a = -191.635; double b = 43.74; int c = 16, d = 45; System.out.printf(&quot;The absolute value &quot; + &quot;of %.3f is %.3f%n&quot;, a, Math.abs(a)); System.out.printf(&quot;The ceiling of &quot; + &quot;%.2f is %.0f%n&quot;, b, Math.ceil(b)); System.out.printf(&quot;The floor of &quot; + &quot;%.2f is %.0f%n&quot;, b, Math.floor(b)); System.out.printf(&quot;The rint of %.2f &quot; + &quot;is %.0f%n&quot;, b, Math.rint(b)); System.out.printf(&quot;The max of %d and &quot; + &quot;%d is %d%n&quot;, c, d, Math.max(c, d)); System.out.printf(&quot;The min of of %d &quot; + &quot;and %d is %d%n&quot;, c, d, Math.min(c, d)); &#125;&#125; Here’s the output from this program: 123456The absolute value of -191.635 is 191.635The ceiling of 43.74 is 44The floor of 43.74 is 43The rint of 43.74 is 44The max of 16 and 45 is 45The min of 16 and 45 is 16 指数和对数方法下表列出了“Math”类的指数和对数方法。 Method Description double exp(double d) 将自然对数的基数e返回为参数的幂。 double log(double d) 返回参数的自然对数。 double pow(double base, double exponent) 返回第一个参数的值乘以第二个参数的幂。 double sqrt(double d) 返回参数的平方根。 以下程序ExponentialDemo，显示“e”的值，然后对任意选择的数字调用上表中列出的每个方法： 123456789101112131415161718192021public class ExponentialDemo &#123; public static void main(String[] args) &#123; double x = 11.635; double y = 2.76; System.out.printf(&quot;The value of &quot; + &quot;e is %.4f%n&quot;, Math.E); System.out.printf(&quot;exp(%.3f) &quot; + &quot;is %.3f%n&quot;, x, Math.exp(x)); System.out.printf(&quot;log(%.3f) is &quot; + &quot;%.3f%n&quot;, x, Math.log(x)); System.out.printf(&quot;pow(%.3f, %.3f) &quot; + &quot;is %.3f%n&quot;, x, y, Math.pow(x, y)); System.out.printf(&quot;sqrt(%.3f) is &quot; + &quot;%.3f%n&quot;, x, Math.sqrt(x)); &#125;&#125; Here’s the output you’ll see when you run ExponentialDemo: 12345The value of e is 2.7183exp(11.635) is 112983.831log(11.635) is 2.454pow(11.635, 2.760) is 874.008sqrt(11.635) is 3.411 三角测量法“Math”类还提供了三角函数的集合，总结如下表所示。传递给每个方法的值都是以弧度表示的角度。可以使用“toRadians”方法将度数转换为弧度。 Method Description double sin(double d) 返回指定双精度值的正弦值。 double cos(double d) 返回指定双精度值的余弦值。 double tan(double d) 返回指定双精度值的正切值。 double asin(double d) 返回指定双精度值的反正弦。 double acos(double d) 返回指定双精度值的反余弦。 double atan(double d) 返回指定双精度值的反正切。 double atan2(double y, double x) 将矩形坐标“（x，y）”转换为极坐标“（r，θ）”并返回“θ”。 double toDegrees(double d)double toRadians(double d) 将参数转换为度或弧度。 这是一个程序TrigonomicDemo，使用这些方法计算45度角的各种三角值： 123456789101112131415161718192021222324252627282930public class TrigonometricDemo &#123; public static void main(String[] args) &#123; double degrees = 45.0; double radians = Math.toRadians(degrees); System.out.format(&quot;The value of pi &quot; + &quot;is %.4f%n&quot;, Math.PI); System.out.format(&quot;The sine of %.1f &quot; + &quot;degrees is %.4f%n&quot;, degrees, Math.sin(radians)); System.out.format(&quot;The cosine of %.1f &quot; + &quot;degrees is %.4f%n&quot;, degrees, Math.cos(radians)); System.out.format(&quot;The tangent of %.1f &quot; + &quot;degrees is %.4f%n&quot;, degrees, Math.tan(radians)); System.out.format(&quot;The arcsine of %.4f &quot; + &quot;is %.4f degrees %n&quot;, Math.sin(radians), Math.toDegrees(Math.asin(Math.sin(radians)))); System.out.format(&quot;The arccosine of %.4f &quot; + &quot;is %.4f degrees %n&quot;, Math.cos(radians), Math.toDegrees(Math.acos(Math.cos(radians)))); System.out.format(&quot;The arctangent of %.4f &quot; + &quot;is %.4f degrees %n&quot;, Math.tan(radians), Math.toDegrees(Math.atan(Math.tan(radians)))); &#125;&#125; The output of this program is as follows: 1234567The value of pi is 3.1416The sine of 45.0 degrees is 0.7071The cosine of 45.0 degrees is 0.7071The tangent of 45.0 degrees is 1.0000The arcsine of 0.7071 is 45.0000 degreesThe arccosine of 0.7071 is 45.0000 degreesThe arctangent of 1.0000 is 45.0000 degrees 随机数“random()”方法返回介于0.0和1.0之间的伪随机选择的数字。范围包括0.0但不包括1.0。换句话说： 0.0 &lt;= Math.random() &lt; 1.0. 要获得不同范围的数字，可以对随机方法返回的值执行算术运算。例如，要生成一个介于0和9之间的整数，您可以写： 1int number = (int)(Math.random() * 10); 通过将该值乘以10，可能值的范围变为 0.0 &lt;= number &lt; 10.0. 使用Math。当你需要生成一个随机数时，“随机”很有效。如果需要生成一系列随机数，应该创建java.util。Random”并调用该对象上的方法以生成数字。 Numbers 总结您可以使用一个包装类（“Byte”、“Double”、”Float“、”Integer“、”Long“或”Short“）来包装对象中的多个基本类型。Java编译器会在必要时自动为您包装（装箱）原语，并在必要时再次打开它们。 “Number”类包括常量和有用的类方法。MIN_VALUE和&#96;MAX_VALUE’常量包含该类型对象可以包含的最小和最大值。“byteValue”、“shortValue”和类似的方法将一种数字类型转换为另一种。“valueOf”方法将字符串转换为数字，“toString”方法将数字转换为字符串。 要格式化包含数字的字符串以进行输出，可以使用“PrintStream”类中的“printf（）”或“format（）”方法。或者，您可以使用“NumberFormat”类使用模式自定义数字格式。 “Math”类包含用于执行数学函数的各种类方法，包括指数、对数和三角方法&#96;Math还包括基本的算术函数，如绝对值和舍入，以及生成随机数的方法“random（）”。 Characters大多数情况下，如果使用的是单个字符值，则将使用基本的“char”类型。例如： 12345char ch = &#x27;a&#x27;; // Unicode for uppercase Greek omega characterchar uniChar = &#x27;\\u03A9&#x27;;// an array of charschar[] charArray = &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; &#125;; 然而，有时需要将字符用作对象，例如，用作需要对象的方法参数。Java编程语言提供了一个wrapper类，用于将“char”“包装”在“Character”对象中。“Character”类型的对象包含一个字段，其类型为“char”。此字符类还提供了许多有用的类（即静态）方法来处理字符。 您可以使用“Character”构造函数创建“Character”对象： 1Character ch = new Character(&#x27;a&#x27;); 在某些情况下，Java编译器还会为您创建一个“字符”对象。例如，如果将原语“char”传递给需要对象的方法，编译器会自动将“char”转换为“Character”。如果转换方向相反，则此功能称为autoboxing或unboxing。有关自动装箱和取消装箱的详细信息，请参见自动装箱和解除装箱. Note: “Character”类是不可变的，因此一旦创建了它，就不能更改“Character”对象。 下表列出了“Character”类中一些最有用的方法，但并不详尽。有关该类中所有方法的完整列表（超过50个），请参阅java.lang.CharacterAPI规范。 Method Description boolean isLetter(char ch)boolean isDigit(char ch) 确定指定的字符值是字母还是数字。 boolean isWhitespace(char ch) 确定指定的字符值是否为空白。 boolean isUpperCase(char ch)boolean isLowerCase(char ch) 确定指定的字符值是大写还是小写。 char toUpperCase(char ch)char toLowerCase(char ch) 返回指定字符值的大小写形式。 toString(char ch) 返回表示指定字符值的“字符串”对象，即一个单字符字符串。 转义序列反斜杠（\\）前面的字符是转义序列，对编译器有特殊意义。下表显示了Java转义序列： Escape Sequence Description \\t 此时在文本中插入一个选项卡。 \\b 此时在文本中插入退格。 \\n 此时在文本中插入新行。 \\r 此时在文本中插入回车符。 \\f 此时在文本中插入表单源。 \\&#39; 此时在文本中插入单引号字符。 \\&quot; 此时在文本中插入双引号字符。 \\\\ 此时在文本中插入反斜杠字符。 当在print语句中遇到转义序列时，编译器会相应地解释它。例如，如果要将引号放在引号内，必须在内部引号上使用转义序列“” 1She said &quot;Hello!&quot; to me. 你会写 1System.out.println(&quot;She said \\&quot;Hello!\\&quot; to me.&quot;); StringsStrings, 在Java编程中广泛使用的字符序列是字符序列。在Java编程语言中，字符串是对象。 Java平台提供String类来创建和操作字符串。 Creating Strings创建字符串的最直接方法是编写： 1String greeting = &quot;Hello world!&quot;; 在这种情况下，“你好世界！”是字符串文字-代码中用双引号括起来的一系列字符。每当在代码中遇到字符串时，编译器都会创建一个“string”对象，其值在本例中为“Hello world！”。 与其他任何对象一样，可以使用“new”关键字和构造函数创建“String”对象。“String”类有13个构造函数，允许您使用不同的源（例如字符数组）提供字符串的初始值： 123char[] helloArray = &#123; &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;.&#x27; &#125;;String helloString = new String(helloArray);System.out.println(helloString); 此代码段的最后一行显示“hello”。 Note: “String”类是不可变的，因此一旦创建了“String”对象就不能更改。“String”类有许多方法，下面将讨论其中一些方法，它们似乎可以修改字符串。由于字符串是不可变的，所以这些方法真正要做的是创建并返回包含操作结果的新字符串。 String Length用于获取对象信息的方法称为访问器方法。可以用于字符串的一个访问器方法是“length（）”方法，它返回字符串对象中包含的字符数。执行以下两行代码后，“len”等于17： 12String palindrome = &quot;Dot saw I was Tod&quot;;int len = palindrome.length(); 回文是一个对称的单词或句子，前后拼写相同，忽略大小写和标点符号。这里有一个简短而低效的程序来反转回文字符串。它调用“String”方法“charAt（i）”，该方法返回字符串中的第i个字符，从0开始计数。 12345678910111213141516171819202122232425public class StringDemo &#123; public static void main(String[] args) &#123; String palindrome = &quot;Dot saw I was Tod&quot;; int len = palindrome.length(); char[] tempCharArray = new char[len]; char[] charArray = new char[len]; // put original string in an // array of chars for (int i = 0; i &lt; len; i++) &#123; tempCharArray[i] = palindrome.charAt(i); &#125; // reverse array of chars for (int j = 0; j &lt; len; j++) &#123; charArray[j] = tempCharArray[len - 1 - j]; &#125; String reversePalindrome = new String(charArray); System.out.println(reversePalindrome); &#125;&#125; Running the program produces this output: 1doT saw I was toD 为了实现字符串反转，程序必须将字符串转换为字符数组（第一个“for”循环），将数组反转为第二个数组（第二个“for“循环），然后再转换回字符串。String类包含一个方法“getChars（）”，用于将字符串或字符串的一部分转换为字符数组，这样我们就可以用 1palindrome.getChars(0, len, tempCharArray, 0); 拼接 Strings“String”类包含一个连接两个字符串的方法： 1string1.concat(string2); 这将返回一个新字符串，该字符串为string1，末尾添加了string2。 还可以对字符串文本使用“concat（）”方法，如： 1&quot;My name is &quot;.concat(&quot;Rumplestiltskin&quot;); 字符串通常用“+”运算符连接，如 1&quot;Hello,&quot; + &quot; world&quot; + &quot;!&quot; 这导致 1&quot;Hello, world!&quot; “+”运算符在“print”语句中广泛使用。例如： 12String string1 = &quot;saw I was &quot;;System.out.println(&quot;Dot &quot; + string1 + &quot;Tod&quot;); which prints 1Dot saw I was Tod 这种连接可以是任何对象的混合。对于每个不是“字符串”的对象，调用其“toString（）”方法将其转换为“字符串”。 Note: Java编程语言不允许文本字符串跨越源文件中的行，因此必须在多行字符串中的每行末尾使用“+”连接运算符。例如： 123String quote = &quot;Now is the time for all good &quot; + &quot;men to come to the aid of their country.&quot;; 在“print”语句中，使用“+”串联运算符断开行之间的字符串也是非常常见的。 创建格式字符串您已经看到了使用“printf（）”和“format（）”方法打印带有格式化数字的输出。“String”类有一个等效的类方法“format（）”，它返回“String”对象而不是“PrintStream”对象。 使用“String”的“static”format（）方法，您可以创建可重复使用的格式化字符串，而不是一次性打印语句。例如，代替 123456System.out.printf(&quot;The value of the float &quot; + &quot;variable is %f, while &quot; + &quot;the value of the &quot; + &quot;integer variable is %d, &quot; + &quot;and the string is %s&quot;, floatVar, intVar, stringVar); you can write 12345678String fs;fs = String.format(&quot;The value of the float &quot; + &quot;variable is %f, while &quot; + &quot;the value of the &quot; + &quot;integer variable is %d, &quot; + &quot; and the string is %s&quot;, floatVar, intVar, stringVar);System.out.println(fs); 在数字和字符串之间转换将字符串转换为数字通常，程序以字符串对象（例如，用户输入的值）中的数字数据结尾。 包装基本数字类型的“Number”子类（Byte，Integer，Double，Float，Long，和Short)每个都提供一个名为“valueOf”的类方法，该方法将字符串转换为该类型的对象。下面是一个示例ValueOfDemo，从命令行获取两个字符串，将它们转换为数字，并对值执行算术运算： 123456789101112131415161718192021222324252627public class ValueOfDemo &#123; public static void main(String[] args) &#123; // this program requires two // arguments on the command line if (args.length == 2) &#123; // convert strings to numbers float a = (Float.valueOf(args[0])).floatValue(); float b = (Float.valueOf(args[1])).floatValue(); // do some arithmetic System.out.println(&quot;a + b = &quot; + (a + b)); System.out.println(&quot;a - b = &quot; + (a - b)); System.out.println(&quot;a * b = &quot; + (a * b)); System.out.println(&quot;a / b = &quot; + (a / b)); System.out.println(&quot;a % b = &quot; + (a % b)); &#125; else &#123; System.out.println(&quot;This program &quot; + &quot;requires two command-line arguments.&quot;); &#125; &#125;&#125; 以下是使用“4.5”和“87.2”作为命令行参数时程序的输出： 12345a + b = 91.7a - b = -82.7a * b = 392.4a / b = 0.0516055a % b = 4.5 Note: 包装原始数字类型的每个“Number”子类还提供了一个“parseXXXX（）”方法（例如，“parseFloat（）”），可用于将字符串转换为原始数字。由于返回的是基元类型而不是对象，因此“parseFloat（）”方法比“valueOf（）”更直接。例如，在“ValueOfDemo”程序中，我们可以使用： 12float a = Float.parseFloat(args[0]);float b = Float.parseFloat(args[1]); 将数字转换为字符串有时您需要将数字转换为字符串，因为您需要对其字符串形式的值进行操作。有几种简单的方法可以将数字转换成字符串： 123int i;// Concatenate &quot;i&quot; with an empty string; conversion is handled for you.String s1 = &quot;&quot; + i; or 12// The valueOf class method.String s2 = String.valueOf(i); 每个“Number”子类都包含一个类方法“toString（）”，该方法将其原始类型转换为字符串。例如： 1234int i;double d;String s3 = Integer.toString(i); String s4 = Double.toString(d); ToStringDemo示例使用“toString”方法将数字转换为字符串。然后，程序使用一些字符串方法计算小数点前后的位数： 1234567891011121314public class ToStringDemo &#123; public static void main(String[] args) &#123; double d = 858.48; String s = Double.toString(d); int dot = s.indexOf(&#x27;.&#x27;); System.out.println(dot + &quot; digits &quot; + &quot;before decimal point.&quot;); System.out.println( (s.length() - dot - 1) + &quot; digits after decimal point.&quot;); &#125;&#125; The output of this program is: 123 digits before decimal point.2 digits after decimal point. 操纵字符串中的字符“String”类有许多方法用于检查字符串的内容、查找字符串中的字符或子字符串、更改大小写和其他任务。 按索引获取字符和子字符串通过调用“charAt（）”访问器方法，可以获取字符串中特定索引处的字符。第一个字符的索引为0，而最后一个字符的指数为“length（）-1”。例如，以下代码获取字符串中索引9处的字符： 12String anotherPalindrome = &quot;Niagara. O roar again!&quot;; char aChar = anotherPalindrome.charAt(9); 索引从0开始，因此索引9处的字符为“O”，如下图所示： 如果要从字符串中获取多个连续字符，可以使用“substring”方法。“substring”方法有两个版本，如下表所示： Method Description String substring(int beginIndex, int endIndex) 返回作为此字符串的子字符串的新字符串。子字符串从指定的“beginIndex”开始，并扩展到索引“endIndex-1”处的字符。 String substring(int beginIndex) 返回作为此字符串的子字符串的新字符串。整数参数指定第一个字符的索引。这里，返回的子字符串扩展到原始字符串的末尾。 以下代码从尼亚加拉回文中获取从索引11延伸到但不包括索引15的子字符串，即单词“咆哮”： 12String anotherPalindrome = &quot;Niagara. O roar again!&quot;; String roar = anotherPalindrome.substring(11, 15); 操纵字符串的其他方法以下是用于操作字符串的其他几种“字符串”方法： Method Description String[] split(String regex) String[] split(String regex, int limit) 搜索字符串参数（包含正则表达式）指定的匹配项，并相应地将此字符串拆分为字符串数组。可选整数参数指定返回数组的最大大小。正则表达式包含在题为“正则表达式”的课程中 CharSequence subSequence(int beginIndex, int endIndex) 返回从“beginIndex”索引到“endIndex”-1构造的新字符序列。 String trim() 返回此字符串的副本，其中删除了前导空格和尾随空格。 String toLowerCase()String toUpperCase() 返回转换为小写或大写的字符串副本。如果不需要转换，这些方法将返回原始字符串。 搜索字符串中的字符和子字符串下面是一些用于查找字符串中的字符或子字符串的其他“字符串”方法。“String”类提供了返回特定字符或子字符串在字符串中的位置的访问器方法：“indexOf（）”和“lastIndexOf（（）”。“indexOf（）”方法从字符串的开头向前搜索，而“lastIndexOf（”方法则从字符串的结尾向后搜索。如果未找到字符或子字符串，“indexOf（）”和“lastIndexOf（（）”将返回-1。 “String”类还提供了一个搜索方法“contains”，如果字符串包含特定的字符序列，则返回true。当您只需要知道字符串包含一个字符序列，但准确的位置并不重要时，可以使用此方法。 下表介绍了各种字符串搜索方法。 Method Description int indexOf(int ch)int lastIndexOf(int ch) 返回指定字符第一次（最后一次）出现的索引。 int indexOf(int ch, int fromIndex)int lastIndexOf(int ch, int fromIndex) 返回指定字符第一次（最后一次）出现的索引，从指定索引向前（向后）搜索。 int indexOf(String str)int lastIndexOf(String str) 返回指定子字符串第一次（最后一次）出现的索引。 int indexOf(String str, int fromIndex)int lastIndexOf(String str, int fromIndex) 返回指定子字符串第一次（最后一次）出现的索引，从指定索引向前（向后）搜索。 boolean contains(CharSequence s) 如果字符串包含指定的字符序列，则返回true。 Note:CharSequence是由“String”类实现的接口。因此，可以使用字符串作为“contains（）”方法的参数。 将字符和子字符串替换为字符串“String”类很少有将字符或子字符串插入字符串的方法。一般来说，它们是不需要的：您可以通过将从字符串中删除的子字符串与要插入的子字符串串联起来来创建新字符串。 不过，“String”类有四个方法来替换找到的字符或子字符串。他们是： Method Description String replace(char oldChar, char newChar) 返回一个新字符串，该字符串是用newChar替换此字符串中所有oldChar的结果。 String replace(CharSequence target, CharSequence replacement) 用指定的文字替换序列替换此字符串中与文字目标序列匹配的每个子字符串。 String replaceAll(String regex, String replacement) 用给定的替换替换此字符串中与给定正则表达式匹配的每个子字符串。 String replaceFirst(String regex, String replacement) 用给定的替换替换此字符串中与给定正则表达式匹配的第一个子字符串。 一个例子以下类[&#96;Filename](https://docs.oracle.com/javase/tutorial/java/data/examples/Filename.java)，说明了使用“lastIndexOf（）”和“substring（）”来隔离文件名的不同部分。 Note: 下面的“Filename”类中的方法不进行任何错误检查，并假定它们的参数包含完整的目录路径和带有扩展名的文件名。如果这些方法是生产代码，它们将验证其参数是否正确构造。 12345678910111213141516171819202122232425262728public class Filename &#123; private String fullPath; private char pathSeparator, extensionSeparator; public Filename(String str, char sep, char ext) &#123; fullPath = str; pathSeparator = sep; extensionSeparator = ext; &#125; public String extension() &#123; int dot = fullPath.lastIndexOf(extensionSeparator); return fullPath.substring(dot + 1); &#125; // gets filename without extension public String filename() &#123; int dot = fullPath.lastIndexOf(extensionSeparator); int sep = fullPath.lastIndexOf(pathSeparator); return fullPath.substring(sep + 1, dot); &#125; public String path() &#123; int sep = fullPath.lastIndexOf(pathSeparator); return fullPath.substring(0, sep); &#125;&#125; 这是一个程序FilenameDemo，构造一个“Filename”对象并调用其所有方法： 123456789public class FilenameDemo &#123; public static void main(String[] args) &#123; final String FPATH = &quot;/home/user/index.html&quot;; Filename myHomePage = new Filename(FPATH, &#x27;/&#x27;, &#x27;.&#x27;); System.out.println(&quot;Extension = &quot; + myHomePage.extension()); System.out.println(&quot;Filename = &quot; + myHomePage.filename()); System.out.println(&quot;Path = &quot; + myHomePage.path()); &#125;&#125; And here’s the output from the program: 123Extension = htmlFilename = indexPath = /home/user 如下图所示，我们的“extension”方法使用“lastIndexOf”来查找文件名中句点（.）的最后一次出现。然后，“substring”使用“lastIndexOf”的返回值提取文件扩展名，即从句点到字符串结尾的子字符串。此代码假定文件名中有句点；如果文件名没有句点，“lastIndexOf”将返回-1，而substring方法将抛出“StringIndexOutOfBoundsException”。 此外，请注意，“extension”方法使用“dot+1”作为“substring”的参数。如果句点字符（.）是字符串的最后一个字符，则“点+1”等于字符串的长度，比字符串中最大的索引大一个（因为索引从0开始）。这是“substring”的合法参数，因为该方法接受一个等于但不大于字符串长度的索引，并将其解释为“字符串的结尾” 比较字符串和部分字符串“String”类有许多用于比较字符串和字符串部分的方法。下表列出了这些方法。 Method Description boolean endsWith(String suffix)boolean startsWith(String prefix) 如果此字符串以指定为方法参数的子字符串结尾或开头，则返回“true”。 boolean startsWith(String prefix, int offset) 考虑以索引“offset”开头的字符串，如果以指定为参数的子字符串开头，则返回“true”。 int compareTo(String anotherString) 以字典方式比较两个字符串。返回一个整数，指示此字符串是否大于（结果&gt;0）、等于（结果&#x3D;0）或小于（结果&lt;0）参数。 int compareToIgnoreCase(String str) 以字典方式比较两个字符串，忽略大小写的差异。返回一个整数，指示此字符串是否大于（结果&gt;0）、等于（结果&#x3D;0）或小于（结果&lt;0）参数。 boolean equals(Object anObject) 当且仅当参数是表示与此对象相同的字符序列的“字符串”对象时，返回“true”。 boolean equalsIgnoreCase(String anotherString) 当且仅当参数是与此对象表示相同字符序列的“字符串”对象时，返回“true”，忽略大小写差异。 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试此字符串的指定区域是否与string参数的指定区域匹配。Region的长度为“len”，对于此字符串以索引“toffset”开始，对于另一个字符串则以索引“ooffset”开头。 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试此字符串的指定区域是否与string参数的指定区域匹配。Region的长度为“len”，对于此字符串以索引“toffset”开始，对于另一个字符串则以索引“ooffset”开头。布尔参数指示是否应忽略大小写；如果为true，则在比较字符时忽略大小写。 boolean matches(String regex) 测试此字符串是否与指定的正则表达式匹配。正则表达式在题为“正则表达式”的课程中讨论 以下程序“RegionMatchesDemo”使用“regionMatches”方法在另一个字符串中搜索字符串： 1234567891011121314151617181920public class RegionMatchesDemo &#123; public static void main(String[] args) &#123; String searchMe = &quot;Green Eggs and Ham&quot;; String findMe = &quot;Eggs&quot;; int searchMeLength = searchMe.length(); int findMeLength = findMe.length(); boolean foundIt = false; for (int i = 0; i &lt;= (searchMeLength - findMeLength); i++) &#123; if (searchMe.regionMatches(i, findMe, 0, findMeLength)) &#123; foundIt = true; System.out.println(searchMe.substring(i, i + findMeLength)); break; &#125; &#125; if (!foundIt) System.out.println(&quot;No match found.&quot;); &#125;&#125; 这个程序的输出是“鸡蛋”。 程序一次一个字符地遍历“searchMe”引用的字符串。对于每个字符，程序调用regionMatches方法来确定以当前字符开头的子字符串是否与程序正在查找的字符串匹配。 The StringBuilder ClassStringBuilder 对象类似于String对象，但它们可以修改。在内部，这些对象被视为包含字符序列的可变长度数组。在任何时候，序列的长度和内容都可以通过方法调用来更改。 除非字符串生成器在更简单的代码（参见本节末尾的示例程序）或更好的性能方面具有优势，否则应始终使用字符串。例如，如果需要连接大量字符串，则附加到“StringBuilder”对象更有效。 长度和容量与“String”类一样，“StringBuilder”类有一个“length（）”方法，用于返回生成器中字符序列的长度。 与字符串不同，每个字符串生成器还具有容量，即已分配的字符空间数。“capacity（）”方法返回的容量始终大于或等于长度（通常大于），并将根据需要自动扩展以适应对字符串生成器的添加。 Constructor Description StringBuilder() 创建容量为16（16个空元素）的空字符串生成器。 StringBuilder(CharSequence cs) 构造一个字符串生成器，其中包含与指定的CharSequence相同的字符，再加上CharSequence后面的16个空元素。 StringBuilder(int initCapacity) 创建具有指定初始容量的空字符串生成器。 StringBuilder(String s) 创建一个字符串生成器，其值由指定的字符串初始化，加上字符串后面的额外16个空元素。 For example, the following code 1234// creates empty builder, capacity 16StringBuilder sb = new StringBuilder();// adds 9 character string at beginningsb.append(&quot;Greetings&quot;); 将产生长度为9、容量为16: “StringBuilder”类有一些与“String”类没有的长度和容量相关的方法： Method Description void setLength(int newLength) 设置字符序列的长度。如果“newLength”小于“length（）”，则将截断字符序列中的最后一个字符。如果“newLength”大于“length（）”，则在字符序列末尾添加空字符。 void ensureCapacity(int minCapacity) 确保容量至少等于指定的最小值。 许多操作（例如，“append（）”、“insert（）”或“setLength（）”）可以增加字符串生成器中字符序列的长度，从而使生成的“length（）”大于当前的“capacity（））”。发生这种情况时，容量会自动增加。 StringBuilder操作“StringBuilder”上的主要操作在“String”中不可用，它们是“append（）”和“insert（）”方法，它们被重载以接受任何类型的数据。每个都将其参数转换为字符串，然后将该字符串的字符附加或插入到字符串生成器中的字符序列中。append方法总是在现有字符序列的末尾添加这些字符，而insert方法在指定的点添加字符。 下面是“StringBuilder”类的一些方法。 Method Description StringBuilder append(boolean b)StringBuilder append(char c)StringBuilder append(char[] str)StringBuilder append(char[] str, int offset, int len)StringBuilder append(double d)StringBuilder append(float f)StringBuilder append(int i)StringBuilder append(long lng)StringBuilder append(Object obj)StringBuilder append(String s) 将参数追加到此字符串生成器。在执行追加操作之前，数据被转换为字符串。 StringBuilder delete(int start, int end)StringBuilder deleteCharAt(int index) 第一个方法删除“StringBuilder”的字符序列中从头至尾1（含）的子序列。第二种方法删除位于“index”的字符。 StringBuilder insert(int offset, boolean b)StringBuilder insert(int offset, char c)StringBuilder insert(int offset, char[] str)StringBuilder insert(int index, char[] str, int offset, int len)StringBuilder insert(int offset, double d)StringBuilder insert(int offset, float f)StringBuilder insert(int offset, int i)StringBuilder insert(int offset, long lng)StringBuilder insert(int offset, Object obj)StringBuilder insert(int offset, String s) 将第二个参数插入字符串生成器。第一个整数参数指示要在其之前插入数据的索引。在执行插入操作之前，数据被转换为字符串。 StringBuilder replace(int start, int end, String s)void setCharAt(int index, char c) 替换此字符串生成器中的指定字符。 StringBuilder reverse() 反转此字符串生成器中的字符序列。 String toString() 返回包含生成器中的字符序列的字符串。 Note: 通过首先使用“StringBuilder”类的“toString（）”方法将字符串生成器转换为字符串，可以在“StringBuilder”对象上使用任何“String”方法。然后使用“StringBuilder（Stringstr）”构造函数将字符串转换回字符串生成器。 一个例子标题为“字符串”的部分中列出的“StringDemo”程序是一个程序的示例，如果使用“StringBuilder”而不是“String”，该程序的效率会更高。 StringDemo反转了回文。再次列出： 12345678910111213141516171819202122232425public class StringDemo &#123; public static void main(String[] args) &#123; String palindrome = &quot;Dot saw I was Tod&quot;; int len = palindrome.length(); char[] tempCharArray = new char[len]; char[] charArray = new char[len]; // put original string in an // array of chars for (int i = 0; i &lt; len; i++) &#123; tempCharArray[i] = palindrome.charAt(i); &#125; // reverse array of chars for (int j = 0; j &lt; len; j++) &#123; charArray[j] = tempCharArray[len - 1 - j]; &#125; String reversePalindrome = new String(charArray); System.out.println(reversePalindrome); &#125;&#125; Running the program produces this output: 1doT saw I was toD 为了实现字符串反转，程序将字符串转换为字符数组（第一个“for”循环），将数组反转为第二个数组（第二个“for“循环），然后转换回字符串。 如果将“回文”字符串转换为字符串生成器，则可以在“StringBuilder”类中使用“reverse（）”方法。它使代码更简单，更容易阅读： 1234567891011public class StringBuilderDemo &#123; public static void main(String[] args) &#123; String palindrome = &quot;Dot saw I was Tod&quot;; StringBuilder sb = new StringBuilder(palindrome); sb.reverse(); // reverse it System.out.println(sb); &#125;&#125; Running this program produces the same output: 1doT saw I was toD Note that println() prints a string builder, as in: 1System.out.println(sb); 因为某人.toString()”被隐式调用，就像在“println（）”调用中对任何其他对象一样。 Note: 还有一个“StringBuffer”类与“StringBuilder”类*完全相同，只是由于方法同步，它是线程安全的。线程将在关于并发的课程中讨论。 Characters and Strings 总结大多数情况下，如果使用的是单个字符值，则将使用基本的“char”类型。然而，有时需要将字符用作对象，例如，用作需要对象的方法参数。Java编程语言提供了一个wrapper类，用于将“char”“包装”在“Character”对象中。“Character”类型的对象包含一个类型为“char”的字段。此字符类还提供了许多有用的类（即静态）方法来处理字符。 字符串是一系列字符，在Java编程中广泛使用。在Java编程语言中，字符串是对象。String类有60多个方法和13个构造函数。 最常见的情况是，您使用以下语句创建字符串 1String s = &quot;Hello world!&quot;; 而不是使用“String”构造函数之一。 “String”类有许多方法来查找和检索子字符串；然后可以使用“+”串联运算符将这些字符串轻松地重新组合成新字符串。 “String”类还包括许多实用程序方法，其中包括“split（）”、“toLowerCase（）”，“toUpperCase（）”和“valueOf（）”。在将用户输入字符串转换为数字时，后一种方法是必不可少的。“Number”子类也有将字符串转换为数字的方法，反之亦然。 除了“String”类之外，还有一个StringBuilder类。使用“StringBuilder”对象有时比使用字符串更有效。“StringBuilder”类提供了一些对字符串有用的方法，其中包括“reverse（）”。然而，一般来说，“String”类有更广泛的方法。 可以使用“StringBuilder”构造函数将字符串转换为字符串生成器。可以使用“toString（）”方法将字符串生成器转换为字符串。 自动装箱和拆箱Autoboxing是Java编译器在原语类型及其对应的对象包装类之间进行的自动转换。例如，将“int”转换成“Integer”，将“double”转换为“double”，依此类推。如果转换相反，则称为“unboxing”。 以下是自动装箱的最简单示例： 1Character ch = &#x27;a&#x27;; 本节中的其他示例使用泛型。如果您还不熟悉泛型的语法，请参阅generics（Updated）教训。 考虑以下代码： 123List&lt;Integer&gt; li = new ArrayList&lt;&gt;();for (int i = 1; i &lt; 50; i += 2) li.add(i); 尽管将“int”值作为基元类型而不是“Integer”对象添加到“li”中，但代码仍会编译。因为“li”是“Integer”对象的列表，而不是“int”值的列表，所以您可能会想为什么Java编译器不会发出编译时错误。编译器不会生成错误，因为它从“i”创建了一个“Integer”对象，并将该对象添加到“li”。因此，编译器在运行时将先前的代码转换为以下代码： 123List&lt;Integer&gt; li = new ArrayList&lt;&gt;();for (int i = 1; i &lt; 50; i += 2) li.add(Integer.valueOf(i)); 将原始值（例如“int”）转换为相应包装类（“Integer”）的对象称为自动装箱。当基元值为： 作为参数传递给需要相应包装类的对象的方法。 分配给相应包装类的变量。 考虑以下方法： 1234567public static int sumEven(List&lt;Integer&gt; li) &#123; int sum = 0; for (Integer i: li) if (i % 2 == 0) sum += i; return sum;&#125; 由于余数（“%”）和一元加号（“+&#x3D;”）运算符不适用于“Integer”对象，您可能会想知道为什么Java编译器编译该方法而不发出任何错误。编译器不会生成错误，因为它在运行时调用“intValue”方法将“Integer”转换为“int”： 1234567public static int sumEven(List&lt;Integer&gt; li) &#123; int sum = 0; for (Integer i : li) if (i.intValue() % 2 == 0) sum += i.intValue(); return sum;&#125; 将包装类型（“Integer”）的对象转换为其对应的原语（“int”）值称为取消装箱。当包装类的对象为： 作为参数传递给需要相应基元类型值的方法。 分配给相应基元类型的变量。 取消装箱示例显示了其工作原理： 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.List;public class Unboxing &#123; public static void main(String[] args) &#123; Integer i = new Integer(-8); // 1. Unboxing through method invocation int absVal = absoluteValue(i); System.out.println(&quot;absolute value of &quot; + i + &quot; = &quot; + absVal); List&lt;Double&gt; ld = new ArrayList&lt;&gt;(); ld.add(3.1416); // Π is autoboxed through method invocation. // 2. Unboxing through assignment double pi = ld.get(0); System.out.println(&quot;pi = &quot; + pi); &#125; public static int absoluteValue(int i) &#123; return (i &lt; 0) ? -i : i; &#125;&#125; 程序打印以下内容： 12absolute value of -8 = 8pi = 3.1416 自动装箱和拆箱可以让开发人员编写更干净的代码，使其更易于阅读。下表列出了Java编译器用于自动装箱和取消装箱的原语类型及其对应的包装类： 元 type 包装 class boolean Boolean byte Byte char Character float Float int Integer long Long short Short double Double","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"JS post方式打开新窗口","slug":"软件开发/技术/编程语言/js/JS-post方式打开新窗口","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/JS-post方式打开新窗口/","link":"","permalink":"https://guoshunfa.com/2022/07/JS-post%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3/","excerpt":"","text":"原理： 前端在打开浏览器窗口的同时，放入一段html代码。 html代码包含表单，也就相当于模拟表单post方式提交。 后端接口也通过表单的方式接受参数。 1. html12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;input id=&quot;btn_amp&quot; type=&quot;button&quot; value=&quot;点点点&quot; /&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; $(&quot;#btn_amp&quot;).click(function () &#123; var url = &quot;http://localhost:8080/test3&quot;; var keys = [&quot;userName&quot;]; var values = [&quot;123&quot;]; openWindowWithPost(url, &quot;预览&quot;, 500, 400, null, keys, values); &#125;); &#125;); /** * 调用 */ function openWindowWithPost(url, name, width, height, resizable, keys, values) &#123; var screenWidth = screen.availWidth, screenHeight = screen.availHeight; var para = &quot;&quot;; para += &#x27;width=&#x27; + (width ? width : screenWidth - 20); para += &#x27;,height=&#x27; + (height ? height : screenHeight - 43); para += &#x27;,left=&#x27; + (width ? (screenWidth - width) / 2 : 0); para += &#x27;,top=&#x27; + (height ? (screenHeight - height) / 2 : 0); if (resizable) para += &#x27;,resizable = yes&#x27;; if (!name) name = &quot;&quot;; var newWindow = window.open(&quot;&quot;, name, para); if (!newWindow) &#123; return false; &#125; var html = &quot;&quot;; html += &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&#x27;formid&#x27; method=&#x27;post&#x27; action=&#x27;&quot; + url + &quot;&#x27;&gt;&quot;; if (keys &amp;&amp; values &amp;&amp; (keys.length == values.length)) &#123; for (var i = 0; i &lt; keys.length; i++) &#123; html += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;&quot; + keys[i] + &quot;&#x27; value=&#x27;&quot; + values[i] + &quot;&#x27;/&gt;&quot;; &#125; &#125; html += &quot;&lt;/form&gt;&lt;script type=&#x27;text/javascript&#x27;&gt;document.getElementById(\\&quot;formid\\&quot;).submit()&lt;\\/script&gt;&lt;\\/body&gt;&lt;\\/html&gt;&quot;; newWindow.document.write(html); return newWindow; &#125;&lt;/script&gt; 2. 接口1234@PostMapping(&quot;/test3&quot;)public String test3Conllection(@RequestParam(&quot;userName&quot;) String userName) &#123; return &quot;测试成功！userName=&quot;+userName;&#125;","categories":[{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/categories/HTML-CSS-JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://guoshunfa.com/tags/JS/"}]},{"title":"Oracle Java类和对象","slug":"软件开发/技术/编程语言/java/Oracle-Java类和对象","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Oracle-Java类和对象/","link":"","permalink":"https://guoshunfa.com/2022/07/Oracle-Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/javaOO/index.html 类(Classes)在题为“面向对象编程概念”的课程中，面向对象概念的介绍以自行车类为例，赛车、山地自行车和串联自行车为子类。下面是Bicycle类的可能实现的示例代码，为您提供类声明的概述。本课程的后续部分将逐步支持和解释类声明。目前，不要关心细节。 1234567891011121314151617181920212223242526272829303132333435public class Bicycle &#123; // the Bicycle class has // three fields public int cadence; public int gear; public int speed; // the Bicycle class has // one constructor public Bicycle(int startCadence, int startSpeed, int startGear) &#123; gear = startGear; cadence = startCadence; speed = startSpeed; &#125; // the Bicycle class has // four methods public void setCadence(int newValue) &#123; cadence = newValue; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public void applyBrake(int decrement) &#123; speed -= decrement; &#125; public void speedUp(int increment) &#123; speed += increment; &#125; &#125; 作为Bicycle子类的MountainBike类的类声明可能如下所示： 123456789101112131415161718192021public class MountainBike extends Bicycle &#123; // the MountainBike subclass has // one field public int seatHeight; // the MountainBike subclass has // one constructor public MountainBike(int startHeight, int startCadence, int startSpeed, int startGear) &#123; super(startCadence, startSpeed, startGear); seatHeight = startHeight; &#125; // the MountainBike subclass has // one method public void setHeight(int newValue) &#123; seatHeight = newValue; &#125; &#125; MountainBike继承了Bicycle的所有字段和方法，并添加了字段seatHeight和设置方法（山地自行车具有可根据地形需要上下移动的座椅）。 声明类您已经看到了以以下方式定义的类： 1234class MyClass &#123; // field, constructor, and // method declarations&#125; 这是一个类声明。类主体（大括号之间的区域）包含了为从类创建的对象的生命周期提供的所有代码：用于初始化新对象的构造函数、用于提供类及其对象状态的字段声明，以及用于实现类及其对象行为的方法。 前面的类声明是最小的。它只包含类声明中需要的那些组件。您可以在类声明的开头提供有关类的更多信息，例如其超类的名称、是否实现任何接口等。例如 1234class MyClass extends MySuperClass implements YourInterface &#123; // field, constructor, and // method declarations&#125; 意味着MyClass是MySuperClass的子类，它实现了YourInterface接口。 您还可以在一开始就添加public或private等修饰符，这样您可以看到类声明的开头行会变得非常复杂。公共和私有修饰符决定了哪些其他类可以访问MyClass，将在本课稍后讨论。关于接口和继承的课程将解释如何以及为什么在类声明中使用扩展和实现关键字。目前你不需要担心这些额外的并发症。 一般来说，类声明可以包括以下组件： 修改器，如public、private和稍后将遇到的许多其他修改器。（但是，请注意，private修饰符只能应用于Nested Classes。） 类名，按照惯例，首字母大写。 类的父类（超类）的名称（如果有的话），前面加上关键字extends。一个类只能扩展（子类）一个父类。 由类实现的接口的逗号分隔列表（如果有），前面是关键字implements。一个类可以实现多个接口。 类主体由大括号｛｝包围。 声明成员变量有几种变量： 类中的成员变量称为字段。 方法或代码块中的变量称为局部变量。 方法声明中的变量称为参数。 Bicycle类使用以下代码行定义其字段： 123public int cadence;public int gear;public int speed; 字段声明由三个组件组成，顺序如下： 零个或多个修饰符，如public或private。 字段的类型。 字段的名称。 Bicycle的字段名为“节奏”、“档位”和“速度”，并且都是整数（int）数据类型。public关键字将这些字段标识为公共成员，可由任何可以访问类的对象访问。 访问修改函数使用的第一个（最左边）修饰符可以控制哪些其他类可以访问成员字段。目前，只考虑公共和私人。稍后将讨论其他访问修饰符。 public修饰符字段可从所有类访问。 private修饰符字段只能在其自己的类中访问。 本着封装的精神，将字段私有化是很常见的。这意味着只能从Bicycle类直接访问它们。然而，我们仍然需要获得这些价值观。这可以通过添加为我们获取字段值的公共方法间接实现： 12345678910111213141516171819202122232425262728293031323334353637383940public class Bicycle &#123; private int cadence; private int gear; private int speed; public Bicycle(int startCadence, int startSpeed, int startGear) &#123; gear = startGear; cadence = startCadence; speed = startSpeed; &#125; public int getCadence() &#123; return cadence; &#125; public void setCadence(int newValue) &#123; cadence = newValue; &#125; public int getGear() &#123; return gear; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public int getSpeed() &#123; return speed; &#125; public void applyBrake(int decrement) &#123; speed -= decrement; &#125; public void speedUp(int increment) &#123; speed += increment; &#125;&#125; 类型所有变量都必须有一个类型。您可以使用基本类型，如int、float、boolean等，也可以使用引用类型，如字符串、数组或对象。 变量名称所有变量，无论是字段、局部变量还是参数，都遵循语言基础课“Variables—Naming.”中介绍的相同命名规则和约定。 在本课中，请注意相同的命名规则和约定用于方法和类名，除了 类名的第一个字母应该大写 方法名中的第一个（或唯一一个）单词应该是动词。 定义方法下面是一个典型方法声明的示例： 1234public double calculateAnswer(double wingSpan, int numberOfEngines, double length, double grossTons) &#123; //do the calculation here&#125; 方法声明中唯一必需的元素是方法的返回类型、名称、一对括号（）和大括号之间的主体｛｝。 更一般地说，方法声明有六个组件，顺序如下： 修改器，如public、private和其他您稍后将了解的修改器。 返回类型是方法返回值的数据类型，如果方法不返回值，则返回void。 方法名字段名规则也适用于方法名，但约定有点不同。 括号中的参数列表—以逗号分隔的输入参数列表，前面是它们的数据类型，用括号（）括起来。如果没有参数，则必须使用空括号。 稍后将讨论的例外列表。 方法体（包含在方法代码的大括号中，包括局部变量的声明）位于此处。 修饰符、返回类型和参数将在本课后面讨论。例外情况将在后面的课程中讨论。 定义：方法声明的两个组件包括方法签名、方法名称和参数类型。 上述方法的签名为： 1calculateAnswer(double, int, double, double) 命名方法尽管方法名可以是任何合法标识符，但代码约定限制了方法名。按照惯例，方法名应该是一个小写的动词，或者是一个以小写的动词开头，然后是形容词、名词等的多单词名。在多单词名中，第二个和后面的每个单词的第一个字母都应该大写。以下是一些示例： 1234567runrunFastgetBackgroundgetFinalDatacompareTosetXisEmpty 通常，方法在其类中具有唯一的名称。但是，由于方法重载，方法可能与其他方法同名。 重载方法Java编程语言支持重载方法，Java可以区分具有不同方法签名的方法。这意味着，如果一个类中的方法有不同的参数列表，那么它们可以具有相同的名称（在“接口和继承”一课中将讨论一些限制条件）。 假设您有一个类可以使用书法绘制各种类型的数据（字符串、整数等），该类包含绘制每个数据类型的方法。为每个方法使用一个新名称是很麻烦的，例如drawString、drawInteger、drawFloat等。在Java编程语言中，您可以为所有绘制方法使用相同的名称，但可以为每个方法传递不同的参数列表。因此，数据绘制类可能会声明四个名为draw的方法，每个方法都有一个不同的参数列表。 123456789101112131415public class DataArtist &#123; ... public void draw(String s) &#123; ... &#125; public void draw(int i) &#123; ... &#125; public void draw(double f) &#123; ... &#125; public void draw(int i, double f) &#123; ... &#125;&#125; 重载方法通过传递给方法的参数的数量和类型进行区分。在代码示例中，draw（Strings）和draw（inti）是截然不同的方法，因为它们需要不同的参数类型。 不能声明多个具有相同名称、相同数量和类型的参数的方法，因为编译器无法区分它们。 编译器在区分方法时不考虑返回类型，因此您不能声明具有相同签名的两个方法，即使它们具有不同的返回类型。 &#x3D;&#x3D;注意：重载方法应该谨慎使用，因为它们会使代码的可读性大大降低。&#x3D;&#x3D; 为类提供构造函数类包含调用以从类蓝图创建对象的构造函数。构造函数声明看起来像方法声明，只是它们使用类的名称并且没有返回类型。例如，Bicycle有一个构造函数： 12345public Bicycle(int startCadence, int startSpeed, int startGear) &#123; gear = startGear; cadence = startCadence; speed = startSpeed;&#125; 要创建名为myBike的新Bicycle对象，new操作符将调用构造函数： 1Bicycle myBike = new Bicycle(30, 0, 8); newBicycle（30,0,8）在内存中为对象创建空间并初始化其字段。 尽管Bicycle只有一个构造函数，但它也可以有其他构造函数，包括无参数构造函数： 12345public Bicycle() &#123; gear = 1; cadence = 10; speed = 0;&#125; Bicycle yourBike = new Bicycle(); 调用无参数构造函数创建名为yourBike的新Bicycle对象。 两个构造函数都可以在Bicycle中声明，因为它们有不同的参数列表。与方法一样，Java平台根据列表中参数的数量及其类型来区分构造函数。不能为同一类编写两个参数数量和类型相同的构造函数，因为平台无法将它们区分开来。这样做会导致编译时错误。 您不必为类提供任何构造函数，但在这样做时必须小心。编译器自动为任何没有构造函数的类提供无参数的默认构造函数。此默认构造函数将调用超类的无参数构造函数。在这种情况下，如果超类没有无参数构造函数，编译器会发出抱怨，因此您必须验证它有无参数构造函数。如果您的类没有显式超类，那么它有一个隐式超类Object，该类没有参数构造函数。 您可以自己使用超类构造函数。本课开始时的山地自行车课就是这样做的。这将在稍后的接口和继承课程中讨论。 可以在构造函数声明中使用访问修饰符来控制哪些其他类可以调用构造函数。 &#x3D;&#x3D;注意：如果另一个类不能调用MyClass构造函数，则不能直接创建MyClass对象。&#x3D;&#x3D; 向方法或构造函数传递信息方法或构造函数的声明声明了该方法或构造函数参数的数量和类型。例如，以下是一种根据贷款金额、利率、贷款期限（期限数）和贷款未来价值计算住房贷款月付款的方法： 12345678910111213public double computePayment( double loanAmt, double rate, double futureValue, int numPeriods) &#123; double interest = rate / 100.0; double partial1 = Math.pow((1 + interest), - numPeriods); double denominator = (1 - partial1) / interest; double answer = (-loanAmt / denominator) - ((futureValue * partial1) / denominator); return answer;&#125; 该方法有四个参数：贷款金额、利率、未来价值和期数。前三个是双精度浮点数，第四个是整数。参数在方法体中使用，在运行时将接受传入的参数值。 &#x3D;&#x3D;注意：参数是指方法声明中的变量列表。参数是调用方法时传入的实际值。调用方法时，使用的参数必须在类型和顺序上与声明的参数匹配。&#x3D;&#x3D; 参数类型您可以将任何数据类型用于方法或构造函数的参数。这包括基本数据类型，如double、float和integer，如您在computePayment方法中看到的，以及引用数据类型，例如对象和数组。 下面是一个接受数组作为参数的方法的示例。在本例中，该方法创建一个新的多边形对象，并从Point对象数组初始化它（假设Point是表示x，y坐标的类）： 123public Polygon polygonFrom(Point[] corners) &#123; // method body goes here&#125; 注意：如果要将方法传递给方法，请使用lambda expression 或 method reference. 任意数量的参数可以使用名为varargs的构造将任意数量的值传递给方法。当您不知道将向方法传递多少特定类型的参数时，可以使用varargs。这是手动创建数组的快捷方式（以前的方法可以使用varargs而不是数组）。 要使用varargs，在最后一个参数的类型后面加一个省略号（三个点，…），然后加一个空格和参数名称。然后可以使用任意数量的该参数调用该方法，包括无。 123456789101112public Polygon polygonFrom(Point... corners) &#123; int numberOfSides = corners.length; double squareOfSide1, lengthOfSide1; squareOfSide1 = (corners[1].x - corners[0].x) * (corners[1].x - corners[0].x) + (corners[1].y - corners[0].y) * (corners[1].y - corners[0].y); lengthOfSide1 = Math.sqrt(squareOfSide1); // more method body code follows that creates and returns a // polygon connecting the Points&#125; 您可以看到，在该方法中，角被视为数组。可以使用数组或参数序列调用该方法。无论哪种情况，方法体中的代码都会将参数视为数组。 您通常会看到带有打印方法的varargs；例如，这个printf方法： 1public PrintStream printf(String format, Object... args) 允许您打印任意数量的对象。可以这样称呼： 1System.out.printf(&quot;%s: %d, %s%n&quot;, name, idnum, address); 或者像这样 1System.out.printf(&quot;%s: %d, %s, %s, %s%n&quot;, name, idnum, address, phone, email); 或者具有不同数量的参数。 参数名称当您向方法或构造函数声明参数时，您需要为该参数提供一个名称。此名称在方法体中用于引用传入的参数。 参数的名称在其范围内必须唯一。它不能与同一方法或构造函数的另一个参数的名称相同，也不能是方法或构造函数中的局部变量的名称。 参数可以与类的某个字段同名。如果是这种情况，则该参数被称为阴影字段。阴影字段会使代码难以阅读，通常仅在设置特定字段的构造函数和方法中使用。例如，考虑以下Circle类及其setOrigin方法： 123456public class Circle &#123; private int x, y, radius; public void setOrigin(int x, int y) &#123; ... &#125;&#125; Circle类有三个字段：x、y和radius。setOrigin方法有两个参数，每个参数的名称与其中一个字段的名称相同。每个方法参数都会隐藏共享其名称的字段。因此，在方法体中使用简单名称x或y是指参数，而不是字段。要访问该字段，必须使用限定名称。这将在本课后面的“使用此关键字”一节中讨论. 传递原语数据类型参数原始参数（如int或double）通过值传递到方法中。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失。下面是一个示例： 123456789101112131415161718192021public class PassPrimitiveByValue &#123; public static void main(String[] args) &#123; int x = 3; // invoke passMethod() with // x as argument passMethod(x); // print x to see if its // value has changed System.out.println(&quot;After invoking passMethod, x = &quot; + x); &#125; // change parameter in passMethod() public static void passMethod(int p) &#123; p = 10; &#125;&#125; 运行此程序时，输出为： 1After invoking passMethod, x = 3 传递引用数据类型参数引用数据类型参数（如对象）也按值传递到方法中。这意味着当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象的字段具有适当的访问级别，则可以在方法中更改这些字段的值。 例如，考虑任意类中移动Circle对象的方法： 12345678public void moveCircle(Circle circle, int deltaX, int deltaY) &#123; // code to move origin of circle to x+deltaX, y+deltaY circle.setX(circle.getX() + deltaX); circle.setY(circle.getY() + deltaY); // code to assign a new reference to circle circle = new Circle(0, 0);&#125; 使用以下参数调用方法： 1moveCircle(myCircle, 23, 56) 在方法中，圆最初是指myCircle。该方法将圆引用的对象（即myCircle）的x和y坐标分别更改23和56。当方法返回时，这些更改将持续存在。然后，圆被分配给一个新的circle对象（x&#x3D;y&#x3D;0）的引用。但是，这种重新分配没有永久性，因为引用是按值传递的，不能更改。在该方法中，圆指向的对象已更改，但当该方法返回时，myCircle仍然引用与调用该方法之前相同的circle对象。 对象(Objects)典型的Java程序创建许多对象，正如您所知，这些对象通过调用方法进行交互。通过这些对象交互，程序可以执行各种任务，例如实现GUI、运行动画或通过网络发送和接收信息。一旦对象完成了为其创建的工作，其资源将被回收供其他对象使用。 这是一个名为CreateObjectDemo的小程序，它创建三个对象：一个Point对象和两个Rectangle对象。编译此程序需要所有三个源文件。 123456789101112131415161718192021222324252627public class CreateObjectDemo &#123; public static void main(String[] args) &#123; // Declare and create a point object and two rectangle objects. Point originOne = new Point(23, 94); Rectangle rectOne = new Rectangle(originOne, 100, 200); Rectangle rectTwo = new Rectangle(50, 100); // display rectOne&#x27;s width, height, and area System.out.println(&quot;Width of rectOne: &quot; + rectOne.width); System.out.println(&quot;Height of rectOne: &quot; + rectOne.height); System.out.println(&quot;Area of rectOne: &quot; + rectOne.getArea()); // set rectTwo&#x27;s position rectTwo.origin = originOne; // display rectTwo&#x27;s position System.out.println(&quot;X Position of rectTwo: &quot; + rectTwo.origin.x); System.out.println(&quot;Y Position of rectTwo: &quot; + rectTwo.origin.y); // move rectTwo and display its new position rectTwo.move(40, 72); System.out.println(&quot;X Position of rectTwo: &quot; + rectTwo.origin.x); System.out.println(&quot;Y Position of rectTwo: &quot; + rectTwo.origin.y); &#125;&#125; 该程序创建、操作和显示有关各种对象的信息。以下是输出： 1234567Width of rectOne: 100Height of rectOne: 200Area of rectOne: 20000X Position of rectTwo: 23Y Position of rectTwo: 94X Position of rectTwo: 40Y Position of rectTwo: 72 以下三个部分使用上面的示例来描述程序中对象的生命周期。从中，您将学习如何编写在自己的程序中创建和使用对象的代码。您还将了解当对象的生命结束时，系统如何在对象之后进行清理。 创建对象如您所知，类提供对象的蓝图；从类创建对象。从 CreateObjectDemo程序中提取的以下语句中的每一个都会创建一个对象并将其指定给一个变量： 123Point originOne = new Point(23, 94);Rectangle rectOne = new Rectangle(originOne, 100, 200);Rectangle rectTwo = new Rectangle(50, 100); 第一行创建Point类的对象，第二行和第三行分别创建Rectangle类的对象。 这些语句中的每一个都有三个部分（下面将详细讨论）： 声明：粗体代码集是将变量名与对象类型关联的所有变量声明。 实例化：new关键字是创建对象的Java运算符。 初始化：新运算符后面是对构造函数的调用，构造函数初始化新对象。 声明变量以引用对象之前，您了解到要声明变量，您可以编写： 1type name; 这会通知编译器，您将使用名称引用类型为type的数据。对于基元变量，此声明还为变量保留了适当的内存量。 您也可以在自己的行中声明引用变量。例如： 1Point originOne; 如果像这样声明originOne，那么在实际创建并分配对象之前，它的值将无法确定。简单地声明引用变量不会创建对象。为此，您需要使用新运算符，如下一节所述。在代码中使用对象之前，必须将其分配给originOne。否则，您将得到一个编译器错误。 此状态下的变量当前未引用任何对象，可以如下所示（变量名originOne加上指向任何对象的引用）： 实例化类新操作符通过为新对象分配内存并返回对该内存的引用来实例化类。新运算符还调用对象构造函数。 &#x3D;&#x3D;注意：短语“实例化一个类”的意思与“创建一个对象”的意思相同。当您创建对象时，您正在创建一个类的“实例”，因此“实例”一个类。&#x3D;&#x3D; 新运算符需要一个后缀参数：对构造函数的调用。构造函数的名称提供了要实例化的类的名称。 新运算符返回对其创建的对象的引用。此引用通常分配给适当类型的变量，如： 1Point originOne = new Point(23, 94); 新运算符返回的引用不必指定给变量。它也可以直接在表达式中使用。例如： 1int height = new Rectangle().height; 这一声明将在下一节讨论。 初始化对象以下是Point类的代码： 123456789public class Point &#123; public int x = 0; public int y = 0; //constructor public Point(int a, int b) &#123; x = a; y = b; &#125;&#125; 此类包含单个构造函数。您可以识别构造函数，因为它的声明使用与类相同的名称，并且没有返回类型。Point类中的构造函数接受两个整数参数，如代码所声明的（int a，int b）。以下语句提供23和94作为这些参数的值： 1Point originOne = new Point(23, 94); 执行此语句的结果如下图所示： 下面是Rectangle类的代码，它包含四个构造函数： 12345678910111213141516171819202122232425262728293031323334public class Rectangle &#123; public int width = 0; public int height = 0; public Point origin; // four constructors public Rectangle() &#123; origin = new Point(0, 0); &#125; public Rectangle(Point p) &#123; origin = p; &#125; public Rectangle(int w, int h) &#123; origin = new Point(0, 0); width = w; height = h; &#125; public Rectangle(Point p, int w, int h) &#123; origin = p; width = w; height = h; &#125; // a method for moving the rectangle public void move(int x, int y) &#123; origin.x = x; origin.y = y; &#125; // a method for computing the area of the rectangle public int getArea() &#123; return width * height; &#125;&#125; 每个构造函数都允许您使用基本类型和引用类型为矩形的原点、宽度和高度提供初始值。如果一个类有多个构造函数，它们必须有不同的签名。Java编译器根据参数的数量和类型区分构造函数。当Java编译器遇到以下代码时，它知道调用Rectangle类中的构造函数，该构造函数需要Point参数后跟两个整数参数： 1Rectangle rectOne = new Rectangle(originOne, 100, 200); 这将调用Rectangle的构造函数之一，该构造函数将origin初始化为originOne。此外，构造函数将宽度设置为100，高度设置为200。现在有两个对同一Point对象的引用，一个对象可以有多个对它的引用，如下图所示： 下面一行代码调用Rectangle构造函数，该构造函数需要两个整数参数，它们提供宽度和高度的初始值。如果检查构造函数中的代码，您会看到它创建了一个新的Point对象，其x和y值被初始化为0： 1Rectangle rectTwo = new Rectangle(50, 100); 以下语句中使用的矩形构造函数不带任何参数，因此称为无参数构造函数： 1Rectangle rect = new Rectangle(); 所有类都至少有一个构造函数。如果类没有显式声明任何，Java编译器会自动提供一个无参数构造函数，称为默认构造函数。此默认构造函数调用类父级的无参数构造函数，如果类没有其他父级，则调用Object构造函数。如果父级没有构造函数（Object有构造函数），编译器将拒绝该程序。 使用对象一旦您创建了一个对象，您可能希望将其用于某些用途。您可能需要使用其中一个字段的值、更改其中一个域或调用其中一个方法来执行操作。 引用对象的字段对象字段通过其名称进行访问。您必须使用明确的名称。 您可以在自己的类中为字段使用一个简单的名称。例如，我们可以在Rectangle类中添加一条语句来打印宽度和高度： 1System.out.println(&quot;Width and height are: &quot; + width + &quot;, &quot; + height); 在这种情况下，宽度和高度是简单的名称。 对象类之外的代码必须使用对象引用或表达式，后跟点（.）运算符，后跟简单字段名，如： 1objectReference.fieldName 例如，CreateObjectDemo类中的代码位于Rectangle类的代码之外。因此，要引用名为rectOne的矩形对象中的原点、宽度和高度字段，CreateObjectDemo类必须使用名称rectOne。原点，rectOne。width和rectOne。高度。程序使用以下两个名称来显示rectOne的宽度和高度： 12System.out.println(&quot;Width of rectOne: &quot; + rectOne.width);System.out.println(&quot;Height of rectOne: &quot; + rectOne.height); 试图使用CreateObjectDemo类中代码中的简单名称width和height是没有意义的-这些字段只存在于对象中-并导致编译器错误。 稍后，该程序使用类似的代码来显示关于rectTwo的信息。相同类型的对象具有自己的相同实例字段副本。因此，每个矩形对象都有名为原点、宽度和高度的字段。通过对象引用访问实例字段时，将引用该特定对象的字段。CreateObjectDemo程序中的两个对象rectOne和rectTwo具有不同的原点、宽度和高度字段。 要访问字段，可以使用对对象的命名引用，如前面的示例所示，也可以使用任何返回对象引用的表达式。回想一下，新操作符返回对对象的引用。因此，您可以使用new返回的值来访问新对象的字段： 1int height = new Rectangle().height; 此语句创建一个新的矩形对象，并立即获得其高度。本质上，该语句计算矩形的默认高度。请注意，在执行此语句之后，程序不再具有对所创建矩形的引用，因为程序从未将该引用存储在任何位置。对象未被引用，其资源可由Java虚拟机自由回收。 调用对象的方法还可以使用对象引用来调用对象的方法。您可以将方法的简单名称附加到对象引用，中间有一个点运算符（.）。此外，还可以在括号内提供该方法的任何参数。如果方法不需要任何参数，请使用空括号。 1objectReference.methodName(argumentList); or: 1objectReference.methodName(); Rectangle类有两个方法：getArea（）计算矩形的面积，move（）更改矩形的原点。下面是调用这两个方法的CreateObjectDemo代码： 123System.out.println(&quot;Area of rectOne: &quot; + rectOne.getArea());...rectTwo.move(40, 72); 第一条语句调用rectOne的getArea（）方法并显示结果。第二行移动rectTwo，因为move（）方法为对象的原点指定了新值。x和原点y。 与实例字段一样，objectReference必须是对对象的引用。可以使用变量名，但也可以使用返回对象引用的任何表达式。new运算符返回一个对象引用，因此您可以使用从new返回的值来调用新对象的方法： 1new Rectangle(100, 50).getArea() 表达式new Rectangle（100，50）返回一个引用矩形对象的对象引用。如图所示，您可以使用点表示法调用新矩形的getArea（）方法来计算新矩形的面积。 一些方法，如getArea（），返回一个值。对于返回值的方法，可以在表达式中使用方法调用。您可以将返回值分配给变量，使用它来进行决策，或控制循环。此代码将getArea（）返回的值分配给变量areaOfRectangle： 1int areaOfRectangle = new Rectangle(100, 50).getArea(); 请记住，对特定对象调用方法与向该对象发送消息相同。在这种情况下，调用getArea（）的对象是构造函数返回的矩形。 垃圾收集器一些面向对象的语言要求您跟踪创建的所有对象，并在不再需要它们时显式销毁它们。显式地管理内存是乏味且容易出错的。Java平台允许您创建任意多的对象（当然，受限于您的系统所能处理的对象），并且您不必担心破坏它们。当Java运行时环境确定不再使用对象时，将删除这些对象。这个过程称为垃圾收集。 当不再有对该对象的引用时，该对象可以进行垃圾收集。当变量超出范围时，通常会删除变量中的引用。或者，可以通过将变量设置为特殊值null来显式删除对象引用。请记住，一个程序可以对同一对象有多个引用；在对象符合垃圾收集条件之前，必须删除对该对象的所有引用。 Java运行时环境有一个垃圾收集器，它定期释放不再被引用的对象所使用的内存。垃圾收集器在确定时间合适时自动执行其任务。 类的更多操作从方法返回值方法返回调用它的代码 完成方法中的所有语句， 到达返回语句， 或抛出异常（稍后介绍）， 以先发生者为准。 在方法声明中声明方法的返回类型。在方法体中，使用return语句返回值。 任何声明为void的方法都不会返回值。它不需要包含return语句，但可以这样做。在这种情况下，可以使用return语句从控制流块中分支出来并退出该方法，其用法如下： 1return; 如果您试图从声明为void的方法返回值，将得到编译器错误。 任何未声明为void的方法都必须包含具有相应返回值的return语句，如下所示： 1return returnValue; 返回值的数据类型必须与方法声明的返回类型匹配；不能从声明为返回布尔值的方法返回整数值。 Rectangle Rectangel类中的getArea()方法返回一个整数： 1234// a method for computing the area of the rectanglepublic int getArea() &#123; return width * height;&#125; 此方法返回表达式width*height计算的整数。 getArea方法返回一个基元类型。方法也可以返回引用类型。例如，在一个操纵Bicycle对象的程序中，我们可能有这样一个方法： 123456789public Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike, Environment env) &#123; Bicycle fastest; // code to calculate which bike is // faster, given each bike&#x27;s gear // and cadence and given the // environment (terrain and wind) return fastest;&#125; 返回类或接口如果这一部分让您感到困惑，请跳过它，在完成接口和继承的课程后返回。当方法使用类名作为其返回类型时，如whosFastest所做的那样，返回对象类型的类必须是返回类型的子类或确切的类。假设您有一个类层次结构，其中ImaginaryNumber是java.lang.Number的子类，而后者又是Object的子类。如下图所示。 现在假设您有一个声明为返回Number的方法： 123public Number returnANumber() &#123; ...&#125; returnANumber方法可以返回ImaginaryNumber，但不能返回Object。ImaginaryNumber是Number，因为它是Number的子类。然而，Object不一定是Number，它可以是String或其他类型。 您可以重写一个方法并将其定义为返回原始方法的子类，如下所示： 123public ImaginaryNumber returnANumber() &#123; ...&#125; 这种称为协变返回类型的技术意味着允许返回类型与子类的方向相同。 &#x3D;&#x3D;注意：您也可以使用接口名称作为返回类型。在这种情况下，返回的对象必须实现指定的接口。&#x3D;&#x3D; 使用this关键字在实例方法或构造函数中，这是对当前对象的引用，即调用其方法或构造函数的对象。通过使用该方法，可以从实例方法或构造函数中引用当前对象的任何成员。 使用this字段使用this关键字的最常见原因是因为字段被方法或构造函数参数遮蔽。 例如，Point类是这样编写的 12345678910public class Point &#123; public int x = 0; public int y = 0; //constructor public Point(int a, int b) &#123; x = a; y = b; &#125;&#125; 但它可能是这样写的： 12345678910public class Point &#123; public int x = 0; public int y = 0; //constructor public Point(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 构造函数的每个参数都会隐藏对象的一个字段——在构造函数x中是构造函数第一个参数的本地副本。要引用点字段x，构造函数必须使用this.x。 将this与构造函数一起使用在构造函数中，还可以使用this关键字调用同一类中的另一个构造函数。这样做称为显式构造函数调用。这是另一个Rectangle类，其实现与Objects部分中的不同。 123456789101112131415161718public class Rectangle &#123; private int x, y; private int width, height; public Rectangle() &#123; this(0, 0, 1, 1); &#125; public Rectangle(int width, int height) &#123; this(0, 0, width, height); &#125; public Rectangle(int x, int y, int width, int height) &#123; this.x = x; this.y = y; this.width = width; this.height = height; &#125; ...&#125; 此类包含一组构造函数。每个构造函数初始化矩形的一些或所有成员变量。构造函数为参数未提供初始值的任何成员变量提供默认值。例如，无参数构造函数在坐标0,0处创建一个1x1矩形。双参数构造函数调用四参数构造函数，传递宽度和高度，但始终使用0,0坐标。如前所述，编译器根据参数的数量和类型确定调用哪个构造函数。 如果存在，对另一个构造函数的调用必须是构造函数中的第一行。 控制对类成员的访问访问级别修饰符确定其他类是否可以使用特定字段或调用特定方法。访问控制有两个级别： 在顶层public或package private（没有显式修饰符）。 在成员级public、private、protected或package private（无显式修饰符）。 类可以用修饰符public声明，在这种情况下，所有类都可以看到该类。如果一个类没有修饰符（默认值，也称为packageprivate），则它只能在其自己的包中可见（包是相关类的命名组，您将在后面的课程中了解它们）。 在成员级别，您也可以使用public修饰符或no修饰符，就像顶级类一样，并具有相同的含义。对于成员，还有两个额外的访问修饰符：private和protected。私有修饰符指定成员只能在其自己的类中访问。protected修饰符指定成员只能在其自己的包中访问（与包private一样），此外，还可以由另一个包中其类的子类访问。 下表显示了每个修饰符允许的成员访问权限。 Modifier Class Package Subclass World public Y Y Y Y protected Y Y Y N no modifier Y Y N N private Y N N N 第一个数据列指示类本身是否有权访问由访问级别定义的成员。如您所见，类始终可以访问自己的成员。第二列指示与该类在同一包中的类（无论其父级如何）是否有权访问该成员。第三列指示在此包外部声明的类的子类是否可以访问该成员。第四列指示是否所有类都可以访问该成员。 访问级别以两种方式影响您。首先，当您使用来自其他源的类（如Java平台中的类）时，访问级别决定您自己的类可以使用这些类的哪些成员。第二，在编写类时，需要确定类中每个成员变量和每个方法应该具有的访问级别。 让我们看看一组类，看看访问级别如何影响可见性。下图显示了本示例中的四个类以及它们之间的关系。 下表显示了Alpha类的成员对于可以应用于它们的每个访问修饰符的可见位置。 Modifier Alpha Beta Alphasub Gamma public Y Y Y Y protected Y Y Y N no modifier Y Y N N private Y N N N 选择访问级别的提示： 如果其他程序员使用您的类，您希望确保不会发生误用错误。访问级别可以帮助您做到这一点。 使用对特定成员有意义的最严格的访问级别。除非你有充分的理由不这样做，否则使用隐私。 避免除常量外的公共字段。（本教程中的许多示例都使用公共字段。这可能有助于简明地说明某些要点，但不建议用于生产代码。）公共字段往往会将您链接到特定的实现，并限制您更改代码的灵活性。 了解类成员在本节中，我们将讨论使用static关键字创建属于类而不是类实例的字段和方法。 类变量当从同一个类蓝图创建多个对象时，它们都有各自不同的实例变量副本。对于Bicycle类，实例变量是节奏、档位和速度。每个Bicycle对象都有自己的这些变量值，存储在不同的内存位置。 有时，您希望所有对象都有通用的变量。这是通过静态修饰符实现的。声明中包含静态修饰符的字段称为静态字段或类变量。它们与类关联，而不是与任何对象关联。类的每个实例共享一个类变量，该变量位于内存中的一个固定位置。任何对象都可以更改类变量的值，但也可以在不创建类实例的情况下操作类变量。 例如，假设您要创建多个Bicycle对象，并为每个对象指定一个序列号，第一个对象从1开始。此ID号对于每个对象都是唯一的，因此是一个实例变量。同时，您需要一个字段来跟踪已创建的Bicycle对象的数量，以便知道要为下一个对象指定什么ID。这样的字段与任何单个对象无关，而是与整个类有关。为此，您需要一个类变量numberOfBicycles，如下所示： 1234567891011121314public class Bicycle &#123; private int cadence; private int gear; private int speed; // add an instance variable for the object ID private int id; // add a class variable for the // number of Bicycle objects instantiated private static int numberOfBicycles = 0; ...&#125; 类变量由类名本身引用，如 1Bicycle.numberOfBicycles 这表明它们是类变量。 &#x3D;&#x3D;注意：您也可以使用像myBike这样的对象引用来引用静态字段。&#x3D;&#x3D; &#x3D;&#x3D;numberOfBicycles，但这是不鼓励的，因为它不清楚它们是类变量。&#x3D;&#x3D; 您可以使用Bicycle构造函数设置id实例变量并递增numberOfBicycles类变量： 123456789101112131415161718192021222324public class Bicycle &#123; private int cadence; private int gear; private int speed; private int id; private static int numberOfBicycles = 0; public Bicycle(int startCadence, int startSpeed, int startGear)&#123; gear = startGear; cadence = startCadence; speed = startSpeed; // increment number of Bicycles // and assign ID number id = ++numberOfBicycles; &#125; // new method to return the ID instance variable public int getID() &#123; return id; &#125; ...&#125; 类方法Java编程语言支持静态方法和静态变量。静态方法（在其声明中有静态修饰符）应使用类名调用，而无需创建类的实例，如 1ClassName.methodName(args) &#x3D;&#x3D;注意：还可以使用对象引用引用静态方法，如&#x3D;&#x3D; &#x3D;&#x3D;instanceName.methodName(args)&#x3D;&#x3D; &#x3D;&#x3D;但这是不鼓励的，因为它没有明确说明它们是类方法&#x3D;&#x3D; 静态方法的一个常见用法是访问静态字段。例如，我们可以向Bicycle类添加一个静态方法来访问numberOfBicycles静态字段： 123public static int getNumberOfBicycles() &#123; return numberOfBicycles;&#125; 并非所有实例和类变量及方法的组合都是允许的： 实例方法可以直接访问实例变量和实例方法。 实例方法可以直接访问类变量和类方法。 类方法可以直接访问类变量和类方法。 类方法不能直接访问实例变量或实例方法，它们必须使用对象引用。此外，类方法不能使用this关键字，因为没有可引用的实例。 常量静态修饰符与最终修饰符结合使用，也用于定义常量。最后一个修饰符表示该字段的值不能更改。 例如，下面的变量声明定义了一个名为PI的常数，其值是PI的近似值（圆的周长与其直径的比值）： 1static final double PI = 3.141592653589793; 无法重新分配以这种方式定义的常量，如果程序尝试这样做，则会出现编译时错误。按照惯例，常量值的名称用大写字母拼写。如果名称由多个单词组成，则这些单词用下划线（_）分隔。 &#x3D;&#x3D;注意：如果基元类型或字符串被定义为常量，并且在编译时已知其值，编译器会用其值替换代码中的所有常量名称。这称为编译时常数。如果外部世界中常量的值发生变化（例如，如果立法规定pi实际上应该是3.975），则需要重新编译使用该常量的任何类以获得当前值。&#x3D;&#x3D; 自行车class 在本节中进行了所有修改后，Bicycle类现在是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Bicycle &#123; private int cadence; private int gear; private int speed; private int id; private static int numberOfBicycles = 0; public Bicycle(int startCadence, int startSpeed, int startGear) &#123; gear = startGear; cadence = startCadence; speed = startSpeed; id = ++numberOfBicycles; &#125; public int getID() &#123; return id; &#125; public static int getNumberOfBicycles() &#123; return numberOfBicycles; &#125; public int getCadence() &#123; return cadence; &#125; public void setCadence(int newValue) &#123; cadence = newValue; &#125; public int getGear()&#123; return gear; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public int getSpeed() &#123; return speed; &#125; public void applyBrake(int decrement) &#123; speed -= decrement; &#125; public void speedUp(int increment) &#123; speed += increment; &#125;&#125; 初始化字段正如您所看到的，您通常可以在字段声明中为其提供初始值： 12345678public class BedAndBreakfast &#123; // initialize to 10 public static int capacity = 10; // initialize to false private boolean full = false;&#125; 当初始化值可用并且可以将初始化放在一行上时，这很好。然而，这种形式的初始化由于其简单性而具有局限性。如果初始化需要一些逻辑（例如错误处理或用于填充复杂数组的for循环），简单的作业是不够的。实例变量可以在构造函数中初始化，其中可以使用错误处理或其他逻辑。为了为类变量提供相同的功能，Java编程语言包括静态初始化块。 &#x3D;&#x3D;注意：没有必要在类定义的开头声明字段，尽管这是最常见的做法。只需要在使用它们之前声明和初始化它们。&#x3D;&#x3D; 静态初始化块静态初始化块是一个普通的代码块，用大括号｛｝括起来，前面是static关键字。下面是一个示例： 123static &#123; // whatever code is needed for initialization goes here&#125; 一个类可以有任意数量的静态初始化块，它们可以出现在类主体中的任何位置。运行时系统保证按照静态初始化块在源代码中出现的顺序调用它们。 有一种替代静态块的方法——您可以编写一个私有静态方法： 12345678class Whatever &#123; public static varType myVar = initializeClassVariable(); private static varType initializeClassVariable() &#123; // initialization code goes here &#125;&#125; 私有静态方法的优点是，如果需要重新初始化类变量，则可以稍后重用它们。 初始化实例成员通常，您会将代码放在构造函数中初始化实例变量。使用构造函数初始化实例变量有两种选择：初始化块和final方法。 实例变量的初始化器块看起来与静态初始化器块类似，但没有static关键字： 123&#123; // 初始化所需的任何代码都在这里&#125; Java编译器将初始化器块复制到每个构造函数中。因此，这种方法可以用于在多个构造函数之间共享代码块。 final方法不能在子类中重写。这在关于接口和继承的课程中进行了讨论。下面是使用final方法初始化实例变量的示例： 12345678class Whatever &#123; private varType myVar = initializeInstanceVariable(); protected final varType initializeInstanceVariable() &#123; // initialization code goes here &#125;&#125; 如果子类可能希望重用初始化方法，这一点尤其有用。该方法是final的，因为在实例初始化期间调用非final方法可能会导致问题。 创建和使用类和对象概述类声明命名类，并将类体括在大括号之间。类名前面可以有修饰符。类主体包含类的字段、方法和构造函数。类使用字段来包含状态信息，并使用方法来实现行为。初始化类的新实例的构造函数使用类的名称，看起来像没有返回类型的方法。 您可以以相同的方式控制对类和成员的访问：在它们的声明中使用访问修饰符，如public。 通过在成员声明中使用static关键字来指定类变量或类方法。未声明为静态的成员隐式为实例成员。类变量由类的所有实例共享，可以通过类名和实例引用访问。类的实例获得每个实例变量的自己副本，必须通过实例引用访问该副本。 使用new运算符和构造函数从类创建对象。新运算符返回对已创建对象的引用。您可以将引用分配给变量或直接使用它。 实例变量和方法可由声明它们的类之外的代码访问，可以通过使用限定名来引用。实例变量的限定名如下所示： 1objectReference.variableName 方法的限定名如下所示： 1objectReference.methodName(argumentList) or: 1objectReference.methodName() 垃圾收集器会自动清理未使用的对象。如果程序不再包含对对象的引用，则对象将不被使用。通过将保持引用的变量设置为null，可以显式删除引用。 内部类Java编程语言允许您在另一个类中定义一个类。这样的类称为嵌套类，如下所示： 123456class OuterClass &#123; ... class NestedClass &#123; ... &#125;&#125; &#x3D;&#x3D;术语：嵌套类分为两类：非静态类和静态类。非静态嵌套类称为内部类。声明为静态的嵌套类称为静态嵌套类。&#x3D;&#x3D; 123456789class OuterClass &#123; ... class InnerClass &#123; ... &#125; static class StaticNestedClass &#123; ... &#125;&#125; 嵌套类是其封闭类的成员。非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有。静态嵌套类无权访问封闭类的其他成员。作为OuterClass的成员，嵌套类可以声明为private、public、protected或package private。（记住，外部类只能声明为public或package private。） 为什么使用嵌套类？使用嵌套类的主要原因如下： 这是一种对仅在一个地方使用的类进行逻辑分组的方法：如果一个类只对另一个类有用，那么将其嵌入该类并将两者保持在一起是合乎逻辑的。嵌套这样的“助手类”使它们的包更加精简。 它增加了封装：考虑两个顶级类A和B，其中B需要访问A的成员，否则这些成员将被声明为私有。通过将类B隐藏在类A中，可以将A的成员声明为私有，B可以访问它们。此外，B本身可以对外界隐藏。 它可以产生更可读和可维护的代码：将小类嵌套在顶级类中，使代码更接近使用它的地方。 内部类与实例方法和变量一样，内部类与其封闭类的实例相关联，并可以直接访问该对象的方法和字段。此外，因为内部类与实例相关联，所以它本身不能定义任何静态成员。 作为内部类实例的对象存在于外部类的实例中。考虑以下类别： 123456class OuterClass &#123; ... class InnerClass &#123; ... &#125;&#125; InnerClass实例只能存在于OuterClass实例中，并且可以直接访问其封闭实例的方法和字段。 要实例化内部类，必须首先实例化外部类。然后，使用以下语法在外部对象中创建内部对象： 12OuterClass outerObject = new OuterClass();OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 有两种特殊的内部类：local classes and anonymous classes. 静态嵌套类与类方法和变量一样，静态嵌套类与其外部类相关联。与静态类方法一样，静态嵌套类不能直接引用其封闭类中定义的实例变量或方法：它只能通过对象引用来使用它们。内部类和嵌套静态类示例演示了这一点。 &#x3D;&#x3D;注意：静态嵌套类与其外部类（和其他类）的实例成员进行交互，就像任何其他顶级类一样。实际上，静态嵌套类在行为上是一个顶级类，为了打包方便，它被嵌套在另一个顶级类别中。内部类和嵌套静态类示例也演示了这一点。&#x3D;&#x3D; 以与顶级类相同的方式实例化静态嵌套类： 1StaticNestedClass staticNestedObject = new StaticNestedClass(); 内部类和嵌套静态类示例以下示例OuterClass与TopLevelClass一起演示了OuterClass的哪些类成员可以访问内部类（InnerClass）、嵌套静态类（StaticNestedClass）和顶级类（TopLevelClass）： OuterClass.java12345678910111213141516171819202122232425262728293031323334353637383940public class OuterClass &#123; String outerField = &quot;Outer field&quot;; static String staticOuterField = &quot;Static outer field&quot;; class InnerClass &#123; void accessMembers() &#123; System.out.println(outerField); System.out.println(staticOuterField); &#125; &#125; static class StaticNestedClass &#123; void accessMembers(OuterClass outer) &#123; // Compiler error: Cannot make a static reference to the non-static // field outerField // System.out.println(outerField); System.out.println(outer.outerField); System.out.println(staticOuterField); &#125; &#125; public static void main(String[] args) &#123; System.out.println(&quot;Inner class:&quot;); System.out.println(&quot;------------&quot;); OuterClass outerObject = new OuterClass(); OuterClass.InnerClass innerObject = outerObject.new InnerClass(); innerObject.accessMembers(); System.out.println(&quot;\\nStatic nested class:&quot;); System.out.println(&quot;--------------------&quot;); StaticNestedClass staticNestedObject = new StaticNestedClass(); staticNestedObject.accessMembers(outerObject); System.out.println(&quot;\\nTop-level class:&quot;); System.out.println(&quot;--------------------&quot;); TopLevelClass topLevelObject = new TopLevelClass(); topLevelObject.accessMembers(outerObject); &#125;&#125; TopLevelClass.java12345678910public class TopLevelClass &#123; void accessMembers(OuterClass outer) &#123; // Compiler error: Cannot make a static reference to the non-static // field OuterClass.outerField // System.out.println(OuterClass.outerField); System.out.println(outer.outerField); System.out.println(OuterClass.staticOuterField); &#125; &#125; 此示例打印以下输出： 1234567891011121314Inner class:------------Outer fieldStatic outer fieldStatic nested class:--------------------Outer fieldStatic outer fieldTop-level class:--------------------Outer fieldStatic outer field 请注意，静态嵌套类与其外部类的实例成员进行交互，就像任何其他顶级类一样。静态嵌套类StaticNestedClass无法直接访问outerField，因为它是封闭类OuterClass的实例变量。Java编译器在突出显示的语句处生成错误： 1234567static class StaticNestedClass &#123; void accessMembers(OuterClass outer) &#123; // Compiler error: Cannot make a static reference to the non-static // field outerField System.out.println(outerField); &#125;&#125; 要修复此错误，请通过对象引用访问outerField： 1System.out.println(outer.outerField); 同样，顶级类TopLevelClass也不能直接访问outerField。 阴影如果特定作用域（如内部类或方法定义）中的类型声明（如成员变量或参数名称）与封闭作用域中的另一声明具有相同的名称，则该声明将隐藏封闭作用域的声明。不能仅通过其名称引用阴影声明。以下示例ShadowTest演示了这一点： 123456789101112131415161718192021public class ShadowTest &#123; public int x = 0; class FirstLevel &#123; public int x = 1; void methodInFirstLevel(int x) &#123; System.out.println(&quot;x = &quot; + x); System.out.println(&quot;this.x = &quot; + this.x); System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x); &#125; &#125; public static void main(String... args) &#123; ShadowTest st = new ShadowTest(); ShadowTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); &#125;&#125; 以下是本示例的输出： 123x = 23this.x = 1ShadowTest.this.x = 0 本例定义了三个名为x的变量：ShadowTest类的成员变量、内部类FirstLevel的成员变量和方法methodInFirstLevel中的参数。定义为方法methodInFirstLevel的参数的变量x隐藏了内部类FirstLevel中的变量。因此，当您在方法methodInFirstLevel中使用变量x时，它会引用方法参数。要引用内部类FirstLevel的成员变量，请使用关键字this表示封闭范围： 1System.out.println(&quot;this.x = &quot; + this.x); 引用成员变量，这些成员变量通过其所属的类名将较大范围括起来。例如，以下语句从方法methodInFirstLevel访问ShadowTest类的成员变量： 1System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x); 序列化强烈不建议序列化内部类，包括本地类和匿名类。当Java编译器编译某些构造（如内部类）时，它会创建合成构造；这些是源代码中没有相应构造的类、方法、字段和其他构造。合成构造使Java编译器能够在不改变JVM的情况下实现新的Java语言特性。然而，合成构造在不同的Java编译器实现中可能有所不同，这意味着.class文件在不同的实现中也可能有所不同。因此，如果序列化内部类，然后使用不同的JRE实现反序列化，则可能会出现兼容性问题。有关编译内部类时生成的合成构造的更多信息，请参阅获取方法参数名称一节中的隐式和合成参数一节。 内部类示例要查看正在使用的内部类，首先考虑一个数组。在下面的示例中，您创建一个数组，用整数值填充它，然后按升序只输出数组偶数索引的值。 DataStructure.java 以下示例包括： DataStructure外部类，它包括一个构造函数，用于创建DataStructure的实例，该实例包含一个填充有连续整数值（0、1、2、3等）的数组，以及一个打印具有偶数索引值的数组元素的方法。 EvenIterator内部类，它实现了DataStructureTerator接口，该接口扩展了Iterator＜Integer＞接口。迭代器用于遍历数据结构，通常具有测试最后一个元素、检索当前元素并移动到下一个元素的方法。 实例化DataStructure对象（ds）的主方法，然后调用printEven方法来打印数组arrayOfInts中具有偶数索引值的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DataStructure &#123; // Create an array private final static int SIZE = 15; private int[] arrayOfInts = new int[SIZE]; public DataStructure() &#123; // fill the array with ascending integer values for (int i = 0; i &lt; SIZE; i++) &#123; arrayOfInts[i] = i; &#125; &#125; public void printEven() &#123; // Print out values of even indices of the array DataStructureIterator iterator = this.new EvenIterator(); while (iterator.hasNext()) &#123; System.out.print(iterator.next() + &quot; &quot;); &#125; System.out.println(); &#125; interface DataStructureIterator extends java.util.Iterator&lt;Integer&gt; &#123; &#125; // Inner class implements the DataStructureIterator interface, // which extends the Iterator&lt;Integer&gt; interface private class EvenIterator implements DataStructureIterator &#123; // Start stepping through the array from the beginning private int nextIndex = 0; public boolean hasNext() &#123; // Check if the current element is the last in the array return (nextIndex &lt;= SIZE - 1); &#125; public Integer next() &#123; // Record a value of an even index of the array Integer retValue = Integer.valueOf(arrayOfInts[nextIndex]); // Get the next even element nextIndex += 2; return retValue; &#125; &#125; public static void main(String s[]) &#123; // Fill the array with integer values and print out only // values of even indices DataStructure ds = new DataStructure(); ds.printEven(); &#125;&#125; The output is: 10 2 4 6 8 10 12 14 请注意，EvenIterator类直接引用DataStructure对象的arrayOfInts实例变量。 您可以使用内部类来实现助手类，例如本示例中所示的助手类。要处理用户界面事件，您必须知道如何使用内部类，因为事件处理机制大量使用它们。 本地和匿名类还有两种额外类型的内部类。可以在方法体中声明内部类。这些类称为本地类。您还可以在方法体中声明内部类，而不必命名该类。这些类称为匿名类。 修改器可以为内部类使用与为外部类的其他成员使用相同的修饰符。例如，可以使用访问说明符private、public和protected来限制对内部类的访问，就像使用它们来限制对其他类成员的访问一样。 本地类声明本地类可以在任何块内定义本地类（有关详细信息，请参见表达式、语句和块）。例如，可以在方法体、For循环或if子句中定义本地类。 以下示例LocalClassExample验证两个电话号码。它在validatePhoneNumber方法中定义了本地类PhoneNumber: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LocalClassExample &#123; static String regularExpression = &quot;[^0-9]&quot;; public static void validatePhoneNumber( String phoneNumber1, String phoneNumber2) &#123; final int numberLength = 10; // Valid in JDK 8 and later: // int numberLength = 10; class PhoneNumber &#123; String formattedPhoneNumber = null; PhoneNumber(String phoneNumber)&#123; // numberLength = 7; String currentNumber = phoneNumber.replaceAll( regularExpression, &quot;&quot;); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null; &#125; public String getNumber() &#123; return formattedPhoneNumber; &#125; // Valid in JDK 8 and later:// public void printOriginalNumbers() &#123;// System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +// &quot; and &quot; + phoneNumber2);// &#125; &#125; PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1); PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2); // Valid in JDK 8 and later:// myNumber1.printOriginalNumbers(); if (myNumber1.getNumber() == null) System.out.println(&quot;First number is invalid&quot;); else System.out.println(&quot;First number is &quot; + myNumber1.getNumber()); if (myNumber2.getNumber() == null) System.out.println(&quot;Second number is invalid&quot;); else System.out.println(&quot;Second number is &quot; + myNumber2.getNumber()); &#125; public static void main(String... args) &#123; validatePhoneNumber(&quot;123-456-7890&quot;, &quot;456-7890&quot;); &#125;&#125; 该示例首先删除电话号码中除数字0到9以外的所有字符，以验证电话号码。然后，它检查电话号码是否正好包含十个数字（北美电话号码的长度）。此示例打印以下内容： 12First number is 1234567890Second number is invalid 访问封闭类的成员本地类可以访问其封闭类的成员。在上一个示例中，PhoneNumber构造函数访问成员LocalClassExample.regularExpression。 此外，局部类可以访问局部变量。然而，局部类只能访问声明为final的局部变量。当局部类访问封闭块的局部变量或参数时，它会捕获该变量或参数。例如，PhoneNumber构造函数可以访问本地变量numberLength，因为它被声明为final；numberLength是捕获的变量。 然而，从JavaSE8开始，本地类可以访问封闭块的最终或有效最终的本地变量和参数。一个变量或参数，其值在初始化后从未改变，实际上是最终的。例如，假设变量numberLength未声明为final，并且在PhoneNumber构造函数中添加突出显示的赋值语句以将有效电话号码的长度更改为7位： 123456789PhoneNumber(String phoneNumber) &#123; numberLength = 7; String currentNumber = phoneNumber.replaceAll( regularExpression, &quot;&quot;); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null;&#125; 由于此赋值语句，变量numberLength实际上不再是final。因此，Java编译器会生成类似于“从内部类引用的本地变量必须是最终的或有效的最终的”的错误消息，其中内部类PhoneNumber尝试访问numberLength变量： 1if (currentNumber.length() == numberLength) 从JavaSE8开始，如果在方法中声明本地类，它可以访问该方法的参数。例如，您可以在PhoneNumber本地类中定义以下方法： 1234public void printOriginalNumbers() &#123; System.out.println(&quot;Original numbers are &quot; + phoneNumber1 + &quot; and &quot; + phoneNumber2);&#125; printOriginalNumbers方法访问validatePhoneNumber方法的参数phoneNumber1和phoneNumber2。 阴影和局部类局部类中的类型声明（例如变量）在封闭范围内的影子声明中具有相同名称。See Shadowing for more information. 局部类与内部类相似本地类与内部类类似，因为它们不能定义或声明任何静态成员。静态方法中的本地类，例如在静态方法validatePhoneNumber中定义的类PhoneNumber，只能引用封闭类的静态成员。例如，如果您没有将成员变量regularExpression定义为static，那么Java编译器会生成类似于“非静态变量regular表达式不能从静态上下文引用”的错误 本地类是非静态的，因为它们可以访问封闭块的实例成员。因此，它们不能包含大多数类型的静态声明。 不能在块内声明接口；接口本质上是静态的。例如，以下代码摘录无法编译，因为接口HelloThere定义在方法greetInEnglish的主体中： 123456789101112public void greetInEnglish() &#123; interface HelloThere &#123; public void greet(); &#125; class EnglishHelloThere implements HelloThere &#123; public void greet() &#123; System.out.println(&quot;Hello &quot; + name); &#125; &#125; HelloThere myGreeting = new EnglishHelloThere(); myGreeting.greet();&#125; 不能在本地类中声明静态初始化器或成员接口。以下代码摘录无法编译，因为方法EnglishGoodbye。sayGoodbye被声明为静态。当编译器遇到此方法定义时，会生成类似于“仅在常量变量声明中允许修饰符’static’”的错误： 12345678public void sayGoodbyeInEnglish() &#123; class EnglishGoodbye &#123; public static void sayGoodbye() &#123; System.out.println(&quot;Bye bye&quot;); &#125; &#125; EnglishGoodbye.sayGoodbye(); &#125; 局部类可以有静态成员，前提是它们是常量变量。（常量变量是基元类型或字符串类型的变量，声明为final并用编译时常量表达式初始化。编译时常量通常是可以在编译时计算的字符串或算术表达式。有关详细信息，请参阅了解类成员。)以下代码摘录编译，因为静态成员EnglishGoodbye。告别是一个常量变量： 12345678910public void sayGoodbyeInEnglish() &#123; class EnglishGoodbye &#123; public static final String farewell = &quot;Bye bye&quot;; public void sayGoodbye() &#123; System.out.println(farewell); &#125; &#125; EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye(); myEnglishGoodbye.sayGoodbye();&#125; 匿名类匿名类使您能够使代码更简洁。它们使您能够同时声明和实例化类。它们就像本地类，只是没有名称。如果只需要使用一次本地类，请使用它们。 声明匿名类虽然本地类是类声明，但匿名类是表达式，这意味着您可以在另一个表达式中定义类。以下示例HelloWorldAnonymousClasses在本地变量frenchGreeting和spanishGreeting的初始化语句中使用匿名类，但在变量englishGreeting初始化时使用本地类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HelloWorldAnonymousClasses &#123; interface HelloWorld &#123; public void greet(); public void greetSomeone(String someone); &#125; public void sayHello() &#123; class EnglishGreeting implements HelloWorld &#123; String name = &quot;world&quot;; public void greet() &#123; greetSomeone(&quot;world&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Hello &quot; + name); &#125; &#125; HelloWorld englishGreeting = new EnglishGreeting(); HelloWorld frenchGreeting = new HelloWorld() &#123; String name = &quot;tout le monde&quot;; public void greet() &#123; greetSomeone(&quot;tout le monde&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Salut &quot; + name); &#125; &#125;; HelloWorld spanishGreeting = new HelloWorld() &#123; String name = &quot;mundo&quot;; public void greet() &#123; greetSomeone(&quot;mundo&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Hola, &quot; + name); &#125; &#125;; englishGreeting.greet(); frenchGreeting.greetSomeone(&quot;Fred&quot;); spanishGreeting.greet(); &#125; public static void main(String... args) &#123; HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses(); myApp.sayHello(); &#125; &#125; 匿名类的语法如前所述，匿名类是一个表达式。匿名类表达式的语法类似于构造函数的调用，只是代码块中包含一个类定义。 考虑frenchGreeting对象的实例化： 12345678910HelloWorld frenchGreeting = new HelloWorld() &#123; String name = &quot;tout le monde&quot;; public void greet() &#123; greetSomeone(&quot;tout le monde&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Salut &quot; + name); &#125; &#125;; 匿名类表达式由以下内容组成： new运算符 要实现的接口或要扩展的类的名称。在本例中，匿名类实现接口HelloWorld。 包含构造函数参数的括号，就像普通的类实例创建表达式一样。注意：当您实现一个接口时，没有构造函数，所以您使用一对空括号，如本例所示。 一个主体，它是一个类声明主体。更具体地说，在正文中，允许方法声明，但不允许语句。 因为匿名类定义是表达式，所以它必须是语句的一部分。在本例中，匿名类表达式是实例化frenchGreeting对象的语句的一部分。（这解释了为什么右大括号后面有分号。） 访问Enclosing作用域的局部变量，以及声明和访问匿名类的成员与本地类一样，匿名类可以捕获变量；它们对封闭作用域的局部变量具有相同的访问权限： 匿名类可以访问其封闭类的成员。 匿名类不能访问其封闭范围中未声明为final或有效final的局部变量。 与嵌套类一样，匿名类中的类型（例如变量）声明隐藏了封闭范围中具有相同名称的任何其他声明。有关详细信息，请参见阴影。 匿名类对其成员也有与本地类相同的限制： 不能在匿名类中声明静态初始化器或成员接口。 匿名类可以有静态成员，前提是它们是常量变量。 请注意，您可以在匿名类中声明以下内容： Fields Extra方法（即使它们没有实现任何父类型的方法） Instance initializers Local classes 但是，您不能在匿名类内声明构造函数。 匿名类示例匿名类通常用于图形用户界面（GUI）应用程序中。 考虑JavaFX示例HelloWorld。java（来自《JavaFX入门》中的Hello World，JavaFX Style一节）。此示例创建一个包含Say“Hello World”按钮的框架。将突出显示匿名类表达式： 12345678910111213141516171819202122232425262728293031import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.StackPane;import javafx.stage.Stage; public class HelloWorld extends Application &#123; public static void main(String[] args) &#123; launch(args); &#125; @Override public void start(Stage primaryStage) &#123; primaryStage.setTitle(&quot;Hello World!&quot;); Button btn = new Button(); btn.setText(&quot;Say &#x27;Hello World&#x27;&quot;); btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent event) &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;); StackPane root = new StackPane(); root.getChildren().add(btn); primaryStage.setScene(new Scene(root, 300, 250)); primaryStage.show(); &#125;&#125; 在此示例中，方法调用btn。setOnAction指定当您选择Say“Hello World”按钮时会发生什么。此方法需要EventHandler＜ActionEvent＞类型的对象。EventHandler＜ActionEvent＞接口仅包含一个方法handle。该示例使用了一个匿名类表达式，而不是用新类实现此方法。请注意，此表达式是传递给btn的参数。setOnAction方法。 因为EventHandler＜ActionEvent＞接口只包含一个方法，所以可以使用lambda表达式而不是匿名类表达式。有关详细信息，请参见 Lambda Expressions一节。 匿名类是实现包含两个或多个方法的接口的理想选择。以下JavaFX示例来自UI控件的自定义部分。突出显示的代码创建一个仅接受数值的文本字段。它通过重写从TextInputControl类继承的replaceText和replaceSelection方法，用匿名类重新定义TextField类的默认实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Insets;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.*;import javafx.scene.layout.GridPane;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class CustomTextFieldSample extends Application &#123; final static Label label = new Label(); @Override public void start(Stage stage) &#123; Group root = new Group(); Scene scene = new Scene(root, 300, 150); stage.setScene(scene); stage.setTitle(&quot;Text Field Sample&quot;); GridPane grid = new GridPane(); grid.setPadding(new Insets(10, 10, 10, 10)); grid.setVgap(5); grid.setHgap(5); scene.setRoot(grid); final Label dollar = new Label(&quot;$&quot;); GridPane.setConstraints(dollar, 0, 0); grid.getChildren().add(dollar); final TextField sum = new TextField() &#123; @Override public void replaceText(int start, int end, String text) &#123; if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123; super.replaceText(start, end, text); &#125; label.setText(&quot;Enter a numeric value&quot;); &#125; @Override public void replaceSelection(String text) &#123; if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123; super.replaceSelection(text); &#125; &#125; &#125;; sum.setPromptText(&quot;Enter the total&quot;); sum.setPrefColumnCount(10); GridPane.setConstraints(sum, 1, 0); grid.getChildren().add(sum); Button submit = new Button(&quot;Submit&quot;); GridPane.setConstraints(submit, 2, 0); grid.getChildren().add(submit); submit.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; label.setText(null); &#125; &#125;); GridPane.setConstraints(label, 0, 1); GridPane.setColumnSpan(label, 3); grid.getChildren().add(label); scene.setRoot(grid); stage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; Lambda表达式匿名类的一个问题是，如果匿名类的实现非常简单，例如一个接口只包含一个方法，那么匿名类的语法可能会显得笨拙和不清楚。在这些情况下，您通常试图将功能作为参数传递给另一个方法，例如当有人单击按钮时应该采取什么操作。Lambda表达式使您能够做到这一点，将功能视为方法参数，或将代码视为数据。 上一节“匿名类”向您展示了如何实现基类而不为其命名。虽然这通常比命名类更简洁，但对于只有一个方法的类，即使是匿名类也显得有点过分和麻烦。Lambda表达式允许您更紧凑地表达单个方法类的实例。 Lambda表达式的理想用例假设您正在创建一个社交网络应用程序。您希望创建一个功能，使管理员能够对满足特定条件的社交网络应用程序成员执行任何类型的操作，例如发送消息。下表详细描述了该用例： Field Description Name 对所选成员执行操作 Primary Actor 管理员 Preconditions 管理员已登录系统。 Postconditions 仅对符合指定条件的成员执行操作。 Main Success Scenario 管理员指定要对其执行特定操作的成员的标准。管理员指定要对这些选定成员执行的操作。管理员选择提交按钮。系统将查找符合指定条件的所有成员。系统对所有匹配的成员执行指定的操作。 Extensions 1a中。管理员可以选择在指定要执行的操作或选择提交按钮之前预览符合指定条件的成员。 Frequency of Occurrence 白天很多次。 假设此社交网络应用程序的成员由以下Person类表示： 12345678910111213141516171819public class Person &#123; public enum Sex &#123; MALE, FEMALE &#125; String name; LocalDate birthday; Sex gender; String emailAddress; public int getAge() &#123; // ... &#125; public void printPerson() &#123; // ... &#125;&#125; 假设社交网络应用程序的成员存储在List&lt;Person&gt;实例中。 本节从这个用例的简单方法开始。它使用本地和匿名类改进了这种方法，然后使用lambda表达式以高效简洁的方法结束。在示例RosterTest中查找本节中描述的代码摘录。 方法1：创建搜索符合一个特征的成员的方法一种简单的方法是创建几种方法；每个方法都搜索与一个特征（如性别或年龄）匹配的成员。以下方法打印早于指定年龄的成员： 1234567public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) &#123; for (Person p : roster) &#123; if (p.getAge() &gt;= age) &#123; p.printPerson(); &#125; &#125;&#125; 注意： List是一个有序的 Collection 。集合是将多个元素分组为单个单元的对象。集合用于存储、检索、操作和传递聚合数据。有关集合的详细信息，请参阅 Collections 跟踪。 这种方法可能会使您的应用程序变得脆弱，这是因为引入了更新（例如更新的数据类型）而导致应用程序无法工作的可能性。假设您升级应用程序并更改Person类的结构，使其包含不同的成员变量；也许该类使用不同的数据类型或算法记录和测量年龄。为了适应这种变化，您必须重写大量API。此外，这种方法具有不必要的限制性；例如，如果你想打印小于某个年龄的会员，该怎么办？ 方法2：创建更通用的搜索方法以下方法比printPersonsHolderThan更通用；它打印指定年龄范围内的成员： 12345678public static void printPersonsWithinAgeRange( List&lt;Person&gt; roster, int low, int high) &#123; for (Person p : roster) &#123; if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123; p.printPerson(); &#125; &#125;&#125; 如果您想打印特定性别的成员，或指定性别和年龄范围的组合，该怎么办？如果您决定更改Person类并添加其他属性，如关系状态或地理位置，该怎么办？尽管此方法比printPersonsOldThan更通用，但尝试为每个可能的搜索查询创建单独的方法仍然会导致代码脆弱。相反，您可以将指定要在不同类中搜索的条件的代码分开。 方法3：在本地类中指定搜索条件代码以下方法打印符合您指定的搜索条件的成员： 12345678public static void printPersons( List&lt;Person&gt; roster, CheckPerson tester) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; p.printPerson(); &#125; &#125;&#125; 此方法通过调用tester.test方法检查List参数列表中包含的每个Person实例是否满足CheckPerson参数测试程序中指定的搜索条件。如果方法测试仪。测试返回一个真值，然后在Person实例上调用printPersons方法。 要指定搜索条件，请实现CheckPerson界面： 123interface CheckPerson &#123; boolean test(Person p);&#125; 下面的类通过指定方法测试的实现来实现CheckPerson接口。此方法筛选符合美国选择性服务资格的成员：如果其Person参数为男性且年龄在18岁至25岁之间，则返回真值： 1234567class CheckPersonEligibleForSelectiveService implements CheckPerson &#123; public boolean test(Person p) &#123; return p.gender == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; &#125;&#125; 要使用该类，请创建它的新实例并调用printPersons方法： 12printPersons( roster, new CheckPersonEligibleForSelectiveService()); 虽然这种方法不那么脆弱，但如果您更改Person的结构，则不必重写方法，您仍有额外的代码：一个新的接口和一个本地类，用于您计划在应用程序中执行的每个搜索。因为CheckPersonEligibleForSelectiveService实现了一个接口，所以您可以使用匿名类而不是本地类，并且不需要为每次搜索声明一个新类。 方法4：在匿名类中指定搜索条件代码下面调用printPersons方法的一个参数是一个匿名类，用于过滤符合美国选择性服务资格的成员：年龄在18岁至25岁之间的男性： 12345678910printPersons( roster, new CheckPerson() &#123; public boolean test(Person p) &#123; return p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; &#125; &#125;); 这种方法减少了所需的代码量，因为您不必为要执行的每个搜索创建新类。然而，考虑到CheckPerson接口仅包含一个方法，匿名类的语法非常庞大。在这种情况下，可以使用lambda表达式而不是匿名类，如下一节所述。 方法5：使用Lambda表达式指定搜索条件代码CheckPerson接口是一个功能接口。函数接口是只包含一个抽象方法的任何接口。（函数接口可能包含一个或多个默认方法或静态方法。）由于函数接口仅包含一个抽象方法，因此在实现该方法时可以省略该方法的名称。为此，不使用匿名类表达式，而是使用lambda表达式，该表达式在以下方法调用中突出显示： 123456printPersons( roster, (Person p) -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25); 有关如何定义Lambda表达式的信息，请参见 Syntax of Lambda Expressions 。 您可以使用标准功能接口代替CheckPerson接口，这进一步减少了所需的代码量。 方法6：使用Lambda表达式的标准函数接口重新考虑CheckPerson interface： 123interface CheckPerson &#123; boolean test(Person p);&#125; 这是一个非常简单的界面。它是一个函数接口，因为它只包含一个抽象方法。此方法接受一个参数并返回一个布尔值。该方法非常简单，可能不值得在应用程序中定义它。因此，JDK定义了几个标准函数接口，您可以在java.util.function包中找到这些接口。 例如，您可以使用Predicate&lt;T&gt;接口代替CheckPerson。此接口包含布尔测试(T t)方法： 123interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; Predicate&lt;T&gt;接口是通用接口的一个示例。（有关泛型的详细信息，请参阅 Generics (Updated) 课程。）泛型类型（如泛型接口）在尖括号（&lt;&gt;）内指定一个或多个类型参数。此接口仅包含一个类型参数T。当您使用实际类型参数声明或实例化泛型类型时，您将拥有一个参数化类型。例如，参数化类型Predicate&lt;Person&gt;如下： 123interface Predicate&lt;Person&gt; &#123; boolean test(Person t);&#125; 此参数化类型包含与CheckPerson具有相同返回类型和参数的方法。布尔测试（Person p）。因此，可以使用Predicate&lt;T&gt;代替CheckPerson，如下方法所示： 12345678public static void printPersonsWithPredicate( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; p.printPerson(); &#125; &#125;&#125; 因此，以下方法调用与方法3中调用printPersons时相同：在本地类中指定搜索条件代码以获取符合选择性服务资格的成员： 123456printPersonsWithPredicate( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25); 这不是此方法中使用lambda表达式的唯一可能位置。以下方法建议使用lambda表达式的其他方法。 方法7：在整个应用程序中使用Lambda表达式重新考虑printPersonsWithPredicate方法，看看您还可以在哪里使用lambda表达式： 12345678public static void printPersonsWithPredicate( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; p.printPerson(); &#125; &#125;&#125; 此方法检查List参数花名册中包含的每个Person实例是否满足Predicate参数测试程序中指定的条件。如果Person实例满足测试人员指定的条件，则在Person实例上调用printPerson方法。 您可以在满足测试人员指定的条件的Person实例上指定要执行的不同操作，而不是调用printPerson方法。可以使用lambda表达式指定此操作。假设您需要一个类似于printPerson的lambda表达式，它接受一个参数（Person类型的对象）并返回void。记住，要使用lambda表达式，需要实现函数接口。在这种情况下，您需要一个包含抽象方法的函数接口，该方法可以接受一个Person类型的参数并返回void。Consumer&lt;T&gt;接口包含方法void accept(T t)，它具有这些特性。以下方法将调用p.printPerson()替换为调用accept方法的Consumer&lt;Person&gt;实例： 12345678910public static void processPersons( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Consumer&lt;Person&gt; block) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; block.accept(p); &#125; &#125;&#125; 因此，以下方法调用与在中调用printPersons时相同 Approach 3: Specify Search Criteria Code in a Local Class 获得符合选择性服务资格的会员。用于打印成员的lambda表达式突出显示： 1234567processPersons( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.printPerson()); 如果您想对成员的个人资料进行更多处理而不是打印出来，该怎么办。假设您要验证成员的配置文件或检索他们的联系信息？在这种情况下，您需要一个包含返回值的抽象方法的函数接口。Function&lt;T,R&gt;接口包含方法R apply(T T)。以下方法检索参数映射器指定的数据，然后对参数块指定的数据执行操作： 123456789101112public static void processPersonsWithFunction( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Function&lt;Person, String&gt; mapper, Consumer&lt;String&gt; block) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; String data = mapper.apply(p); block.accept(data); &#125; &#125;&#125; 以下方法从名册中符合选择性服务资格的每个成员处检索电子邮件地址，然后打印： 12345678processPersonsWithFunction( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.getEmailAddress(), email -&gt; System.out.println(email)); 方法8：更广泛地使用泛型重新考虑方法processPersonsWithFunction。以下是它的通用版本，它接受包含任何数据类型元素的集合作为参数： 123456789101112public static &lt;X, Y&gt; void processElements( Iterable&lt;X&gt; source, Predicate&lt;X&gt; tester, Function &lt;X, Y&gt; mapper, Consumer&lt;Y&gt; block) &#123; for (X p : source) &#123; if (tester.test(p)) &#123; Y data = mapper.apply(p); block.accept(data); &#125; &#125;&#125; 要打印符合选择性服务资格的成员的电子邮件地址，请按如下方式调用processElements方法： 12345678processElements( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.getEmailAddress(), email -&gt; System.out.println(email)); 此方法调用执行以下操作： 从集合源获取对象源。在本例中，它从集合花名册中获取Person对象的源。注意，集合花名册是List类型的集合，也是Iterable类型的对象。 过滤与谓词对象测试器匹配的对象。在本例中，Predicate对象是一个lambda表达式，它指定哪些成员有资格获得选择性服务。 将每个过滤对象映射到Function对象映射器指定的值。在本例中，Function对象是一个lambda表达式，它返回成员的电子邮件地址。 对Consumer对象块指定的每个映射对象执行操作。在本例中，Consumer对象是一个lambda表达式，它打印一个字符串，该字符串是Function对象返回的电子邮件地址。 您可以用聚合操作替换这些操作中的每一个。 方法9：使用接受Lambda表达式作为参数的聚合运算以下示例使用聚合操作打印收集名册中符合选择性服务资格的成员的电子邮件地址： 12345678roster .stream() .filter( p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25) .map(p -&gt; p.getEmailAddress()) .forEach(email -&gt; System.out.println(email)); 下表将processElement方法执行的每个操作与相应的聚合操作进行映射： processElements Action 聚合操作 获取对象源 Stream&lt;E&gt; stream() 筛选与“谓词”对象匹配的对象 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) 将对象映射到“Function”对象指定的另一个值 &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper) 执行“消费者”对象指定的操作 void forEach(Consumer&lt;? super T&gt; action) 操作filter、map和forEach是聚合操作。聚合操作处理来自流的元素，而不是直接来自集合（这就是本例中调用的第一个方法是流的原因）。流是一系列元素。与集合不同，它不是存储元素的数据结构。相反，流通过管道从源（例如集合）承载值。管道是一系列流操作，在本例中，它是Each的过滤器映射。此外，聚合操作通常接受lambda表达式作为参数，使您能够自定义它们的行为方式。 有关聚合操作的详细讨论，请参阅 Aggregate Operations 课程。 GUI应用程序中的Lambda表达式要在图形用户界面（GUI）应用程序中处理事件，例如键盘动作、鼠标动作和滚动动作，通常需要创建事件处理程序，这通常涉及实现特定的界面。通常，事件处理程序接口是功能接口；他们往往只有一种方法。 在JavaFX示例 HelloWorld.java （在前面的Anonymous Classes一节中讨论过），您可以在下面的语句中将突出显示的匿名类替换为lambda表达式： 1234567btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent event) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125;); 方法调用btn。setOnAction指定当您选择btn对象表示的按钮时会发生什么。此方法需要EventHandler&lt;ActionEvent&gt;类型的对象。EventHandler&lt;ActionEvent&gt;接口只包含一个方法，即void handle(T event)。此接口是一个函数接口，因此可以使用以下突出显示的lambda表达式来替换它： 123btn.setOnAction( event -&gt; System.out.println(&quot;Hello World!&quot;)); Lambda表达式的语法lambda表达式由以下内容组成： 用逗号分隔的形式参数列表，用括号括起来。CheckPerson。测试方法包含一个参数p，它表示Person类的一个实例。 注意：可以省略lambda表达式中参数的数据类型。此外，如果只有一个参数，可以省略括号。例如，以下lambda表达式也是有效的： 123p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 箭头标记，-&gt; 正文，由单个表达式或语句块组成。此示例使用以下表达式 123p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 如果指定了一个表达式，则Java运行时将计算该表达式，然后返回其值。或者，您可以使用return语句： 12345p -&gt; &#123; return p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25;&#125; return语句不是表达式；在lambda表达式中，必须将语句括在大括号（{}）中。但是，您不必将void方法调用括在大括号中。例如，以下是有效的lambda表达式： 1email -&gt; System.out.println(email) 注意，lambda表达式看起来很像方法声明；您可以将lambda表达式视为没有名称的匿名方法方法。 以下示例Calculator是采用多个形式参数的lambda表达式的示例： 123456789101112131415161718192021public class Calculator &#123; interface IntegerMath &#123; int operation(int a, int b); &#125; public int operateBinary(int a, int b, IntegerMath op) &#123; return op.operation(a, b); &#125; public static void main(String... args) &#123; Calculator myApp = new Calculator(); IntegerMath addition = (a, b) -&gt; a + b; IntegerMath subtraction = (a, b) -&gt; a - b; System.out.println(&quot;40 + 2 = &quot; + myApp.operateBinary(40, 2, addition)); System.out.println(&quot;20 - 10 = &quot; + myApp.operateBinary(20, 10, subtraction)); &#125;&#125; 方法operateBinary对两个整数操作数执行数学运算。操作本身由IntegerMath的实例指定。该示例使用lambda表达式定义了两个运算：加法和减法。该示例显示以下内容： 1240 + 2 = 4220 - 10 = 10 访问封闭作用域的局部变量与本地类和匿名类一样，lambda表达式可以捕获变量；它们对封闭范围的局部变量具有相同的访问权限。然而，与本地类和匿名类不同，lambda表达式没有任何阴影问题（有关详细信息，请参阅阴影）。Lambda表达式具有词汇范围。这意味着它们不会从父类型继承任何名称，也不会引入新的作用域级别。lambda表达式中的声明的解释与它们在封闭环境中的解释相同。以下示例LambdaScopeTest演示了这一点： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.function.Consumer; public class LambdaScopeTest &#123; public int x = 0; class FirstLevel &#123; public int x = 1; void methodInFirstLevel(int x) &#123; int z = 2; Consumer&lt;Integer&gt; myConsumer = (y) -&gt; &#123; // The following statement causes the compiler to generate // the error &quot;Local variable z defined in an enclosing scope // must be final or effectively final&quot; // // z = 99; System.out.println(&quot;x = &quot; + x); System.out.println(&quot;y = &quot; + y); System.out.println(&quot;z = &quot; + z); System.out.println(&quot;this.x = &quot; + this.x); System.out.println(&quot;LambdaScopeTest.this.x = &quot; + LambdaScopeTest.this.x); &#125;; myConsumer.accept(x); &#125; &#125; public static void main(String... args) &#123; LambdaScopeTest st = new LambdaScopeTest(); LambdaScopeTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); &#125;&#125; 此示例生成以下输出： 12345x = 23y = 23z = 2this.x = 1LambdaScopeTest.this.x = 0 如果在lambda表达式myConsumer的声明中用参数x代替y，则编译器将生成错误： 123Consumer&lt;Integer&gt; myConsumer = (x) -&gt; &#123; // ...&#125; 编译器生成错误“Lambda表达式的参数x无法重新声明在封闭范围中定义的另一个局部变量”，因为Lambda表达式没有引入新的范围级别。因此，您可以直接访问封闭范围的字段、方法和局部变量。例如，lambda表达式直接访问方法methodInFirstLevel的参数x。要访问封闭类中的变量，请使用关键字this。在本例中。x是指成员变量FirstLevel.x。 然而，与本地类和匿名类一样，lambda表达式只能访问封闭块的最终或有效最终的局部变量和参数。在本例中，变量z实际上是final；其值在初始化后从未更改。但是，假设您在lambda表达式myConsumer中添加了以下赋值语句： 1234Consumer&lt;Integer&gt; myConsumer = (y) -&gt; &#123; z = 99; // ...&#125; 由于这个赋值语句，变量z实际上不再是final。因此，Java编译器会生成一条类似于“在封闭范围中定义的本地变量z必须是final或实际上是final”的错误消息。 目标类型如何确定lambda表达式的类型？回想一下lambda表达式，该表达式选择了年龄在18至25岁之间的男性成员： 123p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 此lambda表达式用于以下两种方法： public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester) in Approach 3: Specify Search Criteria Code in a Local Class public void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) in Approach 6: Use Standard Functional Interfaces with Lambda Expressions 当Java运行时调用printPerson方法时，它需要CheckPerson的数据类型，因此lambda表达式是这种类型的。然而，当Java运行时调用printPersonsWithPredicate方法时，它需要Predicate＜Person＞的数据类型，因此lambda表达式是这种类型的。这些方法所期望的数据类型称为目标类型。为了确定lambda表达式的类型，Java编译器使用找到lambda表达式所在的上下文或情况的目标类型。因此，您只能在Java编译器可以确定目标类型的情况下使用lambda表达式： 变量声明 赋值 返回语句 数组初始化器 方法或构造函数参数 Lambda表达式体 条件表达式，? : 强制转换表达式 目标类型和方法参数对于方法参数，Java编译器使用两个其他语言特性来确定目标类型：重载解析和类型参数推断。 考虑以下两个功能接口 ( java.lang.Runnable and java.util.concurrent.Callable): 1234567public interface Runnable &#123; void run();&#125;public interface Callable&lt;V&gt; &#123; V call();&#125; 方法Runnable。run不返回值，而Callable&lt;V&gt;。呼叫成功。 假设您已按如下方式重载方法调用（有关 重载 Methods 的更多信息，请参阅定义方法）： 1234567void invoke(Runnable r) &#123; r.run();&#125;&lt;T&gt; T invoke(Callable&lt;T&gt; c) &#123; return c.call();&#125; 以下语句将调用哪个方法？ 1String s = invoke(() -&gt; &quot;done&quot;); 方法调用（Callable&lt;T&gt;）将被调用，因为该方法返回一个值；方法invoke（Runnable）没有。在这种情况下，lambda表达式（）-&gt;“done”的类型是Callable&lt;T&gt;。 序列化如果lambda表达式的目标类型及其捕获的参数是可 serialize 的，则可以对其进行序列化。然而，与 inner classes,一样，强烈不鼓励lambda表达式的序列化。 方法参考使用 lambda expressions 创建匿名方法。然而，有时lambda表达式只会调用现有方法。在这些情况下，按名称引用现有方法通常更清晰。方法引用使您能够做到这一点；对于已经有名称的方法，它们是紧凑、易于读取的lambda表达式。 再次考虑Lambda表达式一节中讨论的Person类： 1234567891011121314151617181920public class Person &#123; // ... LocalDate birthday; public int getAge() &#123; // ... &#125; public LocalDate getBirthday() &#123; return birthday; &#125; public static int compareByAge(Person a, Person b) &#123; return a.birthday.compareTo(b.birthday); &#125; // ...&#125; 假设您的社交网络应用程序的成员包含在一个数组中，您希望按年龄对该数组进行排序。您可以使用以下代码（在示例MethodReferencesTest中找到本节中描述的代码摘录）： 123456789Person[] rosterAsArray = roster.toArray(new Person[roster.size()]);class PersonAgeComparator implements Comparator&lt;Person&gt; &#123; public int compare(Person a, Person b) &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125;&#125; Arrays.sort(rosterAsArray, new PersonAgeComparator()); 此排序调用的方法签名如下： 1static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) 注意，接口Comparator是一个功能接口。因此，您可以使用lambda表达式，而不是定义并创建实现Comparator的类的新实例： 12345Arrays.sort(rosterAsArray, (Person a, Person b) -&gt; &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125;); 但是，这种比较两个Person实例的出生日期的方法已经作为Person.compareByAge存在。您可以在lambda表达式的主体中调用此方法： 123Arrays.sort(rosterAsArray, (a, b) -&gt; Person.compareByAge(a, b)); 由于此lambda表达式调用现有方法，因此可以使用方法引用而不是lambda表达式： 1Arrays.sort(rosterAsArray, Person::compareByAge); 方法引用Person::compareByAge在语义上与lambda表达式(a, b) -&gt; Person.compareByAge(a, b)比较。每个都具有以下特征： 它的正式参数列表是从Comparator&lt;Person&gt;复制的。比较，即(Person, Person)。 它的主体调用方法Person.compareByAge。 方法引用的类型有四种方法参考： Kind Syntax Examples 对静态方法的引用 ContainingClass::staticMethodName Person::compareByAge MethodReferencesExamples::appendStrings 对特定对象的实例方法的引用 containingObject::instanceMethodName myComparisonProvider::compareByName myApp::appendStrings2 对特定类型的任意对象的实例方法的引用 ContainingType::methodName String::compareToIgnoreCase String::concat 对构造函数的引用 ClassName::new HashSet::new 以下示例MethodReferencesExamples包含前三种类型的方法引用的示例： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.function.BiFunction;public class MethodReferencesExamples &#123; public static &lt;T&gt; T mergeThings(T a, T b, BiFunction&lt;T, T, T&gt; merger) &#123; return merger.apply(a, b); &#125; public static String appendStrings(String a, String b) &#123; return a + b; &#125; public String appendStrings2(String a, String b) &#123; return a + b; &#125; public static void main(String[] args) &#123; MethodReferencesExamples myApp = new MethodReferencesExamples(); // Calling the method mergeThings with a lambda expression System.out.println(MethodReferencesExamples. mergeThings(&quot;Hello &quot;, &quot;World!&quot;, (a, b) -&gt; a + b)); // Reference to a static method System.out.println(MethodReferencesExamples. mergeThings(&quot;Hello &quot;, &quot;World!&quot;, MethodReferencesExamples::appendStrings)); // Reference to an instance method of a particular object System.out.println(MethodReferencesExamples. mergeThings(&quot;Hello &quot;, &quot;World!&quot;, myApp::appendStrings2)); // Reference to an instance method of an arbitrary object of a // particular type System.out.println(MethodReferencesExamples. mergeThings(&quot;Hello &quot;, &quot;World!&quot;, String::concat)); &#125;&#125; 所有 System.out.println() 语句打印相同的内容： Hello World! BiFunction 是 java.util.function 包中许多函数接口之一。BiFunction函数接口可以表示接受两个参数并生成结果的lambda表达式或方法引用。 对静态方法的引用方法引用Person::compareByAge和MethodReferencesExample::appendString是对静态方法的引用。 对特定对象实例方法的引用以下是对特定对象的实例方法的引用示例： 1234567891011class ComparisonProvider &#123; public int compareByName(Person a, Person b) &#123; return a.getName().compareTo(b.getName()); &#125; public int compareByAge(Person a, Person b) &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125;&#125;ComparisonProvider myComparisonProvider = new ComparisonProvider();Arrays.sort(rosterAsArray, myComparisonProvider::compareByName); 方法引用myComparisonProvider::compareByName调用作为对象myComparison Provider的一部分的方法compareByName。JRE推断方法类型参数，在本例中为(Person, Person)。 类似地，方法引用myApp::appendStrings2调用作为对象myApp一部分的方法appendString2。JRE推断方法类型参数，在本例中为(String,String)。 对特定类型的任意对象的实例方法的引用以下是对特定类型的任意对象的实例方法的引用示例： 123String[] stringArray = &#123; &quot;Barbara&quot;, &quot;James&quot;, &quot;Mary&quot;, &quot;John&quot;, &quot;Patricia&quot;, &quot;Robert&quot;, &quot;Michael&quot;, &quot;Linda&quot; &#125;;Arrays.sort(stringArray, String::compareToIgnoreCase); 方法引用String:：compareToIgnoreCase的等效lambda表达式将具有形式参数列表(Stringa，Stringb)，其中a和b是用于更好地描述此示例的任意名称。方法引用将调用方法a.compareToIgnoreCase(b)。 类似地，方法引用String::concat将调用方法a.concat(b)。 对构造函数的引用可以使用名称new以与静态方法相同的方式引用构造函数。以下方法将元素从一个集合复制到另一个集合： 1234567891011public static &lt;T, SOURCE extends Collection&lt;T&gt;, DEST extends Collection&lt;T&gt;&gt; DEST transferElements( SOURCE sourceCollection, Supplier&lt;DEST&gt; collectionFactory) &#123; DEST result = collectionFactory.get(); for (T t : sourceCollection) &#123; result.add(t); &#125; return result;&#125; 函数接口Supplier包含一个不接受参数并返回对象的get方法。因此，可以使用lambda表达式调用transferElement方法，如下所示： 12Set&lt;Person&gt; rosterSetLambda = transferElements(roster, () -&gt; &#123; return new HashSet&lt;&gt;(); &#125;); 可以使用构造函数引用代替lambda表达式，如下所示： 1Set&lt;Person&gt; rosterSet = transferElements(roster, HashSet::new); Java编译器推断您希望创建包含Person类型元素的HashSet集合。或者，可以按如下方式指定： 1Set&lt;Person&gt; rosterSet = transferElements(roster, HashSet&lt;Person&gt;::new); 何时使用嵌套类、本地类、匿名类和Lambda表达式如嵌套类一节所述，嵌套类使您能够对仅在一个地方使用的类进行逻辑分组，增加封装的使用，并创建更可读和可维护的代码。本地类、匿名类和lambda表达式也具有这些优点；然而，它们旨在用于更具体的情况： 本地类：如果您需要创建一个类的多个实例、访问其构造函数或引入新的命名类型（例如，因为您需要稍后调用其他方法），请使用它。 匿名类：如果需要声明字段或其他方法，请使用它。 Lambda表达式： 如果要封装要传递给其他代码的单个行为单元，请使用它。例如，如果希望在集合的每个元素上执行某个操作，当进程完成时，或当进程遇到错误时，可以使用lambda表达式。 如果您需要一个函数接口的简单实例，并且前面的条件都不适用（例如，您不需要构造函数、命名类型、字段或其他方法），请使用它。 嵌套类：如果您的需求与本地类的需求类似，您希望使类型更广泛地可用，并且不需要访问本地变量或方法参数，请使用它。 如果需要访问封闭实例的非公共字段和方法，请使用非静态嵌套类（或内部类）。如果不需要此访问权限，请使用静态嵌套类。 枚举类型枚举类型是一种特殊的数据类型，它允许变量是一组预定义的常量。变量必须等于为其预定义的值之一。常见的示例包括指南针方向（北、南、东和西的值）和一周中的几天。 由于它们是常量，枚举类型字段的名称都是大写字母。 在Java编程语言中，通过使用enum关键字定义枚举类型。例如，您可以将星期枚举类型指定为： 1234public enum Day &#123; SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY &#125; 您应该在任何时候使用枚举类型来表示一组固定的常量。这包括自然枚举类型，例如太阳系中的行星，以及在编译时知道所有可能值的数据集，例如菜单上的选项、命令行标志等。 下面是一些代码，向您展示如何使用上面定义的Day枚举： 12345678910111213141516171819202122232425262728293031323334353637383940public class EnumTest &#123; Day day; public EnumTest(Day day) &#123; this.day = day; &#125; public void tellItLikeItIs() &#123; switch (day) &#123; case MONDAY: System.out.println(&quot;Mondays are bad.&quot;); break; case FRIDAY: System.out.println(&quot;Fridays are better.&quot;); break; case SATURDAY: case SUNDAY: System.out.println(&quot;Weekends are best.&quot;); break; default: System.out.println(&quot;Midweek days are so-so.&quot;); break; &#125; &#125; public static void main(String[] args) &#123; EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); EnumTest fifthDay = new EnumTest(Day.FRIDAY); fifthDay.tellItLikeItIs(); EnumTest sixthDay = new EnumTest(Day.SATURDAY); sixthDay.tellItLikeItIs(); EnumTest seventhDay = new EnumTest(Day.SUNDAY); seventhDay.tellItLikeItIs(); &#125;&#125; The output is: 12345Mondays are bad.Midweek days are so-so.Fridays are better.Weekends are best.Weekends are best. Java编程语言枚举类型比其他语言中的枚举类型强大得多。枚举声明定义了一个类（称为枚举类型）。枚举类主体可以包括方法和其他字段。编译器在创建枚举时自动添加一些特殊方法。例如，它们有一个静态值方法，该方法返回一个数组，该数组按声明顺序包含枚举的所有值。此方法通常与for each构造结合使用，以迭代枚举类型的值。例如，下面的Planet类示例中的这段代码会遍历太阳系中的所有行星。 1234for (Planet p : Planet.values()) &#123; System.out.printf(&quot;Your weight on %s is %f%n&quot;, p, p.surfaceWeight(mass));&#125; &#x3D;&#x3D;注意：所有枚举都隐式扩展java.lang.Enum。因为类只能扩展一个父类（请参见 Declaring Classes），所以Java语言不支持状态的多重继承（请参见状态、实现和类型的多重继承），因此枚举不能扩展任何其他内容。&#x3D;&#x3D; 在下面的示例中，Planet是一个枚举类型，表示太阳系中的行星。它们具有恒定的质量和半径特性。 每个枚举常量都用质量和半径参数的值声明。创建常量时，这些值将传递给构造函数。Java要求先定义常量，然后再定义任何字段或方法。此外，当存在字段和方法时，枚举常量列表必须以分号结尾。 &#x3D;&#x3D;注意：枚举类型的构造函数必须是包私有或私有访问。它会自动创建在枚举体开头定义的常量。不能自己调用枚举构造函数。&#x3D;&#x3D; 除了它的属性和构造器外，Planet还有一些方法可以让您检索每个行星上物体的表面重力和重量。下面是一个示例程序，它可以计算你在地球上的重量（以任何单位），并计算和打印你在所有行星上的重量: 12345678910111213141516171819202122232425262728293031323334353637383940public enum Planet &#123; MERCURY (3.303e+23, 2.4397e6), VENUS (4.869e+24, 6.0518e6), EARTH (5.976e+24, 6.37814e6), MARS (6.421e+23, 3.3972e6), JUPITER (1.9e+27, 7.1492e7), SATURN (5.688e+26, 6.0268e7), URANUS (8.686e+25, 2.5559e7), NEPTUNE (1.024e+26, 2.4746e7); private final double mass; // in kilograms private final double radius; // in meters Planet(double mass, double radius) &#123; this.mass = mass; this.radius = radius; &#125; private double mass() &#123; return mass; &#125; private double radius() &#123; return radius; &#125; // universal gravitational constant (m3 kg-1 s-2) public static final double G = 6.67300E-11; double surfaceGravity() &#123; return G * mass / (radius * radius); &#125; double surfaceWeight(double otherMass) &#123; return otherMass * surfaceGravity(); &#125; public static void main(String[] args) &#123; if (args.length != 1) &#123; System.err.println(&quot;Usage: java Planet &lt;earth_weight&gt;&quot;); System.exit(-1); &#125; double earthWeight = Double.parseDouble(args[0]); double mass = earthWeight/EARTH.surfaceGravity(); for (Planet p : Planet.values()) System.out.printf(&quot;Your weight on %s is %f%n&quot;, p, p.surfaceWeight(mass)); &#125;&#125; 如果你运行Planet.class，您将得到以下输出： 123456789$ java Planet 175Your weight on MERCURY is 66.107583Your weight on VENUS is 158.374842Your weight on EARTH is 175.000000Your weight on MARS is 66.279007Your weight on JUPITER is 442.847567Your weight on SATURN is 186.552719Your weight on URANUS is 158.397260Your weight on NEPTUNE is 199.207413","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"类","slug":"类","permalink":"https://guoshunfa.com/tags/%E7%B1%BB/"}]},{"title":"网络请求AJAX","slug":"软件开发/技术/编程语言/js/网络请求AJAX","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/网络请求AJAX/","link":"","permalink":"https://guoshunfa.com/2022/07/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82AJAX/","excerpt":"","text":"1. AJAX 介绍​ Ajax即Asynchronous Javascript And XML（异步JavaScript和XML）在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的XMLHttpRequest。 [3] 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。 2. AJAX 的实现方式介绍网络目前前端进行网络请求有两种方式，XHR和fatch。 对XHR进行封装的组件有很多，常见的有axios，jquery。 备注：XHR（XMLHttpRequest） （建议使用axios。） 2.1. 优缺点XHR缺点： API用法繁琐。 没有关注分离的设计思想。 fetch优点： 关注分离的设计思想。 API相对于XHR更简单。 fetch是浏览器原生支持的，使用fetch可以不用引用http的类库即可实现。 缺点： 老版浏览器兼容问题。（IE系列是完全不支持的，主流浏览器的早起版本也不支持，所以如果在项目中使用需要做兼容方案处理。） 3. 原生JS 实现 AJAX 直接使用XHR(XMLHttpRequest)。 12345678910var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;,url, true);xhr.send(null);xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status == 200)&#123; alert(xhr.responseText); &#125; &#125;&#125; 4. axios 实现 AJAX 前往 github （详情请查看axios Github 项目README.md 文件。） 4.1. 安装Using npm: 1$ npm install axios Using bower: 1$ bower install axios Using yarn: 1$ yarn add axios Using jsDelivr CDN: 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Using unpkg CDN: 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 4.2. API demo123456789// Send a POST requestaxios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;); 123456789// GET request for remote image in node.jsaxios(&#123; method: &#x27;get&#x27;, url: &#x27;http://bit.ly/2mTM3nY&#x27;, responseType: &#x27;stream&#x27;&#125;) .then(function (response) &#123; response.data.pipe(fs.createWriteStream(&#x27;ada_lovelace.jpg&#x27;)) &#125;); 5. JQuery 实现 AJAX123456$.ajax(&#123; url: &#x27;url&#x27;, type: &#x27;get&#x27;, success: function()&#123; &#125;&#125;) 6. Fetch 实现 AJAX123456try &#123; const response= await fetch(url) const data = await response.json()&#125; catch (error) &#123; console.log(&#x27;请求出错&#x27;,error);&#125; Fetch 更多参数: 12345678910111213fetch(url, &#123; body: JSON.stringify(data), // must match &#x27;Content-Type&#x27; header cache: &#x27;no-cache&#x27;, // *default, no-cache, reload, force-cache, only-if-cached credentials: &#x27;same-origin&#x27;, // include, same-origin, *omit headers: &#123; &#x27;user-agent&#x27;: &#x27;Mozilla/4.0 MDN Example&#x27;, &#x27;content-type&#x27;: &#x27;application/json&#x27; &#125;, method: &#x27;POST&#x27;, // *GET, POST, PUT, DELETE, etc. mode: &#x27;cors&#x27;, // no-cors, cors, *same-origin redirect: &#x27;follow&#x27;, // manual, *follow, error referrer: &#x27;no-referrer&#x27;, // *client, no-referrer&#125;) 参考文档 XHR 和 Fetch 的使用详解和区别总结 百度百科","categories":[{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/categories/HTML-CSS-JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://guoshunfa.com/tags/JS/"},{"name":"AJAX","slug":"AJAX","permalink":"https://guoshunfa.com/tags/AJAX/"}]},{"title":"Python scrapy爬虫","slug":"软件开发/技术/编程语言/python/Python-scrapy爬虫","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Python-scrapy爬虫/","link":"","permalink":"https://guoshunfa.com/2022/07/Python-scrapy%E7%88%AC%E8%99%AB/","excerpt":"","text":"scrapy API | 开源project-github 1. demo1234567891011121314import scrapyclass QuotesSpider(scrapy.Spider): name = &#x27;quotes&#x27; start_urls = [ &#x27;http://quotes.toscrape.com/tag/humor/&#x27;, ] def parse(self, response): for quote in response.css(&#x27;div.quote&#x27;): yield &#123; &#x27;author&#x27;: quote.xpath(&#x27;span/small/text()&#x27;).get(), &#x27;text&#x27;: quote.css(&#x27;span.text::text&#x27;).get(), &#125;","categories":[{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/categories/Python/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://guoshunfa.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"爬虫","slug":"爬虫","permalink":"https://guoshunfa.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://guoshunfa.com/tags/Scrapy/"}]},{"title":"Python 脚本记录","slug":"软件开发/技术/编程语言/python/Python-脚本记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Python-脚本记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Python-%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#-*- coding:utf-8 -*-import osimport re#要改的文件夹dir =&quot;/Library/work/workspace-my/test_file/file&quot;#要改的文件类型（可以输入多个）file_type=[&quot;.txt&quot;]#替换表（可以用python正则表达式）look_up_table=[ [&quot;第一行&quot;,&quot;aaaa&quot;], ]def get_filelist(dir,filetype): Filelist = [] for home, dirs, files in os.walk(dir): for filename in files: if(filename[-len(filetype):]==filetype): Filelist.append(os.path.join(home, filename)) return Filelistif __name__ ==&quot;__main__&quot;: for type in file_type: print(&quot;开始处理&quot;+type+&quot;类型文件&quot;) file_list = get_filelist(dir,type) print(&quot;共发现&quot;+str(len(file_list))+&quot;个&quot;+type+&quot;类型文件&quot;) replace_count=0 file_count=0 for file in file_list: file_count=file_count+1 if(file_count%100==0): print(&quot;修改到第&quot;+str(file_count)+&quot;个文件&quot;) file_data=&quot;&quot; with open(file, &quot;r&quot;) as f: for line in f: for item in look_up_table: if re.search(item[0], line): #print(&quot;正在修改从&quot;+item[0]+&quot;到&quot;+item[1]) line=re.sub(item[0],item[1],line) replace_count=replace_count+1 file_data += line with open(file,&quot;w&quot;) as f: f.write(file_data) print(&quot;一共进行了&quot;+str(replace_count)+&quot;处替换&quot;) print(&quot;结束处理&quot;+type+&quot;类型文件&quot;)print(&quot;全部结束&quot;) :::","categories":[{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/categories/Python/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://guoshunfa.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/tags/Python/"}]},{"title":"Swift基础 下标","slug":"软件开发/技术/编程语言/swift/Swift基础-下标","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Swift基础-下标/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E4%B8%8B%E6%A0%87/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Subscripts.html 类、结构和枚举可以定义下标，下标是访问集合、列表或序列成员元素的快捷方式。您可以使用下标按索引设置和检索值，而无需单独的设置和检索方法。例如，您可以以someArray[index]的形式访问数Array实例中的元素，以someDictionary[key]的形式访问aDictionary实例中的元素。 您可以为单个类型定义多个下标，并根据您传递给下标的索引值类型选择要使用的相应下标重载。下标不限于单个维度，您可以使用多个输入参数定义下标，以满足自定义类型的需求。 下标语法下标使您能够通过在实例名称后的方括号中写入一个或多个值来查询类型的实例。它们的语法与实例方法语法和计算属性语法相似。您使用下标关键字编写下标定义，并以与实例方法相同的方式指定一个或多个输入参数和返回类型。与实例方法不同，下标可以是读写或只读。此行为由获取者和设置器以与计算属性相同的方式进行通信： subscript(index: Int) -&gt; Int { ​ get { ​ &#x2F;&#x2F; Return an appropriate subscript value here. ​ } ​ set(newValue) { ​ &#x2F;&#x2F; Perform a suitable setting action here. ​ } } newValue的类型与下标的返回值相同。与计算属性一样，您可以选择不指定setter的(newValue)参数。如果您自己不提供一个名为newValue默认参数，则会向您的设置器提供一个参数。 与只读计算属性一样，您可以通过删除get关键字及其大括号来简化只读下标的声明： subscript(index: Int) -&gt; Int { ​ &#x2F;&#x2F; Return an appropriate subscript value here. } 以下是只读下标实现的示例，它定义了一个TimesTable结构来表示整数的n次表： struct TimesTable { ​ let multiplier: Int ​ subscript(index: Int) -&gt; Int { ​ return multiplier * index ​ } } let threeTimesTable &#x3D; TimesTable(multiplier: 3) print(“six times three is (threeTimesTable[6])”) &#x2F;&#x2F; Prints “six times three is 18” 在本例中，创建了一个新的TimesTable实例来表示三倍表。这通过将值3传递给结构的initializer作为用于实例multiplier参数的值来表示。 您可以通过调用其下标来查询threeTimesTable实例，如对threeTimesTable[6]的调用所示。这要求三倍表中的第六个条目，返回值为18或3乘以6。 注意 n-times表基于固定的数学规则。将threeTimesTable[someIndex]设置为新值是不合适的，因此TimesTable的下标被定义为只读下标。 下标用法“下标”的确切含义取决于其使用的上下文。下标通常用作访问集合、列表或序列中成员元素的快捷方式。您可以自由地以最适合您特定类或结构功能的方式实现下标。 例如，Swift的Dictionary类型实现了下标来设置和检索存储在Dictionary实例中的值。您可以通过在下标括号中提供字典键类型的键并将字典值类型的值分配给下标来在字典中设置值： var numberOfLegs &#x3D; [“spider”: 8, “ant”: 6, “cat”: 4] numberOfLegs[“bird”] &#x3D; 2 The example above defines a variable called numberOfLegs and initializes it with a dictionary literal containing three key-value pairs. The type of the numberOfLegs dictionary is inferred to be [String: Int]. After creating the dictionary, this example uses subscript assignment to add a String key of &quot;bird&quot; and an Int value of 2 to the dictionary. 有关Dictionary下标的更多信息，请参阅访问和修改词典。 注意 Swift的Dictionary类型将其键值下标实现为接受并返回可选类型的下标。对于上面的numberOfLegs字典，键值下标接受并返回类型为Int?或“可选int”的值。Dictionary类型使用可选的下标类型来模拟并非每个键都有一个值的事实，并通过为该键分配一个nil值来为该值来提供删除该值的方法。 下标选项下标可以接受任意数量的输入参数，这些输入参数可以是任何类型的。下标也可以返回任何类型的值。 与函数一样，下标可以获取不同数量的参数，并为其参数提供默认值，如变量参数和默认参数值中所述。然而，与函数不同，下标不能使用输入输出参数。 类或结构可以根据需要提供尽可能多的下标实现，并将根据使用下标时下标括号中包含的值的类型推断要使用的适当下标。多个下标的定义称为下标重载。 虽然下标取单个参数最常见，但如果适合您的类型，您也可以定义具有多个参数的下标。以下示例定义了一个Matrix结构，它表示Double值的二维矩阵。Matrix结构的下标需要两个整数参数： struct Matrix { ​ let rows: Int, columns: Int ​ var grid: [Double] ​ init(rows: Int, columns: Int) { ​ self.rows &#x3D; rows ​ self.columns &#x3D; columns ​ grid &#x3D; Array(repeating: 0.0, count: rows * columns) ​ } ​ func indexIsValid(row: Int, column: Int) -&gt; Bool { ​ return row &gt;&#x3D; 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;&#x3D; 0 &amp;&amp; column &lt; columns ​ } ​ subscript(row: Int, column: Int) -&gt; Double { ​ get { ​ assert(indexIsValid(row: row, column: column), “Index out of range”) ​ return grid[(row * columns) + column] ​ } ​ set { ​ assert(indexIsValid(row: row, column: column), “Index out of range”) ​ grid[(row * columns) + column] &#x3D; newValue ​ } ​ } } Matrix提供了一个初始化器，该初始化器接受两个称为rows和columns参数，并创建一个足够大的数组来存储类型为Double的rows*columns值。矩阵中的每个位置的初始值为0.0。为了实现这一目标，数组的大小和0.0的初始单元格值被传递给数组初始化器，该初始化器创建和初始化正确大小的新数组。此初始化器在创建具有默认值的数组中进行了更详细的描述。 您可以通过将适当的行和列计数传递给其初始化器来构建新的Matrix实例： var matrix &#x3D; Matrix(rows: 2, columns: 2) 上面的示例创建一个具有两行和两列的新Matrix实例。此Matrix实例的grid数组实际上是矩阵的扁平版本，从左上角读取到右下角： 矩阵中的值可以通过将行和列值传递到下标中来设置，并用逗号分隔： matrix[0, 1] &#x3D; 1.5 matrix[1, 0] &#x3D; 3.2 这两个语句调用下标的设置器，在矩阵的右上角位置设置1.5（row``0，column1），在左下角位置设置3.2（row``1，column``0）： Matrix下标的获取器和设置器都包含一个断言，以检查下标的row和column值是否有效。为了帮助这些断言，Matrix包括一种名为indexIsValid(row:column:)的方便方法，该方法检查请求的row和column是否在矩阵的边界内： func indexIsValid(row: Int, column: Int) -&gt; Bool { ​ return row &gt;&#x3D; 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;&#x3D; 0 &amp;&amp; column &lt; columns } 如果您尝试访问矩阵边界之外的下标，则会触发断言： let someValue &#x3D; matrix[2, 2] &#x2F;&#x2F; This triggers an assert, because [2, 2] is outside of the matrix bounds. 键入下标如上所述，实例下标是您在特定类型的实例上调用的下标。您还可以定义在类型本身上调用的下标。这种下标被称为类型下标。您可以通过在下标关键字之前写静态关键字来指示类型subscript。类可以使用class关键字，以允许子类覆盖超类对该下标的实现。下面的示例显示了您如何定义和调用类型下标： enum Planet: Int { ​ case mercury &#x3D; 1, venus, earth, mars, jupiter, saturn, uranus, neptune ​ static subscript(n: Int) -&gt; Planet { ​ return Planet(rawValue: n)! ​ } } let mars &#x3D; Planet[4] print(mars)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 不透明的类型","slug":"软件开发/技术/编程语言/swift/Swift基础-不透明的类型","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Swift基础-不透明的类型/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E4%B8%8D%E9%80%8F%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html 具有不透明返回类型的函数或方法隐藏其返回值的类型信息。返回值不是提供具体类型作为函数的返回类型，而是根据其支持的协议来描述。隐藏类型信息在调用模块的模块和代码之间的边界上非常有用，因为返回值的底层类型可以保持私密性。与返回类型为协议类型的值不同，不透明类型保留类型标识——编译器可以访问类型信息，但模块的客户端不能访问。 不透明类型解决的问题例如，假设您正在编写一个绘制ASCII艺术形状的模块。ASCII艺术形状的基本特征是draw()函数，该函数返回该形状的字符串表示形式，您可以将其用作Shape协议的要求： protocol Shape { ​ func draw() -&gt; String } struct Triangle: Shape { ​ var size: Int ​ func draw() -&gt; String { ​ var result: [String] &#x3D; [] ​ for length in 1…size { ​ result.append(String(repeating: “*”, count: length)) ​ } ​ return result.joined(separator: “\\n”) ​ } } let smallTriangle &#x3D; Triangle(size: 3) print(smallTriangle.draw()) &#x2F;&#x2F; * &#x2F;&#x2F; ** &#x2F;&#x2F; *** 您可以使用泛型来实现垂直翻转形状等操作，如下代码所示。然而，这种方法有一个重要的局限性：翻转的结果暴露了用于创建它的确切通用类型。 struct FlippedShape&lt;T: Shape&gt;: Shape { ​ var shape: T ​ func draw() -&gt; String { ​ let lines &#x3D; shape.draw().split(separator: “\\n”) ​ return lines.reversed().joined(separator: “\\n”) ​ } } let flippedTriangle &#x3D; FlippedShape(shape: smallTriangle) print(flippedTriangle.draw()) &#x2F;&#x2F; *** &#x2F;&#x2F; ** &#x2F;&#x2F; * This approach to defining a JoinedShape&lt;T: Shape, U: Shape&gt; structure that joins two shapes together vertically, like the code below shows, results in types like JoinedShape&lt;FlippedShape&lt;Triangle&gt;, Triangle&gt; from joining a flipped triangle with another triangle. struct JoinedShape&lt;T: Shape, U: Shape&gt;: Shape { ​ var top: T ​ var bottom: U ​ func draw() -&gt; String { ​ return top.draw() + “\\n” + bottom.draw() ​ } } let joinedTriangles &#x3D; JoinedShape(top: smallTriangle, bottom: flippedTriangle) print(joinedTriangles.draw()) &#x2F;&#x2F; * &#x2F;&#x2F; ** &#x2F;&#x2F; *** &#x2F;&#x2F; *** &#x2F;&#x2F; ** &#x2F;&#x2F; * 公开有关创建形状的详细信息，可以让不打算属于ASCII艺术模块公共界面的类型泄露出去，因为需要声明完整的返回类型。模块内的代码可以以各种方式构建相同的形状，模块外使用该形状的其他代码不应考虑有关转换列表的实现细节。JoinedShape和FlippedShape等包装类型对模块的用户无关紧要，它们不应该可见。该模块的公共接口包括连接和翻转形状等操作，这些操作返回另一个Shape值。 返回不透明类型你可以把不透明的类型想象成通用类型的反面。通用类型允许调用函数的代码为该函数的参数选择类型，并以从函数实现抽象出来的方式返回值。例如，以下代码中的函数返回的类型取决于其调用者： func max&lt;T&gt;(_ x: T, _ y: T) -&gt; T where T: Comparable &#123; ... &#125; 调用max(_:_:)的代码为x和y选择值，这些值的类型决定了T的具体类型。调用代码可以使用任何符合Comparable协议的类型。函数中的代码以一般方式编写，因此它可以处理调用者提供的任何类型。max(_:_:)的实现仅使用所有Comparable类型共享的功能。 对于具有不透明返回类型的函数，这些角色是反向的。不透明类型允许函数实现以一种从调用函数的代码抽象出来的方式选择它返回的值的类型。例如，以下示例中的函数返回梯形而不暴露该形状的底层类型。 12345678struct Square: Shape &#123;​ var size: Int​ func draw() -&gt; String &#123;​ let line = String(repeating: &quot;*&quot;, count: size)​ let result = Array&lt;String&gt;(repeating: line, count: size)​ return result.joined(separator: &quot;\\n&quot;)​ &#125;&#125; func makeTrapezoid() -&gt; some Shape { ​ let top &#x3D; Triangle(size: 2) ​ let middle &#x3D; Square(size: 2) ​ let bottom &#x3D; FlippedShape(shape: top) ​ let trapezoid &#x3D; JoinedShape( ​ top: top, ​ bottom: JoinedShape(top: middle, bottom: bottom) ​ ) ​ return trapezoid } let trapezoid &#x3D; makeTrapezoid() print(trapezoid.draw()) &#x2F;&#x2F; * &#x2F;&#x2F; ** &#x2F;&#x2F; ** &#x2F;&#x2F; ** &#x2F;&#x2F; ** &#x2F;&#x2F; * 本示例中的makeTrapezoid()函数将其返回类型声明为someShape；因此，该函数返回符合Shape协议的给定类型的值，而不指定任何特定的具体类型。以这种方式编写makeTrapezoid()可以表达其公共接口的基本方面——它返回的值是一个形状——而无需制作形状由其公共接口的一部分制成的特定类型。这个实现使用两个三角形和一个正方形，但可以重写该函数，以各种其他方式绘制梯形，而不会改变其返回类型。 此示例突出了不透明的返回类型与泛型类型相反的方式。makeTrapezoid()内部的代码可以返回它需要的任何类型，只要该类型符合Shape协议，就像调用通用函数一样。调用函数的代码需要以一般方式编写，例如实现泛型函数，以便它可以与makeTrapezoid()返回的任何Shape值一起工作。 您还可以将不透明的返回类型与泛型组合在一起。以下代码中的函数都返回符合Shape协议的某种类型的值。 1234567891011121314151. func flip&lt;T: Shape&gt;(_ shape: T) -&gt; some Shape &#123;2. ​ return FlippedShape(shape: shape)3. &#125;4. func join&lt;T: Shape, U: Shape&gt;(_ top: T, _ bottom: U) -&gt; some Shape &#123;5. ​ JoinedShape(top: top, bottom: bottom)6. &#125;7. 8. let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))9. print(opaqueJoinedTriangles.draw())10. // *11. // **12. // ***13. // ***14. // **15. // * 本示例中opaqueJoinedTriangles的值与本章前面不透明类型解决的问题部分中的泛型示例中的joinedTriangles相同。然而，与该示例中的值不同，flip(_:)和join(_:_:)将通用形状操作返回的底层类型包装在不透明的返回类型中，这防止这些类型可见。这两个函数都是通用的，因为它们依赖的类型是通用的，函数的类型参数传递FlippedShape和JoinedShape所需的类型信息。 如果具有不透明返回类型的函数从多个地方返回，则所有可能的返回值必须具有相同的类型。对于泛型函数，该返回类型可以使用函数的泛型类型参数，但它必须仍然是单一类型。例如，以下是形状翻转函数的无效版本，其中包括正方形的特殊情况： 1234561. func invalidFlip&lt;T: Shape&gt;(_ shape: T) -&gt; some Shape &#123;2. ​ if shape is Square &#123;3. ​ return shape // Error: return types don&#x27;t match4. ​ &#125;5. ​ return FlippedShape(shape: shape) // Error: return types don&#x27;t match6. &#125; 如果您使用Square调用此函数，它将返回Square；否则，它将返回aFlippedShape。这违反了仅返回一种类型的值的要求，并使invalidFlip(_:)代码无效。修复invalidFlip(_:)的一种方法是将正方形的特殊情况移动到FlippedShape的实现中，这使得此函数始终返回aFlippedShape值： 123456789101. struct FlippedShape&lt;T: Shape&gt;: Shape &#123;2. ​ var shape: T3. ​ func draw() -&gt; String &#123;4. ​ if shape is Square &#123;5. ​ return shape.draw()6. ​ &#125;7. ​ let lines = shape.draw().split(separator: &quot;\\n&quot;)8. ​ return lines.reversed().joined(separator: &quot;\\n&quot;)9. ​ &#125;10. &#125; 始终返回单个类型的要求并不妨碍您在不透明的返回类型中使用泛型。以下是将其类型参数集成到其返回的值的基础类型的函数示例： 1231. func `repeat`&lt;T: Shape&gt;(shape: T, count: Int) -&gt; some Collection &#123;2. ​ return Array&lt;T&gt;(repeating: shape, count: count)3. &#125; 在这种情况下，返回值的底层类型因T而异：无论传递什么形状，repeat(shape:count:)创建并返回该形状的数组。然而，返回值始终具有相同的[T]底层类型，因此它遵循了具有不透明返回类型的函数必须仅返回单个类型的值的要求。 不透明类型和协议类型之间的差异 返回不透明类型看起来与使用协议类型作为函数的返回类型非常相似，但这两种返回类型在是否保留类型标识方面有所不同。不透明类型是指一种特定类型，尽管函数的调用者无法看到哪种类型；协议类型可以引用任何符合协议的类型。一般来说，协议类型使您更灵活地了解它们存储的值的底层类型，不透明类型允许您对这些底层类型做出更有力的保证。 例如，这是一个flip(_:)版本，它使用协议类型作为其返回类型，而不是不透明的返回类型： 1231. func protoFlip&lt;T: Shape&gt;(_ shape: T) -&gt; Shape &#123;2. ​ return FlippedShape(shape: shape)3. &#125; 此版本的protoFlip(_:)与flip(_:)具有相同的主体，并且它总是返回相同类型的值。与flip(_:)，protoFlip(_:)返回的值不需要始终具有相同的类型——它只需要符合Shape协议。换句话说，protoFlip(_:)与其调用者签订的API合同比flip(_:)的API合同要宽松得多。它保留了返回多种类型值的灵活性： 12345671. func protoFlip&lt;T: Shape&gt;(_ shape: T) -&gt; Shape &#123;2. ​ if shape is Square &#123;3. ​ return shape4. ​ &#125;5. 6. ​ return FlippedShape(shape: shape)7. &#125; 代码的修订版本返回Square的实例或FlippedShape的实例，具体取决于传递的形状。此函数返回的两个翻转形状可能具有完全不同的类型。当翻转相同形状的多个实例时，此函数的其他有效版本可以返回不同类型的值。来自protoFlip(_:)不太具体的返回类型信息意味着许多依赖类型信息的操作在返回的值上不可用。例如，无法编写==运算符来比较此函数返回的结果。 let protoFlippedTriangle &#x3D; protoFlip(smallTriangle) let sameThing &#x3D; protoFlip(smallTriangle) protoFlippedTriangle &#x3D;&#x3D; sameThing &#x2F;&#x2F; Error 示例最后一行的错误有几个原因。迫在眉睫的问题是，Shape不包含==运算符作为其协议要求的一部分。如果您尝试添加一个，您将遇到的下一个问题是==运算符需要知道其左手和右手参数的类型。这种运算符通常接受typeSelf的参数，匹配采用协议的任何具体类型，但在协议中添加Self要求不允许将协议用作类型时发生的类型擦除。 使用协议类型作为函数的返回类型使您可以灵活地返回任何符合协议的类型。然而，这种灵活性的成本是，一些操作无法对返回的值进行。该示例显示了==运算符如何不可用——这取决于使用协议类型无法保留的特定类型信息。 这种方法的另一个问题是形状转换不会嵌套。翻转三角形的结果是类型为Shape的值，protoFlip(_:)函数采用符合Shape协议的某种类型的参数。然而，协议类型的值不符合该协议；protoFlip(_:)返回的值不符合Shape。这意味着像protoFlip(protoFlip(smallTriange))这样的应用多个转换的代码无效，因为翻转的形状不是toprotoFlipprotoFlip(_:)的有效参数。 相比之下，不透明类型保留了底层类型的身份。Swift可以推断关联类型，这允许您在协议类型不能用作返回值的地方使用不透明的返回值。例如，这是来自Generics的Container协议的一个版本： protocol Container { ​ associatedtype Item ​ var count: Int { get } ​ subscript(i: Int) -&gt; Item { get } } extension Array: Container { } 您不能将Container用作函数的返回类型，因为该协议具有关联类型。您也不能在泛型返回类型中将其用作约束，因为函数体外部没有足够的信息来推断泛型类型需要是什么。 1234567891. // Error: Protocol with associated types can&#x27;t be used as a return type.2. func makeProtocolContainer&lt;T&gt;(item: T) -&gt; Container &#123;3. ​ return [item]4. &#125;5. 6. // Error: Not enough information to infer C.7. func makeProtocolContainer&lt;T, C: Container&gt;(item: T) -&gt; C &#123;8. ​ return [item]9. &#125; 使用不透明类型someContainer作为返回类型表示所需的API合同——该函数返回容器，但拒绝指定容器的类型： 12345671. func makeOpaqueContainer&lt;T&gt;(item: T) -&gt; some Container &#123;2. ​ return [item]3. &#125;4. let opaqueContainer = makeOpaqueContainer(item: 12)5. let twelve = opaqueContainer[0]6. print(type(of: twelve))7. // Prints &quot;Int&quot; twelve的类型被推断为Int，这说明了类型推断适用于不透明类型的事实。在makeOpaqueContainer(item:)的实现中，不透明容器的基础类型是[T]在这种情况下，T是Int，因此返回值是整数数数组，并且推断出Item关联的类型为Int。Container上的下标返回Item，这意味着twelve的类型也被推断为Int。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 关于Swift","slug":"软件开发/技术/编程语言/swift/Swift基础-关于Swift","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Swift基础-关于Swift/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8ESwift/","excerpt":"","text":"docs swift | swift learn | youtube | runoob 本站基于swift 5.6进行描述，版本升级带来的变动会以独立文件展示。 翻译自：https://docs.swift.org/swift-book/ Swift 是编写软件的绝佳方式，无论是手机、台式机、服务器还是任何其他运行代码的内容。这是一种安全、快速和互动的编程语言，它结合了现代语言思维的最佳与更广泛的苹果工程文化的智慧以及开源社区的各种贡献。编译器针对性能进行了优化，语言也针对开发进行了优化，同时不影响两者。 Swift对新程序员很友好。它是一种工业质量的编程语言，与脚本语言一样富有表现力和乐趣。在 playground 中编写 Swift 代码可以让您尝试代码并立即查看结果，而无需构建和运行应用程序。 Swift通过采用现代编程模式定义了大类常见编程错误： 变量总是在使用前初始化。 检查数组索引是否有越界错误。 检查整数是否溢出。 可选确保显式处理nil值。 内存是自动管理的。 错误处理允许从意外故障中控制恢复。 Swift代码经过编译和优化，以充分利用现代硬件。语法和标准库是根据以下指导原则设计的，即编写代码的明显方式也应发挥最佳效果。它的安全性和速度相结合，使Swift成为“你好，世界！”等一切的绝佳选择。整个操作系统。 Swift将强大的类型推理和模式匹配与现代轻量级语法相结合，允许以清晰简洁的方式表达复杂的想法。因此，代码不仅更容易编写，而且更容易阅读和维护。 Swift已经酝酿多年，并随着新的特性和功能不断发展。我们对 Swift 的目标雄心勃勃。我们迫不及待地想看看你用它创造了什么。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 内存安全","slug":"软件开发/技术/编程语言/swift/Swift基础-内存安全","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Swift基础-内存安全/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/MemorySafety.html 默认情况下，Swift 可以防止代码中出现不安全行为。例如，Swift确保变量在使用前初始化，在释放后无法访问内存，并检查数组索引是否有越界错误。 Swift 还要求修改内存位置的代码独占该内存访问权限，从而确保对同一内存区域的多次访问不会发生冲突。由于 Swift 会自动管理内存，因此在大多数情况下，您根本不需要考虑访问内存。然而，了解潜在冲突在哪里可能发生很重要，这样您就可以避免编写内存访问冲突的代码。如果您的代码确实包含冲突，您将收到编译时或运行时错误。 了解内存访问冲突当您执行设置变量值或将参数传递给函数等操作时，代码中会发生对内存的访问。例如，以下代码包含读取访问和写入访问： &#x2F;&#x2F; A write access to the memory where one is stored. var one &#x3D; 1 &#x2F;&#x2F; A read access from the memory where one is stored. print(“We’re number (one)!”) 当您代码的不同部分试图同时访问内存中的同一位置时，可能会发生对内存的访问冲突。同时多次访问内存中的位置可能会产生不可预测或不一致的行为。在Swift中，有几种方法可以修改跨越几行代码的值，从而可以在自己的修改过程中尝试访问一个值。 通过考虑如何更新写在纸上的预算，您可以看到类似的问题。更新预算是一个两步过程：首先添加项目的名称和价格，然后更改总金额以反映当前列表中的项目。在更新之前和之后，您可以阅读预算中的任何信息并获得正确的答案，如下图所示。 当您将项目添加到预算中时，它处于临时无效状态，因为总金额尚未更新以反映新添加的项目。在添加项目过程中读取总金额会显示错误的信息。 此示例还展示了您在修复内存访问冲突时可能会遇到的挑战：有时有多种方法可以解决产生不同答案的冲突，并且并不总是很明显哪个答案是正确的。在本例中，根据您想要原始总金额还是更新的总金额，5美元或320美元可能是正确的答案。在修复相互冲突的访问之前，您必须确定它打算做什么。 注意 如果您编写了并发或多线程代码，对内存的访问冲突可能是一个熟悉的问题。然而，这里讨论的相互冲突的访问可能发生在单个线程上，不涉及并发或多线程代码。 如果您从单个线程中对内存的访问存在冲突，Swift保证您在编译时或运行时都会收到错误。对于多线程代码，请使用线程消毒器来帮助检测跨线程的冲突访问。 内存访问的特点在相互冲突的访问中，内存访问有三个特征需要考虑：访问是读还是写，访问持续时间和被访问的内存位置。具体来说，如果您有两个访问满足以下所有条件，则会发生冲突： 至少有一个是写入访问或非原子访问。 他们在内存中访问相同的位置。 它们的持续时间重叠。 读写访问之间的区别通常是显而易见的：写入访问会改变内存中的位置，但读取访问不会。内存中的位置是指正在访问的内容，例如变量、常量或属性。内存访问的持续时间要么是即时的，要么是长期的。 如果操作只使用C原子运算，则该运算是原子运算；否则它是非原子运算。有关这些功能的列表，请参阅stdatomic(3)手册页。 如果访问无法在访问开始后但在访问结束前运行其他代码，则访问是即时的。就其本质而言，两次即时访问不可能同时发生。大多数内存访问都是即时的。例如，以下代码列表中的所有读写访问都是即时的： func oneMore(than number: Int) -&gt; Int { ​ return number + 1 } var myNumber &#x3D; 1 myNumber &#x3D; oneMore(than: myNumber) print(myNumber) &#x2F;&#x2F; Prints “2” 然而，有几种访问内存的方法，称为长期访问，跨越了其他代码的执行。即时访问和长期访问的区别在于，其他代码可以在长期访问开始后但在结束之前运行，这被称为重叠。长期访问可以与其他长期访问和即时访问重叠。 重叠访问主要出现在在函数和方法或结构的突变方法中使用内外参数的代码中。以下各节将讨论使用长期访问的特定类型的Swift代码。 对In-Out参数的访问相互冲突函数可以长期写入其所有输入输出参数。进出参数的写入访问在评估完所有非入出参数后开始，并持续到该函数调用的整个持续时间。如果有多个输入输出参数，写入访问的开始顺序与参数显示的顺序相同。 这种长期写入访问的一个后果是，即使范围规则和访问控制允许，您也无法访问作为进出传递的原始变量——对原始变量的任何访问都会产生冲突。例如： var stepSize &#x3D; 1 func increment(_ number: inout Int) { ​ number +&#x3D; stepSize } increment(&amp;stepSize) &#x2F;&#x2F; Error: conflicting accesses to stepSize 在上面的代码中，stepSize是一个全局变量，通常可以从increment(_:)访问。然而，对stepSize的读取访问与写入访问number重叠。如下图所示，number和stepSize都指内存中的相同位置。读写访问引用相同的内存，它们重叠，产生冲突。 解决这种冲突的一种方法是明确复制stepSize： &#x2F;&#x2F; Make an explicit copy. var copyOfStepSize &#x3D; stepSize increment(&amp;copyOfStepSize) &#x2F;&#x2F; Update the original. stepSize &#x3D; copyOfStepSize &#x2F;&#x2F; stepSize is now 2 When you make a copy of stepSize before calling increment(_:), it’s clear that the value of copyOfStepSize is incremented by the current step size. The read access ends before the write access starts, so there isn’t a conflict. 对进出参数的长期写入访问的另一个后果是，传递单个变量作为同一函数多个输入输出参数的参数会产生冲突。例如： func balance(_ x: inout Int, _ y: inout Int) { ​ let sum &#x3D; x + y ​ x &#x3D; sum &#x2F; 2 ​ y &#x3D; sum - x } var playerOneScore &#x3D; 42 var playerTwoScore &#x3D; 30 balance(&amp;playerOneScore, &amp;playerTwoScore) &#x2F;&#x2F; OK balance(&amp;playerOneScore, &amp;playerOneScore) &#x2F;&#x2F; Error: conflicting accesses to playerOneScore 上面的balance(_:_:)函数修改其两个参数，在它们之间平均分配总值。使用playerOneScore和playerTwoScore将其称为参数不会产生冲突——有两个写入访问在时间上重叠，但它们访问内存中的不同位置。相比之下，将playerOneScore作为两个参数的值会产生冲突，因为它试图同时对内存中的同一位置执行两次写入访问。 注意 Because operators are functions, they can also have long-term accesses to their in-out parameters. For example, if balance(_:_:) was an operator function named &lt;^&gt;, writing playerOneScore &lt;^&gt; playerOneScore would result in the same conflict as balance(&amp;playerOneScore, &amp;playerOneScore). 在方法中自我访问相互冲突结构上的突变方法在方法调用期间具有对self的写入访问权限。例如，考虑一个游戏，其中每个玩家的生命值在受到伤害时会减少，能量量在使用特殊能力时会减少。 struct Player { ​ var name: String ​ var health: Int ​ var energy: Int ​ static let maxHealth &#x3D; 10 ​ mutating func restoreHealth() { ​ health &#x3D; Player.maxHealth ​ } } 在上面的restoreHealth()方法中，对self的写入访问从方法的开头开始，一直持续到方法返回。在这种情况下，restoreHealth()内部没有其他代码可以重叠访问Player实例的属性。下面的shareHealth(with:)方法将另一个Player实例作为进出参数，从而产生重叠访问的可能性。 extension Player { ​ mutating func shareHealth(with teammate: inout Player) { ​ balance(&amp;teammate.health, &amp;health) ​ } } var oscar &#x3D; Player(name: “Oscar”, health: 10, energy: 10) var maria &#x3D; Player(name: “Maria”, health: 5, energy: 10) oscar.shareHealth(with: &amp;maria) &#x2F;&#x2F; OK 在上面的示例中，为奥斯卡的玩家调用shareHealth(with:)方法与Maria的玩家共享健康不会引起冲突。在方法调用期间，对oscar有写入访问权限，因为oscar是突变方法中self的值，并且有对maria的写入访问权限，因为maria是作为进出参数传递的。如下图所示，他们访问内存中的不同位置。尽管这两个写入访问在时间上重叠，但它们不会冲突。 但是，如果您将oscar作为shareHealth(with:)的参数，则存在冲突： oscar.shareHealth(with: &amp;oscar) &#x2F;&#x2F; Error: conflicting accesses to oscar 突变方法需要在方法持续时间内写入对self的访问权限，而入出参数需要在同一持续时间内写入对teammate的访问权限。在方法中，self和teammate都引用了内存中的相同位置——如下图所示。两个写入访问指的是相同的内存，它们重叠，产生冲突。 对属性的访问相互冲突结构、元组和枚举等类型由单个组成值组成，例如结构的属性或元组的元素。由于这些是值类型，因此变异值的任何部分都会改变整个值，这意味着对其中一个属性的读或写访问需要对整个值的读或写访问。例如，对元组元素的重叠写入访问会产生冲突： var playerInformation &#x3D; (health: 10, energy: 20) balance(&amp;playerInformation.health, &amp;playerInformation.energy) &#x2F;&#x2F; Error: conflicting access to properties of playerInformation 在上面的示例中，在元组元素上调用balance(_:_:)会产生冲突，因为对playerInformation写入访问重叠。playerInformation.health和playerInformation.energy都作为输入输出参数传递，这意味着balance(_:_:)需要在函数调用期间写入访问权限。在这两种情况下，对元组元素的写入访问都需要对整个元组进行写入访问。这意味着对playerInformation有两次写入访问，持续时间重叠，导致冲突。 以下代码显示，对存储在全局变量中的结构属性的重叠写入访问也会出现相同的错误。 var holly &#x3D; Player(name: “Holly”, health: 10, energy: 10) balance(&amp;holly.health, &amp;holly.energy) &#x2F;&#x2F; Error 在实践中，大多数对结构属性的访问可以安全地重叠。例如，如果上面示例中的变量holly更改为局部变量而不是全局变量，编译器可以证明对结构存储属性的重叠访问是安全的： func someFunction() { ​ var oscar &#x3D; Player(name: “Oscar”, health: 10, energy: 10) ​ balance(&amp;oscar.health, &amp;oscar.energy) &#x2F;&#x2F; OK } 在上面的示例中，奥斯卡的健康和能量作为两个内外参数来balance(_:_:)编译器可以证明内存安全得到保留，因为两个存储的属性不会以任何方式交互。 限制重叠访问结构属性并不总是必要的，以保持内存安全。内存安全是理想的保证，但独家访问是比内存安全更严格的要求——这意味着一些代码保留了内存安全，即使它违反了对内存的独家访问。如果编译器能够证明对内存的非排他性访问仍然是安全的，Swift允许此内存安全代码。具体而言，如果适用以下条件，它可以证明对结构属性的重叠访问是安全的： 您仅访问实例的存储属性，而不是计算属性或类属性。 该结构是局部变量的值，而不是全局变量。 该结构要么不被任何闭包捕获，要么仅由不转义闭包捕获。 如果编译器无法证明访问是安全的，则不允许访问。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 初始化","slug":"软件开发/技术/编程语言/swift/Swift基础-初始化","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Swift基础-初始化/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Initialization.html 初始化是准备类、结构或枚举实例以供使用的过程。此过程涉及为该实例上的每个存储属性设置初始值，并在新实例准备使用之前执行所需的任何其他设置或初始化。 您通过定义初始化器来实现此初始化过程，初始化器就像可以调用以创建特定类型的新实例的特殊方法。与Objective-C初始化器不同，Swift初始化器不会返回值。他们的主要作用是确保一种类型的新实例在首次使用之前被正确初始化。 类类型的实例还可以实现去初始化器，该初始化器在该类的实例被释放之前执行任何自定义清理。有关去初始化器的更多信息，请参阅取消初始化。 为存储的属性设置初始值类和结构必须在创建该类或结构的实例时将其所有存储属性设置为适当的初始值。存储的属性不能处于不确定状态。 您可以在初始化器中为存储的属性设置初始值，也可以分配默认属性值作为属性定义的一部分。以下各节将介绍这些操作。 注意 当您为存储属性分配默认值或在初始化器中设置其初始值时，该属性的值将直接设置，而无需调用任何属性观察器。 初始化器调用初始化器来创建特定类型的新实例。在最简单的形式中，初始化器就像一个没有参数的实例方法，使用init关键字编写： init() { ​ &#x2F;&#x2F; perform some initialization here } 以下示例定义了一种名为Fahrenheit的新结构，以存储华氏度中表达的温度。Fahrenheit结构有一个存储属性，temperature，属于Double类型： struct Fahrenheit { ​ var temperature: Double ​ init() { ​ temperature &#x3D; 32.0 ​ } } var f &#x3D; Fahrenheit() print(“The default temperature is (f.temperature)° Fahrenheit”) &#x2F;&#x2F; Prints “The default temperature is 32.0° Fahrenheit” 该结构定义了一个没有参数的单个初始化器init，该初始化值为32.0（水的冰点（华氏度））的存储温度。 默认属性值您可以从初始化器中设置存储属性的初始值，如上所示。或者，指定一个默认属性值作为属性声明的一部分。您可以在定义属性时为属性分配初始值来指定默认属性值。 注意 如果属性总是具有相同的初始值，请提供默认值，而不是在初始化器中设置值。最终结果相同，但默认值将属性的初始化与其声明更紧密地联系起来。它使初始化器更短、更清晰，并使您能够从其默认值推断属性的类型。默认值还使您更容易利用默认初始化器和初始化器继承，如本章后面所述。 You can write the Fahrenheit structure from above in a simpler form by providing a default value for its temperature property at the point that the property is declared: struct Fahrenheit { ​ var temperature &#x3D; 32.0 } 自定义初始化您可以使用输入参数和可选属性类型自定义初始化过程，也可以在初始化期间分配常量属性，如以下部分所述。 初始化参数您可以提供初始化参数作为初始化器定义的一部分，以定义自定义初始化过程的值的类型和名称。初始化参数具有与函数和方法参数相同的功能和语法。 以下示例定义了一个名为Celsius结构，该结构以摄氏度表示的温度。Celsius结构实现了两个自定义初始化器，称为init(fromFahrenheit:)和init(fromKelvin:)它们使用不同温度尺度的值初始化结构的新实例： struct Celsius { ​ var temperatureInCelsius: Double ​ init(fromFahrenheit fahrenheit: Double) { ​ temperatureInCelsius &#x3D; (fahrenheit - 32.0) &#x2F; 1.8 ​ } ​ init(fromKelvin kelvin: Double) { ​ temperatureInCelsius &#x3D; kelvin - 273.15 ​ } } let boilingPointOfWater &#x3D; Celsius(fromFahrenheit: 212.0) &#x2F;&#x2F; boilingPointOfWater.temperatureInCelsius is 100.0 let freezingPointOfWater &#x3D; Celsius(fromKelvin: 273.15) &#x2F;&#x2F; freezingPointOfWater.temperatureInCelsius is 0.0 第一个初始化器有一个初始化参数，参数标签为fromFahrenheit，参数名称为fahrenheit。第二个初始化器有一个初始化参数，参数标签为 fromKelvin，参数名称为 ofkelvin。两个初始化器都将单个参数转换为相应的摄氏度值，并将该值存储在名为temperatureInCelsius的属性中。 参数名称和参数标签与函数和方法参数一样，初始化参数既可以有一个参数名称，供初始化器正文使用，也可以有一个参数标签，供调用初始化器时使用。 然而，初始化器在括号前没有像函数和方法那样识别函数名称。因此，初始化器参数的名称和类型在确定应该调用哪个初始化器方面发挥着特别重要的作用。因此，如果您不提供初始化器中的每个参数，Swift会为自动参数标签。 以下示例定义了一个名为Color的结构，具有三个常量属性，称为red、green和blue。这些属性存储的值在0.0到1.0之间，以指示颜色中的红色、绿色和蓝色的数量。 Color为其红色、绿色和蓝色组件提供三个适当命名的Double型参数的初始化器。Color还提供了第二个带有单个white参数的初始化器，该参数用于为所有三个颜色组件提供相同的值。 struct Color { ​ let red, green, blue: Double ​ init(red: Double, green: Double, blue: Double) { ​ self.red &#x3D; red ​ self.green &#x3D; green ​ self.blue &#x3D; blue ​ } ​ init(white: Double) { ​ red &#x3D; white ​ green &#x3D; white ​ blue &#x3D; white ​ } } 两个初始化器都可用于创建新的Color实例，方法是为每个初始化器参数提供命名值： let magenta &#x3D; Color(red: 1.0, green: 0.0, blue: 1.0) let halfGray &#x3D; Color(white: 0.5) 请注意，如果不使用参数标签，就无法调用这些初始化器。如果定义了参数标签，则必须始终在初始化器中使用参数标签，省略它们是一个编译时错误： let veryGreen &#x3D; Color(0.0, 1.0, 0.0) &#x2F;&#x2F; this reports a compile-time error - argument labels are required 没有参数标签的初始化参数如果您不想为初始化参数使用参数标签，请为该参数写下划线（_）而不是显式参数标签，以覆盖默认行为。 以下是上面初始化参数中摄氏度示例的扩展版本，以及一个额外的初始化器，用于从已经在摄氏度范围内的Double值创建新的Celsius实例： struct Celsius { ​ var temperatureInCelsius: Double ​ init(fromFahrenheit fahrenheit: Double) { ​ temperatureInCelsius &#x3D; (fahrenheit - 32.0) &#x2F; 1.8 ​ } ​ init(fromKelvin kelvin: Double) { ​ temperatureInCelsius &#x3D; kelvin - 273.15 ​ } ​ init(_ celsius: Double) { ​ temperatureInCelsius &#x3D; celsius ​ } } let bodyTemperature &#x3D; Celsius(37.0) &#x2F;&#x2F; bodyTemperature.temperatureInCelsius is 37.0 The initializer call Celsius(37.0) is clear in its intent without the need for an argument label. It’s therefore appropriate to write this initializer as init(_ celsius: Double) so that it can be called by providing an unnamed Double value. 可选属性类型如果您的自定义类型有一个逻辑上允许“无值”的存储属性——可能是因为在初始化期间无法设置其值，或者因为它允许在稍后某个时候具有“无值”——请使用可选类型声明该属性。可选类型的属性会自动初始化，值为nil，这表明该属性在初始化期间故意具有“尚无值”。 以下示例定义了一个名为SurveyQuestion类，其可选String属性称为response： class SurveyQuestion { ​ var text: String ​ var response: String? ​ init(text: String) { ​ self.text &#x3D; text ​ } ​ func ask() { ​ print(text) ​ } } let cheeseQuestion &#x3D; SurveyQuestion(text: “Do you like cheese?”) cheeseQuestion.ask() &#x2F;&#x2F; Prints “Do you like cheese?” cheeseQuestion.response &#x3D; “Yes, I do like cheese.” The response to a survey question can’t be known until it’s asked, and so the responseproperty is declared with a type of String?, or “optional String”. It’s automatically assigned a default value of nil, meaning “no string yet”, when a new instance of SurveyQuestion is initialized. 在初始化期间分配常量属性您可以在初始化期间的任何时候为常量属性分配值，只要在初始化完成时将其设置为确定值。一旦一个常量属性被分配了一个值，它就无法进一步修改。 注意 对于类实例，常量属性只能由引入常量属性的类在初始化期间进行修改。它不能被子类修改。 您可以从上面修改SurveyQuestion示例，为问题的text属性使用常量属性而不是变量属性，以表明一旦创建了SurveyQuestion实例，问题不会改变。即使text属性现在是常量，它仍然可以在类的初始化器中设置： class SurveyQuestion { ​ let text: String ​ var response: String? ​ init(text: String) { ​ self.text &#x3D; text ​ } ​ func ask() { ​ print(text) ​ } } let beetsQuestion &#x3D; SurveyQuestion(text: “How about beets?”) beetsQuestion.ask() &#x2F;&#x2F; Prints “How about beets?” beetsQuestion.response &#x3D; “I also like beets. (But not with cheese.)” 默认初始化器Swift为任何为其所有属性提供默认值的结构或类提供默认初始化器，并且本身不提供至少一个初始化器。默认初始化器只需创建一个新实例，其所有属性都设置为默认值。 此示例定义了一个名为ShoppingListItem的类，该类封装了购物清单中商品的名称、数量和购买状态： class ShoppingListItem { ​ var name: String? ​ var quantity &#x3D; 1 ​ var purchased &#x3D; false } var item &#x3D; ShoppingListItem() 由于ShoppingListItem类的所有属性都有默认值，并且因为它是一个没有超类的基类，因此ShoppingListItem会自动获得默认初始化器实现，该实现创建一个新实例，其所有属性都设置为默认值。（name属性是一个可选的String属性，因此它会自动接收默认值为nil，即使该值没有写入代码中。）上面的示例使用ShoppingListItem类的默认初始化器创建具有初始化器语法的类的新实例，写为ShoppingListItem()，并将此新实例分配给名为item的变量。 结构类型的成员初始化器如果结构类型没有定义自己的任何自定义初始化器，它们会自动收到成员初始化器。与默认初始化器不同，该结构即使存储了没有默认值的属性，也会接收成员初始化器。 成员初始化器是初始化新结构实例成员属性的简写方法。新实例属性的初始值可以按名称传递给成员初始化器。 下面的示例定义了一个名为Size的结构，有两个属性称为width和height。通过分配0.0的默认值，可以推断出这两个属性都是Double类型的。 Size结构会自动接收init(width:height:)成员初始化器，您可以使用该初始化新的Size实例： struct Size { ​ var width &#x3D; 0.0, height &#x3D; 0.0 } let twoByTwo &#x3D; Size(width: 2.0, height: 2.0) 当您调用成员初始化器时，您可以省略任何具有默认值的属性的值。在上面的示例中，Size结构的height和width属性都有默认值。您可以省略任何一个属性或两个属性，初始化器对省略的任何内容都使用默认值，例如： let zeroByTwo &#x3D; Size(height: 2.0) print(zeroByTwo.width, zeroByTwo.height) &#x2F;&#x2F; Prints “0.0 2.0” let zeroByZero &#x3D; Size() print(zeroByZero.width, zeroByZero.height) &#x2F;&#x2F; Prints “0.0 0.0” 值类型的初始化委托初始化器可以调用其他初始化器来执行实例的部分初始化。这个过程被称为初始化器委托，避免了跨多个初始化器复制代码。 初始化器委托如何工作以及允许哪种形式的委托的规则对于值类型和类类型是不同的。值类型（结构和枚举）不支持继承，因此它们的初始化器委托过程相对简单，因为它们只能委托给自己提供的另一个初始化器。然而，类可以从其他类继承，如继承中所述。这意味着类有额外的责任来确保在初始化期间为其继承的所有存储属性分配合适的值。这些职责在下面的类继承和初始化中描述。 对于值类型，在编写自己的自定义初始化器时，您可以使用self.init引用来自相同值类型的其他初始化器。您只能从初始化器中调用self.init。 请注意，如果您为值类型定义自定义初始化器，您将无法再访问该类型的默认初始化器（或成员初始化器，如果是结构）。这种约束防止了使用自动初始化器之一的人意外绕过了更复杂的初始化器中提供的额外基本设置的情况。 注意 如果您希望自定义值类型可以使用默认初始化器和成员初始化器初始化，也可以使用您自己的自定义初始化器初始化，请在扩展中编写自定义初始化器，而不是作为值类型原始实现的一部分。有关更多信息，请参阅扩展。 以下示例定义了一个自定义Rect结构来表示几何矩形。该示例需要两个名为Size和Point的支持结构，这两个结构都为其所有属性提供0.0的默认值： struct Size { ​ var width &#x3D; 0.0, height &#x3D; 0.0 } struct Point { ​ var x &#x3D; 0.0, y &#x3D; 0.0 } 您可以通过以下三种方式之一初始化Rect结构——使用其默认的零初始化origin和size属性值，提供特定的原点和大小，或提供特定的中心点和大小。这些初始化选项由三个自定义初始化器表示，它们是Rect结构定义的一部分： struct Rect { ​ var origin &#x3D; Point() ​ var size &#x3D; Size() ​ init() {} ​ init(origin: Point, size: Size) { ​ self.origin &#x3D; origin ​ self.size &#x3D; size ​ } ​ init(center: Point, size: Size) { ​ let originX &#x3D; center.x - (size.width &#x2F; 2) ​ let originY &#x3D; center.y - (size.height &#x2F; 2) ​ self.init(origin: Point(x: originX, y: originY), size: size) ​ } } 第一个Rect初始化器init()在功能上与结构如果没有自己的自定义初始化器时会收到的默认初始化器相同。此初始化器有一个空正文，由一对空的花括号&#123;&#125;表示。调用此初始化器返回aRect实例，其origin和size属性都从其属性定义中初始化为Point(x:0.0,y:0.0)和Size(width:0.0,height:0.0)的默认值： let basicRect &#x3D; Rect() &#x2F;&#x2F; basicRect’s origin is (0.0, 0.0) and its size is (0.0, 0.0) 第二个Rect初始化器init(origin:size:)在功能上与结构如果没有自己的自定义初始化器时会收到的成员初始化器相同。此初始化器只需将origin和size参数值分配给适当的存储属性： let originRect &#x3D; Rect(origin: Point(x: 2.0, y: 2.0), ​ size: Size(width: 5.0, height: 5.0)) &#x2F;&#x2F; originRect’s origin is (2.0, 2.0) and its size is (5.0, 5.0) 第三个Rect初始化器init(center:size:)稍微复杂一些。它首先根据center和size值计算适当的原点。然后，它调用（或委托）init(origin:size:)初始化器，该初始化器将新的原点和大小值存储在适当的属性中： let centerRect &#x3D; Rect(center: Point(x: 4.0, y: 4.0), ​ size: Size(width: 3.0, height: 3.0)) &#x2F;&#x2F; centerRect’s origin is (2.5, 2.5) and its size is (3.0, 3.0) init(center:size:)初始化器可以将origin值和size的新值分配给适当的属性本身。然而，init(center:size:)初始化器更方便（意图更清晰），可以利用已经提供该功能的现有初始化器。 注意 有关在不定义init()和init(origin:size:)初始化器的情况下编写此示例的替代方法，请参阅扩展。 类继承和初始化类的所有存储属性，包括该类从其超类继承的任何属性，在初始化期间必须分配初始值。 Swift为类类型定义了两种初始化器，以帮助确保所有存储的属性都收到初始值。这些被称为指定的初始化器和方便初始化器。 指定初始化器和便利初始化器指定初始化器是类的主要初始化器。指定的初始化器完全初始化该类引入的所有属性，并调用适当的超类初始化器来继续超类链上的初始化过程。 类的指定初始化器往往很少，并且一个类只有一个初始化器很常见。指定的初始化器是进行初始化的“漏斗”点，初始化过程通过这些点继续超类链。 每个类必须至少有一个指定的初始化器。在某些情况下，通过从超类继承一个或多个指定初始化器来满足这一要求，如下文的自动初始化器继承所述。 方便初始化器是次要的，支持类的初始化器。您可以定义一个方便初始化器，以调用与方便初始化器同一类的指定初始化器，其中指定初始化器的一些参数设置为默认值。您还可以定义一个方便的初始化器，为特定的用例或输入值类型创建该类的实例。 如果您的班级不需要方便的初始化器，则不必提供方便的初始化器。每当通用初始化模式的快捷方式将节省时间或使类的初始化更清晰时，请创建方便的初始化器。 指定和方便初始化器的语法类的指定初始化器的编写方式与值类型的简单初始化器相同： init(parameters) { ​ statements } 方便初始化器以相同的样式编写，但convenience修饰符放在init关键字之前，由空格分隔： convenience init(parameters) { ​ statements } 类类型的初始化委托为了简化指定初始化器和方便初始化器之间的关系，Swift对初始化器之间的委托调用适用以下三项规则： 规则1 指定的初始化器必须从其直接超类调用指定的初始化器。 规则2 方便初始化器必须调用同一类的另一个初始化器。 规则3 方便初始化器最终必须调用指定的初始化器。 记住这一点的简单方法是： 指定的初始化器必须始终委托。 方便初始化器必须始终委托。 这些规则如下图所示： 在这里，超类有一个指定的初始化器和两个方便初始化器。一个方便初始化器调用另一个方便初始化器，而方便初始化器又调用单个指定的初始化器。这符合上面的规则2和3。超级班本身没有进一步的超级班级，因此规则1不适用。 本图中的子类有两个指定的初始化器和一个方便初始化器。方便初始化器必须调用两个指定初始化器中的一个，因为它只能调用同一类的另一个初始化器。这符合上面的规则2和3。两个指定的初始化器都必须从超类调用单个指定初始化器，以满足上面的规则1。 注意 这些规则不会影响类用户如何创建每个类的实例。上图中的任何初始化器都可用于创建它们所属类的完全初始化实例。这些规则只会影响您编写类初始化器实现的方式。 下图显示了四个类的更复杂的类层次结构。它说明了此层次结构中的指定初始化器如何充当类初始化的“漏斗”点，简化了链中类之间的相互关系： 两阶段初始化Swift 中的类初始化是一个两阶段的过程。在第一阶段，引入它的类为每个存储的属性分配一个初始值。一旦确定了每个存储属性的初始状态，第二阶段就开始了，每个类都有机会在新实例被认为可供使用之前进一步自定义其存储属性。 使用两阶段初始化过程使初始化安全，同时仍然为类层次结构中的每个类提供完全的灵活性。两阶段初始化可以防止属性值在初始化之前被访问，并防止属性值意外地被另一个初始化器设置为不同的值。 注意 Swift的两阶段初始化过程类似于Objective-C中的初始化。主要区别在于，在第1阶段，Objective-C为每个属性分配零或零值（如0或nil）。Swift的初始化流程更加灵活，因为它允许您设置自定义初始值，并可以处理0或nil不是有效默认值的类型。 Swift的编译器执行了四项有用的安全检查，以确保两阶段初始化没有错误地完成： 安全检查1 指定的初始化器必须确保其类引入的所有属性在委托给超类初始化器之前都已初始化。 如上所述，只有当对象所有存储属性的初始状态已知时，对象的内存才会被视为完全初始化。为了满足此规则，指定的初始化器必须确保其所有自己的属性在启动链条之前都已初始化。 安全检查2 在将值分配给继承的属性之前，指定的初始化器必须委托给超类初始化器。如果没有，指定初始化器分配的新值将被超类覆盖，作为其自身初始化的一部分。 安全检查3 在为任何属性（包括同一类定义的属性）分配值之前，方便初始化器必须委托给另一个初始化器。如果没有，便利初始化器分配的新值将被其自身类的指定初始化器覆盖。 安全检查4 在初始化的第一阶段完成之前，初始化器无法调用任何实例方法，读取任何实例属性的值，或将self称为值。 在第一阶段结束之前，类实例不会完全有效。只有在已知类实例在第一阶段结束时有效时，才能访问属性，并且只能调用方法。 根据上述四项安全检查，以下是两阶段初始化是如何运作的： 第一阶段 类调用指定或方便的初始化器。 为该类的新实例分配内存。内存尚未初始化。 该类的指定初始化器确认该类引入的所有存储属性都有一个值。这些存储属性的内存现已初始化。 指定的初始化器交给超类初始化器，以为自己的存储属性执行相同的任务。 这继续沿着类继承链，直到到达链的顶部。 一旦到达链的顶部，并且链中的最后一个类确保其所有存储属性都有一个值，实例的内存将被视为完全初始化，阶段1完成。 第二阶段 从链的顶部向下工作，链中的每个指定的初始化器都可以选择进一步自定义实例。初始化器现在可以访问self，并可以修改其属性，调用其实例方法等。 最后，链中的任何方便初始化器都可以选择自定义实例并使用self。 以下是第1阶段如何查找假设子类和超类的初始化调用： 在本例中，初始化以调用子类上的方便初始化器开始。此方便初始化器尚无法修改任何属性。它委托给来自同一类的指定初始化器。 根据安全检查1，指定的初始化器确保子类的所有属性都有一个值。然后，它在其超类上调用指定的初始化器，以继续沿着链进行初始化。 超类的指定初始化器确保所有超类属性都有一个值。没有更多的超级类需要初始化，因此不需要进一步的授权。 一旦超类的所有属性都具有初始值，其内存就会被视为完全初始化，第1阶段就完成了。 以下是第2阶段对相同初始化调用的查找方式： 超类的指定初始化器现在有机会进一步自定义实例（尽管它不必这样做）。 一旦超类的指定初始化器完成，子类的指定初始化器可以执行额外的自定义（尽管同样，它不必这样做）。 最后，一旦子类的指定初始化器完成，最初调用的方便初始化器可以执行额外的自定义。 初始化器继承和重写与Objective-C中的子类不同，Swift子类默认不会继承其超类初始化器。Swift的方法防止了超类的简单初始化器被更专业的子类继承，并用于创建未完全或正确初始化的子类的新实例。 注意 在某些情况下，超类初始化器是继承的，但只有在安全且合适的情况下才会继承。有关更多信息，请参阅下面的自动初始化器继承。 如果您希望自定义子类显示与其超类相同的一个或多个初始化器，您可以在子类中提供这些初始化器的自定义实现。 当您编写与超类指定初始化器匹配的子类初始化器时，您实际上是在提供该指定初始化器的重写。因此，您必须在子类的初始化器定义之前编写override修饰符。即使您重写自动提供的默认初始化器，也是如此，如默认初始化器所述。 与重写属性、方法或下标一样，override修饰符的存在会提示Swift检查超类是否有匹配的指定初始化器要重写，并验证重写初始化器的参数是否已按预期指定。 注意 在覆盖超类指定初始化器时，您总是写入override修饰符，即使子类对初始化器的实现是一个方便的初始化器。 相反，如果您编写与超类便利初始化器匹配的子类初始化器，则根据上面类类型初始化器委托中描述的规则，您的子类永远不能直接调用该超类方便初始化器。因此，您的子类（严格来说）不提供超类初始化器的重写。因此，在提供超类方便初始化器的匹配实现时，您不会编写override修饰符。 下面的示例定义了一个名为Vehicle的基类。该基类声明一个名为numberOfWheels的存储属性，默认Int值为0。numberOfWheels属性由称为description的计算属性用于创建车辆特征的String描述： class Vehicle { ​ var numberOfWheels &#x3D; 0 ​ var description: String { ​ return “(numberOfWheels) wheel(s)” ​ } } Vehicle类为其唯一存储的属性提供默认值，并且本身不提供任何自定义初始化器。因此，它会自动接收默认初始化器，如默认初始化器中所述。默认初始化器（如果可用）始终是类的指定初始化器，可用于创建一个新的Vehicle实例，其anumberOfWheels为0： let vehicle &#x3D; Vehicle() print(“Vehicle: (vehicle.description)”) &#x2F;&#x2F; Vehicle: 0 wheel(s) 下一个示例定义了一个名为Bicycle的Vehicle子类： class Bicycle: Vehicle { ​ override init() { ​ super.init() ​ numberOfWheels &#x3D; 2 ​ } } Bicycle子类定义了一个自定义指定的初始化器init()。此指定初始化器与Bicycle超类的指定初始化器匹配，因此此初始化器的Bicycle版本用override修饰符标记。 The init() initializer for Bicycle starts by calling super.init(), which calls the default initializer for the Bicycle class’s superclass, Vehicle. This ensures that the numberOfWheelsinherited property is initialized by Vehicle before Bicycle has the opportunity to modify the property. After calling super.init(), the original value of numberOfWheels is replaced with a new value of 2. 如果您创建Bicycle实例，您可以调用其继承的description计算属性，以查看其numberOfWheels属性是如何更新的： let bicycle &#x3D; Bicycle() print(“Bicycle: (bicycle.description)”) &#x2F;&#x2F; Bicycle: 2 wheel(s) 如果子类初始化器在初始化过程的第2阶段不执行自定义，并且超类具有零参数指定初始化器，则在为子类的所有存储属性分配值后，您可以省略对super.init()的调用。 此示例定义了Vehicle的另一个子类，称为Hoverboard。在其初始化器中，Hoverboard类仅设置其color属性。此初始化器不是显式调用super.init()，而是依赖对其超类初始化器的隐式调用来完成该过程。 class Hoverboard: Vehicle { ​ var color: String ​ init(color: String) { ​ self.color &#x3D; color ​ &#x2F;&#x2F; super.init() implicitly called here ​ } ​ override var description: String { ​ return “(super.description) in a beautiful (color)” ​ } } Hoverboard实例使用Vehicle初始化器提供的默认车轮数量。 let hoverboard &#x3D; Hoverboard(color: “silver”) print(“Hoverboard: (hoverboard.description)”) &#x2F;&#x2F; Hoverboard: 0 wheel(s) in a beautiful silver 注意 子类可以在初始化期间修改继承的变量属性，但不能修改继承的常量属性。 自动初始化器继承如上所述，默认情况下，子类不会继承其超类初始化器。然而，如果满足某些条件，超类初始化器会自动继承。在实践中，这意味着您不需要在许多常见情况下编写初始化器重写，只要安全，就可以毫不费力地继承超类初始化器。 假设您为在子类中引入的任何新属性提供默认值，则适用以下两条规则： 规则1 如果您的子类没有定义任何指定的初始化器，它会自动继承其所有超类指定初始化器。 规则2 如果您的子类提供其所有超类指定初始化器的实现——要么根据规则1继承它们，要么提供自定义实现作为其定义的一部分——那么它会自动继承所有超类方便初始化器。 即使您的子类添加了进一步的便利初始化器，这些规则也适用。 注意 作为满足规则2的一部分，子类可以实现超类指定的初始化器作为子类方便初始化器。 指定和方便的初始化器在操作中以下示例显示了指定的初始化器、方便初始化器和自动初始化器继承。此示例定义了三个类的层次结构，称为Food、RecipeIngredient和ShoppingListItem，并演示了它们的初始化器如何交互。 层次结构中的基类称为Food，这是一个封装食品名称的简单类。Food类引入了一个名为name``String属性，并为创建Food实例提供了两个初始化器： class Food { ​ var name: String ​ init(name: String) { ​ self.name &#x3D; name ​ } ​ convenience init() { ​ self.init(name: “[Unnamed]”) ​ } } 下图显示了Food类的初始化链： 类没有默认的按成员初始化器，因此Food类提供了一个指定的初始化器，该初始化器接受一个名为name参数。此初始化器可用于创建具有特定名称的新Food实例： let namedMeat &#x3D; Food(name: “Bacon”) &#x2F;&#x2F; namedMeat’s name is “Bacon” Food类的init(name:String)初始化器作为指定的初始化器提供，因为它确保新Food实例的所有存储属性都完全初始化。Food类没有超类，因此init(name:String)初始化器不需要调用super.init()即可完成其初始化。 Food类还提供了一个方便的初始化器init()，没有参数。Theinitinit()初始化器通过将name值为[Unnamed]的Food类的init(name:String)委托来为新食物提供默认占位符名称： let mysteryMeat &#x3D; Food() &#x2F;&#x2F; mysteryMeat’s name is “[Unnamed]” 层次结构中的第二类是Food的一个子类，称为RecipeIngredient。RecipeIngredient在烹饪食谱中建模成分。它引入了一个名为quantity``Int属性（除了它从Food继承的name属性外），并定义了用于创建RecipeIngredient实例的两个初始化器： class RecipeIngredient: Food { ​ var quantity: Int ​ init(name: String, quantity: Int) { ​ self.quantity &#x3D; quantity ​ super.init(name: name) ​ } ​ override convenience init(name: String) { ​ self.init(name: name, quantity: 1) ​ } } The figure below shows the initializer chain for the RecipeIngredient class: RecipeIngredient类有一个指定的初始化器init(name:String,quantity:Int)可用于填充新RecipeIngredient实例的所有属性。此初始化器首先将传递的quantity参数分配给quantity属性，这是RecipeIngredient引入的唯一新属性。完成后，初始化器将委托给Food类的init(name:String)初始化器。此过程满足上述两阶段初始化的安全检查1。 RecipeIngredient还定义了一个方便初始化器init(name:String)它仅用于按名称创建RecipeIngredient实例。对于没有显式数量创建的任何RecipeIngredient实例，此方便初始化器假设数量为1。此方便初始化器的定义使RecipeIngredient实例创建更快、更方便，并在创建多个单量RecipeIngredient实例时避免代码复制。此方便初始化器只需将数量值委托给类的指定初始化器，传递quantity为1。 RecipeIngredient提供的init(name:String)方便初始化器采用与Food中指定的init(name:String)指定初始化器相同的参数。由于此方便初始化器从其超类中覆盖指定的初始化器，因此必须用override修饰符标记（如初始化器继承和重写中所述）。 尽管RecipeIngredient提供了init(name:String)初始化器作为方便的初始化器，但RecipeIngredient仍然提供了其所有超类指定初始化器的实现。因此，RecipeIngredient也会自动继承其所有超类的便利初始化器。 在本例中，RecipeIngredient的超类是Food，它只有一个名为init()方便初始化器。因此，此初始化器由RecipeIngredient继承。init()的继承版本的功能与Food版本完全相同，只是它委托给init(name:String)的RecipeIngredient版本，而不是Food版本。 All three of these initializers can be used to create new RecipeIngredient instances: let oneMysteryItem &#x3D; RecipeIngredient() let oneBacon &#x3D; RecipeIngredient(name: “Bacon”) let sixEggs &#x3D; RecipeIngredient(name: “Eggs”, quantity: 6) The third and final class in the hierarchy is a subclass of RecipeIngredient called ShoppingListItem. The ShoppingListItem class models a recipe ingredient as it appears in a shopping list. 购物清单中的每件商品都以“未购买”开头。为了表示这一事实，ShoppingListItem引入了一个名为purchased布尔属性，默认值为关闭。ShoppingListItem还添加了一个计算description属性，该属性提供了ShoppingListItem实例的文本描述： class ShoppingListItem: RecipeIngredient { ​ var purchased &#x3D; false ​ var description: String { ​ var output &#x3D; “(quantity) x (name)” ​ output +&#x3D; purchased ? “ ✔” : “ ✘” ​ return output ​ } } 注意 ShoppingListItem没有定义初始化器来为purchased提供初始值，因为购物清单中的商品（如此处建模）总是从未购买开始。 由于它为其引入的所有属性提供了默认值，并且本身不定义任何初始化器，因此ShoppingListItem会自动从其超类继承所有指定和方便的初始化器。 下图显示了所有三个类别的整体初始化链： 您可以使用所有三个继承的初始化器来创建新的ShoppingListItem实例： var breakfastList &#x3D; [ ​ ShoppingListItem(), ​ ShoppingListItem(name: “Bacon”), ​ ShoppingListItem(name: “Eggs”, quantity: 6), ] breakfastList[0].name &#x3D; “Orange juice” breakfastList[0].purchased &#x3D; true for item in breakfastList { ​ print(item.description) } &#x2F;&#x2F; 1 x Orange juice ✔ &#x2F;&#x2F; 1 x Bacon ✘ &#x2F;&#x2F; 6 x Eggs ✘ 在这里，一个名为breakfastList的新数组是从包含三个新ShoppingListItem实例的数组文字创建的。数组的类型推断为[ShoppingListItem]数组创建后，数组开头的ShoppingListItem名称从&quot;[Unnamed]&quot;更改为&quot;Orangejuice&quot;并标记为已购买。打印数组中每个项目的描述会显示它们的默认状态已按预期设置。 失败的初始化器定义初始化可能失败的类、结构或枚举有时是有用的。此故障可能由无效的初始化参数值、缺乏所需的外部资源或阻止初始化成功的其他条件触发。 要应对可能失败的初始化条件，请将一个或多个故障初始化器定义为类、结构或枚举定义的一部分。您可以通过在init关键字（init?）后放置问号来编写一个失败的初始化器。 注意 您无法使用相同的参数类型和名称定义故障和非故障初始化器。 故障初始化器会创建其初始化类型的可选值。您可以在可故障初始化器中写入returnnil，以指示可以触发初始化失败的点。 注意 严格来说，初始化器不会返回值。相反，他们的作用是确保在初始化结束时完全正确地初始化self。虽然您写returnnil以触发初始化失败，但您不会使用return关键字来指示初始化成功。 例如，为数字类型转换实现了故障初始化器。为了确保数字类型之间的转换准确保持该值，请使用init(exactly:)初始化器。如果类型转换无法维护该值，初始化器将失败。 let wholeNumber: Double &#x3D; 12345.0 let pi &#x3D; 3.14159 if let valueMaintained &#x3D; Int(exactly: wholeNumber) { ​ print(“(wholeNumber) conversion to Int maintains value of (valueMaintained)”) } &#x2F;&#x2F; Prints “12345.0 conversion to Int maintains value of 12345” let valueChanged &#x3D; Int(exactly: pi) &#x2F;&#x2F; valueChanged is of type Int?, not Int if valueChanged &#x3D;&#x3D; nil { ​ print(“(pi) conversion to Int doesn’t maintain value”) } &#x2F;&#x2F; Prints “3.14159 conversion to Int doesn’t maintain value” 以下示例定义了一个名为Animal的结构，其常量String属性称为species。Animal结构还定义了一个具有称为species的单个参数的故障初始化器。此初始化器检查传递给初始化器的species值是否为空字符串。如果找到空字符串，则触发初始化失败。否则，将设置species属性的值，初始化成功： struct Animal { ​ let species: String ​ init?(species: String) { ​ if species.isEmpty { return nil } ​ self.species &#x3D; species ​ } } 您可以使用此故障初始化器尝试初始化新的Animal实例，并检查初始化是否成功： let someCreature &#x3D; Animal(species: “Giraffe”) &#x2F;&#x2F; someCreature is of type Animal?, not Animal if let giraffe &#x3D; someCreature { ​ print(“An animal was initialized with a species of (giraffe.species)”) } &#x2F;&#x2F; Prints “An animal was initialized with a species of Giraffe” 如果您将空字符串值传递给可故障初始化器的species参数，初始化器将触发初始化失败： let anonymousCreature &#x3D; Animal(species: “”) &#x2F;&#x2F; anonymousCreature is of type Animal?, not Animal if anonymousCreature &#x3D;&#x3D; nil { ​ print(“The anonymous creature couldn’t be initialized”) } &#x2F;&#x2F; Prints “The anonymous creature couldn’t be initialized” 注意 检查空字符串值（如&quot;&quot;而不是&quot;Giraffe&quot;与检查nil以指示没有可选String值不同。在上面的示例中，空字符串（“”）是一个有效的、非可选的String。然而，动物用空字符串作为其species属性的值是不合适的。要模拟此限制，如果找到空字符串，则故障初始化器将触发初始化失败。 枚举的失败初始化器您可以使用故障初始化器根据一个或多个参数选择适当的枚举情况。如果提供的参数与适当的枚举情况不匹配，初始化器可能会失败。 以下示例定义了一个名为TemperatureUnit枚举，具有三种可能的状态（kelvin、摄氏度和fahrenheit）。故障初始化器用于为表示温度符号的Character值找到适当的枚举情况： enum TemperatureUnit { ​ case kelvin, celsius, fahrenheit ​ init?(symbol: Character) { ​ switch symbol { ​ case “K”: ​ self &#x3D; .kelvin ​ case “C”: ​ self &#x3D; .celsius ​ case “F”: ​ self &#x3D; .fahrenheit ​ default: ​ return nil ​ } ​ } } 您可以使用此故障初始化器为三种可能的状态选择适当的枚举情况，如果参数与以下状态之一不匹配，则导致初始化失败： let fahrenheitUnit &#x3D; TemperatureUnit(symbol: “F”) if fahrenheitUnit !&#x3D; nil { ​ print(“This is a defined temperature unit, so initialization succeeded.”) } &#x2F;&#x2F; Prints “This is a defined temperature unit, so initialization succeeded.” let unknownUnit &#x3D; TemperatureUnit(symbol: “X”) if unknownUnit &#x3D;&#x3D; nil { ​ print(“This isn’t a defined temperature unit, so initialization failed.”) } &#x2F;&#x2F; Prints “This isn’t a defined temperature unit, so initialization failed.” 具有原始值的枚举的失败初始化器具有原始值的枚举会自动收到一个失败的初始化器，init?(rawValue:)它接受一个名为rawValue的适当原始值类型的参数，如果找到匹配枚举情况，则选择匹配枚举情况，如果没有匹配值，则触发初始化失败。 You can rewrite the TemperatureUnit example from above to use raw values of type Character and to take advantage of the init?(rawValue:) initializer: enum TemperatureUnit: Character { ​ case kelvin &#x3D; “K”, celsius &#x3D; “C”, fahrenheit &#x3D; “F” } let fahrenheitUnit &#x3D; TemperatureUnit(rawValue: “F”) if fahrenheitUnit !&#x3D; nil { ​ print(“This is a defined temperature unit, so initialization succeeded.”) } &#x2F;&#x2F; Prints “This is a defined temperature unit, so initialization succeeded.” let unknownUnit &#x3D; TemperatureUnit(rawValue: “X”) if unknownUnit &#x3D;&#x3D; nil { ​ print(“This isn’t a defined temperature unit, so initialization failed.”) } &#x2F;&#x2F; Prints “This isn’t a defined temperature unit, so initialization failed.” 初始化失败的传播类、结构或枚举的故障初始化器可以委托给来自同一类、结构或枚举的另一个故障初始化器。同样，子类故障初始化器最多可以委托给超类故障初始化器。 无论哪种情况，如果您委托给另一个导致初始化失败的初始化器，整个初始化过程都会立即失败，并且不会执行进一步的初始化代码。 注意 故障初始化器也可以委托给不可失败的初始化器。如果您需要将潜在的失败状态添加到现有初始化进程中，否则不会失败，请使用此方法。 下面的示例定义了一个名为CartItem``Product子类。CartItem类为在线购物车中的商品建模。CartItem引入了一个名为quantity的存储常量属性，并确保该属性始终具有至少1的值： class Product { ​ let name: String ​ init?(name: String) { ​ if name.isEmpty { return nil } ​ self.name &#x3D; name ​ } } class CartItem: Product { ​ let quantity: Int ​ init?(name: String, quantity: Int) { ​ if quantity &lt; 1 { return nil } ​ self.quantity &#x3D; quantity ​ super.init(name: name) ​ } } CartItem的故障初始化器首先验证它是否收到了1或更多quantity。如果quantity无效，整个初始化过程将立即失败，并且不会执行进一步的初始化代码。同样，Product故障初始化器会检查name值，如果name是空字符串，初始化过程将立即失败。 如果您创建具有非空名称且数量为1或更多内容的CartItem实例，初始化将成功： if let twoSocks &#x3D; CartItem(name: “sock”, quantity: 2) { ​ print(“Item: (twoSocks.name), quantity: (twoSocks.quantity)”) } &#x2F;&#x2F; Prints “Item: sock, quantity: 2” 如果您尝试创建quantity为0的CartItem实例，CartItem初始化程序会导致初始化失败： if let zeroShirts &#x3D; CartItem(name: “shirt”, quantity: 0) { ​ print(“Item: (zeroShirts.name), quantity: (zeroShirts.quantity)”) } else { ​ print(“Unable to initialize zero shirts”) } &#x2F;&#x2F; Prints “Unable to initialize zero shirts” 同样，如果您尝试创建name值为空的CartItem实例，超类Product初始化器会导致初始化失败： if let oneUnnamed &#x3D; CartItem(name: “”, quantity: 1) { ​ print(“Item: (oneUnnamed.name), quantity: (oneUnnamed.quantity)”) } else { ​ print(“Unable to initialize one unnamed product”) } &#x2F;&#x2F; Prints “Unable to initialize one unnamed product” 覆盖失败的初始化器您可以像任何其他初始化器一样，在子类中覆盖超类故障初始化器。或者，您可以使用子类不可失败初始化器覆盖超类故障初始化器。这使您能够定义初始化不能失败的子类，即使允许超类的初始化失败。 请注意，如果您使用不可失败的子类初始化器覆盖故障的超类初始化器，则委托给超类初始化器的唯一方法是强制解压可故障超类初始化器的结果。 注意 您可以使用不可失败的初始化器覆盖故障初始化器，但不能反过来。 下面的示例定义了一个名为Document的类。该类建模文档，该文档可以使用非空字符串值或nil的name属性初始化，但不能是空字符串： class Document { ​ var name: String? ​ &#x2F;&#x2F; this initializer creates a document with a nil name value ​ init() {} ​ &#x2F;&#x2F; this initializer creates a document with a nonempty name value ​ init?(name: String) { ​ if name.isEmpty { return nil } ​ self.name &#x3D; name ​ } } 下一个示例定义了一个名为AutomaticallyNamedDocument的Document子类。AutomaticallyNamedDocument子类覆盖了Document引入的两个指定初始化器。如果实例在没有名称的情况下初始化，或者将空字符串传递给init(name:)初始化器，则这些重写确保AutomaticallyNamedDocument实例的初始name值为&quot;[Untitled]&quot;： class AutomaticallyNamedDocument: Document { ​ override init() { ​ super.init() ​ self.name &#x3D; “[Untitled]” ​ } ​ override init(name: String) { ​ super.init() ​ if name.isEmpty { ​ self.name &#x3D; “[Untitled]” ​ } else { ​ self.name &#x3D; name ​ } ​ } } The AutomaticallyNamedDocument overrides its superclass’s failable init?(name:)initializer with a nonfailable init(name:) initializer. Because AutomaticallyNamedDocumentcopes with the empty string case in a different way than its superclass, its initializer doesn’t need to fail, and so it provides a nonfailable version of the initializer instead. 您可以使用初始化器中的强制展开从超类调用故障初始化器，作为子类不可失败初始化器实现的一部分。例如，下面的UntitledDocument子类总是命名为&quot;[Untitled]&quot;并在初始化期间使用其超类的failableinitinit(name:)初始化器。 class UntitledDocument: Document { ​ override init() { ​ super.init(name: “[Untitled]”)! ​ } } 在这种情况下，如果以空字符串为名称调用超类的init(name:)初始化器，强制展开操作将导致运行时错误。但是，由于它是用字符串常量调用的，因此您可以看到初始化器不会失败，因此在这种情况下不会发生运行时错误。 it！初始化器失败您通常定义一个失败的初始化器，通过init关键字（init?）后面放置问号来创建适当类型的可选实例。或者，您可以定义一个可故障的初始化器，该初始化器可以创建适当类型的隐式未包装的可选实例。通过init关键字（init!）后面放置感叹号来做到这一点而不是问号。 You can delegate from init? to init! and vice versa, and you can override init? with init! and vice versa. You can also delegate from init to init!, although doing so will trigger an assertion if the init! initializer causes initialization to fail. 必需的初始化器在定义类初始化器之前写入required修饰符，以指示类中的每个子类都必须实现该初始化器： class SomeClass { ​ required init() { ​ &#x2F;&#x2F; initializer implementation goes here ​ } } 您还必须在每个必需初始化器子类实现之前编写required修饰符，以表明初始化器要求适用于链中的进一步子类。在覆盖所需的指定初始化器时，您不会编写override修饰符： class SomeSubclass: SomeClass { ​ required init() { ​ &#x2F;&#x2F; subclass implementation of the required initializer goes here ​ } } 注意 如果您能够用继承的初始化器满足要求，则不必提供所需初始化器的显式实现。 使用闭包或函数设置默认属性值如果存储属性的默认值需要一些自定义或设置，您可以使用闭包或全局函数为该属性提供自定义默认值。每当初始化属性所属类型的新实例时，都会调用闭包或函数，并将其返回值分配为属性的默认值。 这些类型的闭包或函数通常会创建一个与属性类型相同的临时值，定制该值以表示所需的初始状态，然后返回该临时值作为属性的默认值。 以下是如何使用闭包来提供默认属性值的骨架大纲： class SomeClass { ​ let someProperty: SomeType &#x3D; { ​ &#x2F;&#x2F; create a default value for someProperty inside this closure ​ &#x2F;&#x2F; someValue must be of the same type as SomeType ​ return someValue ​ }() } 请注意，闭合的末端花括号后面是一对空括号。这告诉Swift立即执行关闭。如果您省略这些括号，您将尝试将闭包本身分配给属性，而不是闭包的返回值。 注意 如果您使用闭包初始化属性，请记住，在执行闭包时，实例的其余部分尚未初始化。这意味着您无法从闭包中访问任何其他属性值，即使这些属性具有默认值。您也不能使用隐式self属性，也不能调用实例的任何方法。 下面的示例定义了一个名为Chessboard结构，该结构为国际象棋游戏建模。国际象棋在8 x 8棋盘上进行，黑白方块交替进行。 为了表示这个游戏板，Chessboard结构有一个名为boardColors单一属性，这是一个由64个Bool值组成的数组。数组中的true值表示黑色正方形，false值表示白色正方形。数组中的第一个项目表示板上的左上角正方形，数组中的最后一个项表示板上的右下角正方形。 boardColors数组使用闭包初始化，以设置其颜色值： struct Chessboard { ​ let boardColors: [Bool] &#x3D; { ​ var temporaryBoard: [Bool] &#x3D; [] ​ var isBlack &#x3D; false ​ for i in 1…8 { ​ for j in 1…8 { ​ temporaryBoard.append(isBlack) ​ isBlack &#x3D; !isBlack ​ } ​ isBlack &#x3D; !isBlack ​ } ​ return temporaryBoard ​ }() ​ func squareIsBlackAt(row: Int, column: Int) -&gt; Bool { ​ return boardColors[(row * 8) + column] ​ } } 每当创建新的Chessboard实例时，都会执行闭包，并计算并返回boardColors默认值。上面示例中的闭包计算并设置名为temporaryBoard板上的每个正方形的适当颜色，并在设置完成后将该临时数组作为闭包的返回值。返回的数组值存储在boardColors，可以使用squareIsBlackAt(row:column:)实用程序函数查询： let board &#x3D; Chessboard() print(board.squareIsBlackAt(row: 0, column: 1)) &#x2F;&#x2F; Prints “true” print(board.squareIsBlackAt(row: 7, column: 7)) &#x2F;&#x2F; Prints “false”","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 功能(Functions)","slug":"软件开发/技术/编程语言/swift/Swift基础-功能","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/07/Swift基础-功能/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%8A%9F%E8%83%BD/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Functions.html 函数是执行特定任务的自包含的代码块。您给函数一个名称来标识它的作用，该名称用于在需要时“调用”该函数以执行其任务。 Swift的统一函数语法足够灵活，可以表达任何东西，从没有参数名称的简单C型函数到带有每个参数名称和参数标签的复杂Objective-C风格方法。参数可以提供默认值来简化函数调用，并且可以作为输入输出参数传递，这些参数在函数完成执行后修改传递的变量。 Swift中的每个函数都有一个类型，由函数的参数类型和返回类型组成。您可以像 Swift 中的任何其他类型一样使用此类型，这样可以轻松地将函数作为参数传递给其他函数，并从函数返回函数。函数也可以写入其他函数，以封装嵌套函数范围内的有用功能。 定义和调用函数当您定义函数时，您可以选择定义函数作为输入的一个或多个命名类型值，称为参数。您还可以选择定义一种值类型，该函数将在完成后作为输出传递回，称为其返回类型。 每个函数都有一个函数名，该函数名描述了函数执行的任务。要使用函数，您可以“调用”该函数及其名称，并将其传递与函数参数类型匹配的输入值（称为参数）。函数的参数必须始终以与函数参数列表相同的顺序提供。 以下示例中的函数称为greet(person:)因为它就是这样做的——它以一个人的名字作为输入，并为该人返回问候语。要做到这一点，您定义了一个输入参数——一个名为person的String值——和一个返回类型的String，其中将包含对该人的问候语： 1234func greet(person: String) -&gt; String &#123; let greeting = &quot;Hello, &quot; + person + &quot;!&quot; return greeting&#125; 所有这些信息都汇总到函数的定义中，该定义前缀为func关键字。您可以使用返回箭头-&gt;（连字符后跟直角括号）指示函数的返回类型，后跟要返回的类型名称。 定义描述了函数做什么，它希望收到什么，以及它完成后会返回什么。该定义可以轻松地从代码中的其他地方明确调用该函数： 1234print(greet(person: &quot;Anna&quot;))// Prints &quot;Hello, Anna!&quot;print(greet(person: &quot;Brian&quot;))// Prints &quot;Hello, Brian!&quot; 调用’ greet(person:) ‘函数的方法是在’ person ‘参数标签后给它传递一个’ String ‘值，例如’ greet(person: “Anna”) ‘。因为函数返回’ String ‘值，所以可以调用’ print(_:separator:terminator:) ‘函数来包装’ greet(person:) ‘，以打印该字符串并查看其返回值，如上所示。 注意 print(_:separator:terminator:)函数没有第一个参数的标签，其其他参数是可选的，因为它们具有默认值。下文在函数参数标签和参数名称以及默认参数值中讨论了函数语法的这些变化。 greet(person:)函数的正文从定义一个名为greeting的新String常量并将其设置为简单的问候消息开始。然后，使用return关键字将此问候语传回函数。在显示returngreeting的代码行中，该函数完成其执行并返回greeting的当前值。 您可以多次调用greet(person:)函数，输入值不同。上面的示例显示了如果使用&quot;Anna&quot;的输入值和&quot;Brian&quot;的输入值调用会发生什么。该功能在每种情况下都会返回量身定制的问候语。 为了缩短此函数的主体，您可以将消息创建和返回语句合并为一行： 12345func greetAgain(person: String) -&gt; String &#123; return &quot;Hello again, &quot; + person + &quot;!&quot;&#125;print(greetAgain(person: &quot;Anna&quot;))// Prints &quot;Hello again, Anna!&quot; 函数参数和返回值在Swift中，函数参数和返回值非常灵活。您可以定义任何东西，从具有单个未命名参数的简单实用程序函数到具有表达式参数名称和不同参数选项的复杂函数。 没有参数的函数定义输入参数不需要函数。这里有一个没有输入参数的函数，每当调用时，它总是返回相同的String消息： 12345func sayHelloWorld() -&gt; String &#123; return &quot;hello, world&quot;&#125;print(sayHelloWorld())// Prints &quot;hello, world&quot; 函数定义仍然需要在函数名称后面加上括号，即使它不接受任何参数。调用函数时，函数名后面还有一对空括号。 具有多个参数的函数函数可以有多个输入参数，这些参数写在函数的括号中，用逗号分隔。 此功能使用一个人的名字以及他们是否已经被问候作为输入，并为该人返回适当的问候语： 123456789func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return greetAgain(person: person) &#125; else &#123; return greet(person: person) &#125;&#125;print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))// Prints &quot;Hello again, Tim!&quot; 您通过将标记为person的String参数值和在括号中标记为greedGreeted的Bool参数值，用逗号分隔，来调用 greet(person:alreadyGreeted:)函数。请注意，此函数与前面一节中显示的greet(person:)函数不同。虽然这两个函数都有以greet开头的名字，但greet(person:alreadyGreeted:)函数需要两个参数，但greet(person:)函数只需要一个参数。 没有返回值的函数定义返回类型不需要函数。以下是greet(person:)函数的版本，该函数打印自己的String值，而不是返回它： 12345func greet(person: String) &#123; print(&quot;Hello, \\(person)!&quot;)&#125;greet(person: &quot;Dave&quot;)// Prints &quot;Hello, Dave!&quot; 由于它不需要返回值，函数的定义不包括返回箭头（-&gt;）或返回类型。 注意 严格来说，这个版本的greet(person:)函数仍然返回一个值，即使没有定义返回值。没有定义返回类型的函数返回类型为Void的特殊值。这只是一个空元组，写为() 调用函数时，可以忽略其返回值： 1234567891011func printAndCount(string: String) -&gt; Int &#123; print(string) return string.count&#125;func printWithoutCounting(string: String) &#123; let _ = printAndCount(string: string)&#125;printAndCount(string: &quot;hello, world&quot;)// prints &quot;hello, world&quot; and returns a value of 12printWithoutCounting(string: &quot;hello, world&quot;)// prints &quot;hello, world&quot; but doesn&#x27;t return a value 第一个函数printAndCount(string:)打印字符串，然后将其字符计数返回为Int。第二个函数printWithoutCounting(string:)调用第一个函数，但忽略了其返回值。当调用第二个函数时，消息仍然由第一个函数打印，但返回的值不使用。 注意 返回值可以忽略，但表示将返回值的函数必须始终这样做。具有定义返回类型的函数不允许控件在不返回值的情况下从函数底部掉出来，尝试这样做将导致编译时错误。 具有多个返回值的函数您可以使用元组类型作为函数返回多个值作为复合返回值的一部分的返回类型。 下面的示例定义了一个名为minMax(array:)的函数，该函数在Int值数组中找到最小和最大的数字： 123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; minMax(array:)函数返回一个包含两个Int值的元组。这些值被标记为min和max，以便在查询函数的返回值时按名称访问。 minMax(array:)函数的主体首先将两个名为currentMin和currentMax的工作变量设置为数组中第一个整数的值。然后，该函数迭代数组中的剩余值，并检查每个值，看看它分别小于或大于currentMin和currentMax的值。最后，总体最小值和最大值作为两个Int值的元组返回。 由于元组的成员值被命名为函数返回类型的一部分，因此可以使用点语法访问它们，以检索找到的最小值和最大值： 123let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;)// Prints &quot;min is -6 and max is 109&quot; 请注意，元组的成员不需要在从函数返回元组时命名，因为它们的名称已被指定为函数返回类型的一部分。 可选的元组退货类型如果要从函数返回的元组类型有可能对整个元组具有“无值”，则可以使用可选的元组返回类型来反映整个元组可以为nil的事实。您通过在元组类型的结束括号后放置问号来编写可选的元组返回类型，例如(Int,Int)?或者(String,Int,Bool)? 注意 可选元组类型，如(Int,Int)?不同于包含可选类型的元组，如(Int?,Int?)对于可选的元组类型，整个元组是可选的，而不仅仅是元组中的每个单个值。 上面的minMax(array:)函数返回一个包含两个Int值的元组。然而，该功能不会对传递的数组进行任何安全检查。如果array组参数包含空数组，则上面定义的minMax(array:)函数将在尝试访问数array[0]时触发运行时错误。 要安全地处理空数组，请使用可选的元组返回类型编写minMax(array:)函数，并在数组为空时返回nil值： 12345678910111213func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 您可以使用可选绑定来检查此版本的minMax(array:)函数是返回实际元组值还是nil： 1234if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123; print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;)&#125;// Prints &quot;min is -6 and max is 109&quot; 具有隐式返回的函数如果函数的整个主体都是单个表达式，则函数隐式返回该表达式。例如，以下两个函数都有相同的行为： 1234567891011func greeting(for person: String) -&gt; String &#123; &quot;Hello, &quot; + person + &quot;!&quot;&#125;print(greeting(for: &quot;Dave&quot;))// Prints &quot;Hello, Dave!&quot;func anotherGreeting(for person: String) -&gt; String &#123; return &quot;Hello, &quot; + person + &quot;!&quot;&#125;print(anotherGreeting(for: &quot;Dave&quot;))// Prints &quot;Hello, Dave!&quot; greeting(for:)函数的整个定义是它返回的问候信息，这意味着它可以使用这种较短的形式。anotherGreeting(for:)函数返回相同的问候信息，像使用较长的函数一样使用return关键字。您仅写为一条return行的任何函数都可以省略return。 正如您在速记获取声明中看到的那样，属性获取者也可以使用隐式返回。 注意 您写入的隐式返回值的代码需要返回一些值。例如，您不能使用print(13)作为隐式返回值。但是，您可以使用一个永远不会返回 likefatalErrorfatalError(&quot;Ohno!&quot;)函数作为隐式返回值，因为Swift知道隐式返回不会发生。 函数参数标签和参数名称每个函数参数都有一个参数标签和一个参数名称。调用函数时使用参数标签；每个参数都写在函数调用中，前面有参数标签。参数名称用于实现函数。默认情况下，参数使用其参数名称作为参数标签。 12345func someFunction(firstParameterName: Int, secondParameterName: Int) &#123; // In the function body, firstParameterName and secondParameterName // refer to the argument values for the first and second parameters.&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 所有参数都必须有唯一的名称。虽然多个参数可能具有相同的参数标签，但唯一的参数标签有助于使您的代码更具可读性。 指定参数标签您在参数名称之前写一个参数标签，用空格分隔： 1234func someFunction(argumentLabel parameterName: Int) &#123; // In the function body, parameterName refers to the argument value // for that parameter.&#125; 以下是greet(person:)功能的变体，该函数采用一个人的名字和家乡，并返回问候语： 12345func greet(person: String, from hometown: String) -&gt; String &#123; return &quot;Hello \\(person)! Glad you could visit from \\(hometown).&quot;&#125;print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))// Prints &quot;Hello Bill! Glad you could visit from Cupertino.&quot; 使用参数标签可以允许以表达式、类似句子的方式调用函数，同时仍然提供可读且意图清晰的函数体。 省略参数标签如果您不想要参数的参数标签，请为该参数写一个下划线（_），而不是显式参数标签。 12345func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123; // In the function body, firstParameterName and secondParameterName // refer to the argument values for the first and second parameters.&#125;someFunction(1, secondParameterName: 2) 如果参数有参数标签，则在调用函数时必须标记参数。 默认参数值您可以通过在该参数类型之后为参数分配值来定义函数中任何参数的默认值。如果定义了默认值，您可以在调用函数时省略该参数。 123456func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123; // If you omit the second argument when calling this function, then // the value of parameterWithDefault is 12 inside the function body.&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12 将没有默认值的参数放在函数参数列表的开头，放在具有默认值的参数之前。如果没有默认值的参数通常对函数的含义更重要——首先写入它们可以更容易识别正在调用相同的函数，无论是否省略任何默认参数。 变量参数变参数接受指定类型的零个或多个值。您使用变异参数来指定在调用函数时可以传递不同数量的输入值。通过在参数的类型名称后插入三个句号字符（...）来编写变量参数。 传递给变量参数的值作为适当类型的数组在函数的主体内提供。例如，具有numbers名称和Double...类型的变量参数在函数的主体中作为称为类型[Double]``numbers的常数数组提供。 以下示例计算了任何长度的数字列表的算术平均值（也称为平均值）： 1234567891011func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3.0, which is the arithmetic mean of these five numbersarithmeticMean(3, 8.25, 18.75)// returns 10.0, which is the arithmetic mean of these three numbers 一个函数可以有多个变性参数。变参数之后的第一个参数必须有一个参数标签。参数标签明确了哪些参数传递给变分参数，哪些参数传递给变分参数之后的参数。 输入输出参数默认情况下，函数参数是常量。试图从该函数主体内更改函数参数的值会导致编译时错误。这意味着您不能错误地更改参数的值。如果您希望函数修改参数的值，并希望这些更改在函数调用结束后持续存在，请将该参数定义为进出参数。 您可以通过将输入关键字放在参数类型之前来编写inout输出参数。入出参数有一个值，该值被传递给函数，由函数修改，并从函数中传递回来以替换原始值。有关进出参数和相关编译器优化行为的详细讨论，请参阅输入输出参数。 您只能传递一个变量作为进出参数的参数。您不能传递常量或字面值作为参数，因为常量和文字无法修改。当您将安培数（&amp;）作为参数传递给输入输出参数时，将它直接放在变量名称之前，以指示函数可以修改它。 注意 进出参数不能有默认值，变分参数不能标记为inout。 这是一个名为swapTwoInts(_:_:)的函数示例，它有两个名为a和b的输入输出整数参数： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; ‘ swaptwints(::) ‘函数只是将’ b ‘的值交换为’ a ‘， ‘ a ‘的值交换为’ b ‘。函数通过将’ a ‘的值存储在一个名为’ temporaryA ‘的临时常量中，将’ b ‘的值赋给’ a ‘，然后将’ temporaryA ‘赋给’ b ‘来执行交换。 您可以调用具有Int类型为两个变量的swapTwoIntsswapTwoInts(_:_:)函数来交换其值。请注意，someInt和anotherInt的名称前缀为安培，当它们传递给swapTwoIntsswapTwoInts(_:_:)函数时： 12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \\(someInt), and anotherInt is now \\(anotherInt)&quot;)// Prints &quot;someInt is now 107, and anotherInt is now 3&quot; 上面的示例表明，someInt和anotherInt的原始值被swapTwoIntsswapTwoInts(_:_:)函数修改，即使它们最初是在函数之外定义的。 注意 输入输出参数与从函数返回值不同。上面的swapTwoInts示例没有定义返回类型或返回值，但它仍然修改了someInt和anotherInt的值。输入输出参数是函数在其函数体范围之外产生效果的另一种方式。 功能类型每个函数都有特定的函数类型，由参数类型和函数的返回类型组成。 例如： 123456func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 此示例定义了两个简单的数学函数，称为addTwoInts和multiplyTwoInts。这些函数各接受两个Int值，并返回一个Int值，这是执行适当数学运算的结果。 这两个函数的类型都是’ (Int, Int) -&gt; Int ‘。这可以理解为: “具有两个参数的函数，两个参数都是Int类型，并且返回Int类型的值。” 以下是另一个例子，对于没有参数或返回值的函数： 123func printHelloWorld() &#123; print(&quot;hello, world&quot;)&#125; 这个函数的类型是’ ()-&gt; Void ‘，或者”一个没有参数的函数，返回’ Void ‘ “。 使用功能类型您使用的功能类型就像 Swift 中的任何其他类型一样。例如，您可以将常量或变量定义为函数类型，并为该变量分配适当的函数： 1var mathFunction: (Int, Int) -&gt; Int = addTwoInts 这可以理解为： “定义一个名为mathFunction的变量，该变量具有一种‘接受两个Int值并返回一个Int值的函数’。将这个新变量设置为引用名为addTwoInts函数。” addTwoInts(_:_:)函数具有与mathFunction变量相同的类型，因此Swift的类型检查器允许此分配。 您现在可以调用名为mathFunction的分配函数： 12print(&quot;Result: \\(mathFunction(2, 3))&quot;)// Prints &quot;Result: 5&quot; 具有相同匹配类型的不同函数可以分配给相同的变量，就像非函数类型一样： 123mathFunction = multiplyTwoIntsprint(&quot;Result: \\(mathFunction(2, 3))&quot;)// Prints &quot;Result: 6&quot; 与任何其他类型一样，当您将函数分配给常量或变量时，您可以将其留给Swift来推断函数类型： 12let anotherMathFunction = addTwoInts// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int 函数类型作为参数类型你可以使用像’ (Int, Int) -&gt; Int ‘这样的函数类型作为另一个函数的形参类型。这使您能够将函数实现的某些方面留给函数的调用者来提供。 以下是从上面打印数学函数结果的示例： 12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print(&quot;Result: \\(mathFunction(a, b))&quot;)&#125;printMathResult(addTwoInts, 3, 5)// Prints &quot;Result: 8&quot; 这个例子定义了一个名为’ printMathResult(:::) ‘的函数，它有三个参数。第一个参数叫做’ mathFunction ‘，其类型为’ (Int, Int) -&gt; Int ‘。您可以传递该类型的任何函数作为第一个参数的实参。第二个和第三个形参称为’ a ‘和’ b ‘，都是’ Int ‘类型。它们用作所提供的数学函数的两个输入值。 当调用printMathResult(_:_:_:)时，它传递了addTwoInts(_:_:)函数以及整数值3和5。它调用值为3和5的函数，并打印8的结果。 printMathResult(_:_:_:)的作用是打印对适当类型的数学函数的调用结果。该函数的实现实际做什么并不重要，重要的是该函数的类型是否正确。这使printMathResult(_:_:_:)能够以类型安全的方式将其部分功能移交给函数的调用者。 函数类型作为返回类型您可以使用函数类型作为另一个函数的返回类型。您可以通过在返回函数的返回箭头（-&gt;）后立即写入完整的函数类型来做到这一点。 下一个例子定义了两个简单的函数，分别叫做“stepForward(:)”和“stepBackward(:)”。’ stepForward(:) ‘函数返回的值比其输入值大1，’ stepBackward(:) ‘函数返回的值比其输入值小1。两个函数都具有’ (Int) -&gt; Int ‘类型: 123456func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125; 这里有一个函数叫做’ chooseStepFunction(backward:) ‘，它的返回类型是’ (Int) -&gt; Int ‘。’ chooseStepFunction(backward:) ‘函数返回’ stepForward(:) ‘函数或’ stepBackward(:) ‘函数，该函数基于一个名为’ backward ‘的布尔形参: 123func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 您现在可以使用chooseStepFunction(backward:)获取将向一个或另一个方向前进的函数： var currentValue &#x3D; 3 let moveNearerToZero &#x3D; chooseStepFunction(backward: currentValue &gt; 0) &#x2F;&#x2F; moveNearerToZero now refers to the stepBackward() function 上面的例子决定了将一个名为“currentValue”的变量移动到逐渐接近零的位置时，是需要一个正的步骤还是负的步骤。’ currentValue ‘的初始值为’ 3 ‘，这意味着’ currentValue &gt; 0 ‘返回’ true ‘，导致’ chooseStepFunction(backward:) ‘返回’ stepBackward(:) ‘函数。对返回函数的引用存储在一个名为“moveNearerToZero”的常量中。 现在’ moveNearerToZero ‘指向了正确的函数，它可以被用来计数到0: 1234567891011print(&quot;Counting to zero:&quot;)// Counting to zero:while currentValue != 0 &#123; print(&quot;\\(currentValue)... &quot;) currentValue = moveNearerToZero(currentValue)&#125;print(&quot;zero!&quot;)// 3...// 2...// 1...// zero! 嵌套函数到目前为止，您在本章中遇到的所有函数都是全局函数的示例，这些函数是在全局范围内定义的。您还可以定义其他函数主体内的函数，称为嵌套函数。 默认情况下，嵌套函数对外部世界隐藏，但仍然可以被其封闭函数调用和使用。封闭函数也可以返回其嵌套函数之一，以允许嵌套函数在另一个作用域中使用。 您可以重写上面的chooseStepFunction(backward:)示例来使用和返回嵌套函数： 123456789101112131415161718func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 &#123; print(&quot;\\(currentValue)... &quot;) currentValue = moveNearerToZero(currentValue)&#125;print(&quot;zero!&quot;)// -4...// -3...// -2...// -1...// zero!","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 协议","slug":"软件开发/技术/编程语言/swift/Swift基础-协议","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-协议/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Protocols.html 协议定义了适合特定任务或功能的方法、属性和其他要求的蓝图。然后，该协议可以由类、结构或枚举采用，以提供这些要求的实际实现。任何满足协议要求的类型都被称为符合该协议。 除了指定符合类型必须实现的要求外，您还可以扩展协议来实现其中一些需求或实现符合类型可以利用的其他功能。 协议语法您以与类、结构和枚举非常相似的方式定义协议： protocol SomeProtocol { ​ &#x2F;&#x2F; protocol definition goes here } 自定义类型声明，他们采用特定协议，将协议的名称放在类型名称之后，用冒号分隔，作为其定义的一部分。可以列出多个协议，并用逗号分隔： struct SomeStructure: FirstProtocol, AnotherProtocol { ​ &#x2F;&#x2F; structure definition goes here } 如果一个类有一个超类，请在它采用的任何协议之前列出超类名称，后跟逗号： class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol { ​ &#x2F;&#x2F; class definition goes here } 财产要求协议可以要求任何符合要求的类型为实例属性或类型属性提供特定名称和类型。该协议没有指定该属性是存储属性还是计算属性，它只指定所需的属性名称和类型。该协议还指定每个属性必须是可获取的还是可获取和可设置的。 如果协议要求属性可获取和可设置，则该属性要求无法由常量存储属性或只读计算属性满足。如果协议仅要求属性是可获取的，则任何类型的属性都可以满足该要求，如果这对您自己的代码有用，则该属性也可以设置。 Property requirements are always declared as variable properties, prefixed with the varkeyword. Gettable and settable properties are indicated by writing &#123; get set &#125; after their type declaration, and gettable properties are indicated by writing &#123; get &#125;. protocol SomeProtocol { ​ var mustBeSettable: Int { get set } ​ var doesNotNeedToBeSettable: Int { get } } 在协议中定义类型属性要求时，请务必用静态关键字作为类型属性要求前缀。即使类型属性要求在类实现时可以以class或静态关键字为前缀，但此规则也适用： protocol AnotherProtocol { ​ static var someTypeProperty: Int { get set } } 以下是具有单个实例属性要求的协议示例： protocol FullyNamed { ​ var fullName: String { get } } FullyNamed协议要求符合要求的类型来提供完全限定的名称。该协议没有指定任何关于符合类型性质的任何其他信息——它只指定该类型必须能够为自己提供全名。该协议规定，任何FullyNamed类型都必须有一个名为fullName的gettable实例属性，该属性类型为String。 以下是采用并符合FullyNamed协议的简单结构示例： struct Person: FullyNamed { ​ var fullName: String } let john &#x3D; Person(fullName: “John Appleseed”) &#x2F;&#x2F; john.fullName is “John Appleseed” 此示例定义了一个名为Person结构，该结构表示一个特定的命名人。它表示，它采用FullyNamed协议作为其定义第一行的一部分。 Each instance of Person has a single stored property called fullName, which is of type String. This matches the single requirement of the FullyNamed protocol, and means that Person has correctly conformed to the protocol. (Swift reports an error at compile time if a protocol requirement isn’t fulfilled.) 这里有一个更复杂的类，它也采用并符合FullyNamed协议： class Starship: FullyNamed { ​ var prefix: String? ​ var name: String ​ init(name: String, prefix: String? &#x3D; nil) { ​ self.name &#x3D; name ​ self.prefix &#x3D; prefix ​ } ​ var fullName: String { ​ return (prefix !&#x3D; nil ? prefix! + “ “ : “”) + name ​ } } var ncc1701 &#x3D; Starship(name: “Enterprise”, prefix: “USS”) &#x2F;&#x2F; ncc1701.fullName is “USS Enterprise” 该类实现fullName属性要求，作为星际飞船的计算只读属性。每个Starship类实例都存储一个必填name和一个可选prefix。如果存在，fullName属性使用prefix值，并将其前置于name开头，为星舰创建全名。 方法要求协议可以要求通过符合类型实现特定的实例方法和类型方法。这些方法作为协议定义的一部分，以与普通实例和类型方法完全相同的方式编写，但没有花括号或方法主体。允许变量参数，但须遵守与正常方法相同的规则。然而，无法为协议定义中的方法参数指定默认值。 与类型属性要求一样，当在协议中定义static关键字时，您总是在类型方法要求前加上静态关键字。即使类型方法要求在类实现时以class或静态关键字为前缀，也是如此： protocol SomeProtocol { ​ static func someTypeMethod() } 以下示例定义了具有单个实例方法要求的协议： protocol RandomNumberGenerator { ​ func random() -&gt; Double } 该协议RandomNumberGenerator要求任何符合要求的类型都有一个名为random实例方法，该方法在调用时返回一个Double值。虽然它没有指定为协议的一部分，但假设这个值将从0.0到（但不包括）1.0。 RandomNumberGenerator协议不会对如何生成每个随机数做出任何假设——它只是要求生成器提供一种标准方法来生成新的随机数。 以下是采用并符合RandomNumberGenerator协议的类的实现。该类实现了伪随机数生成器算法，称为线性同余生成器： class LinearCongruentialGenerator: RandomNumberGenerator { ​ var lastRandom &#x3D; 42.0 ​ let m &#x3D; 139968.0 ​ let a &#x3D; 3877.0 ​ let c &#x3D; 29573.0 ​ func random() -&gt; Double { ​ lastRandom &#x3D; ((lastRandom * a + c) ​ .truncatingRemainder(dividingBy:m)) ​ return lastRandom &#x2F; m ​ } } let generator &#x3D; LinearCongruentialGenerator() print(“Here’s a random number: (generator.random())”) &#x2F;&#x2F; Prints “Here’s a random number: 0.3746499199817101” print(“And another one: (generator.random())”) &#x2F;&#x2F; Prints “And another one: 0.729023776863283” 突变方法要求有时，方法需要修改（或突变）它所属的实例。例如，值类型（即结构和枚举）上的方法，您将mutating关键字放在方法的func关键字之前，以指示允许该方法修改其所属的实例和该实例的任何属性。这个过程在从实例内方法修改值类型中进行了描述。 如果您定义了旨在突变采用该协议的任何类型的实例的协议实例方法要求，请将该方法标记为协议定义的一部分。这使结构和枚举能够采用协议并满足该方法要求。 注意 如果您将协议实例方法要求标记为mutating，则在为类编写该方法的实现时无需编写mutating关键字。mutating关键字仅供结构和枚举使用。 下面的示例定义了一个名为Togglable的协议，该协议定义了一个名为toggle单个实例方法要求。顾名思义，toggle()方法旨在切换或反转任何符合类型的状态，通常通过修改该类型的属性。 toggle()方法被标记为mutating关键字，作为Togglable协议定义的一部分，以指示该方法在调用时预计将突变符合实例的状态： protocol Togglable { ​ mutating func toggle() } 如果您为结构或枚举实现Togglable协议，该结构或枚举可以通过提供也标记为mutating的toggle()方法的实现来符合协议。 The example below defines an enumeration called OnOffSwitch. This enumeration toggles between two states, indicated by the enumeration cases on and off. The enumeration’s toggle implementation is marked as mutating, to match the Togglable protocol’s requirements: enum OnOffSwitch: Togglable { ​ case off, on ​ mutating func toggle() { ​ switch self { ​ case .off: ​ self &#x3D; .on ​ case .on: ​ self &#x3D; .off ​ } ​ } } var lightSwitch &#x3D; OnOffSwitch.off lightSwitch.toggle() &#x2F;&#x2F; lightSwitch is now equal to .on 初始化器要求协议可以要求通过符合类型实现特定的初始化器。您以与普通初始化器完全相同的方式编写这些初始化器作为协议定义的一部分，但没有花括号或初始化器主体： protocol SomeProtocol { ​ init(someParameter: Int) } 协议初始化器要求的类实现您可以在符合要求的类上实现协议初始化器要求，作为指定的初始化器或方便初始化器。在这两种情况下，您都必须用required修饰符标记初始化器实现： class SomeClass: SomeProtocol { ​ required init(someParameter: Int) { ​ &#x2F;&#x2F; initializer implementation goes here ​ } } 使用required修饰符可确保您在符合类的所有子类上提供初始化器要求的显式或继承实现，以便它们也符合协议。 有关所需初始化器的更多信息，请参阅所需初始化器。 注意 您不需要在标有final修饰符的类上使用required修饰符标记协议初始化器实现，因为最终类无法子类。有关final修饰符的更多信息，请参阅防止覆盖。 如果子类从超类覆盖指定的初始化器，并且还从协议中实现了匹配的初始化器要求，请用required修饰符和override修饰符标记初始化器实现： protocol SomeProtocol { ​ init() } class SomeSuperClass { ​ init() { ​ &#x2F;&#x2F; initializer implementation goes here ​ } } class SomeSubClass: SomeSuperClass, SomeProtocol { ​ &#x2F;&#x2F; “required” from SomeProtocol conformance; “override” from SomeSuperClass ​ required override init() { ​ &#x2F;&#x2F; initializer implementation goes here ​ } } 失败的初始化器要求协议可以定义符合类型的故障初始化器要求，如故障初始化器中定义。 符合要求的类型上的可故障或不可失败的初始化器可以满足故障初始化器要求。非故障初始化器或隐式未包装的故障初始化器可以满足非故障初始化器要求。 协议作为类型协议本身实际上并没有实现任何功能。尽管如此，您可以在代码中将协议用作成熟的类型。将协议用作类型有时被称为存在类型，它来自短语“存在一种类型T，使得T符合协议”。 您可以在许多允许其他类型的地方使用协议，包括： 作为函数、方法或初始化器中的参数类型或返回类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中项目的类型 注意 由于协议是类型，因此以大写字母（如FullyNamed和RandomNumberGenerator）开头，以匹配Swift中其他类型的名称（如Int、String和Double）。 以下是用作类型的协议示例： class Dice { ​ let sides: Int ​ let generator: RandomNumberGenerator ​ init(sides: Int, generator: RandomNumberGenerator) { ​ self.sides &#x3D; sides ​ self.generator &#x3D; generator ​ } ​ func roll() -&gt; Int { ​ return Int(generator.random() * Double(sides)) + 1 ​ } } 此示例定义了一个名为Dice的新类，它表示用于棋盘游戏的n面骰子。Dice实例有一个称为sides的整数属性，表示它们有多少边，以及一个称为生generator属性，它提供了一个随机数生成器，从中创建骰子滚动值。 generator属性为RandomNumberGenerator类型。因此，您可以将其设置为采用RandomNumberGenerator协议的任何类型的实例。您分配给此属性的实例不需要其他内容，除非实例必须采用RandomNumberGenerator协议。由于其类型是RandomNumberGenerator，Dice类中的代码只能以适用于所有符合此协议的生成器的方式与generator交互。这意味着它不能使用由生成器底层类型定义的任何方法或属性。但是，您可以从协议类型降级类型到底层类型，就像您可以从超类向下转换到子类一样，正如在向下转换中讨论的那样。 Dice还有一个初始化器，用于设置其初始状态。此初始化器有一个名为generator的参数，该参数也属于RandomNumberGenerator类型。在初始化新的Dice实例时，您可以将任何符合类型的值传递给此参数。 Dice提供一种实例方法，roll，它返回1和骰子上边数之间的整数值。此方法调用生成器的random()方法，以创建一个0.0到1.0之间的新随机数，并使用此随机数在正确的范围内创建骰子滚动值。由于已知generator采用RandomNumberGenerator，因此它保证有一个random()方法可以调用。 以下是如何使用Dice创建以aLinearCongruentialGenerator实例作为其随机数生成器的六面骰子： var d6 &#x3D; Dice(sides: 6, generator: LinearCongruentialGenerator()) for _ in 1…5 { ​ print(“Random dice roll is (d6.roll())”) } &#x2F;&#x2F; Random dice roll is 3 &#x2F;&#x2F; Random dice roll is 5 &#x2F;&#x2F; Random dice roll is 4 &#x2F;&#x2F; Random dice roll is 5 &#x2F;&#x2F; Random dice roll is 4 授权委托是一种设计模式，使类或结构能够将其部分责任移交给（或委托）到另一种类型的实例。这种设计模式是通过定义封装委托责任的协议来实现的，这样保证符合的类型（称为委托）可以提供已委托的功能。委托可用于响应特定操作，或从外部来源检索数据，而无需知道该源的基础类型。 以下示例定义了两种用于基于骰子的棋盘游戏的协议： protocol DiceGame { ​ var dice: Dice { get } ​ func play() } protocol DiceGameDelegate: AnyObject { ​ func gameDidStart(_ game: DiceGame) ​ func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) ​ func gameDidEnd(_ game: DiceGame) } DiceGame协议是一种协议，任何涉及骰子的游戏都可以采用。 可以使用DiceGameDelegate协议来跟踪DiceGame的进度。为了防止强引用周期，委托被声明为弱引用。有关弱引用的信息，请参阅类实例之间的强引用周期。将协议标记为仅类可以让SnakesAndLadders类在本章后面声明其委托必须使用弱引用。正如在仅类协议中讨论的那样，仅类协议通过从AnyObject继承来标记。 这是最初在Control Flow中引入的蛇和梯子游戏的一个版本。此版本适用于使用Dice实例进行骰子卷；采用DiceGame协议；并通知DiceGameDelegate其进度： class SnakesAndLadders: DiceGame { ​ let finalSquare &#x3D; 25 ​ let dice &#x3D; Dice(sides: 6, generator: LinearCongruentialGenerator()) ​ var square &#x3D; 0 ​ var board: [Int] ​ init() { ​ board &#x3D; Array(repeating: 0, count: finalSquare + 1) ​ board[03] &#x3D; +08; board[06] &#x3D; +11; board[09] &#x3D; +09; board[10] &#x3D; +02 ​ board[14] &#x3D; -10; board[19] &#x3D; -11; board[22] &#x3D; -02; board[24] &#x3D; -08 ​ } ​ weak var delegate: DiceGameDelegate? ​ func play() { ​ square &#x3D; 0 ​ delegate?.gameDidStart(self) ​ gameLoop: while square !&#x3D; finalSquare { ​ let diceRoll &#x3D; dice.roll() ​ delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll) ​ switch square + diceRoll { ​ case finalSquare: ​ break gameLoop ​ case let newSquare where newSquare &gt; finalSquare: ​ continue gameLoop ​ default: ​ square +&#x3D; diceRoll ​ square +&#x3D; board[square] ​ } ​ } ​ delegate?.gameDidEnd(self) ​ } } 有关蛇和梯子游戏玩法的描述，请参阅Break。 这个版本的游戏被包装成一个名为SnakesAndLadders类，该类采用了DiceGame协议。它提供了一个gettabledice属性和一个play()方法，以符合协议。（dice属性被声明为常量属性，因为它在初始化后不需要更改，并且协议仅要求它必须是可获取的。） Snakes and Ladders游戏板设置在类的init()初始化器中进行。所有游戏逻辑都转移到协议play方法中，该方法使用协议的必需dice属性来提供其骰子滚动值。 请注意，delegate属性被定义为可选的DiceGameDelegate，因为玩游戏不需要委托。由于它是可选类型，delegate属性会自动设置为nil的初始值。此后，游戏实例化器可以选择将属性设置为合适的委托。由于DiceGameDelegate协议仅限类，因此您可以声明委托为weak，以防止引用周期。 DiceGameDelegate提供了三种跟踪游戏进度的方法。这三种方法已纳入上述play()方法中的游戏逻辑，并在新游戏开始、新回合开始或游戏结束时调用。 由于delegate属性是可选的DiceGameDelegate，因此play()方法每次在委托上调用方法时都使用可选链。如果delegate属性为零，则这些委托调用优雅地失败，没有错误。如果delegate属性非零，则调用委托方法，并将SnakesAndLadders实例作为参数传递。 下一个示例显示了一个名为DiceGameTracker的类，该类采用了DiceGameDelegate协议： class DiceGameTracker: DiceGameDelegate { ​ var numberOfTurns &#x3D; 0 ​ func gameDidStart(_ game: DiceGame) { ​ numberOfTurns &#x3D; 0 ​ if game is SnakesAndLadders { ​ print(“Started a new game of Snakes and Ladders”) ​ } ​ print(“The game is using a (game.dice.sides)-sided dice”) ​ } ​ func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) { ​ numberOfTurns +&#x3D; 1 ​ print(“Rolled a (diceRoll)”) ​ } ​ func gameDidEnd(_ game: DiceGame) { ​ print(“The game lasted for (numberOfTurns) turns”) ​ } } DiceGameTracker实现DiceGameDelegate所需的所有三种方法。它使用这些方法来跟踪游戏的转弯次数。当游戏开始时，它会将anumberOfTurns属性重置为零，每次新回合开始时都会增加，并在游戏结束后打印出回合总数。 上面显示的gameDidStart(_:)的实现使用game参数打印一些关于即将玩的游戏的介绍性信息。game参数具有DiceGame类型，而不是SnakesAndLadders，因此gameDidStart(_:)只能访问和使用作为DiceGame协议一部分实现的方法和属性。然而，该方法仍然能够使用类型转换来查询底层实例的类型。在本例中，它检查game是否实际上是幕后SnakesAndLadders的实例，如果是，则打印适当的消息。 gameDidStart(_:)方法还访问传递game参数的dice属性。由于game已知符合DiceGame协议，因此它保证具有dice属性，因此无论玩哪种游戏，gameDidStart(_:)方法都可以访问和打印骰子的sides属性。 以下是DiceGameTracker在操作中的样子： let tracker &#x3D; DiceGameTracker() let game &#x3D; SnakesAndLadders() game.delegate &#x3D; tracker game.play() &#x2F;&#x2F; Started a new game of Snakes and Ladders &#x2F;&#x2F; The game is using a 6-sided dice &#x2F;&#x2F; Rolled a 3 &#x2F;&#x2F; Rolled a 5 &#x2F;&#x2F; Rolled a 4 &#x2F;&#x2F; Rolled a 5 &#x2F;&#x2F; The game lasted for 4 turns 通过扩展添加协议一致性即使您无法访问现有类型的源代码，您也可以扩展现有类型以采用和遵守新协议。扩展可以向现有类型添加新的属性、方法和下标，因此能够添加协议可能要求的任何要求。有关扩展的更多信息，请参阅扩展。 注意 当该一致性在扩展中添加到实例的类型时，类型的现有实例会自动采用并符合协议。 例如，这种名为TextRepresentable的协议可以通过任何可以表示为文本的类型实现。这可能是对自身的描述，也可能是其当前状态的文本版本： protocol TextRepresentable { ​ var textualDescription: String { get } } 上面的Dice可以扩展到采用并符合TextRepresentable： extension Dice: TextRepresentable { ​ var textualDescription: String { ​ return “A (sides)-sided dice” ​ } } 此扩展采用新协议的方式与Dice在其原始实现中提供的方式完全相同。协议名称在类型名称之后提供，由冒号分隔，并在扩展的花括号内提供协议所有要求的实现。 任何Dice实例现在都可以被视为TextRepresentable： let d12 &#x3D; Dice(sides: 12, generator: LinearCongruentialGenerator()) print(d12.textualDescription) &#x2F;&#x2F; Prints “A 12-sided dice” 同样，SnakesAndLadders游戏类可以扩展为采用并符合TextRepresentable协议： extension SnakesAndLadders: TextRepresentable { ​ var textualDescription: String { ​ return “A game of Snakes and Ladders with (finalSquare) squares” ​ } } print(game.textualDescription) &#x2F;&#x2F; Prints “A game of Snakes and Ladders with 25 squares” 有条件地遵守协议只有在特定条件下，例如当类型的通用参数符合协议时，通用类型才能满足协议的要求。您可以通过在扩展类型时列出约束，使泛型类型有条件地符合协议。通过编写通用where子句，在您采用的协议名称后写入这些约束。有关通用where子句的更多信息，请参阅通用where子句。 以下扩展使Array实例在存储符合TextRepresentable的类型元素时符合TextRepresentable协议。 extension Array: TextRepresentable where Element: TextRepresentable { ​ var textualDescription: String { ​ let itemsAsText &#x3D; self.map { $0.textualDescription } ​ return “[“ + itemsAsText.joined(separator: “, “) + “]” ​ } } let myDice &#x3D; [d6, d12] print(myDice.textualDescription) &#x2F;&#x2F; Prints “[A 6-sided dice, A 12-sided dice]” 宣布协议通过扩展如果一种类型已经符合协议的所有要求，但尚未声明它采用该协议，您可以使其采用带有空扩展名的协议： struct Hamster { ​ var name: String ​ var textualDescription: String { ​ return “A hamster named (name)” ​ } } extension Hamster: TextRepresentable {} 现在，只要TextRepresentable是必填类型，都可以使用Hamster实例： let simonTheHamster &#x3D; Hamster(name: “Simon”) let somethingTextRepresentable: TextRepresentable &#x3D; simonTheHamster print(somethingTextRepresentable.textualDescription) &#x2F;&#x2F; Prints “A hamster named Simon” 注意 类型不会仅仅通过满足其要求而自动采用协议。他们必须始终明确宣布通过该议定书。 使用综合实现采用协议在许多简单的情况下，Swift可以自动为Equatable、Hashable和Comparable提供协议一致性。使用此综合实现意味着您不必编写重复的样板代码来自己实现协议要求。 Swift为以下类型的自定义类型提供了Equatable的综合实现： 仅存储符合Equatable协议的属性的结构 仅具有符合Equatable协议的关联类型的枚举 没有关联类型的枚举 To receive a synthesized implementation of ==, declare conformance to Equatable in the file that contains the original declaration, without implementing an == operator yourself. The Equatable protocol provides a default implementation of !=. 下面的示例定义了三维位置向量(x,y,z)的Vector3D结构，类似于Vector2D结构。由于x、y和z属性都是Equatable的，Vector3D接收等价运算符的合成实现。 struct Vector3D: Equatable { ​ var x &#x3D; 0.0, y &#x3D; 0.0, z &#x3D; 0.0 } let twoThreeFour &#x3D; Vector3D(x: 2.0, y: 3.0, z: 4.0) let anotherTwoThreeFour &#x3D; Vector3D(x: 2.0, y: 3.0, z: 4.0) if twoThreeFour &#x3D;&#x3D; anotherTwoThreeFour { ​ print(“These two vectors are also equivalent.”) } &#x2F;&#x2F; Prints “These two vectors are also equivalent.” Swift为以下类型的自定义类型提供了Hashable的综合实现： Structures that have only stored properties that conform to the Hashable protocol 仅具有符合Hashable协议的关联类型的枚举 没有关联类型的枚举 要接收hash(into:)的合成实现，请在包含原始声明的文件中声明与Hashable的一致性，而无需自己实现hash(into:)方法。 Swift为没有原始值的枚举提供了Comparable的综合实现。如果枚举具有关联类型，它们都必须符合Comparable协议。要接收&lt;的合成实现，请在包含原始枚举声明的文件中声明一致性为Comparable，而无需自己实现&lt;运算符。Comparable协议的默认实现&lt;=,&gt;和&gt;=提供了剩余的比较运算符。 以下示例定义了针对初学者、中级和专家案例的SkillLevel列举。专家还根据他们拥有的恒星数量进行排名。 enum SkillLevel: Comparable { ​ case beginner ​ case intermediate ​ case expert(stars: Int) } var levels &#x3D; [SkillLevel.intermediate, SkillLevel.beginner, ​ SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)] for level in levels.sorted() { ​ print(level) } &#x2F;&#x2F; Prints “beginner” &#x2F;&#x2F; Prints “intermediate” &#x2F;&#x2F; Prints “expert(stars: 3)” &#x2F;&#x2F; Prints “expert(stars: 5)” 协议类型的集合协议可以用作存储在集合中的类型，如数组或字典，如协议中所述。此示例创建一个TextRepresentable事物数组： let things: [TextRepresentable] &#x3D; [game, d12, simonTheHamster] 现在可以迭代数组中的项目，并打印每个项目的文本描述： for thing in things { ​ print(thing.textualDescription) } &#x2F;&#x2F; A game of Snakes and Ladders with 25 squares &#x2F;&#x2F; A 12-sided dice &#x2F;&#x2F; A hamster named Simon 请注意，常量为TextRepresentable类型。它不是Dice、orDiceGame或Hamster类型，即使幕后的实际实例是这些类型之一。尽管如此，由于其类型为TextRepresentable，并且已知任何TextRepresentable都具有textualDescription属性，因此每次通过循环访问thing.textualDescription都是安全的。 协议继承协议可以继承一个或多个其他协议，并可以在继承的要求之外添加进一步的要求。协议继承的语法类似于类继承的语法，但可以选择列出多个继承的协议，用逗号分隔： protocol InheritingProtocol: SomeProtocol, AnotherProtocol { ​ &#x2F;&#x2F; protocol definition goes here } 以下是从上面继承TextRepresentable协议的协议示例： protocol PrettyTextRepresentable: TextRepresentable { ​ var prettyTextualDescription: String { get } } This example defines a new protocol, PrettyTextRepresentable, which inherits from TextRepresentable. Anything that adopts PrettyTextRepresentable must satisfy all of the requirements enforced by TextRepresentable, plus the additional requirements enforced by PrettyTextRepresentable. In this example, PrettyTextRepresentable adds a single requirement to provide a gettable property called prettyTextualDescription that returns a String. SnakesAndLadders类可以扩展到采用并符合PrettyTextRepresentable： extension SnakesAndLadders: PrettyTextRepresentable { ​ var prettyTextualDescription: String { ​ var output &#x3D; textualDescription + “:\\n” ​ for index in 1…finalSquare { ​ switch board[index] { ​ case let ladder where ladder &gt; 0: ​ output +&#x3D; “▲ “ ​ case let snake where snake &lt; 0: ​ output +&#x3D; “▼ “ ​ default: ​ output +&#x3D; “○ “ ​ } ​ } ​ return output ​ } } 此扩展声明它采用PrettyTextRepresentable协议，并为SnakesAndLadders类型提供了 prettyTextualDescription属性的实现。任何PrettyTextRepresentable都必须是TextRepresentable，因此prettyTextualDescription的实现从TextRepresentable协议访问textualDescription属性开始，以启动输出字符串。它附加冒号和换行符，并将其用作其漂亮文本表示的开始。然后，它通过板正方形阵列迭代，并附加一个几何形状来表示每个正方形的内容： 如果正方形的值大于0，它是梯子的底部，并用▲表示。 如果正方形的值小于0，那就是蛇的头，并用▼表示。 否则，正方形的值为0，它是一个“自由”正方形，由○表示。 prettyTextualDescription属性现在可用于打印任何SnakesAndLadders实例的漂亮文本描述： print(game.prettyTextualDescription) &#x2F;&#x2F; A game of Snakes and Ladders with 25 squares: &#x2F;&#x2F; ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○ 仅类协议您可以通过将AnyObject协议添加到协议的继承列表中来将协议采用限制为类类型（而不是结构或枚举）。 protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol { ​ &#x2F;&#x2F; class-only protocol definition goes here } 在上面的示例中，SomeClassOnlyProtocol只能由类类型采用。编写试图采用SomeClassOnlyProtocol的结构或枚举定义是一个编译时错误。 注意 当该协议要求定义的行为假设或要求符合的类型具有参考语义而不是值语义时，请使用仅类协议。有关引用和值语义的更多信息，请参阅结构和枚举是值类型，类是参考类型。 礼宾组成要求一种类型同时遵守多个协议可能是有用的。您可以将多个协议组合成一个带有协议组合的单个需求。协议组合的行为就好像您定义了一个临时本地协议，该协议具有组合中所有协议的组合要求。协议组合没有定义任何新的协议类型。 Protocol compositions have the form SomeProtocol &amp; AnotherProtocol. You can list as many protocols as you need, separating them with ampersands (&amp;). In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass. 以下是一个将两个名为Named和Aged的协议组合成函数参数上的单个协议组合要求的示例： protocol Named { ​ var name: String { get } } protocol Aged { ​ var age: Int { get } } struct Person: Named, Aged { ​ var name: String ​ var age: Int } func wishHappyBirthday(to celebrator: Named &amp; Aged) { ​ print(“Happy birthday, (celebrator.name), you’re (celebrator.age)!”) } let birthdayPerson &#x3D; Person(name: “Malcolm”, age: 21) wishHappyBirthday(to: birthdayPerson) &#x2F;&#x2F; Prints “Happy birthday, Malcolm, you’re 21!” 在本例中，Named协议对名为name的可获取String属性有一个单一要求。Aged协议对可取的Int属性调用具有单一要求。这两种协议都由一个名为Person的结构采用。 The example also defines a wishHappyBirthday(to:) function. The type of the celebratorparameter is Named &amp; Aged, which means “any type that conforms to both the Named and Aged protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols. 然后，该示例创建一个名为birthdayPerson的新Person实例，并将此新实例传递给wishHappyBirthday(to:)函数。由于Person符合这两种协议，因此此通话是有效的，wishHappyBirthday(to:)功能可以打印其生日问候语。 以下是将上一个示例中的Named协议与aLocation类相结合的示例： class Location { ​ var latitude: Double ​ var longitude: Double ​ init(latitude: Double, longitude: Double) { ​ self.latitude &#x3D; latitude ​ self.longitude &#x3D; longitude ​ } } class City: Location, Named { ​ var name: String ​ init(name: String, latitude: Double, longitude: Double) { ​ self.name &#x3D; name ​ super.init(latitude: latitude, longitude: longitude) ​ } } func beginConcert(in location: Location &amp; Named) { ​ print(“Hello, (location.name)!”) } let seattle &#x3D; City(name: “Seattle”, latitude: 47.6, longitude: -122.3) beginConcert(in: seattle) &#x2F;&#x2F; Prints “Hello, Seattle!” The beginConcert(in:) function takes a parameter of type Location &amp; Named, which means “any type that’s a subclass of Location and that conforms to the Named protocol.” In this case, City satisfies both requirements. Passing birthdayPerson to the beginConcert(in:) function is invalid because Person isn’t a subclass of Location. Likewise, if you made a subclass of Location that didn’t conform to the Named protocol, calling beginConcert(in:) with an instance of that type is also invalid. 检查协议一致性您可以使用类型转换中描述的is和as运算符来检查协议一致性，并转换为特定协议。检查和转换到协议遵循与检查和转换到类型完全相同的语法： 如果实例符合协议，则is运算符返回true，如果不符合协议，则返回false。 as?向下转换运算符的版本返回协议类型的可选值，如果实例不符合该协议，则该值为nil。 as!下调运算符的版本将下调强制到协议类型，如果下调失败，则触发运行时错误。 此示例定义了一个名为HasArea协议，具有称为area的可获取Double属性的单个属性要求： protocol HasArea { ​ var area: Double { get } } 以下是两个类别，Circle和Country，它们都符合HasArea协议： class Circle: HasArea { ​ let pi &#x3D; 3.1415927 ​ var radius: Double ​ var area: Double { return pi * radius * radius } ​ init(radius: Double) { self.radius &#x3D; radius } } class Country: HasArea { ​ var area: Double ​ init(area: Double) { self.area &#x3D; area } } Circle类基于存储radius属性将area属性要求作为计算属性实现。Country类直接作为存储属性实现area要求。这两个类都正确地符合HasArea协议。 这里有一个名为Animal的类，它不符合HasArea协议： class Animal { ​ var legs: Int ​ init(legs: Int) { self.legs &#x3D; legs } } Circle、Country和Animal类没有共享的基类。尽管如此，它们都是类，因此所有三种类型的实例都可以用于初始化存储类型AnyObject值的数组： let objects: [AnyObject] &#x3D; [ ​ Circle(radius: 2.0), ​ Country(area: 243_610), ​ Animal(legs: 4) ] objects数组初始化为数组文字，其中包含半径为2个单位的Circle实例；以英国表面积（平方公里）初始化Country实例；以及四个腿的Animal实例。 现在可以迭代objects数组，并且可以检查数组中的每个对象，看看它是否符合HasArea协议： for object in objects { ​ if let objectWithArea &#x3D; object as? HasArea { ​ print(“Area is (objectWithArea.area)”) ​ } else { ​ print(“Something that doesn’t have an area”) ​ } } &#x2F;&#x2F; Area is 12.5663708 &#x2F;&#x2F; Area is 243610.0 &#x2F;&#x2F; Something that doesn’t have an area Whenever an object in the array conforms to the HasArea protocol, the optional value returned by the as? operator is unwrapped with optional binding into a constant called objectWithArea. The objectWithArea constant is known to be of type HasArea, and so its area property can be accessed and printed in a type-safe way. 请注意，基础对象不会因铸造过程而改变。他们仍然是Circle、Country和Animal。然而，当它们存储在objectWithArea常量中时，它们只知道是HasArea类型，因此只能访问它们area属性。 《任择议定书》要求您可以定义协议的可选要求。这些要求不必由符合协议的类型实现。作为协议定义的一部分，可选要求前缀为optional饰符。可选要求可用，以便您可以编写与Objective-C互操作的代码。协议和可选要求都必须用@objc属性标记。请注意，@objc协议只能由从Objective-C类或其他@objc类继承的类采用。它们不能被结构或枚举所采用。 当您在可选需求中使用方法或属性时，其类型会自动成为可选类型。例如，类型(Int)-&gt;String的方法变为((Int)-&gt;String)?请注意，整个函数类型包装在可选中，而不是方法的返回值中。 可选协议要求可以通过可选链调用，以解释该要求不是由符合协议的类型实现的可能性。调用可选方法时，您可以通过在方法名称后写一个问号来检查其实现，例如someOptionalMethod?(someArgument)有关可选链的信息，请参阅可选链。 以下示例定义了一个名为Counter的整数计数类，该类使用外部数据源来提供其增量。此数据源由CounterDataSource协议定义，该协议有两个可选要求： @objc protocol CounterDataSource { ​ @objc optional func increment(forCount count: Int) -&gt; Int ​ @objc optional var fixedIncrement: Int { get } } CounterDataSource协议定义了一个名为increment(forCount:)的可选方法要求和一个名为fixedIncrement可选属性要求。这些要求定义了数据源为Counter实例提供适当增量的两种不同方式。 注意 严格来说，您可以编写符合CounterDataSource的自定义类，而无需实现任一协议要求。毕竟，它们都是可选的。虽然技术上允许，但这不会成为一个非常好的数据源。 下面定义的Counter类具有typeCounterDataSourceCounterDataSource?的可选dataSource属性： class Counter { ​ var count &#x3D; 0 ​ var dataSource: CounterDataSource? ​ func increment() { ​ if let amount &#x3D; dataSource?.increment?(forCount: count) { ​ count +&#x3D; amount ​ } else if let amount &#x3D; dataSource?.fixedIncrement { ​ count +&#x3D; amount ​ } ​ } } Counter类将其当前值存储在称为count的变量属性中。Counter类还定义了一个名为increment的方法，每次调用方法时都会增加count属性。 increment()方法首先尝试通过在其数据源上查找increment(forCount:)方法的实现来检索增量。increment()方法使用可选链来尝试调用increment(forCount:)并将currentcount值作为方法的单个参数传递。 请注意，两个级别的可选链在这里起作用。首先，dataSource可能为nil，因此dataSource名称后有一个问号，表示只有当dataSource不是nil才应调用increment(forCount:)）。其次，即使dataSource确实存在，也不能保证它实现increment(forCount:)因为它是一个可选要求。在这里，increment(forCount:)可能无法实现的可能性也通过可选链处理。只有当increment(forCount:)存在时，才会调用increment(forCount:)），也就是说，如果它不是nil。这就是为什么increment(forCount:)在名称后面也用问号书写。 Because the call to increment(forCount:) can fail for either of these two reasons, the call returns an optional Int value. This is true even though increment(forCount:) is defined as returning a non-optional Int value in the definition of CounterDataSource. Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional. For more information about using multiple optional chaining operations, see Linking Multiple Levels of Chaining. 调用increment(forCount:)后，它返回的可选Int使用可选绑定解包装成一个常量称为amount。如果可选的Int确实包含一个值——也就是说，如果委托和方法都存在，并且方法返回了一个值——则未包装的amount将添加到存储count属性中，并且增量完成。 如果无法从increment(forCount:)方法中检索值——要么是因为dataSource为零，要么是因为数据源没有实现increment(forCount:)——那么increment()方法会尝试从数据源的fixedIncrement属性中检索值。fixedIncrement属性也是可选要求，因此其值是可选的Int值，即使fixedIncrement被定义为非可选的Int属性，作为CounterDataSource协议定义的一部分。 这是一个简单的CounterDataSource实现，其中数据源每次查询时都会返回3的常量值。它通过实现可选fixedIncrement属性要求来做到这一点： class ThreeSource: NSObject, CounterDataSource { ​ let fixedIncrement &#x3D; 3 } 您可以使用ThreeSource实例作为新Counter实例的数据源： var counter &#x3D; Counter() counter.dataSource &#x3D; ThreeSource() for _ in 1…4 { ​ counter.increment() ​ print(counter.count) } &#x2F;&#x2F; 3 &#x2F;&#x2F; 6 &#x2F;&#x2F; 9 &#x2F;&#x2F; 12 上面的代码创建一个新的Counter实例；将其数据源设置为newThreeSource实例；并四次调用counter的increment()方法。不出所料，每次调用increment()时，计数器的count属性都会增加三个。 Here’s a more complex data source called TowardsZeroSource, which makes a Counterinstance count up or down towards zero from its current count value: class TowardsZeroSource: NSObject, CounterDataSource { ​ func increment(forCount count: Int) -&gt; Int { ​ if count &#x3D;&#x3D; 0 { ​ return 0 ​ } else if count &lt; 0 { ​ return 1 ​ } else { ​ return -1 ​ } ​ } } The TowardsZeroSource class implements the optional increment(forCount:) method from the CounterDataSource protocol and uses the count argument value to work out which direction to count in. If count is already zero, the method returns 0 to indicate that no further counting should take place. You can use an instance of TowardsZeroSource with the existing Counter instance to count from -4 to zero. Once the counter reaches zero, no more counting takes place: counter.count &#x3D; -4 counter.dataSource &#x3D; TowardsZeroSource() for _ in 1…5 { ​ counter.increment() ​ print(counter.count) } &#x2F;&#x2F; -3 &#x2F;&#x2F; -2 &#x2F;&#x2F; -1 &#x2F;&#x2F; 0 &#x2F;&#x2F; 0 协议扩展协议可以扩展到向符合要求的类型提供方法、初始化器、下标和计算属性实现。这允许您定义协议本身的行为，而不是在每种类型的单个一致性或全局函数中。 例如，RandomNumberGenerator协议可以扩展到提供arandomBoolrandomBool()方法，该方法使用所需的random()方法的结果返回随机Bool值： extension RandomNumberGenerator { ​ func randomBool() -&gt; Bool { ​ return random() &gt; 0.5 ​ } } 通过在协议上创建扩展，所有符合的类型都会自动获得此方法实现，而无需任何额外的修改。 let generator &#x3D; LinearCongruentialGenerator() print(“Here’s a random number: (generator.random())”) &#x2F;&#x2F; Prints “Here’s a random number: 0.3746499199817101” print(“And here’s a random Boolean: (generator.randomBool())”) &#x2F;&#x2F; Prints “And here’s a random Boolean: true” 协议扩展可以向符合要求的类型添加实现，但不能使协议扩展或从其他协议继承。协议继承总是在协议声明本身中指定。 提供默认实现您可以使用协议扩展为该协议的任何方法或计算属性要求提供默认实现。如果符合的类型提供了自己实现所需的方法或属性，则将使用该实现而不是扩展提供的实现。 注意 扩展提供的默认实现的协议要求与任择议定书要求不同。虽然符合要求的类型不必提供它们自己的实现，但可以调用默认实现的需求，而无需可选的链式。 例如，继承TextRepresentable协议的PrettyTextRepresentable协议可以提供其resedprettyTextualDescription属性的默认实现，以简单地返回访问textualDescription属性的结果： extension PrettyTextRepresentable { ​ var prettyTextualDescription: String { ​ return textualDescription ​ } } 为协议扩展添加约束当您定义协议扩展时，您可以指定符合要求的类型在扩展的方法和属性可用之前必须满足的约束。您通过编写通用where子句，在您要扩展的协议名称后编写这些约束。有关通用where子句的更多信息，请参阅通用where子句。 例如，您可以定义Collection协议的扩展，该扩展适用于其元素符合Equatable协议的任何集合。通过将集合的元素限制到标准库的一部分Equatable协议，您可以使用==和!=运算符来检查两个元素之间的等式和不等式。 extension Collection where Element: Equatable { ​ func allEqual() -&gt; Bool { ​ for element in self { ​ if element !&#x3D; self.first { ​ return false ​ } ​ } ​ return true ​ } } 只有当集合中的所有元素相等时，allEqual()方法才会返回true。 考虑两个整数数组，一个所有元素都相同，另一个不相同： let equalNumbers &#x3D; [100, 100, 100, 100, 100] let differentNumbers &#x3D; [100, 100, 200, 100, 200] 由于数组符合Collection，整数符合Equatable，equalNumbers和differentNumbers可以使用allEqual()方法： print(equalNumbers.allEqual()) &#x2F;&#x2F; Prints “true” print(differentNumbers.allEqual()) &#x2F;&#x2F; Prints “false” 注意 如果符合要求的类型满足为同一方法或属性提供实现的多个约束扩展的要求，Swift将使用与最专业约束相对应的实现。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 去初始化","slug":"软件开发/技术/编程语言/swift/Swift基础-去初始化","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-去初始化/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%8E%BB%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html 在类实例被释放之前，会立即调用去初始化器。您使用deinit关键字编写去初始化器，类似于使用init关键字编写初始化器的方式。取消初始化器仅适用于类类型。 Deinitialization如何运作Swift 会在不再需要实例时自动处理这些实例，以释放资源。Swift通过自动引用计数（ARC）处理实例的内存管理，如自动引用计数中所述。通常，在实例被释放时，您不需要进行手动清理。但是，当您使用自己的资源时，您可能需要自己进行一些额外的清理。例如，如果您创建一个自定义类来打开文件并向其写入一些数据，您可能需要在类实例被释放之前关闭文件。 类定义每个类最多可以有一个去初始化器。取消初始化器不接受任何参数，并且没有括号： deinit { ​ &#x2F;&#x2F; perform the deinitialization } 在实例处理分配发生之前，会自动调用去初始化器。您不得自己调用非初始化器。超类非初始化器由其子类继承，超类非初始化器在子类非初始化器实现结束时自动调用。总是调用超类非初始化器，即使子类不提供自己的非初始化器。 由于实例在调用其非初始化器后才会被释放，因此非初始化器可以访问其调用的实例的所有属性，并可以根据这些属性修改其行为（例如查找需要关闭的文件的名称）。 去初始化器在行动以下是一个非初始化器在起作用的例子。这个例子为一个简单的游戏定义了两种新类型，Bank和Player。Bank级管理一种制成币，流通量永远不会超过10,000枚硬币。游戏中只能有一个Bank，因此该Bank是一个具有类型属性和方法来存储和管理其当前状态的类实现： class Bank { ​ static var coinsInBank &#x3D; 10_000 ​ static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int { ​ let numberOfCoinsToVend &#x3D; min(numberOfCoinsRequested, coinsInBank) ​ coinsInBank -&#x3D; numberOfCoinsToVend ​ return numberOfCoinsToVend ​ } ​ static func receive(coins: Int) { ​ coinsInBank +&#x3D; coins ​ } } Bank keeps track of the current number of coins it holds with its coinsInBank property. It also offers two methods—distribute(coins:) and receive(coins:)—to handle the distribution and collection of coins. distribute(coins:)方法在分发硬币之前检查银行中是否有足够的硬币。如果硬币不够，Bank返回的数字比请求的数字要小（如果银行中没有硬币，则返回零）。它返回一个整数值，以指示提供的实际硬币数量。 receive(coins:)方法只需将收到的硬币数量重新添加到银行的硬币商店。 Player类描述了游戏中的玩家。每个玩家的钱包里随时都有一定数量的硬币。这由玩家的coinsInPurse属性表示： class Player { ​ var coinsInPurse: Int ​ init(coins: Int) { ​ coinsInPurse &#x3D; Bank.distribute(coins: coins) ​ } ​ func win(coins: Int) { ​ coinsInPurse +&#x3D; Bank.distribute(coins: coins) ​ } ​ deinit { ​ Bank.receive(coins: coinsInPurse) ​ } } 在初始化期间，每个Player实例都使用银行指定数量的硬币的起始限额进行初始化，尽管如果没有足够的硬币可用，Player实例收到的硬币可能少于该数字。 Player类定义了一个win(coins:)方法，该方法从银行检索一定数量的硬币并将其添加到玩家的钱包中。Player类还实现了去初始化器，该去初始化器是在Player实例被释放之前调用的。在这里，去初始化器只需将玩家的所有硬币退还给银行： var playerOne: Player? &#x3D; Player(coins: 100) print(“A new player has joined the game with (playerOne!.coinsInPurse) coins”) &#x2F;&#x2F; Prints “A new player has joined the game with 100 coins” print(“There are now (Bank.coinsInBank) coins left in the bank”) &#x2F;&#x2F; Prints “There are now 9900 coins left in the bank” 创建一个新的Player实例，如果有的话，需要100枚硬币。此Player实例存储在名为playerOne的可选Player变量中。这里使用可选变量，因为玩家可以随时离开游戏。可选功能允许您跟踪游戏中目前是否有玩家。 因为playerOne是可选的，所以它有资格获得感叹号（!）当访问itscoinsInPurse属性以打印其默认硬币数量时，以及每当调用itswinwin(coins:)方法时： playerOne!.win(coins: 2_000) print(“PlayerOne won 2000 coins &amp; now has (playerOne!.coinsInPurse) coins”) &#x2F;&#x2F; Prints “PlayerOne won 2000 coins &amp; now has 2100 coins” print(“The bank now only has (Bank.coinsInBank) coins left”) &#x2F;&#x2F; Prints “The bank now only has 7900 coins left” 在这里，玩家赢得了2000枚硬币。玩家的钱包现在包含2100枚硬币，而银行只剩下7900枚硬币。 playerOne &#x3D; nil print(“PlayerOne has left the game”) &#x2F;&#x2F; Prints “PlayerOne has left the game” print(“The bank now has (Bank.coinsInBank) coins”) &#x2F;&#x2F; Prints “The bank now has 10000 coins” 玩家现在已经离开了游戏。这通过将可选的playerOne变量设置为nil来指示，这意味着“没有Player实例”。发生这种情况时，playerOne变量对Player实例的引用被破坏。没有其他属性或变量仍然引用Player实例，因此将其释放以释放其内存。就在这种情况发生之前，其去初始化器会自动调用，其硬币被退回银行。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 可选链条","slug":"软件开发/技术/编程语言/swift/Swift基础-可选链条","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-可选链条/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%8F%AF%E9%80%89%E9%93%BE%E6%9D%A1/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html 可选链是一个在当前可能为nil的可选链上查询和调用属性、方法和下标的过程。如果可选包含值，则属性、方法或下标调用成功；如果可选值为nil，则属性、方法或下标调用返回nil。多个查询可以链接在一起，如果链中的任何链接为nil整个链条会优雅地失败。 注意 Swift中的可选链类似于Objective-C中的消息nil，但以适用于任何类型的方式，并且可以检查成功或失败。 可选链作为强制打开包装的替代方案您通过放置问号（?）来指定可选的链条在可选值之后，如果可选值为非nil在您希望调用属性、方法或下标的可选值之后。这与放置感叹号（!）非常相似在可选值之后，强制展开其值。主要区别在于，当可选链接为nil，可选链会优雅地失败，而当可选链接为nil，强制展开包装会触发运行时错误。 为了反映可选链可以在nil值上调用的事实，可选链调用的结果始终是可选值，即使您正在查询的属性、方法或下标返回非可选值。您可以使用此可选返回值来检查可选链调用是否成功（返回的可选包含值），还是由于链中的nil值而没有成功（返回的可选值为nil）。 具体来说，可选链调用的结果与预期返回值类型相同，但包装在可选中。通常返回Int的属性会返回Int?通过可选链访问时。 接下来的几个代码片段演示了可选链与强制拆开的区别，并使您能够检查成功。 First, two classes called Person and Residence are defined: class Person { ​ var residence: Residence? } class Residence { ​ var numberOfRooms &#x3D; 1 } Residence实例有一个名为numberOfRooms``Int属性，默认值为1。Person实例具有Residence?类型为可选的residence属性。 如果您创建一个新的Person实例，其residence属性默认初始化为nil，因为它是可选的。在下面的代码中，john的residence物业价值为nil： let john &#x3D; Person() 如果您尝试访问此人residence的numberOfRooms属性，通过在residence后放置感叹号以强制解开其值，您将触发运行时错误，因为没有residence值可以打开： let roomCount &#x3D; john.residence!.numberOfRooms &#x2F;&#x2F; this triggers a runtime error john.residence具有非nil值时，上述代码将成功，并将roomCount设置为包含适当数量房间的Int值。然而，如上所述，当residence为nil，此代码总是触发运行时错误。 可选链提供了一种访问numberOfRooms值的替代方式。要使用可选的链条，请使用问号代替感叹号： if let roomCount &#x3D; john.residence?.numberOfRooms { ​ print(“John’s residence has (roomCount) room(s).”) } else { ​ print(“Unable to retrieve the number of rooms.”) } &#x2F;&#x2F; Prints “Unable to retrieve the number of rooms.” 这告诉Swift在可选的residence属性上“链”，如果存在residence，则检索numberOfRooms值。 由于访问numberOfRooms尝试可能会失败，因此可选的链式尝试返回类型为Int?或“optional Int”的值。如上例所示，当residence为nil，此可选的Int也将为nil，以反映无法访问numberOfRooms的事实。可选的Int通过可选绑定访问，以解开整数，并将非可选值分配给roomCount常量。 请注意，即使numberOfRooms是一个非可选的Int也是如此。它通过可选链查询的事实意味着对numberOfRooms调用将始终返回anIntInt?而不是Int。 您可以将Residence实例分配给john.residence，使其不再具有nil值： john.residence &#x3D; Residence() john.residence现在包含一个实际的Residence实例，而不是nil。如果您尝试使用与以前相同的可选链条访问numberOfRooms，它现在将返回一个Int?包含默认numberOfRooms值为1： if let roomCount &#x3D; john.residence?.numberOfRooms { ​ print(“John’s residence has (roomCount) room(s).”) } else { ​ print(“Unable to retrieve the number of rooms.”) } &#x2F;&#x2F; Prints “John’s residence has 1 room(s).” 定义可选链的模型类您可以使用可选链来调用多个级别深的属性、方法和下标。这使您能够深入了解相互关联的复杂模型中的子属性，并检查是否可以访问这些子属性的属性、方法和下标。 下面的代码片段定义了四个模型类，用于后续几个示例，包括多级可选链的示例。这些类通过添加Room和Address类以及相关的属性、方法和下标来扩展上面的Person``Residence模式。 Person类的定义与以前相同： class Person { ​ var residence: Residence? } Residence舱比以前更复杂。这一次，Residence类定义了一个名为rooms的变量属性，该属性使用[Room]类型的空数组初始化： class Residence { ​ var rooms: [Room] &#x3D; [] ​ var numberOfRooms: Int { ​ return rooms.count ​ } ​ subscript(i: Int) -&gt; Room { ​ get { ​ return rooms[i] ​ } ​ set { ​ rooms[i] &#x3D; newValue ​ } ​ } ​ func printNumberOfRooms() { ​ print(“The number of rooms is (numberOfRooms)”) ​ } ​ var address: Address? } 由于此版本的Residence存储了一个Room实例数组，因此其numberOfRooms属性作为计算属性实现，而不是存储属性。computednumberOfRooms属性只需从rooms数组返回count属性的值。 作为访问其rooms数组的快捷方式，此版本的Residence提供了一个读写下标，该下标可根据rooms数组中请求的索引访问房间。 这个版本的Residence还提供了一种名为printNumberOfRooms的方法，它只需打印住宅中的房间数量。 Finally, Residence defines an optional property called address, with a type of Address?. The Address class type for this property is defined below. 用于rooms数组的Room类是一个简单的类，有一个名为name的属性，以及将该属性设置为合适房间名称的初始化器： class Room { ​ let name: String ​ init(name: String) { self.name &#x3D; name } } 这个模型中的最后一个类称为Address。该类有三个typeStringString?的可选属性。前两个属性，buildingName和buildingNumber，是将特定建筑物识别为地址一部分的替代方法。第三种财产，street，用于为该地址命名街道： class Address { ​ var buildingName: String? ​ var buildingNumber: String? ​ var street: String? ​ func buildingIdentifier() -&gt; String? { ​ if let buildingNumber &#x3D; buildingNumber, let street &#x3D; street { ​ return “(buildingNumber) (street)” ​ } else if buildingName !&#x3D; nil { ​ return buildingName ​ } else { ​ return nil ​ } ​ } } The Address class also provides a method called buildingIdentifier(), which has a return type of String?. This method checks the properties of the address and returns buildingName if it has a value, or buildingNumber concatenated with street if both have values, or nil otherwise. 通过可选链访问属性正如可选链作为强制打开包装的替代方案所示，您可以使用可选链访问可选值上的属性，并检查该属性访问是否成功。 使用上面定义的类创建一个新的Person实例，并尝试像以前一样访问其numberOfRooms属性： let john &#x3D; Person() if let roomCount &#x3D; john.residence?.numberOfRooms { ​ print(“John’s residence has (roomCount) room(s).”) } else { ​ print(“Unable to retrieve the number of rooms.”) } &#x2F;&#x2F; Prints “Unable to retrieve the number of rooms.” 由于john.residence为nil，这个可选的链式调用与以前一样失败。 您还可以尝试通过可选链设置属性的值： let someAddress &#x3D; Address() someAddress.buildingNumber &#x3D; “29” someAddress.street &#x3D; “Acacia Road” john.residence?.address &#x3D; someAddress 在本例中，设置john.residence``address属性的尝试将失败，因为john.residence目前为nil。 该赋值是可选链的一部分，这意味着没有计算=运算符右侧的代码。在上一个示例中，不容易看到someAddress从未被评估过，因为访问常量没有任何副作用。以下列表执行相同的分配，但它使用函数来创建地址。该函数在返回值之前打印“函数已调用”，该值允许您查看是否计算了=运算符的右侧。 func createAddress() -&gt; Address { ​ print(“Function was called.”) ​ let someAddress &#x3D; Address() ​ someAddress.buildingNumber &#x3D; “29” ​ someAddress.street &#x3D; “Acacia Road” ​ return someAddress } john.residence?.address &#x3D; createAddress() 您可以判断没有调用createAddress()函数，因为没有打印任何东西。 通过可选链调用方法您可以使用可选链调用可选值上的方法，并检查该方法调用是否成功。即使该方法没有定义返回值，您也可以这样做。 Residence类上的printNumberOfRooms()方法打印numberOfRooms当前值。以下是方法的外观： func printNumberOfRooms() { ​ print(“The number of rooms is (numberOfRooms)”) } 此方法没有指定返回类型。然而，没有返回类型的函数和方法具有隐式返回类型为Void，如《没有返回值的函数》中所述。这意味着它们返回一个值()或一个空元组。 If you call this method on an optional value with optional chaining, the method’s return type will be Void?, not Void, because return values are always of an optional type when called through optional chaining. This enables you to use an if statement to check whether it was possible to call the printNumberOfRooms() method, even though the method doesn’t itself define a return value. Compare the return value from the printNumberOfRooms call against nil to see if the method call was successful: if john.residence?.printNumberOfRooms() !&#x3D; nil { ​ print(“It was possible to print the number of rooms.”) } else { ​ print(“It was not possible to print the number of rooms.”) } &#x2F;&#x2F; Prints “It was not possible to print the number of rooms.” 如果您尝试通过可选链设置属性，也是如此。上面通过可选链访问属性中的示例试图为john.residence设置address值，即使residence属性为nil。任何通过可选链设置属性的尝试都会返回Void?类型的值，这使您能够与nil进行比较，看看属性是否已成功设置： if (john.residence?.address &#x3D; someAddress) !&#x3D; nil { ​ print(“It was possible to set the address.”) } else { ​ print(“It was not possible to set the address.”) } &#x2F;&#x2F; Prints “It was not possible to set the address.” 通过可选链条访问下标您可以使用可选链尝试从可选值的下标中检索和设置值，并检查该下标调用是否成功。 注意 当您通过可选链访问可选值的下标时，您将问号放在下标括号之前，而不是之后。可选的链式问号总是紧随其后于表达式的可选部分之后。 下面的示例试图使用Residence类上定义的下标检索john.residence属性的rooms数组中第一个房间的名称。由于john.residence目前为nil，下标调用失败： if let firstRoomName &#x3D; john.residence?[0].name { ​ print(“The first room name is (firstRoomName).”) } else { ​ print(“Unable to retrieve the first room name.”) } &#x2F;&#x2F; Prints “Unable to retrieve the first room name.” 此下标调用中的可选链问号立即放在john.residence之后的下标括号之前，因为john.residence是尝试可选链的可选值。 同样，您可以尝试通过带有可选链的下标设置新值： john.residence?[0] &#x3D; Room(name: “Bathroom”) 此下标设置尝试也失败，因为residence目前为nil。 如果您创建并向john.residence分配实际的Residence实例，其rooms数组中有一个或多个Room实例，您可以使用Residence下标通过可选链访问rooms数组中的实际项目： let johnsHouse &#x3D; Residence() johnsHouse.rooms.append(Room(name: “Living Room”)) johnsHouse.rooms.append(Room(name: “Kitchen”)) john.residence &#x3D; johnsHouse if let firstRoomName &#x3D; john.residence?[0].name { ​ print(“The first room name is (firstRoomName).”) } else { ​ print(“Unable to retrieve the first room name.”) } &#x2F;&#x2F; Prints “The first room name is Living Room.” 访问可选类型的下标如果下标返回可选类型的值（例如Swift’sDictionary类型的键下标），请在下标的闭括号后放置一个问号，以链式链接到其可选返回值： var testScores &#x3D; [“Dave”: [86, 82, 84], “Bev”: [79, 94, 81]] testScores[“Dave”]?[0] &#x3D; 91 testScores[“Bev”]?[0] +&#x3D; 1 testScores[“Brian”]?[0] &#x3D; 72 &#x2F;&#x2F; the “Dave” array is now [91, 82, 84] and the “Bev” array is now [80, 94, 81] 上面的示例定义了一个名为testScores字典，其中包含两个键值对，将String键映射到Int值数组。该示例使用可选链将&quot;Dave&quot;数组中的第一个项目设置为91；将&quot;Bev&quot;数组中的第一个项目增加1；并尝试将数组中的第一个项目设置为&quot;Brian&quot;的键。前两个调用成功了，因为testScores字典包含&quot;Dave&quot;和&quot;Bev&quot;的键。第三次调用失败，因为testScores字典不包含&quot;Brian&quot;的密钥。 连接多个级别的链条您可以将多个级别的可选链链接在一起，以深入了解模型中更深处的属性、方法和下标。然而，多个级别的可选链不会为返回的值添加更多级别的可选性。 换句话说： 如果您试图检索的类型不是可选的，它将因可选的链而成为可选的。 如果您试图检索的类型已经是可选的，它不会因为链而变得更加可选。 因此： 如果您尝试通过可选链检索Int值，则为Int?无论使用多少级别的链条，总是会返回。 同样，如果您尝试检索Int?通过可选链获得价值，一个Int?无论使用多少级别的链条，总是会返回。 下面的示例试图访问john``address属性的street财产。这里有两个级别的可选链条，用于链穿residence和address属性，两者都是可选类型： if let johnsStreet &#x3D; john.residence?.address?.street { ​ print(“John’s street name is (johnsStreet).”) } else { ​ print(“Unable to retrieve the address.”) } &#x2F;&#x2F; Prints “Unable to retrieve the address.” john.residence的值目前包含一个有效的Residence实例。然而，john.residence.address的价值目前为nil。因此，给john.residence?.address?.street的电话失败了。 请注意，在上面的示例中，您正在尝试检索street属性的值。此属性的类型是String?。因此，john.residence?.address?.street的返回值也是String?，尽管除了属性的基础可选类型外，还应用了两个级别的可选链。 如果您将实际Address实例设置为john.residence.address的值，并为地址的street属性设置实际值，您可以通过多级可选链访问street属性的值： let johnsAddress &#x3D; Address() johnsAddress.buildingName &#x3D; “The Larches” johnsAddress.street &#x3D; “Laurel Street” john.residence?.address &#x3D; johnsAddress if let johnsStreet &#x3D; john.residence?.address?.street { ​ print(“John’s street name is (johnsStreet).”) } else { ​ print(“Unable to retrieve the address.”) } &#x2F;&#x2F; Prints “John’s street name is Laurel Street.” 在本例中，设置john.residence``address属性的尝试将成功，因为john.residence的值目前包含一个有效的Residence实例。 具有可选返回值的方法链前面的示例展示了如何通过可选链检索可选类型属性的值。您还可以使用可选链调用返回可选类型值的方法，并在需要时链上该方法的返回值。 The example below calls the Address class’s buildingIdentifier() method through optional chaining. This method returns a value of type String?. As described above, the ultimate return type of this method call after optional chaining is also String?: if let buildingIdentifier &#x3D; john.residence?.address?.buildingIdentifier() { ​ print(“John’s building identifier is (buildingIdentifier).”) } &#x2F;&#x2F; Prints “John’s building identifier is The Larches.” 如果您想对此方法的返回值执行进一步的可选链式，请在方法的括号后放置可选链问号： if let beginsWithThe &#x3D; ​ john.residence?.address?.buildingIdentifier()?.hasPrefix(“The”) { ​ if beginsWithThe { ​ print(“John’s building identifier begins with &quot;The&quot;.”) ​ } else { ​ print(“John’s building identifier doesn’t begin with &quot;The&quot;.”) ​ } } &#x2F;&#x2F; Prints “John’s building identifier begins with “The”.” 注意 In the example above, you place the optional chaining question mark after the parentheses, because the optional value you are chaining on is the buildingIdentifier() method’s return value, and not the buildingIdentifier() method itself.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 基本运算符","slug":"软件开发/技术/编程语言/swift/Swift基础-基本运算符","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-基本运算符/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID72 操作符是用来检查、更改或合并值的特殊符号或短语。例如，加法运算符(‘ + ‘)将两个数字相加，如’ let i &#x3D; 1 + 2 ‘，逻辑和运算符(‘ &amp;&amp; ‘)结合两个布尔值，如’ if enteredDoorCode &amp;&amp; passsedretinascan ‘。 Swift支持您可能已经从C等语言中知道的运算符，并改进了几种功能来消除常见的编码错误。赋值运算符（&#x3D;）不返回值，以防止在等于运算符（==时被错误使用。算术运算符（+、-、*、/、%等）检测并禁止值溢出，以避免在处理大于或小于存储它们的类型允许值范围的数字时出现意外结果。您可以选择使用Swift的溢出运算符来评估溢出行为，如溢出运算符中所述。 Swift还提供了C中找不到的范围运算符，例如a..&lt;b和a...b，作为表达一系列值的快捷方式。 本章介绍了Swift中的常见运算符。高级运算符涵盖了Swift的高级运算符，并描述了如何定义自己的自定义运算符，并实现您自己的自定义类型的标准运算符。 术语运算符是一元、二进制或三元： 一元运算符对单个目标（如-a）进行操作。元前缀运算符出现在目标之前（例如!b），一元后缀运算符立即出现在目标后面（例如c!）。 Binary operators operate on two targets (such as 2 + 3) and are infix because they appear in between their two targets. Ternary operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator (a ? b : c). 操作符影响的值是操作数。在表达式 1 + 2 中，+ 符号是一个中缀操作符，它的两个操作数是值 1 和 2 。 分配操作员赋值操作符 ( a = b )用 b 的值初始化或更新 a 的值: 1234let b = 10var a = 5a = b// a is now equal to 10 如果赋值的右侧是一个具有多个值的元组，则其元素可以同时分解为多个常量或变量： 12let (x, y) = (1, 2)// x is equal to 1, and y is equal to 2 与C和Objective-C中的赋值运算符不同，Swift中的赋值运算符本身不会返回值。以下陈述无效： 123if x = y &#123; // This isn&#x27;t valid, because x = y doesn&#x27;t return a value.&#125; 这个特性可以防止在实际使用等于操作符( == )时意外使用赋值操作符( = )。通过使 if x = y 无效，Swift可以帮助你在代码中避免这类错误。 算术运算符Swift支持所有数字类型的四个标准算术运算符： 添加（+） 减法（-） 乘法（*） 司（/） 12341 + 2 // equals 35 - 3 // equals 22 * 3 // equals 610.0 / 2.5 // equals 4.0 与C和Objective-C中的算术操作符不同，Swift的算术操作符默认情况下不允许值溢出。你可以通过使用Swift的溢出操作符(例如 a &amp;+ b )来选择值溢出行为。See Overflow Operators. String串联也支持加法运算符： 1&quot;hello, &quot; + &quot;world&quot; // equals &quot;hello, world&quot; 剩余运算符remainder操作符 ( a % b )计算出 b 的多少倍将适合于 a 并返回剩余的值(称为remainder)。 注意 其余运算符（%）在其他语言中也被称为模运算符。然而，它在Swift中对负数的行为意味着，严格来说，它是一个剩余的操作，而不是一个模块化操作。 以下是剩余运算符的工作原理。要计算%，您首先计算出9个4个内部有多少个： 您可以在9个内部安装两个4s，其余为1（以橙色显示）。 在Swift中，这将写为： 19 % 4 // equals 1 为了确定%b的答案，%运算符计算以下方程，并将remainder作为其输出返回： 1a = (b x some multiplier) + remainder 其中somemultiplier是适合a内部的b的最大倍数。 将9和4插入此方程会产生： 19=(4 x 2)+1 在计算负值的余数时，也应用了相同的方法： 1-9 % 4 // equals -1 在方程中插入-9和4会产生： 1-9=(4 x -2)-1 给出剩余值-1。 当 b 值为负值时， b 的符号将被忽略。这意味着 a % b 和 a % -b 总是给出相同的答案。 一元减号运算符数字值的符号可以使用前缀-（称为一元减号运算符）切换： 123let three = 3let minusThree = -three // minusThree equals -3let plusThree = -minusThree // plusThree equals 3, or &quot;minus minus three&quot; 一元减算符（-）直接放在它操作的值之前，没有任何空格。 Unary Plus运算符一元加运算符（+）只需返回其操作的值，无需任何更改： 12let minusSix = -6let alsoMinusSix = +minusSix // alsoMinusSix equals -6 虽然一元加运算符实际上什么都没做，但当使用一元减运算符进行负数时，您可以使用它来在代码中为正数提供对称性。 复合分配运算符与C一样，Swift提供了将赋值（&#x3D;）与另一个操作相结合的复合赋值运算符。一个例子是加法赋值运算符（+=： 123var a = 1a += 2// a is now equal to 3 表达式 a += 2 是 a = a + 2 的缩写。实际上，加法和赋值被合并到一个操作符中，同时执行这两个任务。 注意 复合赋值操作符不返回值。例如，你不能写let b = a += 2。 有关Swift标准库提供的运算符的信息，请参阅运算符声明。 比较运算符Swift 支持以下比较运算符： Equal to (a == b) Not equal to (a != b) Greater than (a &gt; b) Less than (a &lt; b) Greater than or equal to (a &gt;= b) Less than or equal to (a &lt;= b) 注意 Swift还提供了两个身份运算符（===和!==，用于测试两个对象引用是否都引用同一个对象实例。有关更多信息，请参阅身份运营商。 每个比较运算符都返回一个Bool值，以指示语句是否为真： 1234561 == 1 // true because 1 is equal to 12 != 1 // true because 2 isn&#x27;t equal to 12 &gt; 1 // true because 2 is greater than 11 &lt; 2 // true because 1 is less than 21 &gt;= 1 // true because 1 is greater than or equal to 12 &lt;= 1 // false because 2 isn&#x27;t less than or equal to 1 比较运算符通常用于条件语句，例如if语句： 1234567let name = &quot;world&quot;if name == &quot;world&quot; &#123; print(&quot;hello, world&quot;)&#125; else &#123; print(&quot;I&#x27;m sorry \\(name), but I don&#x27;t recognize you&quot;)&#125;// Prints &quot;hello, world&quot;, because name is indeed equal to &quot;world&quot;. 有关if语句的更多信息，请参阅控制流。 如果两个元组具有相同的类型和相同数量的值，您可以比较它们。元组从左到右比较，一次一个值，直到比较发现两个不相等的值。对这两个值进行了比较，比较的结果决定了元组比较的总体结果。如果所有元素都是相等的，那么元组本身就是相等的。例如： 123(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true because 1 is less than 2; &quot;zebra&quot; and &quot;apple&quot; aren&#x27;t compared(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;) // true because 3 is equal to 3, and &quot;apple&quot; is less than &quot;bird&quot;(4, &quot;dog&quot;) == (4, &quot;dog&quot;) // true because 4 is equal to 4, and &quot;dog&quot; is equal to &quot;dog&quot; 在上面的示例中，您可以在第一行看到从左到右的比较行为。因为1小于2(1,&quot;zebra&quot;)被认为是小于(2,&quot;apple&quot;)，无论元组中的任何其他值如何。&quot;zebra&quot;不亚于&quot;apple&quot;并不重要，因为比较已经由元组的第一个元素决定了。然而，当元组的第一个元素相同时，它们的第二个元素会进行比较——这就是第二行和第三行发生的事情。 只有当运算符可以应用于各自元组中的每个值时，元组才能与给定运算符进行比较。例如，如下代码所示，您可以比较两个类型的元组(String,Int)因为可以使用&lt;运算符比较String和Int值。相比之下，两个类型的元组(String,Bool)无法与&lt;运算符进行比较，因为&lt;运算符不能应用于Bool值。 12(&quot;blue&quot;, -1) &lt; (&quot;purple&quot;, 1) // OK, evaluates to true(&quot;blue&quot;, false) &lt; (&quot;purple&quot;, true) // Error because &lt; can&#x27;t compare Boolean values 注意 Swift标准库包括少于七个元素的元组的元组比较运算符。要将元组与七个或更多元素进行比较，您必须自己实现比较运算符。 三元条件运算符三元条件算子是一个有三个部分的特殊算子，它接受形式question?answer1:answer2。这是根据question是真还是假来评估两个表达式之一的快捷方式。如果question属实，它会评估answer1并返回其值；否则，它会评估answer2并返回其值。 三元条件运算符是以下代码的缩写： 12345if question &#123; answer1&#125; else &#123; answer2&#125; 这里有一个例子，它计算了表格行的高度。如果行有标题，行高应比内容高度高50分，如果行没有标头，则高20分： 1234let contentHeight = 40let hasHeader = truelet rowHeight = contentHeight + (hasHeader ? 50 : 20)// rowHeight is equal to 90 上面的示例是以下代码的简写： 123456789let contentHeight = 40let hasHeader = truelet rowHeight: Intif hasHeader &#123; rowHeight = contentHeight + 50&#125; else &#123; rowHeight = contentHeight + 20&#125;// rowHeight is equal to 90 第一个示例对三元条件运算符的使用意味着rowHeight可以在一行代码上设置为正确的值，这比第二个示例中使用的代码更简洁。 三元条件算子为决定考虑两个表达式中的哪一个提供了一个高效的简写。然而，请小心使用三元条件操作员。如果过度使用，它的简洁性可能会导致难以阅读的代码。避免将三元条件运算符的多个实例组合成一个复合语句。 nil 合并运算符零共同化操作员（a??b) 如果可选a包含一个值，则解开它，如果a为nil则返回默认值b。表达式a总是可选类型。表达式b必须与存储在a中的类型匹配。 零共同算符是以下代码的缩写： 1a != nil ? a! : b 上面的代码使用三元条件运算符和强制展开（a!）当a不是nil，访问包裹在a中的值，否则返回b。零凝聚运算符提供了一种更优雅的方式，以简洁易读的形式封装这种有条件的检查和展开包装。 注意 如果a的值非nil，则不计算b的值。这被称为短路评估。 以下示例使用零共同化运算符在默认颜色名称和可选用户定义的颜色名称之间进行选择： 12345let defaultColorName = &quot;red&quot;var userDefinedColorName: String? // defaults to nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName is nil, so colorNameToUse is set to the default of &quot;red&quot; userDefinedColorName变量定义为可选String，默认值为nil。由于userDefinedColorName是可选类型，因此您可以使用零强制运算符来考虑其值。在上面的示例中，运算符用于确定名为colorNameToUse的String变量的初始值。因为userDefinedColorName，所以表达式userDefinedColorName??defaultColorName返回defaultColorName或&quot;red&quot;的值。 如果您将非nil值分配给userDefinedColorName，并再次执行零共同计算符检查，则使用userDefinedColorName中包装的值，而不是默认值： 123userDefinedColorName = &quot;green&quot;colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName isn&#x27;t nil, so colorNameToUse is set to &quot;green&quot; 范围操作员Swift包括几个范围运算符，它们是表达一系列值的快捷方式。 封闭式距离操作员闭范围运算符（a...b）定义了一个从a到b的范围，包括值a和b。a的值不得大于b。 在您想要使用所有值的范围上迭代时，闭合范围运算符非常有用，例如for-in循环： 12345678for index in 1...5 &#123; print(&quot;\\(index) times 5 is \\(index * 5)&quot;)&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 有关for-in循环的更多信息，请参阅控制流。 半开放式范围操作员半开范围运算符（a..&lt;b）定义了一个从a到b运行的范围，但不包括b。据说它是半开放的，因为它包含它的第一个值，但不包含它的最终值。与闭区间运算符一样，a的值不得大于b。如果a的值等于b，那么结果范围将是空的。 当您使用基于零的列表（如数组）时，半开放范围特别有用，其中最多（但不包括）列表的长度非常有用： 123456789let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]let count = names.countfor i in 0..&lt;count &#123; print(&quot;Person \\(i + 1) is called \\(names[i])&quot;)&#125;// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack 请注意，数组包含四个项目，但0..&lt;count仅计入3（数组中最后一个项目的索引），因为它是一个半开放的范围。有关数组的更多信息，请参阅数组。 单面范围闭区间运算符对尽可能在一个方向上继续的范围有另一种形式——例如，范围包括从索引2到数组末尾的数组的所有元素。在这些情况下，您可以省略范围运算符一侧的值。这种范围被称为单边范围，因为运算符只在一边有一个值。例如： 123456789101112for name in names[2...] &#123; print(name)&#125;// Brian// Jackfor name in names[...2] &#123; print(name)&#125;// Anna// Alex// Brian 半开范围运算符还有一个单边形式，仅用其最终值书写。就像您在两侧都包含一个值一样，最终值不是范围的一部分。例如： 12345for name in names[..&lt;2] &#123; print(name)&#125;// Anna// Alex 单边范围可用于其他上下文，而不仅仅是下标。您无法迭代省略第一个值的单边范围，因为不清楚迭代应该从哪里开始。您可以迭代省略其最终值的单边范围；但是，由于范围无限期地持续，请确保为循环添加显式结束条件。您还可以检查单边范围是否包含特定值，如下代码所示。 1234let range = ...5range.contains(7) // falserange.contains(4) // truerange.contains(-1) // true 逻辑运算符逻辑运算符修改或组合布尔逻辑值true和false。Swift支持在基于C的语言中找到的三个标准逻辑运算符： 逻辑不是（!a） 逻辑和（a&amp;&amp;b） Logical OR (a || b) 逻辑非运算符逻辑非运算符（!a）反转布尔值，使true变成false，false变成true。 逻辑NOt运算符是一个前缀运算符，并显示在其操作的值之前，没有任何空格。它可以读作“不是a”，如以下示例所示： 12345let allowedEntry = falseif !allowedEntry &#123; print(&quot;ACCESS DENIED&quot;)&#125;// Prints &quot;ACCESS DENIED&quot; 短语if!allowedEntry可以读作“如果不允许进入”。只有当“不允许输入”为true时，才会执行后续行；也就是说，如果allowedEntry为false。 与本示例一样，仔细选择布尔常量和变量名称有助于保持代码的可读性和简洁性，同时避免双重否定或混淆逻辑语句。 逻辑和运算符(&amp;&amp;)逻辑和运算符（a&amp;&amp;b）创建逻辑表达式，其中两个值都必须true，整体表达式也为true。 如果任一值为false，则整体表达式也为false。事实上，如果第一个值是false的，第二个值甚至不会被计算，因为它不可能使整个表达式等同于true。这被称为短路评估。 此示例考虑两个Bool值，并且仅当两个值都为true时才允许访问： 12345678let enteredDoorCode = truelet passedRetinaScan = falseif enteredDoorCode &amp;&amp; passedRetinaScan &#123; print(&quot;Welcome!&quot;)&#125; else &#123; print(&quot;ACCESS DENIED&quot;)&#125;// Prints &quot;ACCESS DENIED&quot; 逻辑OR运算符(||)逻辑OR操作符 ( a || b )是由两个相邻管道字符组成的中缀操作符。你可以用它来创建逻辑表达式，其中只有两个值中的一个必须为“true”，才能使整个表达式为“true”。 与上面的逻辑和运算符一样，逻辑OR运算符使用短路求值来考虑其表达式。如果逻辑OR表达式的左侧为true，则不会计算右侧，因为它无法改变整体表达式的结果。 在下面的示例中，第一个Bool值（hasDoorKey）为false，但第二个值（knowsOverridePassword）为true。因为一个值为true，因此整体表达式也计算为true，并且允许访问： 12345678let hasDoorKey = falselet knowsOverridePassword = trueif hasDoorKey || knowsOverridePassword &#123; print(&quot;Welcome!&quot;)&#125; else &#123; print(&quot;ACCESS DENIED&quot;)&#125;// Prints &quot;Welcome!&quot; 组合逻辑运算符您可以组合多个逻辑运算符来创建更长的复合表达式： 123456if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123; print(&quot;Welcome!&quot;)&#125; else &#123; print(&quot;ACCESS DENIED&quot;)&#125;// Prints &quot;Welcome!&quot; 此示例使用多个&amp;&amp;和||运算符来创建更长的复合表达式。然而，&amp;&amp;和||运算符仍然只在两个值上运行，因此这实际上是三个较小的表达式链在一起。该示例可以理解为： 如果我们输入了正确的门密码并通过了视网膜扫描，或者我们有有效的门钥匙，或者我们知道紧急覆盖密码，那么允许访问。 根据 enteredDoorCode ， passedRetinaScan 和 hasDoorKey 的值，前两个子表达式为 false 。但是，紧急重写密码是已知的，因此整个复合表达式的计算结果仍然为“true”。 注意 Swift逻辑运算符&amp;&amp;和||是左关联，这意味着具有多个逻辑运算符的复合表达式首先计算最左边的子表达式。 显式括号有时，在不严格需要括号时包含括号是有用的，以使复杂表达式的意图更容易阅读。在上面的门访问示例中，在复合表达式的第一部分周围添加括号以明确其意图是有用的： 123456if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123; print(&quot;Welcome!&quot;)&#125; else &#123; print(&quot;ACCESS DENIED&quot;)&#125;// Prints &quot;Welcome!&quot; 括号清楚地表明，前两个值被视为整体逻辑中单独可能状态的一部分。复合表达式的输出不会改变，但整体意图对读者来说更清楚。可读性总是比简洁更受欢迎；使用括号，它们有助于明确你的意图。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 基础知识","slug":"软件开发/技术/编程语言/swift/Swift基础-基础知识","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-基础知识/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html Swift 是 iOS、macOS、watchOS 和 Apple tvOS app 开发的新编程语言。尽管如此，从您在C和Objective-C开发的经验来看，Swift的许多部分都会很熟悉。 Swift提供了所有基本C和Objective-C类型的自己的版本，包括用于整数的Int、用于浮点值的Double和Float、用于布尔值的Bool和用于文本数据的String。Swift还提供了三种主要集合类型的强大版本，Array、Set和Dictionary，如集合类型中所述。 与C一样，Swift使用变量通过标识名称存储和引用值。Swift还广泛使用值无法更改的变量。这些被称为常数，比C中的常数强大得多。在整个 Swift 中，常量会使用，使代码在处理不需要更改的值时更加安全、更清晰。 除了熟悉的类型外，Swift还引入了Objective-C中没有的高级类型，例如元组。元组使您能够创建和传递值分组。您可以使用元组从函数中返回多个值作为单个复合值。 Swift还引入了可选类型，用于处理值缺失的情况。可选内容要么说“有一个值，它等于x”或“根本没有值”。使用可选类似于在Objective-C中使用nil和指针，但它们适用于任何类型，而不仅仅是类。可选选项不仅比Objective-C中的nil指针更安全、更具表现力，而且是Swift许多最强大功能的核心。 Swift 是一种类型安全的语言，这意味着该语言可帮助您清楚地了解代码可以使用的值类型。如果您的部分代码需要String，则类型安全可以防止您错误地传递给Int。同样，类型安全可防止您意外地将可选String传递给需要非可选String的代码。类型安全可帮助您在开发过程中尽早捕获和修复错误。 常量和变量(Constants and Variables)常量和变量将名称（如maximumNumberOfLoginAttempts或welcomeMessage）与特定类型的值（如数字10或字符串&quot;Hello&quot;相关联。常量的值一旦设置就无法更改，而变量将来可以设置为不同的值。 声明常量和变量常量和变量在使用之前必须声明。您可以使用let关键字声明常量，并使用var关键字声明变量。以下是如何使用常量和变量来跟踪用户尝试登录次数的示例： 12let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0 此代码可以读作： “声明一个名为maximumNumberOfLoginAttempts的新常量，并给它的值10。然后，声明一个名为currentLoginAttempt的新变量，并给它一个初始值0。” 在本例中，允许的最大登录尝试次数被声明为常量，因为最大值永远不会改变。当前登录尝试计数器声明为变量，因为每次登录尝试失败后，此值必须递增。 您可以在一行上声明多个常量或多个变量，用逗号分隔： 1var x = 0.0, y = 0.0, z = 0.0 注意 如果代码中的存储值不会更改，请始终将其声明为带有let关键字的常量。仅使用变量来存储需要能够更改的值。 类型注释您可以在声明常量或变量时提供类型注释，以明确常量或变量可以存储的值类型。通过在常量或变量名称后放置冒号，后跟空格，后跟要使用的类型名称来编写类型注释。 此示例为名为welcomeMessage的变量提供了一个类型注释，以指示该变量可以存储String值： 1var welcomeMessage: String 声明中的冒号的意思是“类型……”，因此上面的代码可以理解为： “Declare a variable called welcomeMessage that’s of type String.” “String类型”一词的意思是“可以存储任何String值”。把它想象成“可以存储的东西的类型”（或“东西的类型”）。 welcomeMessage变量现在可以设置为任何字符串值，没有错误： 1welcomeMessage = &quot;Hello&quot; 您可以在一行上定义同一类型的多个相关变量，用逗号分隔，并在最终变量名称后面添加单个类型注释： 1var red, green, blue: Double 注意 在实践中，您很少需要编写类型注释。如果您在定义的点为常量或变量提供初始值，Swift几乎总是可以推断用于该常量或变量的类型，如类型安全和类型推断中所述。在上面的welcomeMessage示例中，没有提供初始值，因此welcomeMessage变量的类型用类型注释指定，而不是从初始值推断。 命名常量和变量常量和变量名几乎可以包含任何字符，包括Unicode字符： 123let π = 3.14159let 你好 = &quot;你好世界&quot;let 🐶🐮 = &quot;dogcow&quot; 常量和变量名称不能包含空格字符、数学符号、箭头、私人使用的Unicode标量值或线条和框绘制字符。它们也不能以数字开头，尽管数字可能包含在名称的其他地方。 一旦您声明了特定类型的常量或变量，您就无法以相同名称再次声明它，也无法将其更改为存储其他类型的值。您也不能将常量更改为变量或将变量更改为常量。 注意 如果您需要为常量或变量提供与保留的Swift关键字相同的名称，请在将关键字用作名称时用反勾（&#96;）包围该关键字。但是，除非您完全别无选择，否则请避免使用关键字作为名称。 您可以将现有变量的值更改为兼容类型的另一个值。在本例中， friendlyWelcome 的值从 &quot;Hello!&quot; 改变成了 &quot;Bonjour!&quot;: 1231. var friendlyWelcome = &quot;Hello!&quot;2. friendlyWelcome = &quot;Bonjour!&quot;3. // friendlyWelcome is now &quot;Bonjour!&quot; 与变量不同，常量的值在设置后无法更改。编译代码时，尝试这样做将报告为错误： 1231. let languageName = &quot;Swift&quot;2. languageName = &quot;Swift++&quot;3. // This is a compile-time error: languageName cannot be changed. 打印常量和变量您可以使用print(_:separator:terminator:)函数打印常量或变量的当前值： 12print(friendlyWelcome)// Prints &quot;Bonjour!&quot; print(_:separator:terminator:)函数是一个全局函数，将一个或多个值打印到适当的输出。例如，在Xcode中，print(_:separator:terminator:)函数在Xcode的“控制台”窗格中打印其输出。separator和terminator参数具有默认值，因此您可以在调用此函数时省略它们。默认情况下，该函数通过添加换行符来终止其打印的行。要打印后没有换行符的值，请传递一个空字符串作为终止符——例如，print(someValue,terminator:&quot;&quot;)。有关具有默认值的参数的信息，请参阅默认参数值。 Swift使用字符串插值将常量或变量的名称作为占位符包含在较长的字符串中，并提示Swift将其替换为该常量或变量的当前值。将名称包装在括号中，并在开头括号前用反斜杠转义： 12print(&quot;The current value of friendlyWelcome is \\(friendlyWelcome)&quot;)// Prints &quot;The current value of friendlyWelcome is Bonjour!&quot; 注意 可用于字符串插值的所有选项都在字符串插值中描述。 注释使用注释在您的代码中包含不可执行的文本，作为对您自己的便条或提醒。编译代码时，Swift编译器会忽略注释。 Swift 中的注释与 C 中的注释非常相似。单行注释以两个正斜杠（//）开头： 1// This is a comment. 多行注释以前斜杠后跟星号（/*）开始，以星号后跟前斜杠（*/）结束： 12/* This is also a commentbut is written over multiple lines. */ 与C中的多行注释不同，Swift中的多行注释可以嵌套在其他多行注释中。您可以通过启动多行注释块，然后在第一个块中启动第二个多行注释来编写嵌套注释。然后关闭第二个块，然后是第一个块： 123/* This is the start of the first multiline comment./* This is the second, nested multiline comment. */This is the end of the first multiline comment. */ 嵌套的多行注释使您可以快速轻松地注释大块代码，即使代码已经包含多行注释。 分号(;)与许多其他语言不同，Swift不要求您在代码中的每个语句后编写分号（;），尽管如果您愿意，您可以这样做。但是，如果您想在一行上写多个单独的语句，则需要分号： 12let cat = &quot;🐱&quot;; print(cat)// Prints &quot;🐱&quot; 整数(Integers)整数是没有小数分量的整数，例如42和-23。整数要么是有符号（正数、零或负数），要么无符号（正数或零）。 Swift以8、16、32和64位形式提供有符号和无符号整数。这些整数遵循类似于C的命名约定，即8位无符号整数类型为UInt8，32位有符号整数类型为Int32。与 Swift 中的所有类型一样，这些整数类型都有大写名称。 整数边界(Integer Bounds)您可以访问每种整数类型的最小值和最大值及其min和max： 12let minValue = UInt8.min // minValue is equal to 0, and is of type UInt8let maxValue = UInt8.max // maxValue is equal to 255, and is of type UInt8 这些属性的值是适当大小的数字类型（如上面示例中的UInt8），因此可以与相同类型的其他值一起用于表达式。 Int在大多数情况下，您不需要选择特定大小的整数来在代码中使用。Swift提供了一种额外的整数类型Int，其大小与当前平台的原生单词大小相同： 在32位平台上，Int与Int32的大小相同。 在64位平台上，Int与Int64的大小相同。 除非您需要使用特定大小的整数，否则请始终使用Int来处理代码中的整数值。这有助于代码一致性和互操作性。即使在32位平台上，Int也可以存储在-2,147,483,648和2,147,483,647之间的任何值，并且对于许多整数范围来说足够大。 UIntSwift还提供了一种无符号整数类型UInt，其大小与当前平台的原生单词大小相同： 在32位平台上，UInt与UInt32的大小相同。 在64位平台上，UInt与UInt64的大小相同。 注意 仅当您特别需要与平台原生单词大小相同的无符号整数类型时，才使用UInt。如果不是这样，最好是Int，即使已知要存储的值是非负值。一致地使用Int进行整数值有助于代码互操作性，避免在不同数字类型之间转换，并匹配整数类型推断，如类型安全和类型推断所述。 浮点数浮点数是具有小数分量的数字，如3.14159、0.1和-273.15。 浮点类型可以表示比整数类型更广泛的值范围，并且可以存储比Int中存储的要大得多或小得多的数字。Swift提供了两种有符号浮点数类型： Double表示64位浮点数。 Float表示32位浮点数。 注意 Double精度至少为小数点后15位，而Float的精度可以小到小数点后6位。要使用的合适浮点类型取决于您需要在代码中使用的值的性质和范围。在这两种类型合适的情况下，首选Double。 类型安全和类型推断Swift是一种类型安全的语言。类型安全语言鼓励您明确代码可以使用的值类型。如果您的部分代码需要String，则不能错误地将其传递给Int。 由于Swift是类型安全的，它在编译代码时执行类型检查，并将任何不匹配的类型标记为错误。这使您能够尽早在开发过程中捕获和修复错误。 类型检查可帮助您在处理不同类型的值时避免错误。然而，这并不意味着您必须指定您声明的每个常量和变量的类型。如果您没有指定所需的值类型，Swift会使用类型推断来计算适当的类型。类型推断使编译器在编译代码时能够自动推断特定表达式的类型，只需检查您提供的值。 由于类型推断，Swift需要的类型声明比C或Objective-C等语言少得多。常量和变量仍然是显式类型，但指定其类型的大部分工作都是为您完成的。 当您声明具有初始值的常量或变量时，类型推断特别有用。这通常通过在您声明常量或变量时为常量或变量分配字面值（或字面值）来完成。（字面值是直接出现在源代码中的值，例如以下示例中的42和3.14159。） 例如，如果您在不说明类型的情况下为新常量分配42的字面值，Swift推断您希望该常量为Int，因为您已经用一个看起来像整数的数字初始化了它： 12let meaningOfLife = 42// meaningOfLife is inferred to be of type Int 同样，如果您没有为浮点文字指定类型，Swift推断您想创建一个Double： 12let pi = 3.14159// pi is inferred to be of type Double Swift在推断浮点数类型时总是选择Double（而不是Float）。 如果您在表达式中组合整数和浮点文字，则将从上下文中推断出一种Double类型： 12let anotherPi = 3 + 0.14159// anotherPi is also inferred to be of type Double 3的字面值本身没有显式类型，因此从浮点字面值的存在中推断出适当的Double输出类型作为加法的一部分。 数字文字整数文字可以写成： 没有前缀的小数 带有0b前缀的二进制数字 一个八度数，前缀为0o 十六进制数字，前缀为0x 所有这些整数文字的十进制值为17： 1234let decimalInteger = 17let binaryInteger = 0b10001 // 17 in binary notationlet octalInteger = 0o21 // 17 in octal notationlet hexadecimalInteger = 0x11 // 17 in hexadecimal notation 浮点文字可以是十进制（没有前缀）或十六进制（带有0x前缀）。它们必须在小数点的两侧始终有一个数字（或十六进制数字）。十进制浮点数也可以有一个可选的指数，用大写或小写e表示；十六进制浮点必须有一个指数，用大写或小写p表示。 对于指数为exp的小数，基数乘以10exp： 1.25e2意思是1.25 x 102，或125.0。 1.25e-2意思是1.25 x 10-2，或0.0125。 对于指数为exp的十六进制数字，基数乘以2exp： 0xFp2意思是15 x 22或60.0。 0xFp-2意思是15 x 2-2，或3.75。 所有这些浮点文字的十进制值为12.1875： 123let decimalDouble = 12.1875let exponentDouble = 1.21875e1let hexadecimalDouble = 0xC.3p0 数字文字可以包含额外的格式，使其更容易阅读。整数和浮点数都可以用额外的零填充，并可以包含下划线，以帮助提高可读性。这两种格式都不会影响文字的基本值： 123let paddedDouble = 000123.456let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1 数字类型转换对于代码中的所有通用整数常量和变量，即使已知它们是非负数，也请使用Int类型。在日常情况下使用默认整数类型意味着整数常量和变量在您的代码中立即互操作，并将与整数字面值的推断类型匹配。 仅在手头任务特别需要时使用其他整数类型，因为外部来源的数据显式大小，或用于性能、内存使用或其他必要的优化。在这些情况下，使用显式大小的类型有助于捕获任何意外值溢出，并隐式记录所用数据的性质。 整数转换可以存储在整数常数或变量中的数字范围因每种数字类型而异。Int8常量或变量可以存储-128和127之间的数字，而UInt8常量或变量可以存储0到255之间的数字。编译代码时，不适合大小整数类型的常量或变量的数字将报告为错误： 12345let cannotBeNegative: UInt8 = -1// UInt8 can&#x27;t store negative numbers, and so this will report an errorlet tooBig: Int8 = Int8.max + 1// Int8 can&#x27;t store a number larger than its maximum value,// and so this will also report an error 由于每种数字类型可以存储不同范围的值，因此您必须根据具体情况选择数字类型转换。这种选择加入方法可以防止隐藏的转换错误，并有助于在代码中明确类型转换意图。 要将一种特定数字类型转换为另一种特定数字类型，请使用现有值初始化所需类型的新数字。在下面的示例中，常量twoThousand是类型UInt16，而常数是UInt8类型。它们不能直接添加在一起，因为它们不是同一类型。相反，此示例调用UInt16(one)创建一个新的UInt16，初始化为one，并使用此值代替原始值： 123let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one) 由于添加的两侧现在都是UInt16类型，因此允许添加。输出常数（twoThousandAndOne）被推断为UInt16类型，因为它是两个UInt16值的总和。 SomeType(ofInitialValue)是调用Swift类型的初始化器并传递初始值的默认方式。在幕后，UInt16有一个接受UInt8值的初始化器，因此此初始化器用于从现有的UInt8制作新的UInt16。然而，您不能在这里传递任何类型——它必须是UInt16提供初始化器的类型。扩展涵盖了扩展现有类型以提供接受新类型（包括您自己的类型定义）的初始化器。 整数和浮点转换整数和浮点数字类型之间的转换必须明确： 1234let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine// pi equals 3.14159, and is inferred to be of type Double 在这里，常数three的值用于创建Double类型的新值，以便加法的两侧都是相同的类型。如果没有这种转换，将不允许添加。 浮点到整数转换也必须明确。整数类型可以用Double或Float值初始化： 12let integerPi = Int(pi)// integerPi equals 3, and is inferred to be of type Int 当用于以这种方式初始化新的整数值时，浮点值总是被截断。这意味着4.75变成4，-3.9变成-3。 注意 组合数字常数和变量的规则与数字文字的规则不同。字面值3可以直接添加到字面值0.14159中，因为数字文字本身没有显式类型。只有在编译器评估它们时，才会推断出它们的类型。 类型别名类型别名定义了现有类型的替代名称。您可以使用typealias关键字定义类型别名。 当您想用上下文更合适的名称引用现有类型时，例如在处理来自外部来源的特定大小的数据时，类型别名非常有用： 1typealias AudioSample = UInt16 定义类型别名后，您可以在可能使用原始名称的任何地方使用别名： 12var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound is now 0 在这里，AudioSample被定义为UInt16的别名。由于它是一个别名，对AudioSample.min的调用实际上调用UInt16.min，它为maxAmplitudeFound变量提供了初始值0。 布尔值(Booleans)Swift有一个基本的布尔类型，称为Bool。布尔值被称为逻辑值，因为它们只能是真或假。Swift提供了两个布尔常量值，true和false： 12let orangesAreOrange = truelet turnipsAreDelicious = false orangesAreOrange 和 turnnipsaredelicious 的类型被推断为Bool，因为它们是用布尔值初始化的。与上面的’ Int ‘和’ Double ‘一样，如果你在创建常量或变量时将它们设置为’ true ‘或’ false ‘，你就不需要将它们声明为’ Bool ‘。当Swift使用其他已知类型的值初始化常量或变量时，类型推断有助于使代码更加简洁和可读。 当您使用条件语句（如if语句）时，布尔值特别有用： 123456if turnipsAreDelicious &#123; print(&quot;Mmm, tasty turnips!&quot;)&#125; else &#123; print(&quot;Eww, turnips are horrible.&quot;)&#125;// Prints &quot;Eww, turnips are horrible.&quot; Control Flow更详细地介绍了条件语句，如if语句。 Swift的类型安全防止非布尔值被替换为Bool。以下示例报告编译时错误： 1234let i = 1if i &#123; // this example will not compile, and will report an error&#125; 然而，下面的替代示例是有效的： 1234let i = 1if i == 1 &#123;​ // this example will compile successfully&#125; The result of the i == 1 comparison is of type Bool, and so this second example passes the type-check. Comparisons like i == 1 are discussed in Basic Operators. 与 Swift 中的其他类型安全示例一样，这种方法可以避免意外错误，并确保特定代码部分的意图始终清晰。 元组元组将多个值分组为单个复合值。元组中的值可以是任何类型，不必是彼此相同的类型。 在本例中，(404,&quot;NotFound&quot;)是描述HTTP状态代码的元组。HTTP状态代码是Web服务器在请求网页时返回的特殊值。如果您请求不存在的网页，则返回404NotFound的状态代码。 12let http404Error = (404, &quot;Not Found&quot;)// http404Error is of type (Int, String), and equals (404, &quot;Not Found&quot;) (404,&quot;NotFound&quot;)元组将一个Int和一个String组合在一起，为HTTP状态代码提供两个单独的值：数字和人类可读描述。它可以被描述为“类型元组(Int,String)”。 您可以从任何类型的排列中创建元组，它们可以包含任意数量的不同类型。没有什么可以阻止您拥有类型元组(Int,Int,Int)或(String,Bool)或者您所需的任何其他排列。 您可以将元组的内容分解为单独的常量或变量，然后像往常一样访问： 12345let (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \\(statusCode)&quot;)// Prints &quot;The status code is 404&quot;print(&quot;The status message is \\(statusMessage)&quot;)// Prints &quot;The status message is Not Found&quot; 如果您只需要元组的一些值，请在分解元组时忽略带下划线（_）的元组部分： 123let (justTheStatusCode, _) = http404Errorprint(&quot;The status code is \\(justTheStatusCode)&quot;)// Prints &quot;The status code is 404&quot; 或者，使用从零开始的索引号访问元组中的单个元素值： 1234print(&quot;The status code is \\(http404Error.0)&quot;)// Prints &quot;The status code is 404&quot;print(&quot;The status message is \\(http404Error.1)&quot;)// Prints &quot;The status message is Not Found&quot; 当定义元组时，您可以命名元组中的单个元素： 1let http200Status = (statusCode: 200, description: &quot;OK&quot;) 如果您命名元组中的元素，则可以使用元素名称访问这些元素的值： 1234print(&quot;The status code is \\(http200Status.statusCode)&quot;)// Prints &quot;The status code is 200&quot;print(&quot;The status message is \\(http200Status.description)&quot;)// Prints &quot;The status message is OK&quot; 元组作为函数的返回值特别有用。尝试检索网页的函数可能会返回(Int,String)元组类型，以描述页面检索的成功或失败。通过返回具有两个不同值的元组，每个值都具有不同的类型，该函数提供了有关其结果的更有用的信息，而不是只能返回单个类型的单个值。有关更多信息，请参阅具有多个返回值的函数。 注意 元组对简单的相关值组非常有用。它们不适合创建复杂的数据结构。如果您的数据结构可能更复杂，请将其建模为类或结构，而不是元组。有关更多信息，请参阅结构和类。 可选在值可能不存在的情况下，您可以使用可选选项。可选代表两种可能性：要么有一个值，你可以解开可选值来访问该值，要么根本没有值。 注意 C或Objective-C中不存在可选概念。Objective-C中最近的东西是能够从否则会返回对象的方法返回nil，nil的意思是“没有有效的对象”。然而，这仅适用于对象，不适用于结构、基本C类型或枚举值。对于这些类型，Objective-C方法通常会返回一个特殊值（如NSNotFound），以指示没有值。这种方法假设方法的调用者知道有一个特殊值需要测试，并记得检查它。Swift的可选选项允许您指示任何类型的值，而无需特殊常量。 以下是如何使用可选选项来应对值缺失的示例。Swift的sInt类型有一个初始化器，尝试将String值转换为Int值。然而，并非每个字符串都可以转换为整数。字符串&quot;123&quot;可以转换为数字值123，但字符串&quot;hello,world&quot;没有明显的数字值可以转换到。 下面的示例使用初始化器尝试将String转换为Int： 123let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber)// convertedNumber is inferred to be of type &quot;Int?&quot;, or &quot;optional Int&quot; 由于初始化器可能会失败，它返回一个可选的Int，而不是一个Int。可选的Int写成Int?，而不是Int。问号表示它包含的值是可选的，这意味着它可能包含一些Int值，或者它可能根本不包含任何值。（它不能包含任何其他内容，例如Bool值或String值。它要么是Int，要么什么都不是。） nil您可以通过为特殊值nil将其设置为无值状态的可选变量： 1234var serverResponseCode: Int? = 404// serverResponseCode contains an actual Int value of 404serverResponseCode = nil// serverResponseCode now contains no value 注意 您不能将nil与非可选常量和变量一起使用。如果代码中的常量或变量在某些条件下需要在没有值的情况下工作，请始终将其声明为适当类型的可选值。 如果您在不提供默认值的情况下定义可选变量，该变量将自动设置为nil： 12var surveyAnswer: String?// surveyAnswer is automatically set to nil 注意 Swift的“nil”和Objective-C中的“nil”不一样。在Objective-C中，’ nil ‘是一个指向不存在对象的指针。在Swift中，’ nil ‘不是一个指针——它是一个特定类型的值的缺失。任何类型的可选参数都可以设置为nil，而不仅仅是对象类型。 如果陈述和强制打开包装你可以使用’ if ‘语句，通过比较可选的和’ nil ‘来确定可选的是否包含一个值。可以使用“等于”操作符(‘ &#x3D;&#x3D; ‘)或“不等于”操作符(‘ !&#x3D; ‘)执行此比较。 如果可选选项具有值，则将其视为“不等于”nil： 1234if convertedNumber != nil &#123; print(&quot;convertedNumber contains some integer value.&quot;)&#125;// Prints &quot;convertedNumber contains some integer value.&quot; 一旦您确定可选内容确实包含一个值，您可以通过添加感叹号来访问其基础值（!）直到可选名称的末尾。感叹号有效地说：“我知道这个可选肯定有价值；请使用它。”这被称为强制打开可选值： 1234if convertedNumber != nil &#123; print(&quot;convertedNumber has an integer value of \\(convertedNumber!).&quot;)&#125;// Prints &quot;convertedNumber has an integer value of 123.&quot; 有关if语句的更多信息，请参阅控制流。 注意 尝试使用!访问不存在的可选值会触发运行时错误。在使用之前，请务必确保可选选项包含非nil值!强行打开它的价值。 可选绑定你可以使用可选绑定来确定一个可选绑定是否包含一个值，如果是，则将该值用作临时常量或变量。可选绑定可以与’ if ‘和’ while ‘语句一起使用，以检查可选绑定中的值，并将该值提取到一个常量或变量中，作为单个操作的一部分。“if”和“while”语句在Control Flow中有更详细的描述。 为if语句编写可选绑定，如下所示： 123if let constantName = someOptional &#123; statements&#125; 您可以从可选部分重写possibleNumber示例，以使用可选绑定而不是强制展开包装： 123456if let actualNumber = Int(possibleNumber) &#123; print(&quot;The string \\&quot;\\(possibleNumber)\\&quot; has an integer value of \\(actualNumber)&quot;)&#125; else &#123; print(&quot;The string \\&quot;\\(possibleNumber)\\&quot; couldn&#x27;t be converted to an integer&quot;)&#125;// Prints &quot;The string &quot;123&quot; has an integer value of 123&quot; 此代码可以读作： “如果Int(possibleNumber)返回的可选Int包含一个值，请将名为actualNumber的新常量设置为可选值。” 如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经用可选中包含的值初始化，因此您不使用!后缀以访问其值。在本例中，actualNumber仅用于打印转换结果。 可以使用带有可选绑定的常量和变量。如果你想在’ If ‘语句的第一个分支中操作’ actualNumber ‘的值，你可以写’ If var actualNumber ‘代替，而包含在可选的值将作为一个变量而不是一个常量可用。 您可以根据需要在单个if语句中包含尽可能多的可选绑定和布尔条件，并用逗号分隔。如果可选绑定中的任何值为nil，或者任何布尔条件计算为false，则整个if语句的条件被视为false。if陈述等效，请按以下方式处理： 12345678910111213if let firstNumber = Int(&quot;4&quot;), let secondNumber = Int(&quot;42&quot;), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print(&quot;\\(firstNumber) &lt; \\(secondNumber) &lt; 100&quot;)&#125;// Prints &quot;4 &lt; 42 &lt; 100&quot;if let firstNumber = Int(&quot;4&quot;) &#123; if let secondNumber = Int(&quot;42&quot;) &#123; if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print(&quot;\\(firstNumber) &lt; \\(secondNumber) &lt; 100&quot;) &#125; &#125;&#125;// Prints &quot;4 &lt; 42 &lt; 100 注意 在if语句中使用可选绑定创建的常量和变量仅在if语句的正文中可用。相比之下，使用guard语句创建的常量和变量可以在guard语句后面的代码行中找到，如Early Exit所述。 隐式拆开的可选如上所述，可选表示允许常量或变量“无值”。可选选项可以用if语句检查，看看是否存在值，并且可以使用可选绑定有条件地展开，以访问可选值（如果存在）。 有时，从程序的结构中可以清楚地看到，在首次设置该值后，可选值将始终具有该值。在这些情况下，每次访问可选值时，无需检查和打开其值，因为可以安全地假设它一直具有值。 这些类型的可选选项被定义为隐式未包装的可选选项。您通过放置感叹号（String!）来编写隐式打开的可选选项而不是问号（String?）在您想要选择的类型之后。使用时，不要在可选名称后放置感叹号，而是在声明选项类型后放置感叹号。 当可选值在首次定义可选后立即确认存在时，隐式未包装的可选值非常有用，并且可以肯定可以假设在此后的每个点都存在。Swift中隐式未包装的可选选项的主要用途是在类初始化期间，如Unowned References和Imlicitly Unwrapped Optional Properties中所述。 隐式展开的可选选项是幕后正常的可选选项，但也可以像非可选值一样使用，而无需每次访问时解开可选值。以下示例显示了可选字符串和隐式未包装的可选字符串在以显式String的形式访问其包装值时的行为差异： 12345let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // 需要一个感叹号let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString // 不需要感叹号 您可以将隐式解封的可选选项视为在需要时强制打开可选选项。当您使用隐式展开的可选值时，Swift首先尝试将其用作普通的可选值；如果不能用作可选值，Swift将强制解开该值。在上面的代码中，可选值 assumedString在将其值分配给implicitString之前被强制解开，因为implicitString具有显式、非可选类型的String。在下面的代码中，optionalString没有显式类型，因此它是普通的可选。 12let optionalString = assumedString// optionalString的类型是“String?”，而assumedString不强制解包装。 如果隐式解包的可选选项为nil，并且您尝试访问其包装值，您将触发运行时错误。结果与您在不包含值的正常可选选项后放置感叹号完全相同。 您可以检查隐式未包装的可选选项是否为nil，就像检查正常可选选项一样： 1234if assumedString != nil &#123; print(assumedString!)&#125;// Prints &quot;隐式解除包装的可选字符串。&quot; 您还可以使用带有可选绑定的隐式解包装可选选项，在单个语句中检查和解包装其值： 1234if let definiteString = assumedString &#123; print(definiteString)&#125;// Prints &quot;An implicitly unwrapped optional string.&quot; 注意 当变量以后可能变成nil，不要使用隐式未包装的可选选项。如果您需要在变量生命周期内检查nil值，请始终使用正常的可选类型。 错误处理您使用错误处理来响应程序在执行过程中可能遇到的错误条件。 与可选选项不同，后者可以使用值的存在或不存在来传达函数的成功或失败，与之相反，错误处理允许您确定失败的根本原因，并在必要时将错误传播到程序的另一部分。 当函数遇到错误条件时，它会抛出错误。然后，该函数的调用者可以捕获错误并做出适当的响应。 123func canThrowAnError() throws &#123; // 这个函数可能抛出错误，也可能不抛出错误&#125; 函数表示可以通过在其声明中包含throws关键字来抛出错误。当您调用可以抛出错误的函数时，您将try关键字之前置于表达式。 Swift会自动将错误传播到当前范围之外，直到它们由catch子句处理。 123456do &#123; try canThrowAnError() // no error was thrown&#125; catch &#123; // an error was thrown&#125; do语句创建一个新的包含范围，允许将错误传播到一个或多个catch子句。 以下是如何使用错误处理来响应不同错误条件的示例： 123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 在本例中，如果没有干净的菜肴或缺少任何成分，makeASandwich()函数将抛出错误。由于makeASandwich()可以抛出错误，函数调用被包装在try表达式中。通过将函数调用包装在do语句中，抛出的任何错误都将传播到提供的catch子句。 如果没有抛出错误，则调用eatASandwich()函数。如果抛出错误，并且与SandwichError.outOfCleanDishes情况匹配，则将调用washDishes()函数。如果抛出错误，并且它与SandwichError.missingIngredients的情况匹配，则使用catch模式捕获的关联[String]值调用buyGroceries(_:)函数。 错误处理中更详细地介绍了抛出、捕获和传播错误。 断言和先决条件断言和先决条件是在运行时发生的检查。在执行任何进一步的代码之前，您可以使用它们来确保满足基本条件。如果断言或先决条件中的布尔条件计算为true，则代码执行将照常继续。如果条件计算为false，则程序的当前状态无效；代码执行结束，您的应用程序被终止。 您使用断言和先决条件来表达您在编码时所做的假设和期望，因此您可以将它们包含在代码中。断言可帮助您在开发过程中发现错误和错误的假设，先决条件可帮助您检测生产中的问题。 除了在运行时验证您的期望外，断言和先决条件也成为代码中有用的文档形式。与上面错误处理中讨论的错误条件不同，断言和先决条件不用于可恢复或预期错误。由于失败的断言或先决条件表示无效的程序状态，因此无法捕获失败的断言。 使用断言和先决条件不能替代以不太可能出现无效条件的方式设计代码。然而，使用它们来强制执行有效数据和状态会导致您的应用程序在发生无效状态时更可预测地终止，并有助于使问题更容易调试。一旦检测到无效状态就停止执行也有助于限制该无效状态造成的损害。 断言和先决条件之间的区别在于它们被检查时：断言仅在调试构建中检查，但先决条件在调试和生产构建中都被检查。在生产构建中，不评估断言中的条件。这意味着您可以在开发过程中使用任意数量的断言，而不会影响生产性能。 使用断言进行调试您通过从Swift标准库调用assert(_:_:file:line:)函数来编写断言。您传递此函数，一个计算为true或false表达式，如果条件的结果为false，则显示一条消息。例如： 123let age = -3assert(age &gt;= 0, &quot;A person&#x27;s age can&#x27;t be less than zero.&quot;)// 这个断言失败，因为-3不是&gt;= 0。 在本例中，如果’ age &gt;&#x3D; 0 ‘的值为’ true ‘，也就是说，如果’ age ‘的值是非负的，则代码继续执行。如果’ age ‘的值为负值，如上面的代码所示，那么’ age &gt;&#x3D; 0 ‘的计算结果为’ false ‘，断言将失败，从而终止应用程序。 您可以省略断言消息——例如，当它只是作为散文重复条件时。 1assert(age &gt;= 0) 如果代码已经检查了条件，则使用‘ assertionFailure(:file:line:) ‘function表示断言失败。例如: 1234567if age &gt; 10 &#123; print(&quot;You can ride the roller-coaster or the ferris wheel.&quot;)&#125; else if age &gt;= 0 &#123; print(&quot;You can ride the ferris wheel.&quot;)&#125; else &#123; assertionFailure(&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;)&#125; 执行先决条件每当条件可能为假时，请使用先决条件，但您的代码必须是真的才能继续执行。例如，使用先决条件检查下标没有越界，或检查函数是否传递了有效值。 您可以通过调用precondition(_:_:file:line:)函数编写先决条件。您传递此函数，一个计算为true或false表达式，如果条件的结果为false，则显示一条消息。例如： 12// 在下标的实现中…precondition(index &gt; 0, &quot;Index must be greater than zero.&quot;) 您还可以调用preconditionFailure(_:file:line:)函数来指示发生了故障——例如，如果采用了交换机的默认情况，但所有有效的输入数据都应该由交换机的其他情况之一处理。 注意 如果您以未选中模式（-Ounchecked编译，则不会检查先决条件。编译器假设先决条件始终为真，并相应地优化您的代码。然而，无论优化设置如何，thefatalErrorfatalError(_:file:line:)函数总是停止执行。 您可以在原型和早期开发期间使用fatalError(_:file:line:)函数，通过编写fatalError(&quot;Unimplemented&quot;)作为存根实现，为尚未实现的功能创建存根。由于致命错误永远不会被优化，与断言或先决条件不同，您可以确保如果遇到存根实现，执行总是会停止。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 字符串和字符","slug":"软件开发/技术/编程语言/swift/Swift基础-字符串和字符","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-字符串和字符/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html 字符串是一系列角色，如&quot;hello,world&quot;或&quot;albatross&quot;Swift字符串由String类型表示。String的内容可以通过各种方式访问，包括作为Character值的集合。 Swift的String和Character类型提供了一种快速、符合Unicode的方式来处理代码中的文本。字符串创建和操作的语法轻巧且可读，字符串文字语法与C相似。字符串串联就像将两个字符串与+运算符组合在一起一样简单，字符串的可变性通过在常量或变量之间进行选择来管理，就像Swift中的任何其他值一样。您还可以使用字符串将常量、变量、文字和表达式插入较长的字符串中，该过程称为字符串插值。这样可以轻松创建用于显示、存储和打印的自定义字符串值。 尽管语法简单，但Swift的String类型是一个快速、现代的字符串实现。每个字符串都由独立于编码的Unicode字符组成，并支持在各种Unicode表示中访问这些字符。 注意 Swift的String类型与Foundation的NSString类桥接。Foundation还扩展了String，以公开NSString定义的方法。这意味着，如果您导入Foundation，您可以在String上访问这些NSString方法，而无需铸造。 有关将String与Foundation和Cocoa一起使用的更多信息，请参阅String和NSString之间的桥接。 弦文学您可以在代码中包含预定义的String值作为字符串文字。字符串文字是用双引号包围的字符序列（“）。 使用字符串文字作为常量或变量的初始值： 1let someString = &quot;Some string literal value&quot; 请注意，Swift推断出someString常量的String类型，因为它是用字符串字面值初始化的。 多行字符串文字如果您需要一个跨越几行的字符串，请使用多行字符串文字——一个由三个双引号包围的字符序列： 1234567let quotation = &quot;&quot;&quot;The White Rabbit put on his spectacles. &quot;Where shall I begin,please your Majesty?&quot; he asked.&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go ontill you come to the end; then stop.&quot;&quot;&quot;&quot; 多行字符串文字包括其开头和结尾引号之间的所有行。字符串在开头引号（“”）后的第一行开始，在结束引号之前的一行结束，这意味着下面的字符串都没有以换行符开头或结束： 1234let singleLineString = &quot;These are the same.&quot;let multilineString = &quot;&quot;&quot;These are the same.&quot;&quot;&quot; 当您的源代码在多行字符串文字中包含换行符时，该换行符也会出现在字符串的值中。如果您想使用换行符使源代码更容易阅读，但不希望换行符成为字符串值的一部分，请在这些行末尾写一个反斜杠（\\）： 1234567let softWrappedQuotation = &quot;&quot;&quot;The White Rabbit put on his spectacles. &quot;Where shall I begin, \\please your Majesty?&quot; he asked.&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on \\till you come to the end; then stop.&quot;&quot;&quot;&quot; 要制作以行提要开头或结尾的多行字符串文字，请写一行作为第一行或最后一行。例如： 123456let lineBreaks = &quot;&quot;&quot;This string starts with a line break.It also ends with a line break.&quot;&quot;&quot; 可以缩进多行字符串以匹配周围的代码。结尾引号（“”）前的空格告诉Swift在所有其他行之前要忽略哪个空格。但是，如果您在行的开头写空格，除了结束引号之前的内容外，则该空格也包括在内。 在上面的示例中，即使整个多行字符串文字缩进，字符串中的第一行和最后一行也不会以任何空格开头。中间线的缩进比结束引号更多，所以它从额外的四空格缩进开始。 文字中的特殊字符字符串文字可以包括以下特殊字符： 转义的特殊字符\\0（空字符）、\\\\（反斜杠）、\\t（水平选项卡）、\\n（行馈送）、\\r（回车）、\\&quot;（双引号）和\\&#39;（单引号） 一个任意的Unicode标量值，写为\\u&#123;n&#125;，其中n是一个1-8位十六进制数字（Unicode在下面的Unicode中讨论） 下面的代码显示了这些特殊字符的四个示例。wiseWords常数包含两个转义的双引号。dollarSign、blackHeart和sparklingHeart常量演示了Unicode标量格式： 12345let wiseWords = &quot;\\&quot;Imagination is more important than knowledge\\&quot; - Einstein&quot;// &quot;Imagination is more important than knowledge&quot; - Einsteinlet dollarSign = &quot;\\u&#123;24&#125;&quot; // $, Unicode scalar U+0024let blackHeart = &quot;\\u&#123;2665&#125;&quot; // ♥, Unicode scalar U+2665let sparklingHeart = &quot;\\u&#123;1F496&#125;&quot; // 💖, Unicode scalar U+1F496 由于多行字符串文字使用三个双引号，而不仅仅是一个，因此您可以在多行字符串文字中包含一个双引号（”）而不逃避它。要在多行字符串中包含文本&quot;&quot;&quot;请至少转义一个引号。例如： 1234let threeDoubleQuotationMarks = &quot;&quot;&quot;Escaping the first quotation mark \\&quot;&quot;&quot;Escaping all three quotation marks \\&quot;\\&quot;\\&quot;&quot;&quot;&quot; 扩展字符串分隔符你可以在扩展分隔符中放置一个字符串字面值，以包含字符串中的特殊字符而不调用它们的效果。将字符串放在引号( &quot; )内，然后用数字符号( # )包围它。例如，打印字符串字面量 #&quot;Line 1\\nLine 2&quot;# 将打印换行转义序列( \\n )，而不是跨两行打印字符串。 如果您需要字符串字面量中的字符的特殊效果，请匹配转义字符(\\ ‘)之后字符串中的数字符号的数量。例如，如果你的字符串是#”Line 1\\nLine 2”# ‘，而你想要换行，你可以使用#”Line 1#nLine 2”# ‘代替。类似地，“###”Line1###nLine2“###”也会断行。 使用扩展分隔符创建的字符串文字也可以是多行字符串文字。您可以使用扩展分隔符将文本&quot;&quot;&quot;包含在多行字符串中，覆盖结束文字的默认行为。例如： 123let threeMoreDoubleQuotationMarks = #&quot;&quot;&quot;Here are three more double quotes: &quot;&quot;&quot;&quot;&quot;&quot;# 初始化空字符串要创建一个空String值作为构建较长字符串的起点，请为变量分配空字符串文字，或使用初始化器语法初始化新的String实例： 123var emptyString = &quot;&quot; // empty string literalvar anotherEmptyString = String() // initializer syntax// these two strings are both empty, and are equivalent to each other 通过检查isEmpty ‘属性来确定String ‘值是否为空: 1234if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125;// Prints &quot;Nothing to see here&quot; 字符串可变性您指示是否可以通过将特定String分配给变量（在这种情况下可以修改）或常量（在这种情况下无法修改）来修改（或突变）： 1234567var variableString = &quot;Horse&quot;variableString += &quot; and carriage&quot;// variableString is now &quot;Horse and carriage&quot;let constantString = &quot;Highlander&quot;constantString += &quot; and another Highlander&quot;// this reports a compile-time error - a constant string cannot be modified 注意 这种方法不同于Objective-C和Cocoa中的字符串突变，在这两个类（NSString和NSMutableString）之间进行选择，以指示字符串是否可以突变。 字符串是值类型Swift的String类型是一种值类型。如果您创建新的String值，则该String值在传递给函数或方法时，或分配给常量或变量时将被复制。在每种情况下，都会创建现有String值的新副本，并传递或分配新副本，而不是原始版本。值类型在结构中描述，枚举是值类型。 Swift的默认复制String行为确保当函数或方法向您传递String值时，很明显，无论它来自哪里，您都拥有该确切的String值。您可以放心，除非您自己修改，否则传递的字符串不会被修改。 在幕后，Swift的编译器优化了字符串使用，因此只有在绝对必要的情况下才能进行实际复制。这意味着在将字符串作为值类型使用时，您总是会获得出色的性能。 与角色合作您可以通过使用for-in循环迭代字符串来访问String的单个Character值： 12345678for character in &quot;Dog!🐶&quot; &#123; print(character)&#125;// D// o// g// !// 🐶 for-in循环在For-In循环中描述。 或者，您可以通过提供Character类型注释从单个字符字符串文字中创建独立的Character常量或变量： 1let exclamationMark: Character = &quot;!&quot; String可以通过将Character值数组作为参数传递给其初始化器来构建值： 1234let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]let catString = String(catCharacters)print(catString)// Prints &quot;Cat!🐱&quot; 串联字符串和字符String值可以与加法运算符（+）一起添加（或串联），以创建新的String值： 1234let string1 = &quot;hello&quot;let string2 = &quot; there&quot;var welcome = string1 + string2// welcome now equals &quot;hello there&quot; 您还可以使用加法赋值运算符（+=) String值附加到现有的String变量： 123var instruction = &quot;look over&quot;instruction += string2// instruction now equals &quot;look over there&quot; 您可以使用String类型的append()方法将Character值附加到String变量： 123let exclamationMark: Character = &quot;!&quot;welcome.append(exclamationMark)// welcome now equals &quot;hello there!&quot; 注意 您无法将String或Character附加到现有Character变量，因为Character值必须仅包含单个字符。 如果您使用多行字符串文字来构建较长字符串的行，则希望字符串中的每行都以换行符结束，包括最后一行。例如： 12345678910111213141516171819202122let badStart = &quot;&quot;&quot;onetwo&quot;&quot;&quot;let end = &quot;&quot;&quot;three&quot;&quot;&quot;print(badStart + end)// Prints two lines:// one// twothreelet goodStart = &quot;&quot;&quot;onetwo&quot;&quot;&quot;print(goodStart + end)// Prints three lines:// one// two// three 在上面的代码中，将badStart与end连接会产生一个两行字符串，这不是所需的结果。由于badStart的最后一行不会以换行符结束，因此该行与第一行end相结合。相比之下，两条goodStart线都以换行符结束，因此当它与end相结合时，结果有三条线，正如预期的那样。 字符串插值字符串插值是一种通过将常量、变量、文字和表达式的值包含在字符串文字中来构建新String值的方法。您可以在单行和多行字符串文字中使用字符串插值。您插入字符串文字的每个项目都包裹在一对括号中，前缀为反斜杠（\\）： 123let multiplier = 3let message = &quot;\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)&quot;// message is &quot;3 times 2.5 is 7.5&quot; 在上面的示例中，multiplier的值被插入字符串文字为\\(multiplier)当计算字符串插值以创建实际字符串时，此占位符将被multiplier的实际值取代。 multiplier 的值也是字符串后面更大的表达式的一部分。这个表达式计算 Double(multiplier) * 2.5 的值，并将结果( 7.5 )插入到字符串中。在本例中，当表达式包含在字符串字面值中时，它被写成\\(Double(multiplier) * 2.5) 。 您可以使用扩展字符串分隔符创建包含字符的字符串，否则这些字符将被视为字符串插值。例如： 12print(#&quot;Write an interpolated string in Swift using \\(multiplier).&quot;#)// Prints &quot;Write an interpolated string in Swift using \\(multiplier).&quot; 要在使用扩展分隔符的字符串中使用字符串插值，请将反斜杠后的数字符号数量与字符串开头和结尾的数字符号数量匹配。例如： 12print(#&quot;6 times 7 is \\#(6 * 7).&quot;#)// Prints &quot;6 times 7 is 42.&quot; 注意 您在插值字符串括号内写的表达式不能包含未转义反斜杠（\\）、回车或行馈送。然而，它们可以包含其他字符串文字。 UnicodeUnicode是在不同书写系统中编码、表示和处理文本的国际标准。它使您能够以标准化的形式表示来自任何语言的几乎任何字符，并从外部来源（如文本文件或网页）读取和写入这些字符。如本节所述，Swift的String和Character类型完全符合Unicode。 Unicode标量值在幕后，Swift的原生 String 类型是由Unicode标量值构建的。Unicode标量值是字符或修饰符的唯一21位数字，例如’ U+0061 表示’拉丁小写字母A ( “ A “)，或 U+1F425 表示正面的BABY CHICK ( “🐥”)。 请注意，并非所有21位Unicode标量值都分配给一个字符——一些标量保留用于未来的分配或用于UTF-16编码。分配给字符的标量值通常也有一个名称，例如上面示例中的LATINSMALLLETTERA和FRONT-FACINGBABY。 扩展的语法集群SwiftCharacter类型的每个实例都代表一个扩展的字素集群。扩展字素集群是一个或多个Unicode标量的序列，（当组合时）产生单个人类可读字符。 这是一个例子。字母 é 可以表示为单个Unicode标量 é ( 拉丁小写字母E WITH ACUTE ，或’ U+00E9 ‘)。然而，同样的字母也可以表示为一对标量——一个标准字母 e (拉丁小写字母e ，或’ U+0065 ‘)，后面跟着一个组合急性重音标量( U+0301 )。 combined ACUTE ACCENT 标量图形化地应用于它前面的标量，当一个支持unicode的文本呈现系统呈现一个 e 时，它就会变成一个’ é ‘。 在这两种情况下，字母é都表示为单个SwiftCharacter值，表示扩展的字素集群。在第一种情况下，集群包含单个标量；在第二种情况下，它是一个由两个标量组成的集群： 123let eAcute: Character = &quot;\\u&#123;E9&#125;&quot; // élet combinedEAcute: Character = &quot;\\u&#123;65&#125;\\u&#123;301&#125;&quot; // e followed by ́// eAcute is é, combinedEAcute is é 扩展字素集群是一种灵活的方式，可以将许多复杂的脚本字符表示为单个Character值。例如，韩语字母的韩语音节可以表示为预写或分解序列。这两种表示形式都符合 Swift 中的单个Character值： 123let precomposed: Character = &quot;\\u&#123;D55C&#125;&quot; // 한let decomposed: Character = &quot;\\u&#123;1112&#125;\\u&#123;1161&#125;\\u&#123;11AB&#125;&quot; // ᄒ, ᅡ, ᆫ// precomposed is 한, decomposed is 한 扩展的字素集群使用于封闭标记的标量（如COMBININGENCLOSINGCIRCLE或U+20DD）能够将其他Unicode标量作为单个Character值的一部分包围： 12let enclosedEAcute: Character = &quot;\\u&#123;E9&#125;\\u&#123;20DD&#125;&quot;// enclosedEAcute is é⃝ 区域指标符号的Unicode标量可以成对组合，形成单个Character值，例如REGIONALINDICATORSYMBOLLETTERU（U+1F1FA）REGIONALINDICATORSYMBOLLETTERS（U+1F1F8的组合： 12let regionalIndicatorForUS: Character = &quot;\\u&#123;1F1FA&#125;\\u&#123;1F1F8&#125;&quot;// regionalIndicatorForUS is 🇺🇸 计数字符要检索字符串中Character值的计数，请使用字符串的count属性： 123let unusualMenagerie = &quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;print(&quot;unusualMenagerie has \\(unusualMenagerie.count) characters&quot;)// Prints &quot;unusualMenagerie has 40 characters&quot; 请注意，Swift对Character值使用扩展字素簇意味着字符串串联和修改可能并不总是影响字符串的字符数。 例如，如果您使用四个字符的单词cafe初始化新字符串，然后在字符串末尾附加COMBININGACUTEACCENT（U+0301），则生成的字符串仍将有4个字符数，第四个字符为é，而不是e： 12345678var word = &quot;cafe&quot;print(&quot;the number of characters in \\(word) is \\(word.count)&quot;)// Prints &quot;the number of characters in cafe is 4&quot;word += &quot;\\u&#123;301&#125;&quot; // COMBINING ACUTE ACCENT, U+0301print(&quot;the number of characters in \\(word) is \\(word.count)&quot;)// Prints &quot;the number of characters in café is 4&quot; 注意 扩展的字素集群可以由多个Unicode标量组成。这意味着不同的字符——以及同一字符的不同表示形式——可能需要不同数量的内存来存储。因此，Swift中的字符在字符串表示中不会各自占用相同数量的内存。因此，如果不迭代字符串以确定其扩展的字素集群边界，就无法计算字符串中的字符数。如果您正在处理特别长的字符串值，请注意count属性必须迭代整个字符串中的Unicode标量，以确定该字符串的字符。 count属性返回的字符计数并不总是与包含相同字符的NSString的length属性相同。NSString的长度基于字符串UTF-16表示中的16位代码单元数量，而不是字符串中Unicode扩展字素集群的数量。 访问和修改字符串您可以通过字符串的方法和属性或使用下标语法访问和修改字符串。 字符串索引每个String值都有一个关联的索引类型String.Index，对应于字符串中每个Character的位置。 如上所述，不同的字符可能需要不同数量的内存来存储，因此为了确定哪个Character位于特定位置，您必须从该String的开头或结尾迭代每个Unicode标量。因此，Swift字符串无法按整数值进行索引。 使用startIndex属性访问String的第一个Character的位置。TheendIndex属性是String中最后一个字符后的位置。因此，endIndex属性不是字符串下标的有效参数。如果String为空，startIndex和endIndex是相等的。 您可以使用String的index(before:)和index(after:)方法访问给定索引之前和之后的索引。要访问离给定索引更远的索引，您可以使用index(_:offsetBy:)方法，而不是多次调用这些方法之一。 您可以使用下标语法访问特定String索引的Character。 12345678910let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// a 尝试访问字符串范围之外的索引或字符串范围之外的索引中的Character将触发运行时错误。 12greeting[greeting.endIndex] // Errorgreeting.index(after: greeting.endIndex) // Error 使用indices属性访问字符串中单个字符的所有索引。 1234for index in greeting.indices &#123; print(&quot;\\(greeting[index]) &quot;, terminator: &quot;&quot;)&#125;// Prints &quot;G u t e n T a g ! &quot; 注意 您可以在符合Collection协议的任何类型上使用startIndex和endIndex属性以及index(before:) index(after:)和index(_:offsetBy:)方法。这包括String，如图所示，以及集合类型，如数Array、Dictionary和Set。 插入和移除要在指定索引处将单个字符插入字符串，请使用insert(_:at:)方法，要在指定索引处插入另一个字符串的内容，请使用insert(contentsOf:at:)方法。 123456var welcome = &quot;hello&quot;welcome.insert(&quot;!&quot;, at: welcome.endIndex)// welcome now equals &quot;hello!&quot;welcome.insert(contentsOf: &quot; there&quot;, at: welcome.index(before: welcome.endIndex))// welcome now equals &quot;hello there!&quot; 要在指定索引处从字符串中删除单个字符，请使用remove(at:)方法，要删除指定范围内的子字符串，请使用removeSubrange(_:)方法： 123456welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome now equals &quot;hello there&quot;let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome now equals &quot;hello&quot; 注意 你可以使用’ insert(:at:) ‘， ‘ insert(contentsOf:at:) ‘， ‘ remove(at:) ‘和’ removeSubrange(:) ‘方法来处理任何符合’ RangeReplaceableCollection ‘协议的类型。这包括如下所示的’ String ‘，以及’ Array ‘、’ Dictionary ‘和’ Set ‘等集合类型。 子字符串当您从字符串（例如，使用下标或类似prefix(_:)的方法获得子字符串时，结果是Substring的实例，而不是另一个字符串。Swift中的子字符串具有大多数与字符串相同的方法，这意味着您可以像处理字符串一样使用子字符串。然而，与字符串不同，您在对字符串执行操作时仅使用子字符串的时间很短。当您准备将结果存储更长时间时，您将子字符串转换为String实例。例如： 1234567let greeting = &quot;Hello, world!&quot;let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning is &quot;Hello&quot;// Convert the result to a String for long-term storage.let newString = String(beginning) 与字符串一样，每个子字符串都有一个内存区域，其中存储了构成子字符串的字符。字符串和子字符串的区别在于，作为性能优化，子字符串可以重用用于存储原始字符串的部分内存，或用于存储另一个子字符串的部分内存。（字符串具有类似的优化，但如果两个字符串共享内存，它们是相等的。）这种性能优化意味着，在您修改字符串或子字符串之前，您不必支付复制内存的性能成本。如上所述，子字符串不适合长期存储——因为它们重用原始字符串的存储，只要使用其任何子字符串，整个原始字符串都必须保存在内存中。 在上面的示例中，greeting是一个字符串，这意味着它有一个内存区域，其中存储了构成字符串的字符。因为beginning是greeting的子字符串，所以它重用greeting使用的记忆。相比之下，newString是一个字符串——当它从子字符串创建时，它有自己的存储空间。下图显示了这些关系： 注意 String和Substring都符合StringProtocol协议，这意味着字符串操作函数通常可以方便地接受StringProtocol值。您可以使用String或Substring值调用此类函数。 比较字符串Swift提供了三种比较文本值的方法：字符串和字符平等、前缀平等和后缀平等。 弦乐和性格平等字符串和字符相等性与“等于”运算符（==和“不等于”运算符（!=），如比较运算符中所述： 123456let quotation = &quot;We&#x27;re a lot alike, you and I.&quot;let sameQuotation = &quot;We&#x27;re a lot alike, you and I.&quot;if quotation == sameQuotation &#123; print(&quot;These two strings are considered equal&quot;)&#125;// Prints &quot;These two strings are considered equal&quot; 如果扩展的字素簇在正典上等价，则两个String值（或两个Character值）被认为是相等的。如果扩展的字素簇具有相同的语言意义和外观，即使它们是由幕后不同的Unicode标量组成的，它们在规范上也是等价的。 例如，拉丁小写字母E加急音(U+00E9) 在规范上等同于拉丁小写字母E(U+0065)后面跟着组合急音(U+0301)。这两个扩展的字素集群都是表示字符 é 的有效方法，因此它们被认为是规范等价的: 12345678910// &quot;Voulez-vous un café?&quot; using LATIN SMALL LETTER E WITH ACUTElet eAcuteQuestion = &quot;Voulez-vous un caf\\u&#123;E9&#125;?&quot;// &quot;Voulez-vous un café?&quot; using LATIN SMALL LETTER E and COMBINING ACUTE ACCENTlet combinedEAcuteQuestion = &quot;Voulez-vous un caf\\u&#123;65&#125;\\u&#123;301&#125;?&quot;if eAcuteQuestion == combinedEAcuteQuestion &#123; print(&quot;These two strings are considered equal&quot;)&#125;// Prints &quot;These two strings are considered equal&quot; 相反，英语中使用的LATINCAPITALLETTERA（U+0041或&quot;A&quot;不等同于俄语中使用的CYRILLICLETTERA（U+0410或&quot;А&quot;。这些角色在视觉上相似，但没有相同的语言含义： 12345678let latinCapitalLetterA: Character = &quot;\\u&#123;41&#125;&quot;let cyrillicCapitalLetterA: Character = &quot;\\u&#123;0410&#125;&quot;if latinCapitalLetterA != cyrillicCapitalLetterA &#123; print(&quot;These two characters aren&#x27;t equivalent.&quot;)&#125;// Prints &quot;These two characters aren&#x27;t equivalent.&quot; 注意 Swift 中的字符串和字符比较不区分区域设置。 前缀和后缀平等要检查字符串是否具有特定的字符串前缀或后缀，请调用string’shasPrefixhasPrefix(_:)和hasSuffix(_:)方法，这两种方法都采用typeString的单个参数并返回布尔值。 以下示例考虑了代表莎士比亚《罗密欧与朱丽叶》前两幕场景位置的一系列弦： 12345678910111213let romeoAndJuliet = [ &quot;Act 1 Scene 1: Verona, A public place&quot;, &quot;Act 1 Scene 2: Capulet&#x27;s mansion&quot;, &quot;Act 1 Scene 3: A room in Capulet&#x27;s mansion&quot;, &quot;Act 1 Scene 4: A street outside Capulet&#x27;s mansion&quot;, &quot;Act 1 Scene 5: The Great Hall in Capulet&#x27;s mansion&quot;, &quot;Act 2 Scene 1: Outside Capulet&#x27;s mansion&quot;, &quot;Act 2 Scene 2: Capulet&#x27;s orchard&quot;, &quot;Act 2 Scene 3: Outside Friar Lawrence&#x27;s cell&quot;, &quot;Act 2 Scene 4: A street in Verona&quot;, &quot;Act 2 Scene 5: Capulet&#x27;s mansion&quot;, &quot;Act 2 Scene 6: Friar Lawrence&#x27;s cell&quot;] 您可以使用hasPrefix(_:)方法与romeoAndJuliet数组一起计算该剧第1幕中的场景数量： 12345678var act1SceneCount = 0for scene in romeoAndJuliet &#123; if scene.hasPrefix(&quot;Act 1 &quot;) &#123; act1SceneCount += 1 &#125;&#125;print(&quot;There are \\(act1SceneCount) scenes in Act 1&quot;)// Prints &quot;There are 5 scenes in Act 1&quot; 同样，使用hasSuffix(_:)方法来计算卡普莱特豪宅和劳伦斯修士牢房内或周围发生的场景数量： 1234567891011var mansionCount = 0var cellCount = 0for scene in romeoAndJuliet &#123; if scene.hasSuffix(&quot;Capulet&#x27;s mansion&quot;) &#123; mansionCount += 1 &#125; else if scene.hasSuffix(&quot;Friar Lawrence&#x27;s cell&quot;) &#123; cellCount += 1 &#125;&#125;print(&quot;\\(mansionCount) mansion scenes; \\(cellCount) cell scenes&quot;)// Prints &quot;6 mansion scenes; 2 cell scenes&quot; 注意 hasPrefix(_:)和hasSuffix(_:)方法在每个字符串中的扩展字素簇之间执行逐个字符规范等价比较，如String和字符平等中所述。 字符串的Unicode表示当将Unicode字符串写入文本文件或其他存储时，该字符串中的Unicode标量将以几种Unicode定义的编码形式之一编码。每个表单都以称为代码单元的小块对字符串进行编码。这些包括UTF-8编码形式（将字符串编码为8位代码单元）、UTF-16编码形式（将字符串编码为16位代码单元）和UTF-32编码形式（将字符串编码为32位代码单元）。 Swift提供了几种不同的方式来访问字符串的Unicode表示形式。您可以使用in语句迭代字符串，以Unicode扩展字素集群的形式访问其单个Character值。这个过程在《处理角色》中进行了描述。 或者，在其他三种符合Unicode的表示形式之一中访问String值： UTF-8代码单元的集合（使用字符串的utf8属性访问） UTF-16代码单元的集合（使用字符串的utf16属性访问） 21位Unicode标量值的集合，相当于字符串的UTF-32编码形式（使用字符串的unicodeScalars属性访问） 下面的每个例子显示了以下字符串的不同表示形式，该字符串由字符D, o, g, ‼ (DOUBLE EXCLAMATION MARK, 或Unicode标量U+203C)，和🐶字符(‘ DOG FACE ‘，或Unicode标量’ U+1F436 ‘)组成: 1let dogString = &quot;Dog‼🐶&quot; UTF-8代表您可以通过迭代其utf8属性来访问String的UTF-8表示形式。此属性类型为String.UTF8View，这是无符号8位（UInt8）值的集合，字符串UTF-8表示中的每个字节一个： 12345for codeUnit in dogString.utf8 &#123; print(&quot;\\(codeUnit) &quot;, terminator: &quot;&quot;)&#125;print(&quot;&quot;)// Prints &quot;68 111 103 226 128 188 240 159 144 182 &quot; 在上面的例子中，前三个十进制’ codeUnit ‘值(‘ 68 ‘，’ 111 ‘，’ 103 ‘)表示字符’ D ‘， ‘ o ‘和’ g ‘，它们的UTF-8表示与它们的ASCII表示相同。接下来的三个十进制’ codeUnit ‘值(‘ 226 ‘，’ 128 ‘，’ 188 ‘)是’ DOUBLE感叹号’字符的三字节UTF-8表示。最后四个’ codeUnit ‘值(‘ 240 ‘，’ 159 ‘，’ 144 ‘，’ 182 ‘)是’ DOG FACE ‘字符的四字节UTF-8表示。 UTF-16代表您可以通过迭代其utf16属性来访问String的UTF-16表示形式。此属性类型为String.UTF16View，这是无符号16位（UInt16）值的集合，字符串UTF-16表示中的每个16位代码单元一个： 12345for codeUnit in dogString.utf16 &#123; print(&quot;\\(codeUnit) &quot;, terminator: &quot;&quot;)&#125;print(&quot;&quot;)// Prints &quot;68 111 103 8252 55357 56374 &quot; 同样，前三个codeUnit值（68、111、103）代表字符D、o和g，其UTF-16代码单元的值与字符串的UTF-8表示相同（因为这些Unicode标量代表ASCII字符）。 第四个codeUnit值（8252）是十六进制值203C的十进制，它表示DOUBLEEXCLAMATIONMARK字符的Unicode标量U+203C。此字符可以在UTF-16中表示为单个代码单元。 第5和第6个’ codeUnit ‘值(‘ 55357 ‘和’ 56374 ‘)是’ DOG FACE ‘字符的UTF-16代理对表示。这些值是高替代值‘U+D83D’(十进制值‘55357’)和低替代值‘U+DC36’(十进制值‘56374’)。 Unicode标量表示您可以通过迭代其unicodeScalars属性来访问String值的Unicode标量表示形式。此属性类型为UnicodeScalarView，这是UnicodeScalar类型的值集合。 每个UnicodeScalar都有一个value属性，返回标量的21位值，在UInt32值中表示： 12345for scalar in dogString.unicodeScalars &#123; print(&quot;\\(scalar.value) &quot;, terminator: &quot;&quot;)&#125;print(&quot;&quot;)// Prints &quot;68 111 103 8252 128054 &quot; 前三个UnicodeScalar值（68、111、103）的value属性再次表示字符D、o和g。 第四个codeUnit值（8252）再次等价于十六进制值203C，该值表示DOUBLEEXCLAMATION字符的Unicode标量U+203C。 The value property of the fifth and final UnicodeScalar, 128054, is a decimal equivalent of the hexadecimal value 1F436, which represents the Unicode scalar U+1F436 for the DOG FACEcharacter. 作为查询其value属性的替代方案，每个UnicodeScalar值也可以用于构建新的String值，例如字符串插值： 12345678for scalar in dogString.unicodeScalars &#123; print(&quot;\\(scalar) &quot;)&#125;// D// o// g// ‼// 🐶","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 属性","slug":"软件开发/技术/编程语言/swift/Swift基础-属性","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-属性/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%B1%9E%E6%80%A7/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Properties.html 属性将值与特定类、结构或枚举相关联。存储属性将常量和变量值存储为实例的一部分，而计算属性计算（而不是存储）值。计算属性由类、结构和枚举提供。存储属性仅由类和结构提供。 存储和计算属性通常与特定类型的实例相关联。然而，属性也可以与类型本身相关联。这些属性被称为类型属性。 此外，您可以定义属性观察器来监控属性值的变化，您可以通过自定义操作来响应。属性观察者可以添加到您自己定义的存储属性中，也可以添加到子类从其超类继承的属性中。 您还可以使用属性包装器在多个属性的获取器和设置器中重用代码。 存储的属性在最简单的形式中，存储属性是作为特定类或结构实例的一部分存储的常量或变量。存储属性可以是变量存储属性（由var关键字引入）或常量存储属性（由let关键字引入）。 您可以为存储属性提供默认值，作为其定义的一部分，如默认属性值中所述。您还可以在初始化期间设置和修改存储属性的初始值。即使是常量存储属性也是如此，如初始化期间分配常量属性中所述。 以下示例定义了一个名为FixedLengthRange的结构，该结构描述了创建后无法更改范围长度的整数范围： struct FixedLengthRange { ​ var firstValue: Int ​ let length: Int } var rangeOfThreeItems &#x3D; FixedLengthRange(firstValue: 0, length: 3) &#x2F;&#x2F; the range represents integer values 0, 1, and 2 rangeOfThreeItems.firstValue &#x3D; 6 &#x2F;&#x2F; the range now represents integer values 6, 7, and 8 FixedLengthRange的实例有一个名为firstValue变量存储属性和一个名为length的常量存储属性。在上面的示例中，length在创建新范围时初始化，此后无法更改，因为它是一个常量属性。 恒定结构实例的存储属性如果您创建结构实例并将该实例分配给常量，则无法修改实例的属性，即使它们被声明为变量属性： let rangeOfFourItems &#x3D; FixedLengthRange(firstValue: 0, length: 4) &#x2F;&#x2F; this range represents integer values 0, 1, 2, and 3 rangeOfFourItems.firstValue &#x3D; 6 &#x2F;&#x2F; this will report an error, even though firstValue is a variable property 由于rangeOfFourItems被声明为常量（使用let关键字），因此无法更改其firstValue属性，即使firstValue是一个变量属性。 这种行为是由于结构是值类型。当值类型的实例被标记为常量时，其所有属性也是如此。 类的情况并非如此，类是参考类型。如果您将引用类型的实例分配给常量，您仍然可以更改该实例的变量属性。 懒惰存储的房产惰性存储属性是直到首次使用时才计算初始值的属性。您可以通过在声明之前写入lazy修饰符来指示惰性存储属性。 注意 您必须始终将惰性属性声明为变量（使用var关键字），因为在实例初始化完成之前，可能无法检索其初始值。在初始化完成之前，常量属性必须始终具有值，因此不能声明为懒惰。 当属性的初始值依赖于外部因素时，懒惰属性非常有用，这些因素的值直到实例初始化完成后才知道。当属性的初始值需要复杂或计算昂贵的设置时，懒惰属性也很有用，除非或直到需要，否则不应执行。 下面的示例使用惰性存储属性来避免不必要的复杂类初始化。此示例定义了两个名为DataImporter和DataManager的类，这两个类都没有完整显示： class DataImporter { ​ &#x2F;* ​ DataImporter is a class to import data from an external file. ​ The class is assumed to take a nontrivial amount of time to initialize. ​ *&#x2F; ​ var filename &#x3D; “data.txt” ​ &#x2F;&#x2F; the DataImporter class would provide data importing functionality here } class DataManager { ​ lazy var importer &#x3D; DataImporter() ​ var data: [String] &#x3D; [] ​ &#x2F;&#x2F; the DataManager class would provide data management functionality here } let manager &#x3D; DataManager() manager.data.append(“Some data”) manager.data.append(“Some more data”) &#x2F;&#x2F; the DataImporter instance for the importer property hasn’t yet been created DataManager类有一个名为data的存储属性，该属性使用一个新的空String值数组初始化。虽然没有显示其其余功能，但此DataManager类的目的是管理和提供对String数据数组的访问。 DataManager类的部分功能是能够从文件导入数据。此功能由DataImporter类提供，该类假设初始化需要非常平凡的时间。这可能是因为DataImporter实例在初始化DataImporter实例时需要打开文件并将其内容读取到内存中。 由于DataManager实例可以在不从文件中导入数据的情况下管理其数据，因此在创建DataManager本身时，DataManager不会创建新的DataImporter实例。相反，当DataImporter实例首次使用时，创建它更有意义。 由于它标有lazy修饰符，因此只有在首次访问importer属性时才会创建importer属性的DataImporter实例，例如查询其filename属性时： print(manager.importer.filename) &#x2F;&#x2F; the DataImporter instance for the importer property has now been created &#x2F;&#x2F; Prints “data.txt” 注意 如果标记有lazy修饰符的属性同时由多个线程访问，并且该属性尚未初始化，则不能保证该属性只会初始化一次。 存储属性和实例变量如果您有Objective-C的经验，您可能知道它提供了两种存储值和引用作为类实例的一部分的方法。除了属性外，您还可以使用实例变量作为存储在属性中的值的备份存储。 Swift将这些概念统一为单个属性声明。Swift属性没有相应的实例变量，并且不会直接访问属性的备份存储。这种方法避免了在不同上下文中如何访问该值的混淆，并将属性的声明简化为单个确定性语句。有关属性的所有信息——包括其名称、类型和内存管理特征——都是在单个位置定义的，作为类型定义的一部分。 计算属性除了存储属性外，类、结构和枚举还可以定义计算属性，这些属性实际上不会存储值。相反，它们提供了一个getter和一个可选的setter来间接检索和设置其他属性和值。 struct Point { ​ var x &#x3D; 0.0, y &#x3D; 0.0 } struct Size { ​ var width &#x3D; 0.0, height &#x3D; 0.0 } struct Rect { ​ var origin &#x3D; Point() ​ var size &#x3D; Size() ​ var center: Point { ​ get { ​ let centerX &#x3D; origin.x + (size.width &#x2F; 2) ​ let centerY &#x3D; origin.y + (size.height &#x2F; 2) ​ return Point(x: centerX, y: centerY) ​ } ​ set(newCenter) { ​ origin.x &#x3D; newCenter.x - (size.width &#x2F; 2) ​ origin.y &#x3D; newCenter.y - (size.height &#x2F; 2) ​ } ​ } } var square &#x3D; Rect(origin: Point(x: 0.0, y: 0.0), ​ size: Size(width: 10.0, height: 10.0)) let initialSquareCenter &#x3D; square.center &#x2F;&#x2F; initialSquareCenter is at (5.0, 5.0) square.center &#x3D; Point(x: 15.0, y: 15.0) print(“square.origin is now at ((square.origin.x), (square.origin.y))”) &#x2F;&#x2F; Prints “square.origin is now at (10.0, 10.0)” 此示例定义了用于处理几何形状的三种结构： Point封装点的x坐标和y坐标。 Size封装width和height。 Rect按原点和大小定义矩形。 Rect结构还提供了一个称为center计算属性。Rect的当前中心位置始终可以根据其origin和size确定，因此您不需要将中心点存储为显式Point值。相反，Rect为称为center的计算变量定义了一个自定义获取器和setter，使您能够像处理矩形center一样使用它，就像它是真正的存储属性一样。 上面的示例创建一个名为square的新Rect变量。square变量初始化为(0,0)宽度和高度为10。这个正方形由下图中的浅绿色正方形表示。 然后通过点语法（square.center）访问square变量center属性，从而调用center获取器来检索当前属性值。得到者实际上计算并返回一个新点来表示正方形的中心，而不是返回现有值。如上所示，获取器正确返回中心点(5,5) 然后将center属性设置为(15,15)的新值，将正方形向上和向右移动，到下图中深绿色正方形显示的新位置。设置center属性调用center设置器，该设置器修改存储origin属性的x和y值，并将正方形移动到其新位置。 速记获取声明如果得到者的整个主体是一个表达式，则得到者会隐式返回该表达式。以下是利用此速记符号和设置者速记符号的Rect结构的另一个版本： struct CompactRect { ​ var origin &#x3D; Point() ​ var size &#x3D; Size() ​ var center: Point { ​ get { ​ Point(x: origin.x + (size.width &#x2F; 2), ​ y: origin.y + (size.height &#x2F; 2)) ​ } ​ set { ​ origin.x &#x3D; newValue.x - (size.width &#x2F; 2) ​ origin.y &#x3D; newValue.y - (size.height &#x2F; 2) ​ } ​ } } 省略getter的return遵循与省略函数return相同的规则，如《隐式返回函数》中所述。 只读计算属性具有获取器但没有设置器的计算属性称为只读计算属性。只读计算属性总是返回一个值，可以通过点语法访问，但不能设置为其他值。 注意 您必须使用var关键字将计算属性（包括只读计算属性）声明为变量属性，因为它们的值不是固定的。let关键字仅用于常量属性，以指示一旦将其设置为实例初始化的一部分，其值就无法更改。 您可以通过删除get关键字及其大括号来简化只读计算属性的声明： struct Cuboid { ​ var width &#x3D; 0.0, height &#x3D; 0.0, depth &#x3D; 0.0 ​ var volume: Double { ​ return width * height * depth ​ } } let fourByFiveByTwo &#x3D; Cuboid(width: 4.0, height: 5.0, depth: 2.0) print(“the volume of fourByFiveByTwo is (fourByFiveByTwo.volume)”) &#x2F;&#x2F; Prints “the volume of fourByFiveByTwo is 40.0” 此示例定义了一个名为Cuboid的新结构，它代表一个具有width、height和depth属性的3D矩形框。该结构还有一个名为volume的只读计算属性，该属性计算并返回长方体的当前体积。volume可设置没有意义，因为对于特定volume值应该使用哪些width、height和depth值是模棱两可的。尽管如此，对于Cuboid，提供只读计算属性以使外部用户能够发现其当前的计算卷是有用的。 财产观察员财产观察者观察并回应财产价值的变化。每次设置属性值时都会调用属性观察者，即使新值与属性的当前值相同。 您可以在以下位置添加属性观察者： 您定义的存储属性 您继承的存储属性 您继承的计算属性 对于继承的属性，您可以通过在子类中重写该属性来添加属性观察者。对于您定义的计算属性，请使用属性的设置器来观察和响应值更改，而不是尝试创建观察者。重写属性在重写中描述。 您可以选择在属性上定义以下一个或多个观察者： willSet在存储值之前调用。 didSet在存储新值后立即调用。 If you implement a willSet observer, it’s passed the new property value as a constant parameter. You can specify a name for this parameter as part of your willSetimplementation. If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of newValue. Similarly, if you implement a didSet observer, it’s passed a constant parameter containing the old property value. You can name the parameter or use the default parameter name of oldValue. If you assign a value to a property within its own didSet observer, the new value that you assign replaces the one that was just set. 注意 在调用超类初始化器后，当在子类初始化器中设置属性时，调用超类属性的willSet和didSet观察器。在调用超类初始化器之前，当类设置自己的属性时，不会调用它们。 有关初始化器委托的更多信息，请参阅值类型的初始化器委托和类类型的初始化器委托。 以下是willSet和didSet执行的实例。下面的示例定义了一个名为StepCounter的新类，该类跟踪一个人在行走时采取的总步数。该课程可以与计步器或其他步数计数器的输入数据一起使用，以跟踪一个人在日常生活中的锻炼情况。 class StepCounter { ​ var totalSteps: Int &#x3D; 0 { ​ willSet(newTotalSteps) { ​ print(“About to set totalSteps to (newTotalSteps)”) ​ } ​ didSet { ​ if totalSteps &gt; oldValue { ​ print(“Added (totalSteps - oldValue) steps”) ​ } ​ } ​ } } let stepCounter &#x3D; StepCounter() stepCounter.totalSteps &#x3D; 200 &#x2F;&#x2F; About to set totalSteps to 200 &#x2F;&#x2F; Added 200 steps stepCounter.totalSteps &#x3D; 360 &#x2F;&#x2F; About to set totalSteps to 360 &#x2F;&#x2F; Added 160 steps stepCounter.totalSteps &#x3D; 896 &#x2F;&#x2F; About to set totalSteps to 896 &#x2F;&#x2F; Added 536 steps The StepCounter class declares a totalSteps property of type Int. This is a stored property with willSet and didSet observers. The willSet and didSet observers for totalSteps are called whenever the property is assigned a new value. This is true even if the new value is the same as the current value. This example’s willSet observer uses a custom parameter name of newTotalSteps for the upcoming new value. In this example, it simply prints out the value that’s about to be set. The didSet observer is called after the value of totalSteps is updated. It compares the new value of totalSteps against the old value. If the total number of steps has increased, a message is printed to indicate how many new steps have been taken. The didSet observer doesn’t provide a custom parameter name for the old value, and the default name of oldValue is used instead. 注意 如果您将具有观察者作为进出参数的函数的属性传递，则始终调用将willSet和didSet观察者。这是因为输入输出参数的复制内存模型：该值总是写回函数末尾的属性。有关进出参数行为的详细讨论，请参阅输入输出参数。 物业包装纸属性包装器在管理属性存储方式的代码和定义属性的代码之间添加了一层分离。例如，如果您的属性提供线程安全检查或将其基础数据存储在数据库中，则必须在每个属性上编写该代码。当您使用属性包装器时，您在定义包装器时编写一次管理代码，然后通过将其应用于多个属性来重用该管理代码。 要定义属性包装器，请制作一个定义awrappedValue属性的结构、枚举或类。在下面的代码中，TwelveOrLess结构确保它包装的值始终包含小于或等于12的数字。如果您要求它存储更大的数量，它将存储12个。 @propertyWrapper struct TwelveOrLess { ​ private var number &#x3D; 0 ​ var wrappedValue: Int { ​ get { return number } ​ set { number &#x3D; min(newValue, 12) } ​ } } 设置器确保新值小于或等于12，并且获取器返回存储值。 注意 上面示例中的number声明将变量标记为private，这确保number仅用于TwelveOrLess的实现。写在其他地方的代码使用wrappedValue的getter和setter访问值，并且不能直接使用number。有关private信息，请参阅访问控制。 您可以通过将包装器的名称写在属性之前作为属性来将包装器应用于属性。这里有一个结构，它存储一个矩形，该矩形使用TwelveOrLess属性包装器，以确保其尺寸始终为12或更少： struct SmallRectangle { ​ @TwelveOrLess var height: Int ​ @TwelveOrLess var width: Int } var rectangle &#x3D; SmallRectangle() print(rectangle.height) &#x2F;&#x2F; Prints “0” rectangle.height &#x3D; 10 print(rectangle.height) &#x2F;&#x2F; Prints “10” rectangle.height &#x3D; 24 print(rectangle.height) &#x2F;&#x2F; Prints “12” The height and width properties get their initial values from the definition of TwelveOrLess, which sets TwelveOrLess.number to zero. The setter in TwelveOrLess treats 10 as a valid value so storing the number 10 in rectangle.height proceeds as written. However, 24 is larger than TwelveOrLess allows, so trying to store 24 end up setting rectangle.height to 12 instead, the largest allowed value. 当您将包装器应用于属性时，编译器会合成为包装器提供存储的代码和通过包装器访问该属性的代码。（属性包装器负责存储包装的值，因此没有合成代码。）您可以编写使用属性包装器行为的代码，而无需利用特殊属性语法。例如，这是之前代码列表中的SmallRectangle版本，该版本显式将其属性包装在TwelveOrLess结构中，而不是将@TwelveOrLess写为属性： struct SmallRectangle { ​ private var _height &#x3D; TwelveOrLess() ​ private var _width &#x3D; TwelveOrLess() ​ var height: Int { ​ get { return _height.wrappedValue } ​ set { _height.wrappedValue &#x3D; newValue } ​ } ​ var width: Int { ​ get { return _width.wrappedValue } ​ set { _width.wrappedValue &#x3D; newValue } ​ } } _height和_width属性存储属性包装器TwelveOrLess实例。height和width的获取器和设置器对wrappedValue属性的访问。 为包装属性设置初始值上面示例中的代码通过在TwelveOrLess的定义中给出number初始值来设置包装属性的初始值。使用此属性包装器的代码无法为由TwelveOrLess包装的属性指定不同的初始值——例如，SmallRectangle的定义不能给出height或width初始值。为了支持设置初始值或其他自定义，属性包装器需要添加初始化器。以下是名为SmallNumber的TwelveOrLess扩展版本，它定义了设置包装和最大值的初始化器： @propertyWrapper struct SmallNumber { ​ private var maximum: Int ​ private var number: Int ​ var wrappedValue: Int { ​ get { return number } ​ set { number &#x3D; min(newValue, maximum) } ​ } ​ init() { ​ maximum &#x3D; 12 ​ number &#x3D; 0 ​ } ​ init(wrappedValue: Int) { ​ maximum &#x3D; 12 ​ number &#x3D; min(wrappedValue, maximum) ​ } ​ init(wrappedValue: Int, maximum: Int) { ​ self.maximum &#x3D; maximum ​ number &#x3D; min(wrappedValue, maximum) ​ } } SmallNumber的定义包括三个初始化器——init()）、init(wrappedValue:)和init(wrappedValue:maximum:)——以下示例用于设置包装值和最大值。有关初始化和初始化器语法的信息，请参阅初始化。 当您将包装器应用于属性并且没有指定初始值时，Swift会使用thinitinit()初始化器来设置包装器。例如： struct ZeroRectangle { ​ @SmallNumber var height: Int ​ @SmallNumber var width: Int } var zeroRectangle &#x3D; ZeroRectangle() print(zeroRectangle.height, zeroRectangle.width) &#x2F;&#x2F; Prints “0 0” 包裹height和width的SmallNumber实例是通过调用SmallNumber()创建的。该初始化器内部的代码使用零和12的默认值设置初始包装值和初始最大值。属性包装器仍然提供所有初始值，就像之前在SmallRectangle中使用TwelveOrLess的示例一样。与该示例不同，SmallNumber还支持编写这些初始值，作为声明属性的一部分。 当您为属性指定初始值时，Swift使用init(wrappedValue:)初始化器来设置包装器。例如： struct UnitRectangle { ​ @SmallNumber var height: Int &#x3D; 1 ​ @SmallNumber var width: Int &#x3D; 1 } var unitRectangle &#x3D; UnitRectangle() print(unitRectangle.height, unitRectangle.width) &#x2F;&#x2F; Prints “1 1” When you write = 1 on a property with a wrapper, that’s translated into a call to the init(wrappedValue:) initializer. The instances of SmallNumber that wrap height and widthare created by calling SmallNumber(wrappedValue: 1). The initializer uses the wrapped value that’s specified here, and it uses the default maximum value of 12. 当您在自定义属性后的括号中写入参数时，Swift使用接受这些参数的初始化器来设置包装器。例如，如果您提供初始值和最大值，Swift将使用init(wrappedValue:maximum:)初始化器： struct NarrowRectangle { ​ @SmallNumber(wrappedValue: 2, maximum: 5) var height: Int ​ @SmallNumber(wrappedValue: 3, maximum: 4) var width: Int } var narrowRectangle &#x3D; NarrowRectangle() print(narrowRectangle.height, narrowRectangle.width) &#x2F;&#x2F; Prints “2 3” narrowRectangle.height &#x3D; 100 narrowRectangle.width &#x3D; 100 print(narrowRectangle.height, narrowRectangle.width) &#x2F;&#x2F; Prints “5 4” 包裹height的SmallNumber实例是通过调用SmallNumber(wrappedValue:2,maximum:5)创建的，包装width的实例是通过调用SmallNumber(wrappedValue:3,maximum:4)创建的。 通过将参数包含在属性包装器中，您可以在包装器中设置初始状态，或在创建包装器时将其他选项传递给包装器。此语法是使用属性包装器的最通用方式。您可以为属性提供所需的任何参数，它们将传递给初始化器。 When you include property wrapper arguments, you can also specify an initial value using assignment. Swift treats the assignment like a wrappedValue argument and uses the initializer that accepts the arguments you include. For example: struct MixedRectangle { ​ @SmallNumber var height: Int &#x3D; 1 ​ @SmallNumber(maximum: 9) var width: Int &#x3D; 2 } var mixedRectangle &#x3D; MixedRectangle() print(mixedRectangle.height) &#x2F;&#x2F; Prints “1” mixedRectangle.height &#x3D; 20 print(mixedRectangle.height) &#x2F;&#x2F; Prints “12” The instance of SmallNumber that wraps height is created by calling SmallNumber(wrappedValue: 1), which uses the default maximum value of 12. The instance that wraps width is created by calling SmallNumber(wrappedValue: 2, maximum: 9). 从属性包装器中投射值除了包装值外，属性包装器还可以通过定义投影值来公开其他功能——例如，管理数据库访问的属性包装器可以在其投影值上公开flushDatabaseConnection()方法。预计价值的名称与包装价值相同，只是以美元符号（$）开头。由于您的代码无法定义以$开头的属性，因此投影值永远不会干扰您定义的属性。 在上面的SmallNumber示例中，如果您尝试将属性设置为太大的数字，属性包装器将在存储之前调整数字。以下代码将projectedValue属性添加到SmallNumber结构中，以跟踪属性包装器在存储该新值之前是否调整了该属性的新值。 @propertyWrapper struct SmallNumber { ​ private var number: Int ​ private(set) var projectedValue: Bool ​ var wrappedValue: Int { ​ get { return number } ​ set { ​ if newValue &gt; 12 { ​ number &#x3D; 12 ​ projectedValue &#x3D; true ​ } else { ​ number &#x3D; newValue ​ projectedValue &#x3D; false ​ } ​ } ​ } ​ init() { ​ self.number &#x3D; 0 ​ self.projectedValue &#x3D; false ​ } } struct SomeStructure { ​ @SmallNumber var someNumber: Int } var someStructure &#x3D; SomeStructure() someStructure.someNumber &#x3D; 4 print(someStructure.$someNumber) &#x2F;&#x2F; Prints “false” someStructure.someNumber &#x3D; 55 print(someStructure.$someNumber) &#x2F;&#x2F; Prints “true” 编写someStructure.$someNumber访问包装器的投影值。存储一个小数字（如4）后，someStructure.$someNumber的值为false。然而，在尝试存储一个太大的数字（如55）后，预测值true 属性包装器可以返回任何类型的值作为其投影值。在本例中，属性包装器只公开一条信息——无论数字是否调整——因此它将布尔值作为其预测值。需要公开更多信息的包装器可以返回其他数据类型的实例，也可以返回self以将包装器的实例作为其投影值公开。 当您从属于该类型的代码（如属性获取器或实例方法）访问投影值时，您可以在属性名称之前省略self.就像访问其他属性一样。以下示例中的代码将包装器围绕height和width的投影值称为$height和$width： enum Size { ​ case small, large } struct SizedRectangle { ​ @SmallNumber var height: Int ​ @SmallNumber var width: Int ​ mutating func resize(to size: Size) -&gt; Bool { ​ switch size { ​ case .small: ​ height &#x3D; 10 ​ width &#x3D; 20 ​ case .large: ​ height &#x3D; 100 ​ width &#x3D; 100 ​ } ​ return $height || $width ​ } } 由于属性包装语法只是具有获取器和设置器的属性的句法糖，因此访问height和width的行为与访问任何其他属性的行为相同。例如，resize(to:)中的代码使用其属性包装器访问height和width。如果您调用resize(to:.large)``.large的开关盒将矩形的高度和宽度设置为100。包装器防止这些属性的值大于12，并将投影值设置为true，以记录它调整其值的事实。在resize(to:)结束时，返回语句检查$height和$width，以确定属性包装器是否调整了height或width。 全局和局部变量上述计算和观察属性的功能也适用于全局变量和局部变量。全局变量是在任何函数、方法、闭包或类型上下文之外定义的变量。局部变量是在函数、方法或闭包上下文中定义的变量。 您在前几章中遇到的全局变量和局部变量都已存储。存储的变量，如存储的属性，为特定类型的值提供存储，并允许设置和检索该值。 但是，您还可以在全局或局域范围内定义计算变量并为存储变量定义观察者。计算变量计算其值，而不是存储它，并且它们的写入方式与计算属性相同。 注意 全局常量和变量总是以与懒惰存储属性相似的方式计算。与惰性存储属性不同，全局常量和变量不需要用lazy修饰符标记。 局部常数和变量从不懒惰地计算。 您可以将属性包装器应用于本地存储变量，但不能应用于全局变量或计算变量。例如，在下面的代码中，myNumber使用SmallNumber作为属性包装器。 func someFunction() { ​ @SmallNumber var myNumber: Int &#x3D; 0 ​ myNumber &#x3D; 10 ​ &#x2F;&#x2F; now myNumber is 10 ​ myNumber &#x3D; 24 ​ &#x2F;&#x2F; now myNumber is 12 } 像将SmallNumber应用于属性一样，将myNumber的值设置为10是有效的。由于属性包装器不允许值高于12，因此将myNumber设置为12而不是24。 类型属性实例属性是属于特定类型实例的属性。每次您创建该类型的新实例时，它都有自己的属性值集，与任何其他实例分开。 您还可以定义属于类型本身的属性，而不是该类型的任何实例。无论您创建多少个此类实例，这些属性都将只有一个副本。这些类型的属性称为类型属性。 类型属性可用于定义特定类型所有实例通用的值，例如所有实例都可以使用的常量属性（如C中的静态常量），或存储该类型所有实例的全局值的变量属性（如C中的静态变量）。 存储的类型属性可以是变量或常量。计算类型属性总是声明为变量属性，就像计算实例属性一样。 注意 与存储实例属性不同，您必须始终为存储类型属性提供默认值。这是因为类型本身没有可以在初始化时为存储的类型属性分配值的初始化器。 存储类型属性在首次访问时被懒惰地初始化。它们保证只初始化一次，即使同时由多个线程访问，并且不需要用lazy修饰符标记它们。 类型属性语法在C和Objective-C中，您将与类型关联的静态常量和变量定义为全局静态变量。然而，在Swift中，类型属性是作为类型定义的一部分，在类型的外部花括号内编写的，每个类型属性都显式扩展到它支持的类型。 您可以使用static关键字定义类型属性。对于类类型的计算类型属性，您可以使用class关键字来允许子类覆盖超类的实现。下面的示例显示了存储和计算类型属性的语法： struct SomeStructure { ​ static var storedTypeProperty &#x3D; “Some value.” ​ static var computedTypeProperty: Int { ​ return 1 ​ } } enum SomeEnumeration { ​ static var storedTypeProperty &#x3D; “Some value.” ​ static var computedTypeProperty: Int { ​ return 6 ​ } } class SomeClass { ​ static var storedTypeProperty &#x3D; “Some value.” ​ static var computedTypeProperty: Int { ​ return 27 ​ } ​ class var overrideableComputedTypeProperty: Int { ​ return 107 ​ } } 注意 上面的计算类型属性示例适用于只读计算类型属性，但您也可以使用与计算实例属性相同的语法定义读写计算类型属性。 查询和设置类型属性类型属性使用点语法查询和设置，就像实例属性一样。但是，类型属性是在类型上查询和设置的，而不是在该类型的实例上。例如： print(SomeStructure.storedTypeProperty) &#x2F;&#x2F; Prints “Some value.” SomeStructure.storedTypeProperty &#x3D; “Another value.” print(SomeStructure.storedTypeProperty) &#x2F;&#x2F; Prints “Another value.” print(SomeEnumeration.computedTypeProperty) &#x2F;&#x2F; Prints “6” print(SomeClass.computedTypeProperty) &#x2F;&#x2F; Prints “27” 以下示例使用两个存储的类型属性作为为多个音频通道建模音频电平计的结构的一部分。每个通道的整数音频电平在0到10之间。 下图说明了如何将其中两个音频通道组合成立体声音频电平计建模。当一个频道的音频电平为0时，该频道的灯都不会亮起。当音频电平为10时，该通道的所有灯都亮了。在这个图中，左通道的当前电平为9，右信道的当前电平为7： 上述音频通道由AudioChannel结构的实例表示： struct AudioChannel { ​ static let thresholdLevel &#x3D; 10 ​ static var maxInputLevelForAllChannels &#x3D; 0 ​ var currentLevel: Int &#x3D; 0 { ​ didSet { ​ if currentLevel &gt; AudioChannel.thresholdLevel { ​ &#x2F;&#x2F; cap the new audio level to the threshold level ​ currentLevel &#x3D; AudioChannel.thresholdLevel ​ } ​ if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels { ​ &#x2F;&#x2F; store this as the new overall maximum input level ​ AudioChannel.maxInputLevelForAllChannels &#x3D; currentLevel ​ } ​ } ​ } } AudioChannel结构定义了两个存储的类型属性来支持其功能。第一个，thresholdLevel，定义了音频级别可以达到的最大阈值。对于所有AudioChannel实例，这是一个10的常量值。如果音频信号的值高于10，它将被限制为此阈值（如下所述）。 第二种类型属性是一个名为maxInputLevelForAllChannels变量存储属性。这可以跟踪任何AudioChannel实例收到的最大输入值。它以初始值0开头。 AudioChannel结构还定义了一个名为currentLevel的存储实例属性，该属性以0到10的比例表示通道的当前音频级别。 currentLevel属性有一个didSet属性观察器，用于在设置currentLevel时检查其值。此观察者执行两项检查： 如果currentLevel的新值大于允许的thresholdLevel，则属性观察者将currentLevel上限为 thresholdLevel。 如果currentLevel的新值（在任何上限之后）高于任何AudioChannel实例之前收到的任何值，则属性观察者将newcurrentLevel值存储在maxInputLevelForAllChannels类型属性中。 注意 In the first of these two checks, the didSet observer sets currentLevel to a different value. This doesn’t, however, cause the observer to be called again. 您可以使用AudioChannel结构创建两个名为leftChannel和rightChannel的新音频通道，以表示立体声系统的音频水平： var leftChannel &#x3D; AudioChannel() var rightChannel &#x3D; AudioChannel() 如果您将左侧通道的currentLevel设置为7，您可以看到maxInputLevelForAllChannels类型属性更新为等于7： leftChannel.currentLevel &#x3D; 7 print(leftChannel.currentLevel) &#x2F;&#x2F; Prints “7” print(AudioChannel.maxInputLevelForAllChannels) &#x2F;&#x2F; Prints “7” 如果您尝试将正确通道的currentLevel设置为11，您可以看到右侧通道的currentLevel属性上限为最大值10，maxInputLevelForAllChannels类型属性更新为等于10： rightChannel.currentLevel &#x3D; 11 print(rightChannel.currentLevel) &#x2F;&#x2F; Prints “10” print(AudioChannel.maxInputLevelForAllChannels) &#x2F;&#x2F; Prints “10”","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 嵌套","slug":"软件开发/技术/编程语言/swift/Swift基础-嵌套","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-嵌套/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%B5%8C%E5%A5%97/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID102 嵌套是自包含的功能块，可以在代码中传递和使用。Swift中的闭包类似于C和Objective-C中的块以及其他编程语言中的lambdas。 闭包可以从定义常量和变量的上下文中捕获和存储对任何常量和变量的引用。这被称为关闭这些常量和变量。Swift为您处理捕获的所有内存管理。 注意 如果您不熟悉捕获的概念，请不要担心。下文在《捕捉价值观》中对此进行了详细解释。 函数中引入的全局和嵌套函数实际上是闭包的特殊情况。关闭采取三种形式之一： 全局函数是具有名称且不捕获任何值的闭包。 嵌套函数是具有名称的闭包，可以从其封闭函数中捕获值。 闭包表达式是用轻量级语法编写的未命名闭包，可以从其周围上下文中捕获值。 Swift的闭包表达式具有干净、清晰的风格，优化鼓励在常见场景中进行简短、无杂乱的语法。这些优化包括： 从上下文推断参数和返回值类型 来自单表达式闭包的隐式回报 速记参数名称 尾随闭包语法 嵌套表达式Nested Functions中引入的嵌套函数是命名和定义自包含代码块作为更大函数的一部分的便捷手段。然而，在没有完整声明和名称的情况下编写类似函数的构造的较短版本有时是有用的。当您使用将函数作为一个或多个参数的函数或方法时，尤其如此。 闭包表达式是一种以简短、聚焦的语法编写内联闭包的方法。闭包表达式提供了几种语法优化，用于以缩短的形式编写闭包，而不会失去清晰度或意图。下面的闭包表达式示例通过在几次迭代中完善sorted(by:)方法的单个示例来说明这些优化，每个迭代都以更简洁的方式表达相同的功能。 排序方法Swift的标准库提供了一个名为sorted(by:)的方法，该方法根据您提供的排序闭包的输出对已知类型的值数组进行排序。完成排序过程后，sorted(by:)方法返回与旧数组类型和大小相同的新数组，其元素按正确的排序顺序排列。原始数组不会被sorted(by:)方法修改。 下面的闭包表达式示例使用sorted(by:)方法按反向字母顺序对String值数组进行排序。以下是要排序的初始数组： 1let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;] sorted(by:)方法接受一个闭包，该闭包接受两个与数组内容相同的类型参数，并返回一个Bool值，说明对值进行排序后，第一个值应该出现在第二个值之前还是之后。如果第一个值出现在第二个值之前，排序闭包需要返回true，否则返回false。 这个例子是对一个’ String ‘值的数组进行排序，因此排序闭包需要是一个类型为’ (String, String) -&gt; Bool ‘的函数。 提供排序闭包的一种方法是编写正确类型的正常函数，并将其作为参数传递给sorted(by:)方法： 12345func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)// reversedNames is equal to [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;] 如果第一个字符串（s1）大于第二个字符串（s2），则 backward(_:_:)函数将返回true，表明s1应该出现在排序数组的s2之前。对于字符串中的字符，“大于”意味着“在字母表中出现得晚于”。这意味着字母&quot;B&quot;大于字母&quot;A&quot;字符串&quot;Tom&quot;大于字符串&quot;Tim&quot;这给出了一个反向字母排序，将&quot;Barry&quot;放在&quot;Alex&quot;之前，以此类过。 然而，这是一种相当冗长的方式来编写本质上是一个单表达式函数(‘ a &gt;b ‘)。在这个例子中，最好使用闭包表达式语法内联编写排序闭包。 嵌套表达式语法嵌套表达式语法具有以下一般形式： 123&#123; (parameters) -&gt; return type in statements&#125; 嵌套表达式语法中的参数可以是输入输出参数，但它们不能有默认值。如果您命名变量参数，则可以使用变量参数。元组也可以用作参数类型和返回类型。 下面的示例显示了上面的向backward(_:_:)函数的闭包表达式版本： 123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 请注意，这个内联闭包的形参声明和返回类型与’ backward(::) ‘函数的声明相同。在这两种情况下，它都被写成’ (s1: String, s2: String) -&gt; Bool ‘。但是，对于内联闭包表达式，参数和返回类型写在花括号的*内部，而不是在花括号的外面。 闭包正文的开头由关键字引入。此关键字表示闭包参数和返回类型的定义已经完成，闭包的主体即将开始。 由于闭包的主体太短，它甚至可以写在一行上： 1reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; ) 这表明对sorted(by:)方法的总体调用保持不变。一对括号仍然包裹着方法的整个参数。然而，这个论点现在是一个内联闭包。 从上下文推断类型因为排序闭包是作为参数传递给方法的，所以Swift可以推断出其参数的类型以及返回值的类型。’ sorted(by:) ‘方法是在一个字符串数组上调用的，所以它的参数必须是一个类型为’ (String, String) -&gt; Bool ‘的函数。这意味着’ (String, String) ‘和’ Bool ‘类型不需要作为闭包表达式定义的一部分编写。因为所有类型都可以被推断，所以返回箭头(‘ -&gt; ‘)和形参名称周围的括号也可以被省略: 1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 当将闭包作为内联闭包表达式传递给函数或方法时，始终可以推断参数类型和返回类型。因此，当闭包用作函数或方法参数时，您永远不需要以最完整的形式编写内联闭包。 尽管如此，如果您愿意，您仍然可以明确这些类型，如果这能避免代码读者的歧义，则鼓励这样做。在sorted(by:)方法的情况下，从正在进行排序的事实中可以清楚地看出闭包的目的，读者可以安全地假设闭包可能与String值一起工作，因为它有助于对字符串数组进行排序。 单表达式关闭的隐式返回单表达式闭包可以通过从声明中省略return关键字来隐式返回其单个表达式的结果，如上一个示例的这个版本： 1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) 这里，’ sorted(by:) ‘方法的参数的函数类型明确表示闭包必须返回’ Bool ‘值。因为闭包的主体包含一个返回’ Bool ‘值的表达式(‘ s1 &gt; s2 ‘)，所以没有歧义，并且’ return ‘关键字可以被省略。 运算符方法实际上，有更短的方法来编写上面的闭包表达式。Swift的String类型将其大于运算符（&gt;）的字符串特定实现定义为具有两个String类型参数的方法，并返回Bool类型的值。这完全符合sorted(by:)方法所需的方法类型。因此，您可以简单地传递大于运算符，Swift将推断您想要使用其字符串特定的实现： 1reversedNames = names.sorted(by: &gt;) 有关运算符方法的更多信息，请参阅运算符方法。 尾随关闭如果您需要将闭包表达式传递给函数作为函数的最终参数，并且闭包表达式很长，则将其写为尾随闭包可能会有用。您在函数调用的括号后写一个尾随闭包，即使尾随闭包仍然是函数的参数。当您使用尾随闭包语法时，您不会将第一个闭包的参数标签作为函数调用的一部分。函数调用可以包括多个尾随闭包；然而，以下前几个示例使用单个尾随闭包。 123456789101112131415func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; // function body goes here&#125;// 下面是如何在不使用末尾闭包的情况下调用这个函数:someFunctionThatTakesAClosure(closure: &#123; // 结束的身体在这里&#125;)// 下面是如何使用末尾闭包来调用这个函数:someFunctionThatTakesAClosure() &#123; // trailing closure&#x27;s body goes here&#125; 上面的闭包表达式语法部分的字符串排序闭包可以在sorted(by:)方法的括号之外写成尾随闭包： 1reversedNames = names.sorted() &#123; $0 &gt; $1 &#125; 如果闭包表达式作为函数或方法的唯一参数提供，并且您将该表达式作为尾随闭包提供，则在调用函数时，您无需在函数或方法名称后写一对括号()）： 1reversedNames = names.sorted &#123; $0 &gt; $1 &#125; 当闭包足够长，无法将其内联写在一行上时，尾随闭包最有用。例如，Swift的Array类型有一个map(_:)方法，该方法以闭包表达式为单个参数。为数组中的每个项目调用一次闭包，并返回该项目的替代映射值（可能是其他类型）。您通过在传递给map(_:)的闭包中编写代码来指定映射的性质和返回值的类型。 将提供的闭包应用于每个数组元素后，map(_:)方法返回一个包含所有新映射值的新数组，顺序与原始数组中的相应值相同。 下面介绍如何使用带有尾随闭包的’ map(:) ‘方法将’ Int ‘值的数组转换为’ String ‘值的数组。数组[16,58,510]被用来创建新的数组[“OneSix”， “FiveEight”， “FiveOneZero”]: 12345let digitNames = [ 0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;, 3: &quot;Three&quot;, 4: &quot;Four&quot;, 5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;]let numbers = [16, 58, 510] 上面的代码创建了整数数字与其名称的英语版本之间的映射词典。它还定义了一个整数数数组，准备转换为字符串。 您现在可以使用numbers数组创建String值数组，方法是将闭包表达式作为尾随闭包传递到数组的map(_:)方法： 1234567891011let strings = numbers.map &#123; (number) -&gt; String in var number = number var output = &quot;&quot; repeat &#123; output = digitNames[number % 10]! + output number /= 10 &#125; while number &gt; 0 return output&#125;// strings is inferred to be of type [String]// its value is [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;] map(_:)方法为数组中的每个项调用闭包表达式一次。您不需要指定闭包输入参数number的类型，因为类型可以从要映射的数组中的值中推断出来。 在本例中，变量number使用闭包number参数的值初始化，以便可以在闭包主体内修改该值。（函数和闭包的参数始终是常量。）闭包表达式还指定了String的返回类型，以指示将存储在映射输出数组中的类型。 闭包表达式每次调用时都会构建一个名为output的字符串。它使用剩余运算符（number%10）计算number的最后一个数字，并使用此数字在digitNames字典中查找适当的字符串。闭包可用于创建任何大于零的整数的字符串表示形式。 注意 对digitNames字典下标的调用后是感叹号（!），因为字典下标返回一个可选值，表示如果键不存在，字典查找可能会失败。在上面的示例中，保证number%10始终是digitNames字典的有效下标键，因此使用感叹号来强制解开存储在下标可选返回值中的String值。 从digitNames字典中检索到的字符串被添加到output的前面，有效地反向构建数字的字符串版本。（表达式number%10对16、58为8，对510值为0。） 然后将number变量除以10。因为它是一个整数，所以它在分区期间四舍五入，所以16变成1，58变成5，510变成51。 重复该过程，直到number等于0，此时output字符串由闭包返回，并通过map(_:)方法添加到输出数组中。 在上述示例中使用尾随闭包语法，在闭包支持的函数之后立即整齐地封装闭包的功能，而无需将整个闭包包包在map(_:)方法的外括号中。 如果一个函数需要多个闭包，则省略第一个尾随闭包的参数标签，并标记剩余的尾随闭包。例如，下面的功能加载照片库的图片： 1234567func loadPicture(from server: Server, completion: (Picture) -&gt; Void, onFailure: () -&gt; Void) &#123; if let picture = download(&quot;photo.jpg&quot;, from: server) &#123; completion(picture) &#125; else &#123; onFailure() &#125;&#125; 当您调用此函数加载图片时，您提供了两个闭包。第一个闭包是一个完成处理程序，在成功下载后显示图片。第二个闭包是一个错误处理程序，向用户显示错误。 12345loadPicture(from: someServer) &#123; picture in someView.currentPicture = picture&#125; onFailure: &#123; print(&quot;Couldn&#x27;t download the next picture.&quot;)&#125; 在本例中，loadPicture(from:completion:onFailure:)函数将其网络任务发送到后台，并在网络任务完成后调用两个完成处理程序之一。以这种方式编写该功能可以让您干净地将负责处理网络故障的代码与成功下载后更新用户界面的代码分开，而不是只使用一个处理这两种情况的闭包。 捕捉价值观闭包可以从定义它的周围上下文中捕获常量和变量。然后，闭包可以从其主体内引用和修改这些常量和变量的值，即使定义常量和变量的原始范围不再存在。 在Swift中，可以捕获值的最简单闭包形式是写在另一个函数主体中的嵌套函数。嵌套函数可以捕获其外部函数的任何参数，也可以捕获外部函数中定义的任何常量和变量。 这里有一个名为makeIncrementer的函数的示例，它包含一个名为incrementer嵌套函数。嵌套incrementer()函数从其周围的上下文捕获两个值，runningTotal和amount。捕获这些值后，makeIncrementer将作为闭包返回，每次调用时按amount增加runningTotal。 12345678func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125; ‘ makeIncrementer ‘的返回类型是’ ()-&gt; Int ‘。这意味着它返回一个函数，而不是一个简单的值。它返回的函数没有参数，每次调用都返回一个’ Int ‘值。要了解函数如何返回其他函数，请参阅函数类型作为返回类型。 makeIncrementer(forIncrement:)函数定义了一个名为runningTotal的整数变量，以存储将返回的增量的当前运行总数。此变量初始化值为0。 makeIncrementer(forIncrement:)函数具有单个Int参数，参数标签为forIncrement，参数名称为amount。传递给此参数的参数值指定每次调用返回的增量函数时，runningTotal应该增加多少。makeIncrementer函数定义了一个名为incrementer的嵌套函数，该函数执行实际增量。此函数只需为runningTotal添加amount，然后返回结果。 当孤立地考虑时，嵌套incrementer()函数可能看起来不寻常： 1234func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal&#125; incrementer()函数没有任何参数，但它指的是在其函数主体内runningTotal和amount。它通过捕获对周围函数中runningTotal和amount的引用，并在自己的功能体中使用它们来做到这一点。通过引用捕获确保在makeIncrementer调用结束时，runningTotal和amount不会消失，并确保下次调用incrementer函数时runningTotal可用。 注意 作为优化，如果值没有被闭包突变，并且值在闭包创建后没有突变，则可以捕获和存储该值的副本。 Swift 还负责处理不再需要的变量时涉及的所有内存管理。 以下是makeIncrementer在起作用的一个例子： 1let incrementByTen = makeIncrementer(forIncrement: 10) 此示例设置了一个名为incrementByTen的常量，以引用每次调用时为其runningTotal变量添加10增量函数。多次调用函数会显示此行为： 123456incrementByTen()// returns a value of 10incrementByTen()// returns a value of 20incrementByTen()// returns a value of 30 如果您创建第二个增量器，它将对一个新的单独runningTotal变量有自己的存储引用： 123let incrementBySeven = makeIncrementer(forIncrement: 7)incrementBySeven()// returns a value of 7 调用原始增量器（incrementByTen）继续增加自己的runningTotal变量，并且不影响incrementBySeven捕获的变量： 12incrementByTen()// returns a value of 40 注意 如果您为类实例的属性分配闭包，并且闭包通过引用实例或其成员来捕获该实例，您将在闭包和实例之间创建一个强大的引用周期。Swift 使用采集列表来打破这些强大的参考周期。有关更多信息，请参阅关闭的强参考周期。 关闭是参考类型在上面的例子中，’ incrementBySeven ‘和’ incrementByTen ‘是常量，但是这些常量所引用的闭包仍然能够增加它们捕获的’ runningTotal ‘变量。这是因为函数和闭包都是引用类型。 每当您将函数或闭包分配给常量或变量时，您实际上都会将该常量或变量设置为对函数或闭包的引用。在上面的示例中，incrementByTen指的是闭包的选择是常量，而不是闭包本身的内容。 这也意味着，如果您将闭包分配给两个不同的常量或变量，这两个常量或变量都引用相同的闭包。 123456let alsoIncrementByTen = incrementByTenalsoIncrementByTen()// returns a value of 50incrementByTen()// returns a value of 60 上面的示例表明，调用alsoIncrementByTen与调用incrementByTen相同。由于它们都引用相同的闭包，因此它们都会增加并返回相同的运行总数。 逃避关闭当闭包作为参数传递给函数时，闭包被称为转义函数，但在函数返回后调用闭包。当您声明一个以闭包作为其参数之一的函数时，您可以在参数类型之前编写@escaping，以指示允许闭包转义。 闭包可以转义的一种方法是存储在函数之外定义的变量中。例如，许多启动异步操作的函数将闭包参数作为完成处理程序。该函数在开始操作后返回，但在操作完成之前不会调用闭包——闭包需要转义，以便稍后调用。例如： 1234var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; someFunctionWithEscapingClosure(_:)函数以闭包为参数，并将其添加到函数之外声明的数组中。如果您没有用@escaping标记此函数的参数，您将收到编译时错误。 如果self引用类的实例，则引用self的转义闭包需要特殊考虑。在逃逸闭合中捕获self很容易意外地创建一个强大的参考周期。有关参考周期的信息，请参阅自动参考计数。 通常，闭包通过在闭包正文中使用变量来隐式捕获变量，但在这种情况下，您需要显式变量。如果您想捕获self，请在使用它时显式写入self，或将self包含在闭包的捕获列表中。写self明确可以让您表达自己的意图，并提醒您确认没有参考周期。例如，在下面的代码中，传递给someFunctionWithEscapingClosure(_:)的闭包显式引用self显式。相比之下，传递给someFunctionWithNonescapingClosure(_:)的闭包是一个不可转义闭包，这意味着它可以隐式引用self。 1234567891011121314151617181920func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapingClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x)// Prints &quot;200&quot;completionHandlers.first?()print(instance.x)// Prints &quot;100&quot; 以下是doSomething()的一个版本，通过将其包含在闭包的捕获列表中来捕获self，然后隐含地引用self： 1234567class SomeOtherClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapingClosure &#123; [self] in x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125; 如果self是结构或枚举的实例，您可以始终隐式引用self。然而，当self是结构或枚举的实例时，转义闭包无法捕获对self的可变引用。结构和枚举不允许共享可变性，正如结构和枚举是值类型中讨论的那样。 1234567struct SomeStruct &#123; var x = 10 mutating func doSomething() &#123; someFunctionWithNonescapingClosure &#123; x = 200 &#125; // Ok someFunctionWithEscapingClosure &#123; x = 100 &#125; // Error &#125;&#125; 上面示例中对someFunctionWithEscapingClosure函数的调用是一个错误，因为它位于突变方法中，因此self是可变的。这违反了规逃逸闭包不能捕获结构对self的可变引用的规则。 自动关闭自动闭包是自动创建的闭包，用于包装作为参数传递给函数的表达式。它不需要任何参数，当调用它时，它会返回包裹在里面的表达式的值。这种语法便利性允许您通过编写正态表达式而不是显式闭包来省略函数参数周围的大括号。 通常调用带有自动闭包的函数，但实现这类函数并不常见。例如，assert(condition:message:file:line:)函数的condition和message参数接受一个自动闭包;它的“condition”参数仅在调试版本中计算，而它的“message”参数仅在“condition”为“false”时计算。 自动关闭允许您延迟评估，因为在您调用关闭之前，内部代码不会运行。延迟评估对于具有副作用或计算成本的代码非常有用，因为它允许您控制代码何时进行评估。以下代码显示了关闭如何延迟评估。 123456789101112var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]print(customersInLine.count)// Prints &quot;5&quot;let customerProvider = &#123; customersInLine.remove(at: 0) &#125;print(customersInLine.count)// Prints &quot;5&quot;print(&quot;Now serving \\(customerProvider())!&quot;)// Prints &quot;Now serving Chris!&quot;print(customersInLine.count)// Prints &quot;4&quot; 即使闭包内的代码删除了customersInLine数组的第一个元素，但在实际调用闭包之前，数组元素也不会被删除。如果从未调用闭包，则永远不会计算闭包内的表达式，这意味着永远不会删除数组元素。请注意，customerProvider的类型不是String，而是()-&gt;String——一个没有返回字符串的参数的函数。 当您将闭包作为参数传递给函数时，您将获得相同的延迟评估行为。 123456// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func serve(customer customerProvider: () -&gt; String) &#123; print(&quot;Now serving \\(customerProvider())!&quot;)&#125;serve(customer: &#123; customersInLine.remove(at: 0) &#125; )// Prints &quot;Now serving Alex!&quot; 上面清单中的’ serve(customer:) ‘函数接受一个显式的闭包，该闭包返回客户的名字。下面的’ serve(customer:) ‘版本执行了相同的操作，但它没有采用显式闭包，而是通过使用’ @autoclosure ‘属性标记其参数的类型来接受一个自动闭包。现在你可以调用这个函数，就好像它有一个’ String ‘参数而不是一个闭包一样。参数会自动转换为闭包，因为’ customerProvider ‘参数的类型是用’ @autoclosure ‘属性标记的。 123456// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; print(&quot;Now serving \\(customerProvider())!&quot;)&#125;serve(customer: customersInLine.remove(at: 0))// Prints &quot;Now serving Ewa!&quot; 注意 过度使用自动关闭可能会使您的代码难以理解。上下文和函数名称应明确表示正在推迟评估。 如果您想要一个允许转义的自动关闭，请使用@autoclosure和@escaping属性。@escaping属性在上文的“逃避关闭”中进行了描述。 123456789101112131415// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]var customerProviders: [() -&gt; String] = []func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123; customerProviders.append(customerProvider)&#125;collectCustomerProviders(customersInLine.remove(at: 0))collectCustomerProviders(customersInLine.remove(at: 0))print(&quot;Collected \\(customerProviders.count) closures.&quot;)// Prints &quot;Collected 2 closures.&quot;for customerProvider in customerProviders &#123; print(&quot;Now serving \\(customerProvider())!&quot;)&#125;// Prints &quot;Now serving Barry!&quot;// Prints &quot;Now serving Daniella!&quot; 在上面的代码中，collectCustomerProviders(_:)函数将闭包附加到customerProviders数组中，而不是将传递给它的闭包作为其customerProvider参数。数组声明在函数范围之外，这意味着数组中的闭包可以在函数返回后执行。因此，必须允许customerProvider参数的值转义函数的范围。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 嵌套类型","slug":"软件开发/技术/编程语言/swift/Swift基础-嵌套类型","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-嵌套类型/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/NestedTypes.html 创建枚举通常是为了支持特定类或结构的功能。同样，可以方便地定义纯属实用程序类和结构，以便在更复杂类型的上下文中使用。为了做到这一点，Swift使您能够定义嵌套类型，从而在它们支持的类型的定义中嵌套支持枚举、类和结构。 要将类型嵌套在另一种类型中，请在它支持的类型的外部大括号中写入其定义。类型可以嵌套到所需的任意级别。 嵌套类型在行动下面的示例定义了一个名为BlackjackCard结构，该结构模拟了二十一点游戏中使用的扑克牌。BlackjackCard结构包含两种嵌套枚举类型，称为Suit和Rank。 在二十一点中，Ace卡的价值为1或11。此功能由一个名为Values结构表示，该结构嵌套在Rank枚举中： struct BlackjackCard { ​ &#x2F;&#x2F; nested Suit enumeration ​ enum Suit: Character { ​ case spades &#x3D; “♠”, hearts &#x3D; “♡”, diamonds &#x3D; “♢”, clubs &#x3D; “♣” ​ } ​ &#x2F;&#x2F; nested Rank enumeration ​ enum Rank: Int { ​ case two &#x3D; 2, three, four, five, six, seven, eight, nine, ten ​ case jack, queen, king, ace ​ struct Values { ​ let first: Int, second: Int? ​ } ​ var values: Values { ​ switch self { ​ case .ace: ​ return Values(first: 1, second: 11) ​ case .jack, .queen, .king: ​ return Values(first: 10, second: nil) ​ default: ​ return Values(first: self.rawValue, second: nil) ​ } ​ } ​ } ​ &#x2F;&#x2F; BlackjackCard properties and methods ​ let rank: Rank, suit: Suit ​ var description: String { ​ var output &#x3D; “suit is (suit.rawValue),” ​ output +&#x3D; “ value is (rank.values.first)” ​ if let second &#x3D; rank.values.second { ​ output +&#x3D; “ or (second)” ​ } ​ return output ​ } } Suit枚举描述了四套常见的扑克牌套装，以及代表其符号的原始Character值。 Rank枚举描述了13个可能的扑克牌排名，以及表示其面值的原始Int值。（此原始Int值不用于Jack、Queen、King和Ace卡。） 如上所述，Rank枚举定义了自己的进一步嵌套结构，称为Values。这种结构概括了一个事实，即大多数卡片只有一个值，但Ace卡有两个值。Values结构定义了两个属性来表示这一点： first，类型Int second，类型为Int?，或“optional Int” Rank还定义了一个计算属性，即values，它返回Values结构的实例。此计算属性考虑卡的排名，并根据排名使用适当的值初始化一个新的Values实例。它为jack、queen、king和ace使用特殊值。对于数字卡，它使用排名的原始Int值。 BlackjackCard结构本身有两个属性——rank和suit。它还定义了一个名为description计算属性，该属性使用rank和suit中存储的值来构建卡片名称和值的描述。description属性使用可选绑定来检查是否有第二个值要显示，如果是，则为第二个值插入额外的描述细节。 由于BlackjackCard是一个没有自定义初始化器的结构，因此它有一个隐式成员初始化器，如结构类型的成员初始化器中所述。您可以使用此初始化器初始化名为theAceOfSpades的新常量： let theAceOfSpades &#x3D; BlackjackCard(rank: .ace, suit: .spades) print(“theAceOfSpades: (theAceOfSpades.description)”) &#x2F;&#x2F; Prints “theAceOfSpades: suit is ♠, value is 1 or 11” 即使Rank和Suit嵌套在BlackjackCard中，它们的类型可以从上下文中推断出来，因此此实例的初始化只能通过它们的大小写名称（.ace和.spades）来引用枚举案例。在上面的示例中，description属性正确地报告黑桃王牌的值为1或11。 提及嵌套类型要在其定义上下文之外使用嵌套类型，请在其名称前加上嵌套在其中的类型名称： let heartsSymbol &#x3D; BlackjackCard.Suit.hearts.rawValue &#x2F;&#x2F; heartsSymbol is “♡” 对于上面的例子，这使Suit、Rank和Values的名称可以故意保持简短，因为它们的名字自然会被定义它们的上下文所限定。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 扩展","slug":"软件开发/技术/编程语言/swift/Swift基础-扩展","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-扩展/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E6%89%A9%E5%B1%95/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Extensions.html 扩展为现有类、结构、枚举或协议类型添加了新功能。这包括扩展您无法访问原始源代码（称为追溯建模）的类型的能力。扩展类似于Objective-C中的类别。（与Objective-C类别不同，Swift扩展没有名称。） Swift中的扩展可以： 添加计算实例属性和计算类型属性 定义实例方法和类型方法 提供新的初始化器 定义下标 定义和使用新的嵌套类型 使现有类型符合协议 在 Swift 中，您甚至可以扩展协议，以提供其要求的实现，或添加符合要求的类型可以利用的其他功能。有关更多详细信息，请参阅协议扩展。 注意 扩展可以为类型添加新功能，但它们不能覆盖现有功能。 扩展语法使用extension关键字声明扩展： extension SomeType { ​ &#x2F;&#x2F; new functionality to add to SomeType goes here } 扩展可以扩展现有类型，使其采用一个或多个协议。要添加协议一致性，您编写协议名称的方式与为类或结构编写协议名称的方式相同： extension SomeType: SomeProtocol, AnotherProtocol { ​ &#x2F;&#x2F; implementation of protocol requirements goes here } 以这种方式添加协议一致性在使用扩展添加协议一致性中进行了描述。 扩展可用于扩展现有的泛型类型，如扩展通用类型中所述。您还可以扩展泛型类型以有条件地添加功能，如带有通用Where子句的扩展中所述。 注意 如果您定义了一个扩展来向现有类型添加新功能，则该新功能将在该类型的所有现有实例上可用，即使它们是在定义扩展之前创建的。 计算属性扩展可以将计算实例属性和计算类型属性添加到现有类型中。此示例为Swift的内置Double类型添加了五个计算实例属性，为使用距离单元提供基本支持： extension Double { ​ var km: Double { return self * 1_000.0 } ​ var m: Double { return self } ​ var cm: Double { return self &#x2F; 100.0 } ​ var mm: Double { return self &#x2F; 1_000.0 } ​ var ft: Double { return self &#x2F; 3.28084 } } let oneInch &#x3D; 25.4.mm print(“One inch is (oneInch) meters”) &#x2F;&#x2F; Prints “One inch is 0.0254 meters” let threeFeet &#x3D; 3.ft print(“Three feet is (threeFeet) meters”) &#x2F;&#x2F; Prints “Three feet is 0.914399970739201 meters” 这些计算属性表示，Double值应被视为一定的长度单位。虽然它们是作为计算属性实现的，但这些属性的名称可以附加到带有点语法的浮点字面值中，作为使用该字面值执行距离转换的一种方式。 在本例中，1.0的Double值被视为表示“一米”。这就是为什么m计算属性返回self——表达式1.m被认为是计算aDouble值1.0的原因。 其他单位需要一些转换才能表示为以米为单位的值。一公里与1000米相同，因此计算km属性将值乘以1_000.00，转换为以米为单位的数字。同样，一米有3.28084英尺，因此ft计算属性将底层Double值除以3.28084，将其从英尺转换为米。 这些属性是只读计算属性，因此它们在没有get关键字的情况下表示，以便简短。它们的返回值为Double类型，无论何时接受Double，都可以在数学计算中使用： let aMarathon &#x3D; 42.km + 195.m print(“A marathon is (aMarathon) meters long”) &#x2F;&#x2F; Prints “A marathon is 42195.0 meters long” 注意 扩展可以添加新的计算属性，但它们不能添加存储的属性，也不能向现有属性添加属性观察器。 初始化器扩展可以为现有类型添加新的初始化器。这使您能够扩展其他类型，以接受自己的自定义类型作为初始化参数，或提供未作为类型原始实现的一部分的其他初始化选项。 扩展可以向类添加新的方便初始化器，但它们不能向类添加新的指定初始化器或去初始化器。指定的初始化器和去初始化器必须始终由原始类实现提供。 如果您使用扩展程序将初始化器添加到为其所有存储属性提供默认值且不定义任何自定义初始化器的值类型中，您可以从扩展的初始化器中调用该值类型的默认初始化器和成员初始化器。如果您将初始化器写为值类型原始实现的一部分，则情况并非如此，如值类型的初始化委托所述。 如果您使用扩展程序将初始化器添加到另一个模块中声明的结构中，则新初始化器在从定义模块调用初始化器之前无法访问self。 下面的示例定义了一个自定义Rect结构来表示几何矩形。该示例还定义了两个名为Size和Point的支持结构，这两个结构都为其所有属性提供0.0的默认值： struct Size { ​ var width &#x3D; 0.0, height &#x3D; 0.0 } struct Point { ​ var x &#x3D; 0.0, y &#x3D; 0.0 } struct Rect { ​ var origin &#x3D; Point() ​ var size &#x3D; Size() } 由于Rect结构为其所有属性提供默认值，因此它会自动接收默认初始化器和成员初始化器，如默认初始化器所述。这些初始化器可用于创建新的Rect实例： let defaultRect &#x3D; Rect() let memberwiseRect &#x3D; Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0)) 您可以扩展Rect结构，以提供具有特定中心点和大小的额外初始化器： extension Rect { ​ init(center: Point, size: Size) { ​ let originX &#x3D; center.x - (size.width &#x2F; 2) ​ let originY &#x3D; center.y - (size.height &#x2F; 2) ​ self.init(origin: Point(x: originX, y: originY), size: size) ​ } } 这个新的初始化器首先根据提供的center和size值计算适当的原点。然后，初始化器调用结构的自动成员初始化器init(origin:size:)该初始化器将新的原点和大小值存储在适当的属性中： let centerRect &#x3D; Rect(center: Point(x: 4.0, y: 4.0), ​ size: Size(width: 3.0, height: 3.0)) &#x2F;&#x2F; centerRect’s origin is (2.5, 2.5) and its size is (3.0, 3.0) 注意 如果您提供带有扩展的新初始化器，您仍然有责任确保初始化器完成后每个实例都已完全初始化。 方法扩展可以向现有类型添加新的实例方法和类型方法。以下示例为Int类型添加了一个名为repetitions的新实例方法： extension Int { ​ func repetitions(task: () -&gt; Void) { ​ for _ in 0..&lt;self { ​ task() ​ } ​ } } The repetitions(task:) method takes a single argument of type () -&gt; Void, which indicates a function that has no parameters and doesn’t return a value. 定义此扩展后，您可以在任何整数上调用repetitions(task:)方法来执行多次任务： 3.repetitions { ​ print(“Hello!”) } &#x2F;&#x2F; Hello! &#x2F;&#x2F; Hello! &#x2F;&#x2F; Hello! 突变实例方法使用扩展添加的实例方法也可以修改（或突变）实例本身。修改self或其属性的结构和枚举方法必须将实例方法标记为mutating，就像原始实现的突变方法一样。 以下示例在Swift的Int类型中添加了一种名为square的新突变方法，该方法将原始值平方： extension Int { ​ mutating func square() { ​ self &#x3D; self * self ​ } } var someInt &#x3D; 3 someInt.square() &#x2F;&#x2F; someInt is now 9 下标扩展可以向现有类型添加新的下标。此示例为Swift的内置Int类型添加了整数下标。此下标[n]从数字右侧返回小数n位： 123456789[0]退货9 123456789[1]退货8 …等等： extension Int { ​ subscript(digitIndex: Int) -&gt; Int { ​ var decimalBase &#x3D; 1 ​ for _ in 0..&lt;digitIndex { ​ decimalBase *&#x3D; 10 ​ } ​ return (self &#x2F; decimalBase) % 10 ​ } } 746381295[0] &#x2F;&#x2F; returns 5 746381295[1] &#x2F;&#x2F; returns 9 746381295[2] &#x2F;&#x2F; returns 2 746381295[8] &#x2F;&#x2F; returns 7 如果Int值没有足够的数字来满足请求的索引，下标实现将返回0，就像数字在左侧填充了零一样： 746381295[9] &#x2F;&#x2F; returns 0, as if you had requested: 0746381295[9] 嵌套类型扩展可以向现有类、结构和枚举添加新的嵌套类型： extension Int { ​ enum Kind { ​ case negative, zero, positive ​ } ​ var kind: Kind { ​ switch self { ​ case 0: ​ return .zero ​ case let x where x &gt; 0: ​ return .positive ​ default: ​ return .negative ​ } ​ } } 此示例为Int添加了一个新的嵌套枚举。这个枚举称为Kind，表示特定整数所代表的数字类型。具体来说，它表示数字是负数、零还是正数。 此示例还向Int添加了一个新的计算实例属性，称为kind，该属性返回该整数的适当Kind枚举情况。 嵌套枚举现在可以与任何Int值一起使用： func printIntegerKinds(_ numbers: [Int]) { ​ for number in numbers { ​ switch number.kind { ​ case .negative: ​ print(“- “, terminator: “”) ​ case .zero: ​ print(“0 “, terminator: “”) ​ case .positive: ​ print(“+ “, terminator: “”) ​ } ​ } ​ print(“”) } printIntegerKinds([3, 19, -27, 0, -6, 0, 7]) &#x2F;&#x2F; Prints “+ + - 0 - 0 + “ 此函数printIntegerKinds(_:)接受Int值的输入数组，并依次迭代这些值。对于数组中的每个整数，函数考虑该整数的kind计算属性，并打印适当的描述。 注意 number.kind已经知道是Int.Kind类型。因此，所有Int.Kind大小写值都可以在switch语句中以速记形式书写，例如.negative而不是Int.Kind.negative。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 并发性","slug":"软件开发/技术/编程语言/swift/Swift基础-并发性","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-并发性/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E6%80%A7/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html Swift内置支持以结构化方式编写异步和并行代码。异步代码可以暂停并稍后恢复，尽管一次只执行一个程序。在程序中暂停和恢复代码可以让它继续在更新用户界面等短期操作上取得进展，同时继续处理长期运行的操作，如通过网络获取数据或解析文件。并行代码意味着多个代码同时运行——例如，一台配备四核处理器的计算机可以同时运行四条代码，每个核心执行其中一项任务。使用并行和异步代码的程序一次执行多个操作；它暂停等待外部系统的操作，并使其更容易以内存安全的方式编写此代码。 并行或异步代码的额外调度灵活性也增加了复杂性。Swift允许您以允许一些编译时检查的方式表达您的意图——例如，您可以使用参与者安全地访问可变状态。然而，向缓慢或错误的代码添加并发并不能保证它会变得快速或正确。事实上，添加并发性甚至可能会使您的代码更难调试。然而，使用Swift对代码中需要并发的并发的语言级支持意味着Swift可以帮助您在编译时发现问题。 本章的其余部分使用并发一词来指代异步和并行代码的常见组合。 注意 如果您以前编写过并发代码，您可能习惯于处理线程。Swift 中的并发模型构建在线程之上，但您不会直接与它们交互。Swift中的异步函数可以放弃它正在运行的线程，这允许另一个异步函数在第一个函数被阻止时在该线程上运行。 虽然可以在不使用Swift语言支持的情况下编写并发代码，但该代码往往更难阅读。例如，以下代码下载照片名称列表，下载该列表中的第一张照片，并向用户显示该照片： listPhotos(inGallery: “Summer Vacation”) { photoNames in ​ let sortedNames &#x3D; photoNames.sorted() ​ let name &#x3D; sortedNames[0] ​ downloadPhoto(named: name) { photo in ​ show(photo) ​ } } 即使在这种简单的情况下，由于代码必须编写为一系列完成处理程序，您最终也会编写嵌套闭包。在这种风格下，具有深嵌套的更复杂的代码可能会很快变得笨拙。 定义和调用异步函数异步函数或异步方法是一种特殊的函数或方法，可以在执行过程中暂停。这与普通的同步函数和方法形成鲜明对比，这些函数和方法要么运行到完成，要么抛出错误，要么永远不会返回。异步函数或方法仍然可以做这三件事之一，但当它等待某事时，它也可以在中间暂停。在异步函数或方法的主体中，您可以标记可以暂停执行的每个地方。 要指示函数或方法是异步的，您将async关键字写入其参数后的声明中，类似于您如何使用throws标记抛出函数。如果函数或方法返回值，则在返回箭头（-&gt;）之前写入async。例如，以下是您可以在图库中获取照片名称的方法： func listPhotos(inGallery name: String) async -&gt; [String] { ​ let result &#x3D; &#x2F;&#x2F; … some asynchronous networking code … ​ return result } 对于既异步又抛出的函数或方法，您在throws前编写async。 当调用异步方法时，执行暂停，直到该方法返回。您在通话前写下await，以标记可能的暂停点。这就像在调用抛出函数时try写入，如果出现错误，则标记程序流程的可能更改。在异步方法中，只有当您调用另一个异步方法时，执行流程才会暂停——暂停从来都不是隐式或先发制人的——这意味着每个可能的暂停点都标有await。 例如，下面的代码获取图库中所有图片的名称，然后显示第一张图片： let photoNames &#x3D; await listPhotos(inGallery: “Summer Vacation”) let sortedNames &#x3D; photoNames.sorted() let name &#x3D; sortedNames[0] let photo &#x3D; await downloadPhoto(named: name) show(photo) 由于listPhotos(inGallery:)和downloadPhoto(named:)功能都需要提出网络请求，因此它们可能需要相对较长的时间才能完成。通过在返回箭头之前写入async使它们都异步，可以让应用程序的其余代码在该代码等待图片准备就绪时继续运行。 为了了解上述示例的并发性质，这里有一个可能的执行顺序： 代码从第一行开始运行，一直运行到第一行await。它调用listPhotos(inGallery:)函数，并在等待该函数返回时暂停执行。 当此代码的执行暂停时，同一程序中还会运行一些其他并发代码。例如，一个长期运行的背景任务可能会继续更新新照片库列表。该代码也会运行到下一个暂停点，以await为标记，或直到它完成。 listPhotos(inGallery:)返回后，此代码从那时开始继续执行。它分配返回到photoNames值。 定义sortedNames和name行是常规的同步代码。由于这些线路上没有标记await，因此没有任何可能的暂停点。 下一个await标志着对downloadPhoto(named:)函数的调用。此代码再次暂停执行，直到该函数返回，使其他并发代码有机会运行。 downloadPhoto(named:)返回后，其返回值被分配给photo，然后在调用show(_:)时作为参数传递。 标记为await的代码中可能的暂停点表示，当前代码可能会在等待异步函数或方法返回时暂停执行。这也被称为生成线程，因为在幕后，Swift暂停在当前线程上执行代码，而是在该线程上运行一些其他代码。由于await的代码需要能够暂停执行，因此程序中的某些地方只能调用异步函数或方法： 异步函数、方法或属性主体中的代码。 标记为@main结构、类或枚举的静态main()方法中的代码。 非结构化子任务中的代码，如下所示。 注意 Task.sleep(nanoseconds:)方法在编写简单代码以了解并发工作原理时非常有用。这种方法什么也做不了，但至少要等待给定的纳秒数才能返回。以下是listPhotos(inGallery:)函数的版本，该函数使用sleep(nanoseconds:)来模拟等待网络操作： func listPhotos(inGallery name: String) async throws -&gt; [String] { ​ try await Task.sleep(nanoseconds: 2 * 1_000_000_000) &#x2F;&#x2F; Two seconds ​ return [“IMG001”, “IMG99”, “IMG0404”] } 异步序列在数组的所有元素准备就绪后，上一节中的listPhotos(inGallery:)函数会异步返回整个数组。另一种方法是使用异步序列一次等待集合的一个元素。以下是异步序列迭代的样子： import Foundation let handle &#x3D; FileHandle.standardInput for try await line in handle.bytes.lines { ​ print(line) } 上面的示例不是使用普通的for-in循环，而是在它之后写for和await。与您调用异步函数或方法时一样，写入await表示可能的悬浮点。当等待下一个元素可用时，await循环可能会在每次迭代开始时暂停执行。 就像您可以通过添加Sequence协议的一致性在for-in循环中使用自己的类型一样，您可以通过添加对AsyncSequence协议的一致性在for-await-in循环中使用自己的类型。 并行调用异步函数调用带有await的异步函数一次只运行一段代码。当异步代码运行时，调用者等待该代码完成，然后再继续运行下一行代码。例如，要从图库中获取前三张照片，您可以等待downloadPhoto(named:)功能的三次调用，具体如下： let firstPhoto &#x3D; await downloadPhoto(named: photoNames[0]) let secondPhoto &#x3D; await downloadPhoto(named: photoNames[1]) let thirdPhoto &#x3D; await downloadPhoto(named: photoNames[2]) let photos &#x3D; [firstPhoto, secondPhoto, thirdPhoto] show(photos) 这种方法有一个重要的缺点：虽然下载是异步的，并允许在进行其他工作时进行，但一次只运行一个downloadPhoto(named:)的调用。每张照片在下一张照片开始下载之前都会完全下载。然而，这些操作无需等待——每张照片都可以独立下载，甚至可以同时下载。 要调用异步函数并让它与周围的代码并行运行，请在定义常量时在let前面写入async，然后在每次使用常量时写入await。 async let firstPhoto &#x3D; downloadPhoto(named: photoNames[0]) async let secondPhoto &#x3D; downloadPhoto(named: photoNames[1]) async let thirdPhoto &#x3D; downloadPhoto(named: photoNames[2]) let photos &#x3D; await [firstPhoto, secondPhoto, thirdPhoto] show(photos) 在本例中，所有三个downloadPhoto(named:)的调用都无需等待前一个调用完成即可开始。如果有足够的系统资源可用，它们可以同时运行。这些函数调用都没有标记为await，因为代码不会暂停等待函数的结果。相反，执行一直持续到定义photos行——此时，程序需要这些异步调用的结果，因此您写await暂停执行，直到所有三张照片完成下载。 以下是您如何思考这两种方法之间的差异： 当以下行上的代码取决于该函数的结果时，使用await调用异步函数。这创造了按顺序进行的工作。 当您直到代码稍后才需要结果时，使用async``let调用异步函数。这创造了可以并行进行的工作。 await和async``let允许其他代码在暂停时运行。 在这两种情况下，您都会用await标记可能的悬浮点，以指示如果需要，执行将暂停，直到返回异步函数。 您还可以在同一代码中混合这两种方法。 任务和任务组任务是可以作为程序的一部分异步运行的工作单元。所有异步代码都作为某些任务的一部分运行。上一节中描述的async``let语法为您创建一个子任务。您还可以创建一个任务组，并将子任务添加到该组中，这使您可以更好地控制优先级和取消，并允许您创建动态数量的任务。 任务排列在层次结构中。任务组中的每个任务都有相同的父任务，每个任务都可以有子任务。由于任务和任务组之间的显式关系，这种方法被称为结构化并发。虽然您承担了一些正确性的责任，但任务之间的明确父子关系允许Swift为您处理一些行为，例如传播取消，并允许Swift在编译时检测到一些错误。 await withTaskGroup(of: Data.self) { taskGroup in ​ let photoNames &#x3D; await listPhotos(inGallery: “Summer Vacation”) ​ for name in photoNames { ​ taskGroup.addTask { await downloadPhoto(named: name) } ​ } } 有关任务组的更多信息，请参阅TaskGroup。 非结构化并发除了前几节中描述的结构化并发方法外，Swift还支持非结构化并发。与任务组中的任务不同，非结构化任务没有父任务。您可以完全灵活地以任何程序需要的方式管理非结构化任务，但您也要对其正确性承担全部责任。要创建在当前参与者上运行的非结构化任务，请调用Task.init(priority:operation:)初始化器。要创建不属于当前参与者的非结构化任务，更具体地说，称为分离任务，请调用Task.detached(priority:operation:)类方法。这两个操作都返回一个任务句柄，允许您与任务交互——例如，等待其结果或取消它。 let newPhoto &#x3D; &#x2F;&#x2F; … some photo data … let handle &#x3D; Task { ​ return await add(newPhoto, toGalleryNamed: “Spring Adventures”) } let result &#x3D; await handle.value 有关管理独立任务的更多信息，请参阅Task。 任务取消Swift并发使用合作取消模型。每个任务都会检查它是否在执行的适当点被取消，并以任何适当的方式响应取消。根据您正在做的工作，这通常意味着以下内容之一： 抛出错误，比如CancellationError 返回nil或空收藏 退回部分完成的工作 要检查取消，请调用Task.checkCancellation()，如果任务已取消，则会抛出CancellationError，要么检查Task.isCancelled的值，并在您自己的代码中处理取消。例如，从图库下载照片的任务可能需要删除部分下载并关闭网络连接。 要手动传播取消，请调用Task.cancel()。 演员与类一样，参与者是引用类型，因此类是引用类型中的值类型和引用类型的比较适用于参与者和类。与类不同，参与者一次只允许一个任务访问其可变状态，这使得多个任务中的代码可以安全地与参与者的同一实例交互。例如，这里有一个记录温度的演员： actor TemperatureLogger { ​ let label: String ​ var measurements: [Int] ​ private(set) var max: Int ​ init(label: String, measurement: Int) { ​ self.label &#x3D; label ​ self.measurements &#x3D; [measurement] ​ self.max &#x3D; measurement ​ } } 您介绍一个带有actor关键字的演员，然后在一对大括号中定义。TemperatureLogger参与者具有演员以外的其他代码可以访问的属性，并限制max属性，因此只有参与者内部的代码可以更新最大值。 您可以使用与结构和类相同的初始化器语法创建参与者的实例。当您访问演员的属性或方法时，您可以使用await来标记潜在的暂停点——例如： let logger &#x3D; TemperatureLogger(label: “Outdoors”, measurement: 25) print(await logger.max) &#x2F;&#x2F; Prints “25” 在本例中，访问logger.max是一个可能的悬架点。由于参与者一次只允许一个任务访问其可变状态，如果来自另一个任务的代码已经在与记录器交互，则该代码在等待访问属性时暂停。 相比之下，作为参与者一部分的代码在访问参与者的属性时不会写入await。例如，这里有一个用新温度更新TemperatureLogger的方法： extension TemperatureLogger { ​ func update(with measurement: Int) { ​ measurements.append(measurement) ​ if measurement &gt; max { ​ max &#x3D; measurement ​ } ​ } } The update(with:) method is already running on the actor, so it doesn’t mark its access to properties like max with await. This method also shows one of the reasons why actors allow only one task at a time to interact with their mutable state: Some updates to an actor’s state temporarily break invariants. The TemperatureLogger actor keeps track of a list of temperatures and a maximum temperature, and it updates the maximum temperature when you record a new measurement. In the middle of an update, after appending the new measurement but before updating max, the temperature logger is in a temporary inconsistent state. Preventing multiple tasks from interacting with the same instance simultaneously prevents problems like the following sequence of events: 您的代码调用update(with:)方法。它首先更新measurements阵列。 在代码可以更新max之前，其他地方的代码会读取最大值和温度数组。 您的代码通过更改max完成更新。 在这种情况下，在其他地方运行的代码会读取错误的信息，因为它对行为者的访问在update(with:)的调用中交织在一起，而数据暂时无效。在使用Swift角色时，您可以防止这个问题，因为它们一次只允许在其状态上执行一次操作，并且该代码只能在await标记暂停点的地方中断。由于update(with:)不包含任何暂停点，因此没有其他代码可以在更新过程中访问数据。 如果您尝试从演员外部访问这些属性，就像使用类实例一样，您将收到编译时错误；例如： print(logger.max) &#x2F;&#x2F; Error 在不写入的情况下访问logger.max失败，因为演员的属性是该演员孤立的本地状态的一部分。Swift保证只有演员内部的代码才能访问演员的本地状态。这种保证被称为演员隔离。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 控制流程","slug":"软件开发/技术/编程语言/swift/Swift基础-控制流程","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.289Z","comments":true,"path":"2022/07/Swift基础-控制流程/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html Swift提供了各种控制流语句。这些包括while循环多次执行任务；if、guard和switch语句，以根据特定条件执行不同的代码分支；以及break和continue将执行流程转移到代码中的另一个点等语句。 Swift还提供了一个for-in循环，可以轻松地在数组、字典、范围、字符串和其他序列上迭代。 Swift的switch语句在许多类似C语言中比它的对应语句强大得多。案例可以匹配许多不同的模式，包括间隔匹配、元组和特定类型的转换。switch情况下的匹配值可以绑定到临时常量或变量，以便在案例正文中使用，复杂的匹配条件可以用每个案例的where子句表示。 For-In循环您可以使用for-in循环迭代序列，例如数组中的项、数字范围或字符串中的字符。 此示例使用for-in循环来迭代数组中的项目： 12345678let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names &#123; print(&quot;Hello, \\(name)!&quot;)&#125;// Hello, Anna!// Hello, Alex!// Hello, Brian!// Hello, Jack! 您还可以迭代字典以访问其键值对。字典迭代时，字典中的每个项目都会作为(key,value)元组返回，您可以将(key,value)元组的成员分解为显式命名的常量，以便在for-in循环的正文中使用。在下面的代码示例中，字典的键被分解为名为animalName的常量，字典的值被分解为名为legCount的常量。 1234567let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]for (animalName, legCount) in numberOfLegs &#123; print(&quot;\\(animalName)s have \\(legCount) legs&quot;)&#125;// cats have 4 legs// ants have 6 legs// spiders have 8 legs Dictionary的内容本质上是无序的，迭代它们并不能保证检索它们的顺序。特别是，您在Dictionary中插入项目的顺序并不能定义它们迭代的顺序。有关数组和字典的更多信息，请参阅集合类型。 您还可以使用数字范围的for-in循环。此示例打印五次表中的前几个条目： 12345678for index in 1...5 &#123; print(&quot;\\(index) times 5 is \\(index * 5)&quot;)&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 正在迭代的序列是从1到5的数字范围，包括使用闭区间运算符（...）所示。index的值设置为范围（1）中的第一个数字，并执行循环中的语句。在这种情况下，循环只包含一个语句，该语句从五次表中打印index当前值的条目。执行语句后，index值将更新为包含范围（2）中的第二个值，并再次调用print(_:separator:terminator:)函数。这个过程一直持续到范围结束。 在上面的示例中，index是一个常量，其值在循环每次迭代开始时自动设置。因此，index在使用之前不必声明。它仅通过包含在循环声明中来隐式声明，而无需let声明关键字。 如果您不需要序列中的每个值，您可以使用下划线代替变量名称来忽略这些值。 12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print(&quot;\\(base) to the power of \\(power) is \\(answer)&quot;)// Prints &quot;3 to the power of 10 is 59049&quot; 上面的示例计算了一个数字对另一个数字幂的值（在这种情况下，3到10的幂）。它使用以1开头和以10结尾的闭合范围将1（即3到0的幂）乘以3、十倍。对于此计算，每次通过循环的单个计数器值是不必要的——代码只需正确执行循环次数。代替循环变量的下划线字符（_）会导致单个值被忽略，并且在循环的每次迭代中不提供对当前值的访问。 在某些情况下，您可能不想使用闭合范围，包括两个端点。考虑在表盘上每分钟绘制刻度。你想画60勾号，从0分钟开始。使用半开范围运算符（..&lt;）包括下界，但不包括上界。有关范围的更多信息，请参阅范围操作员。 1234let minutes = 60for tickMark in 0..&lt;minutes &#123; // render the tick mark each minute (60 times)&#125; 一些用户可能希望在他们的UI中少打勾。他们可以选择每“5”分钟打一个分数。使用’ stride(from:to:by:) ‘函数来跳过不需要的标记。 1234let minuteInterval = 5for tickMark in stride(from: 0, to: minutes, by: minuteInterval) &#123; // render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)&#125; 闭合范围也可用，使用 stride(from:through:by:)代替： 12345let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) &#123; // render the tick mark every 3 hours (3, 6, 9, 12)&#125; 上面的示例使用for-in循环来迭代范围、数组、字典和字符串。但是，您可以使用此语法迭代任何集合，包括您自己的类和集合类型，只要这些类型符合Sequence协议。 While循环while循环执行一组语句，直到条件变成false。当第一次迭代开始前不知道迭代次数时，最好使用这些类型的循环。Swift提供了两种类型的while循环： while在每次通过循环开始时评估其状态。 repeat-while在每次通过循环结束时评估其状态。 Whilewhile循环从评估单个条件开始。如果条件为true，则重复一组语句，直到条件变为false。 以下是while循环的一般形式： while condition { ​ statements } 这个例子玩一个简单的蛇和梯子游戏（也称为滑槽和梯子）： 游戏规则如下： 董事会有25个正方形，目标是降落在25个正方形或25个以上。 玩家的起始方块是“正方形零”，就在棋盘的左下角。 每次转弯，您滚动一个六面骰子，并沿着上面虚线箭头指示的水平路径按该数量的正方形移动。 如果你的转弯在梯子底部结束，你就向上移动。 如果你的转弯在蛇的头上结束，你就沿着那条蛇向下移动。 游戏板由Int值数组表示。它的大小基于一个名为finalSquare常量，该常量用于初始化数组，并在示例后面检查获胜条件。因为玩家从棋盘开始，在“平方零”上，棋盘初始化为26个零Int值，而不是25个。 12let finalSquare = 25var board = [Int](repeating: 0, count: finalSquare + 1) 然后将一些正方形设置为蛇和梯子具有更具体的值。带梯子底座的正数可以将您向上移动，而带蛇头的正方形则有一个负数将您移回板上。 12board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08 正方形3包含一个梯子的底部，该梯子将您移动到正方形11。为了表示这一点，board[03]等于+08，这相当于整数值8（3和11之间的差）。为了对齐值和语句，一元加运算符（+i）显式地与一元减运算符（-i）一起使用，小于10的数字用零填充。（两者都不是严格必要的文体技术，但它们会导致代码更整洁。） 1234567891011121314var square = 0var diceRoll = 0while square &lt; finalSquare &#123; // roll the dice diceRoll += 1 if diceRoll == 7 &#123; diceRoll = 1 &#125; // move by the rolled amount square += diceRoll if square &lt; board.count &#123; // if we&#x27;re still on the board, move up or down for a snake or a ladder square += board[square] &#125;&#125;print(&quot;Game over!&quot;) 上面的例子使用一种非常简单的方法来掷骰子。它不是生成随机数，而是以diceRoll值0开头。每次通过while循环，diceRoll都会增加一个，然后检查它是否变得太大。每当这个返回值等于7时，骰子卷就变得太大，并重置为1。结果是一系列diceRoll值，总是1、2、3、4、5、6、1、2等等。 掷骰子后，玩家通过diceRoll正方形向前移动。骰子卷可能已经将玩家移到了25方块之外，在这种情况下，游戏就结束了。为了应对这种情况，代码检查该square小于board数组的count属性。如果square有效，则将存储在board[square]中的值添加到当前square值中，以向上或向下移动任何梯子或蛇。 注意 如果不执行此检查，board[square]可能会尝试访问board数组范围之外的值，这将触发运行时错误。 然后，电流while循环执行结束，并检查循环的条件，看看是否应该再次执行循环。如果玩家在正方形25上移动或超过25，循环的条件将计算为false，游戏结束。 在这种情况下，while循环是合适的，因为while循环开始时游戏的长度不明确。相反，循环被执行，直到满足特定条件。 Repeat-Whilewhile循环的另一个变体，称为repeat``while循环，在考虑循环的条件之前，先执行一次循环块的传递。然后，它继续重复循环，直到条件为false。 注意 Swift 中的repeat循环类似于其他语言中的while循环。 以下是repeat循环的一般形式： repeat { ​ statements } while condition 这是蛇和梯子的例子，写成repeat循环，而不是while循环。finalSquare、board、square和diceRoll的值初始化方式与while循环完全相同。 123456let finalSquare = 25var board = [Int](repeating: 0, count: finalSquare + 1)board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0 在这个版本的游戏中，循环中的第一个动作是检查梯子或蛇。棋盘上没有梯子将玩家直接带到25号方块，因此不可能通过向上移动梯子来赢得比赛。因此，检查蛇或梯子作为循环中的第一个动作是安全的。 在游戏开始时，玩家处于“平方零”。board[0]总是等于0，没有效果。 12345678910repeat &#123; // move up or down for a snake or ladder square += board[square] // roll the dice diceRoll += 1 if diceRoll == 7 &#123; diceRoll = 1 &#125; // move by the rolled amount square += diceRoll&#125; while square &lt; finalSquareprint(&quot;Game over!&quot;) 在代码检查蛇和梯子后，掷骰子，玩家被diceRoll正方形向前移动。然后，当前的循环执行结束。 循环的条件（whilesquare&lt;finalSquare）与以前相同，但这次要到第一次循环运行结束时才会进行评估。repeat循环的结构比上一个示例中的while循环更适合这个游戏。在上面的while循环中，square+=board[square]总是在循环后立即执行，while条件确认square仍在板上。此行为消除了前面描述的游戏while循环版本中对数组边界检查的需求。 条件声明根据特定条件执行不同的代码通常非常有用。您可能希望在发生错误时运行额外的代码，或者在值变得太高或太低时显示消息。为此，您可以将部分代码附加条件。 Swift提供了两种向代码添加条件分支的方法：if语句和switch语句。通常，您使用if语句来评估只有少数可能结果的简单条件。switch语句更适合具有多种可能排列的更复杂条件，在模式匹配可以帮助选择适当的代码分支执行的情况下非常有用。 if在最简单的形式中，if语句有一个单一的if条件。只有当条件为true时，它才会执行一组语句。 12345var temperatureInFahrenheit = 30if temperatureInFahrenheit &lt;= 32 &#123; print(&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;)&#125;// Prints &quot;It&#x27;s very cold. Consider wearing a scarf.&quot; 上面的例子检查温度是小于还是等于32华氏度（水的冰点）。如果是，则打印一条消息。否则，不会打印消息，代码执行在if语句的关闭大括号后继续。 if语句可以为if条件为false的情况提供一组替代语句，称为e else子句。这些语句由else关键字表示。 1234567temperatureInFahrenheit = 40if temperatureInFahrenheit &lt;= 32 &#123; print(&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;)&#125; else &#123; print(&quot;It&#x27;s not that cold. Wear a t-shirt.&quot;)&#125;// Prints &quot;It&#x27;s not that cold. Wear a t-shirt.&quot; 这两个分支中的一个总是被执行的。由于温度已升至华氏40度，因此不再足够冷，无法建议戴围巾，因此会触发else分支。 您可以将多个if语句链接在一起，以考虑其他子句。 123456789temperatureInFahrenheit = 90if temperatureInFahrenheit &lt;= 32 &#123; print(&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;)&#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(&quot;It&#x27;s really warm. Don&#x27;t forget to wear sunscreen.&quot;)&#125; else &#123; print(&quot;It&#x27;s not that cold. Wear a t-shirt.&quot;)&#125;// Prints &quot;It&#x27;s really warm. Don&#x27;t forget to wear sunscreen.&quot; 在这里，添加了一个额外的if语句，以应对特别温暖的温度。最后的else句仍然存在，它打印了对任何既不太温暖也不太冷的温度的响应。 然而，最终的al else子句是可选的，如果一组条件不需要完整，则可以排除。 123456temperatureInFahrenheit = 72if temperatureInFahrenheit &lt;= 32 &#123; print(&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;)&#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(&quot;It&#x27;s really warm. Don&#x27;t forget to wear sunscreen.&quot;)&#125; 由于温度既不太冷也不太暖，无法触发if或if条件，因此没有打印任何消息。 switchswitch语句考虑一个值，并将其与几种可能的匹配模式进行比较。然后，它根据第一个成功匹配的模式执行适当的代码块。switch语句提供了if语句的替代方案，用于响应多个潜在状态。 以最简单的形式，switch语句将一个值与同一类型的一个或多个值进行比较。 123456789switch some value to consider &#123;case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else&#125; 每个switch语句由多个可能的大小写组成，每个case关键字开头。除了与特定值进行比较外，Swift还为每种情况提供了几种方法来指定更复杂的匹配模式。本章后面将介绍这些选项。 if语句的正文一样，每个case都是代码执行的单独分支。switch语句决定应该选择哪个分支。此过程被称为对正在考虑的值进行切换。 每个switch语句必须详尽无遗。也就是说，所考虑的类型的每个可能值都必须与其中一个switch情况匹配。如果为每个可能的值提供一个案例不合适，您可以定义一个默认大小写，以涵盖任何未显式处理的值。此默认情况由default关键字表示，并且必须始终显示在最后。 此示例使用switch语句来考虑单个小写字符，称为someCharacter： 12345678910let someCharacter: Character = &quot;z&quot;switch someCharacter &#123;case &quot;a&quot;: print(&quot;The first letter of the alphabet&quot;)case &quot;z&quot;: print(&quot;The last letter of the alphabet&quot;)default: print(&quot;Some other character&quot;)&#125;// Prints &quot;The last letter of the alphabet&quot; switch语句的第一个大小写与英语字母表a的第一个字母匹配，其第二个大小写与最后一个字母z匹配。由于switch必须为每个可能的字符（而不仅仅是每个字母字符）有一个大小写，因此此switch语句使用default大小写来匹配a和z以外的所有字符。该条款确保了switch语句详尽无遗。 没有隐含Fallthrough与C和Objective-C中的switch语句不同，Swift中的switch语句不会默认地从每个案例的底部掉到下一个案例中。相反，整个switch语句在第一个匹配的switch案例完成后立即完成执行，而无需显式break语句。这使得switch语句比C中的交换机语句更安全、更易于使用，并避免错误地执行多个switch案例。 注意 虽然 Swift 中不需要break，但您可以使用break语句来匹配和忽略特定案例，或者在案例完成执行之前打破匹配的案例。有关详细信息，请参阅切换语句中的断裂。 每个案例的正文必须包含至少一个可执行的语句。编写以下代码无效，因为第一个案例为空： 123456789let anotherCharacter: Character = &quot;a&quot;switch anotherCharacter &#123;case &quot;a&quot;: // Invalid, the case has an empty bodycase &quot;A&quot;: print(&quot;The letter A&quot;)default: print(&quot;Not the letter A&quot;)&#125;// This will report a compile-time error. 与C中的switch语句不同，此switch语句与&quot;a&quot;和&quot;A&quot;都不匹配。相反，它报告了一个编译时错误，case&quot;a&quot;:不包含任何可执行语句。这种方法避免了从一个案例到另一个案例的意外故障，并使其意图更安全的代码更加清晰。 要使用同时匹配&quot;a&quot;和&quot;A&quot;的单个大小写进行switch请将这两个值组合成一个复合大小写，用逗号分隔值。 12345678let anotherCharacter: Character = &quot;a&quot;switch anotherCharacter &#123;case &quot;a&quot;, &quot;A&quot;: print(&quot;The letter A&quot;)default: print(&quot;Not the letter A&quot;)&#125;// Prints &quot;The letter A&quot; 为了可读性，复合情况也可以写在多行上。有关复合病例的更多信息，请参阅复合案例。 注意 要在特定switch大小写的末尾显式掉线，请使用fallthrough关键字，如Fallthrough中所述。 间隔匹配switch情况下的值可以检查它们是否在间隔内包含。此示例使用数字间隔为任何大小的数字提供自然语言计数： 12345678910111213141516171819let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;let naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = &quot;no&quot;case 1..&lt;5: naturalCount = &quot;a few&quot;case 5..&lt;12: naturalCount = &quot;several&quot;case 12..&lt;100: naturalCount = &quot;dozens of&quot;case 100..&lt;1000: naturalCount = &quot;hundreds of&quot;default: naturalCount = &quot;many&quot;&#125;print(&quot;There are \\(naturalCount) \\(countedThings).&quot;)// Prints &quot;There are dozens of moons orbiting Saturn.&quot; 在上面的示例中，approximateCount在switch语句中计算。每个case都将该值与数字或区间进行比较。由于approximateCount的值在12到100之间，naturalCount被分配到&quot;dozens并从switch语句中转移执行。 元组您可以使用元组在同一switch语句中测试多个值。元组的每个元素都可以根据不同的值或值间隔进行测试。或者，使用下划线字符（_），也称为通配符模式，以匹配任何可能的值。 下面的示例取了一个（x，y）点，表示为类型的简单元组(Int,Int)并在示例后面的图表上对其进行分类。 1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print(&quot;\\(somePoint) is at the origin&quot;)case (_, 0): print(&quot;\\(somePoint) is on the x-axis&quot;)case (0, _): print(&quot;\\(somePoint) is on the y-axis&quot;)case (-2...2, -2...2): print(&quot;\\(somePoint) is inside the box&quot;)default: print(&quot;\\(somePoint) is outside of the box&quot;)&#125;// Prints &quot;(1, 1) is inside the box&quot; switch语句确定该点是在原点（0，0）、红色x轴上、绿色y轴上、以原点为中心的蓝色4乘4框内，还是在框外。 与C不同，Swift允许多个switch考虑相同的值。事实上，点（0，0）可以匹配本示例中的所有四个情况。但是，如果可以进行多次匹配，则始终使用第一个匹配案例。点（0，0）将首先匹配case(0,0)因此所有其他匹配情况将被忽略。 价值绑定switch大小写可以命名其匹配的值或值，以用于临时常量或变量，以便在正文中使用。这种行为被称为值绑定，因为值绑定到案例正文中的临时常量或变量。 下面的示例取了一个（x，y）点，表示为类型(Int,Int)的元组，并将其分类如下图： 12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print(&quot;on the x-axis with an x value of \\(x)&quot;)case (0, let y): print(&quot;on the y-axis with a y value of \\(y)&quot;)case let (x, y): print(&quot;somewhere else at (\\(x), \\(y))&quot;)&#125;// Prints &quot;on the x-axis with an x value of 2&quot; switch语句决定了该点是在红色x轴上，还是在绿色y轴上，还是在其他地方（在两个轴上）。 这三种’ switch ‘情况声明了占位符常量’ x ‘和’ y ‘，它们临时接受’ anotherPoint ‘中的一个或两个元组值。第一种情况，’ case (let x, 0) ‘，匹配任何点的’ y ‘值为’ 0 ‘，并将该点的’ x ‘值赋给临时常数’ x ‘。类似地，第二种情况，’ case (0, let y) ‘，匹配任何点的’ x ‘值为’ 0 ‘，并将该点的’ y ‘值赋给临时常数’ y ‘。 声明临时常量后，它们可以在案例的代码块中使用。在这里，它们用于打印点的分类。 此switch语句没有default案例。最后一个案例，caselet(x,y)声明一个由两个占位符常量组成，可以匹配任何值。由于anotherPoint始终是两个值的元组，因此此情况与所有可能的剩余值匹配，并且不需要default大小写即可使switch语句详尽无遗。 whereswitch盒可以使用where子句来检查其他条件。 以下示例对以下图表上的（x，y）点进行了分类： 12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print(&quot;(\\(x), \\(y)) is on the line x == y&quot;)case let (x, y) where x == -y: print(&quot;(\\(x), \\(y)) is on the line x == -y&quot;)case let (x, y): print(&quot;(\\(x), \\(y)) is just some arbitrary point&quot;)&#125;// Prints &quot;(1, -1) is on the line x == -y&quot; ‘ switch ‘语句确定这个点是在绿色对角线上的’ x &#x3D;&#x3D; y ‘，还是在紫色对角线上的’ x &#x3D;&#x3D; -y ‘，或者两者都不在。 三个switch情况声明占位符常量x和y，这些常量暂时接受 yetAnotherPoint的两个元组值。这些常量被用作where子句的一部分，以创建动态过滤器。where子句的条件计算为true时，switch大小写才匹配point的当前值。 与上一个示例一样，最终大小写匹配所有可能的剩余值，因此不需要default大小写来使switch语句详尽无遗。 复合病例共享同一主体的多个开关案例可以通过在case后写多个模式组合，每个模式之间都有一个逗号。如果任何模式匹配，则认为情况匹配。如果列表很长，图案可以写在多行上。例如： 1234567891011let someCharacter: Character = &quot;e&quot;switch someCharacter &#123;case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;: print(&quot;\\(someCharacter) is a vowel&quot;)case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;: print(&quot;\\(someCharacter) is a consonant&quot;)default: print(&quot;\\(someCharacter) isn&#x27;t a vowel or a consonant&quot;)&#125;// Prints &quot;e is a vowel&quot; switch语句的第一个大小写与英语中的所有五个小写元音相匹配。同样，它的第二个大小写匹配所有小写英语辅音。最后，default大小写与任何其他字符匹配。 复合情况也可以包括值绑定。复合情况的所有模式都必须包含相同的值绑定集，并且每个绑定必须从复合情况下的所有模式中获得相同类型的值。这确保了无论复合情况的哪个部分匹配，大小写正文中的代码都可以始终访问绑定的值，并且该值始终具有相同的类型。 12345678let stillAnotherPoint = (9, 0)switch stillAnotherPoint &#123;case (let distance, 0), (0, let distance): print(&quot;On an axis, \\(distance) from the origin&quot;)default: print(&quot;Not on an axis&quot;)&#125;// Prints &quot;On an axis, 9 from the origin&quot; 上述case有两种模式：(letdistance,0)匹配x轴上的点，(0,letdistance)匹配y轴上的点。这两种模式都包括distance的绑定，distance是两种模式中的整数——这意味着case正文中的代码始终可以访问distance值。 控制转移声明控制转移语句通过将控制权从一段代码传输到另一段代码来更改代码的执行顺序。Swift有五个控制转移语句： continue break fallthrough return throw continue、break和fallthrough的陈述如下所述。return语句在函数中描述，throw语句在使用抛出函数传播错误中描述。 continuecontinue语句告诉循环停止它正在做的事情，并在下一个迭代开始时通过循环重新开始。它说“我完成了当前的循环迭代”，而没有完全离开循环。 以下示例从小写字符串中删除所有元音和空格，以创建神秘的益智短语： 1234567891011let puzzleInput = &quot;great minds think alike&quot;var puzzleOutput = &quot;&quot;let charactersToRemove: [Character] = [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;]for character in puzzleInput &#123; if charactersToRemove.contains(character) &#123; continue &#125; puzzleOutput.append(character)&#125;print(puzzleOutput)// Prints &quot;grtmndsthnklk&quot; 上面的代码每当它匹配元音或空格时都会调用continue关键字，导致循环的当前迭代立即结束，并直接跳转到下一个迭代的开始。 breakbreak语句立即结束整个控制流语句的执行。当您想提前终止switch或循环语句的执行时，可以在switch或循环语句中使用。 打破循环语句当在循环语句中使用时，break会立即结束循环的执行，并在循环的关闭大括号（&#125;）后将控制权传输到代码。没有执行循环当前迭代的进一步代码，也没有开始循环的进一步迭代。 切换语句中的中断当在switch语句中使用时，break会导致switch语句立即结束执行，并在switch语句的关闭大括号（&#125;）后将控制权转移到代码中。 此行为可用于匹配和忽略switch语句中的一个或多个案例。由于 Swift 的switch语句非常详尽，不允许空案例，因此有时需要故意匹配和忽略案例，以便明确您的意图。您通过将break声明写成您要忽略的整个案例正文来做到这一点。当该案例与switch语句匹配时，案例中的break语句将立即结束switch语句的执行。 注意 仅包含注释的switch案例被报告为编译时错误。评论不是陈述，也不会导致switch案例被忽略。务必使用break语句来忽略switch案例。 以下示例切换Character值，并确定它是否代表四种语言之一的数字符号。为了简洁起，单个switch案例中包含多个值。 1234567891011121314151617181920let numberSymbol: Character = &quot;三&quot; // Chinese symbol for the number 3var possibleIntegerValue: Int?switch numberSymbol &#123;case &quot;1&quot;, &quot;١&quot;, &quot;一&quot;, &quot;๑&quot;: possibleIntegerValue = 1case &quot;2&quot;, &quot;٢&quot;, &quot;二&quot;, &quot;๒&quot;: possibleIntegerValue = 2case &quot;3&quot;, &quot;٣&quot;, &quot;三&quot;, &quot;๓&quot;: possibleIntegerValue = 3case &quot;4&quot;, &quot;٤&quot;, &quot;四&quot;, &quot;๔&quot;: possibleIntegerValue = 4default: break&#125;if let integerValue = possibleIntegerValue &#123; print(&quot;The integer value of \\(numberSymbol) is \\(integerValue).&quot;)&#125; else &#123; print(&quot;An integer value couldn&#x27;t be found for \\(numberSymbol).&quot;)&#125;// Prints &quot;The integer value of 三 is 3.&quot; 此示例检查numberSymbol，以确定数字1到4的符号是拉丁文、阿拉伯文、中文还是泰语符号。如果找到匹配项，switch语句的一个案例会设置一个可选的Int?变量称为possibleIntegerValue到适当的整数值。 在switch语句完成执行后，该示例使用可选绑定来确定是否找到了值。由于是可选类型，possibleIntegerValue变量的隐式初始值为nil，因此只有当possibleIntegerValue被switch语句的前四种情况之一设置为实际值时，可选绑定才会成功。 因为在上面的例子中列出所有可能的’ Character ‘值是不实际的，所以’ default ‘ case处理任何不匹配的字符。这种’ default ‘情况不需要执行任何操作，所以它是用一个’ break ‘语句作为它的主体编写的。只要匹配到’ default ‘的大小写，’ break ‘语句就会结束’ switch ‘语句的执行，代码的执行从’ if let ‘语句开始。 fallthrough在 Swift 中，switch语句不会从每个案例的底部掉到下一个案例中。也就是说，整个switch语句在第一个匹配案例完成后立即完成执行。相比之下，C要求您在每个switch盒的末尾插入一个显式break语句，以防止掉线。避免默认的故障意味着Swiftswitch语句比C中的对应语句更简洁、更可预测，因此它们避免错误地执行多个switch案例。 如果您需要C型跌倒性行为，您可以使用fallthrough关键字逐案选择加入此行为。下面的示例使用fallthrough创建数字的文本描述。 1234567891011let integerToDescribe = 5var description = &quot;The number \\(integerToDescribe) is&quot;switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += &quot; a prime number, and also&quot; fallthroughdefault: description += &quot; an integer.&quot;&#125;print(description)// Prints &quot;The number 5 is a prime number, and also an integer.&quot; 此示例声明一个名为description的新String变量，并为其分配初始值。然后，函数使用switch语句考虑integerToDescribe的值。如果integerToDescribe的值是列表中的素数之一，则函数会将文本附加到description的末尾，以注意该数字是素数。然后，它使用fallthrough关键字来“落入”default情况。default情况下，在描述的末尾添加了一些额外的文本，switch语句已完成。 除非integerToDescribe的值在已知素数列表中，否则它根本不与第一个switch情况匹配。由于没有其他特定情况，integerToDescribe与default情况匹配。 switch语句执行完成后，使用print(_:separator:terminator:)函数打印数字描述。在本例中，数字5被正确标识为素数。 注意 fallthrough关键字不会检查它导致执行陷入的switch案例的大小写条件。fallthrough关键字只是导致代码执行直接移动到下一个案例（或default大小写）块中的语句，就像C的标准switch语句行为一样。 带标签的语句在Swift中，您可以在其他循环和条件语句中嵌套循环和条件语句，以创建复杂的控制流结构。然而，循环语句和条件语句都可以使用break语句过早地结束其执行。因此，有时明确您希望break语句终止哪个循环或条件语句是有用的。同样，如果您有多个嵌套循环，明确continue语句应该影响哪个循环可能会有用。 为了实现这些目标，您可以使用声明标签标记循环语句或条件语句。使用条件语句，您可以使用带有break语句的语句标签来结束标记语句的执行。使用循环语句，您可以使用带有break或continue语句的语句标签来结束或继续执行标记语句。 标记语句通过在与语句的介绍关键字相同的行上放置标签来指示，后跟冒号。以下是while循环语法的一个示例，尽管所有循环和switch语句的原则都是一样的： label name: while condition { ​ statements } 以下示例使用您在本章前面看到的Snakes and Ladders游戏改编版本的带有标签while循环的break和continue语句。这一次，游戏有一个额外的规则： 要获胜，你必须正好降落在25号广场。 如果一个特定的骰子卷会带你超过25方块，你必须再次滚动，直到你滚动落在25方块所需的确切数字。 游戏板和以前一样。 finalSquare、board、square和diceRoll的值与之前相同初始化： 123456let finalSquare = 25var board = [Int](repeating: 0, count: finalSquare + 1)board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0 这个版本的游戏使用while循环和switch语句来实现游戏的逻辑。while循环有一个名为gameLoop的语句标签，表示它是蛇和梯子游戏的主要游戏循环。 The while loop’s condition is while square != finalSquare, to reflect that you must land exactly on square 25. 1234567891011121314151617gameLoop: while square != finalSquare &#123; diceRoll += 1 if diceRoll == 7 &#123; diceRoll = 1 &#125; switch square + diceRoll &#123; case finalSquare: // diceRoll will move us to the final square, so the game is over break gameLoop case let newSquare where newSquare &gt; finalSquare: // diceRoll will move us beyond the final square, so roll again continue gameLoop default: // this is a valid move, so find out its effect square += diceRoll square += board[square] &#125;&#125;print(&quot;Game over!&quot;) 骰子在每个循环的开头滚动。Loop不立即移动播放器，而是使用switch语句来考虑移动的结果，并确定是否允许移动： 如果掷骰子将玩家带到最后一个方格，那么游戏就结束了。“break gamelloop”语句将控制转移到“while”循环之外的第一行代码，从而结束游戏。 如果掷骰子将玩家移出最后的方格，那么这一移动就是无效的，玩家需要再次掷骰子。“continue gameLoop”语句结束当前的“while”循环迭代，并开始下一个循环迭代。 在所有其他情况下，掷骰子是一个有效的举动。玩家通过diceRoll方块向前移动，游戏逻辑检查是否有任何蛇和梯子。然后循环结束，控件返回到while条件，以决定是否需要再次回合。 注意 如果上面的break语句没有使用gameLoop标签，它将从switch语句中脱颖而出，而不是while语句。使用gameLoop标签可以明确应该终止哪个控制语句。 当调用“continue gameLoop”来跳转到循环的下一个迭代时，并不一定要使用“gameLoop”标签。游戏中只有一个循环，因此“continue”语句将影响哪个循环并不含糊。然而，在“continue”语句中使用“gameLoop”标签并没有什么坏处。这样做与标签的使用与“中断”声明是一致的，并有助于让游戏的逻辑更清晰地阅读和理解。 提前退出guard语句，如if语句，根据表达式的布尔值执行语句。您使用guard语句要求条件必须为真，才能执行guard语句之后的代码。与if语句不同，guard语句总是有一个else子句——如果条件不正确，则执行else子句中的代码。 123456789101112131415161718192021func greet(person: [String: String]) &#123; guard let name = person[&quot;name&quot;] else &#123; return &#125; print(&quot;Hello \\(name)!&quot;) guard let location = person[&quot;location&quot;] else &#123; print(&quot;I hope the weather is nice near you.&quot;) return &#125; print(&quot;I hope the weather is nice in \\(location).&quot;)&#125;greet(person: [&quot;name&quot;: &quot;John&quot;])// Prints &quot;Hello John!&quot;// Prints &quot;I hope the weather is nice near you.&quot;greet(person: [&quot;name&quot;: &quot;Jane&quot;, &quot;location&quot;: &quot;Cupertino&quot;])// Prints &quot;Hello Jane!&quot;// Prints &quot;I hope the weather is nice in Cupertino.&quot; 如果满足guard语句的条件，则在guard语句的闭幕大括号后继续执行代码。使用可选绑定作为条件的一部分分配值的任何变量或常量都可用于guard语句中显示的代码块的其余部分。 如果不符合此条件，则执行else分支内的代码。该分支必须传输控件才能退出出现guard语句的代码块。它可以通过return、break、continue或throw等控件传输语句来执行此操作，也可以调用不返回的函数或方法，例如fatalError(_:file:line:) 与对if语句进行相同的检查相比，对需求使用guard语句可以提高代码的可读性。它允许您编写通常执行的代码，而无需将其包装在else块中，并允许您将处理违反要求的代码保留在需求旁边。 检查API可用性Swift内置了对检查API可用性的支持，这确保您不会意外使用给定部署目标上不可用的API。 编译器使用SDK中的可用性信息来验证代码中使用的所有API是否在项目指定的部署目标上可用。如果您尝试使用不可用的API，Swift会在编译时报告错误。 您在if或guard语句中使用可用性条件执行代码块，具体取决于您要使用的API在运行时是否可用。编译器在验证该代码块中的API是否可用时，使用可用性条件中的信息。 12345if #available(iOS 10, macOS 10.12, *) &#123; // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS&#125; else &#123; // Fall back to earlier iOS and macOS APIs&#125; 上述可用性条件指定，在iOS中，if语句的正文仅在iOS 10及更高版本中执行；在macOS中，仅在macOS 10.12及更高版本中执行。最后一个参数*是必需的，并指定在任何其他平台上，if的正文对目标指定的最小部署目标执行。 在其一般形式中，可用性条件接受平台名称和版本列表。您可以使用平台名称，如’ iOS ‘， ‘ macOS ‘， ‘ watchOS ‘和’ tvOS ‘ -完整的列表，请参阅声明属性。除了指定主要版本号(如iOS 8或macOS 10.10)外，还可以指定次要版本号(如iOS 11.2.6和macOS 10.13.3)。 12345if #available(platform name version, ..., *) &#123; statements to execute if the APIs are available&#125; else &#123; fallback statements to execute if the APIs are unavailable&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 方法","slug":"软件开发/技术/编程语言/swift/Swift基础-方法","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-方法/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E6%96%B9%E6%B3%95/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Methods.html 方法是与特定类型关联的函数。类、结构和枚举都可以定义实例方法，这些方法封装了处理给定类型实例的特定任务和功能。类、结构和枚举还可以定义类型方法，这些方法与类型本身相关联。类型方法类似于Objective-C中的类方法。 结构和枚举可以在Swift中定义方法，这一事实与C和Objective-C有很大区别。在Objective-C中，类是唯一可以定义方法的类型。在 Swift 中，您可以选择是定义类、结构还是枚举，并且仍然可以灵活地定义您创建的类型上的方法。 实例方法实例方法是属于特定类、结构或枚举实例的函数。它们支持这些实例的功能，要么通过提供访问和修改实例属性的方法，要么通过提供与实例目的相关的功能。实例方法具有与函数完全相同的语法，如函数中所述。 您可以在它所属类型的打开和关闭大括号中编写实例方法。实例方法可以隐式访问该类型的所有其他实例方法和属性。实例方法只能调用其所属类型的特定实例。没有现有实例，就无法孤立地调用它。 以下是定义简单Counter类的示例，可用于计算操作发生的次数： class Counter { ​ var count &#x3D; 0 ​ func increment() { ​ count +&#x3D; 1 ​ } ​ func increment(by amount: Int) { ​ count +&#x3D; amount ​ } ​ func reset() { ​ count &#x3D; 0 ​ } } Counter类定义了三种实例方法： increment()将计数器增加1。 increment(by: Int)计数器以指定的整数量增加。 reset()重置计数器为零。 Counter类还声明一个变量属性count，以跟踪当前计数器值。 您调用与属性具有相同点语法的实例方法： let counter &#x3D; Counter() &#x2F;&#x2F; the initial counter value is 0 counter.increment() &#x2F;&#x2F; the counter’s value is now 1 counter.increment(by: 5) &#x2F;&#x2F; the counter’s value is now 6 counter.reset() &#x2F;&#x2F; the counter’s value is now 0 函数参数可以具有名称（用于函数正文）和参数标签（用于调用函数时），如函数参数标签和参数名称所述。方法参数也是如此，因为方法只是与类型关联的函数。 自我财产类型的每个实例都有一个名为self的隐式属性，这与实例本身完全等价。您使用self属性在自己的实例方法中引用当前实例。 上面示例中的increment()方法可以这样写： func increment() { ​ self.count +&#x3D; 1 } 在实践中，您不需要经常在代码中编写self。如果您没有显式写入self，每当您在方法中使用已知的属性或方法名称时，Swift都会假设您指的是当前实例的属性或方法。Counter的三个实例方法中使用count（而不是self.count）证明了这一假设。 当实例方法的参数名称与该实例的属性具有相同的名称时，就会出现此规则的主要异常。在这种情况下，参数名称优先，有必要以更限定的方式引用该属性。您使用self属性来区分参数名称和属性名称。 在这里，self消除名为x的方法参数和也称为x的实例属性之间的歧义： struct Point { ​ var x &#x3D; 0.0, y &#x3D; 0.0 ​ func isToTheRightOf(x: Double) -&gt; Bool { ​ return self.x &gt; x ​ } } let somePoint &#x3D; Point(x: 4.0, y: 5.0) if somePoint.isToTheRightOf(x: 1.0) { ​ print(“This point is to the right of the line where x &#x3D;&#x3D; 1.0”) } &#x2F;&#x2F; Prints “This point is to the right of the line where x &#x3D;&#x3D; 1.0” 没有self前缀，Swift将假设x的两个用法都提到了称为x的方法参数。 从实例内方法修改值类型结构和枚举是值类型。默认情况下，值类型的属性无法从其实例方法中修改。 但是，如果您需要在特定方法中修改结构或枚举的属性，您可以选择该方法的突变行为。然后，该方法可以从方法内部突变（即更改）其属性，并在方法结束时将其所做的任何更改写回原始结构。该方法还可以为其隐式self属性分配一个全新的实例，当方法结束时，该新实例将取代现有实例。 您可以通过将mutating关键字放在该方法的func关键字之前来选择加入此行为： struct Point { ​ var x &#x3D; 0.0, y &#x3D; 0.0 ​ mutating func moveBy(x deltaX: Double, y deltaY: Double) { ​ x +&#x3D; deltaX ​ y +&#x3D; deltaY ​ } } var somePoint &#x3D; Point(x: 1.0, y: 1.0) somePoint.moveBy(x: 2.0, y: 3.0) print(“The point is now at ((somePoint.x), (somePoint.y))”) &#x2F;&#x2F; Prints “The point is now at (3.0, 4.0)” The Point structure above defines a mutating moveBy(x:y:) method, which moves a Pointinstance by a certain amount. Instead of returning a new point, this method actually modifies the point on which it’s called. The mutating keyword is added to its definition to enable it to modify its properties. 请注意，您无法在结构类型的常量上调用突变方法，因为它的属性无法更改，即使它们是变量属性，如常量结构实例的存储属性中所述： let fixedPoint &#x3D; Point(x: 3.0, y: 3.0) fixedPoint.moveBy(x: 2.0, y: 3.0) &#x2F;&#x2F; this will report an error 在突变方法中分配给自我突变方法可以为隐式self属性分配一个全新的实例。上面显示的Point示例可以写成以下方式： struct Point { ​ var x &#x3D; 0.0, y &#x3D; 0.0 ​ mutating func moveBy(x deltaX: Double, y deltaY: Double) { ​ self &#x3D; Point(x: x + deltaX, y: y + deltaY) ​ } } This version of the mutating moveBy(x:y:) method creates a new structure whose x and yvalues are set to the target location. The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version. 枚举的突变方法可以将隐式self参数设置为与同一枚举不同的情况： enum TriStateSwitch { ​ case off, low, high ​ mutating func next() { ​ switch self { ​ case .off: ​ self &#x3D; .low ​ case .low: ​ self &#x3D; .high ​ case .high: ​ self &#x3D; .off ​ } ​ } } var ovenLight &#x3D; TriStateSwitch.low ovenLight.next() &#x2F;&#x2F; ovenLight is now equal to .high ovenLight.next() &#x2F;&#x2F; ovenLight is now equal to .off 此示例定义了三态开关的枚举。每次调用其next()方法时，开关都会在三种不同的功率状态（off、low和high）之间循环。 类型方法如上所述，实例方法是您在特定类型的实例上调用的方法。您还可以定义在类型本身上调用的方法。这些方法被称为类型方法。您可以通过在方法的func关键字之前写入static关键字来指示类型方法。类可以使用class关键字，以允许子类覆盖超类对该方法的实现。 注意 在Objective-C中，您只能为Objective-C类定义类型级方法。在 Swift 中，您可以为所有类、结构和枚举定义类型级方法。每个类型方法都显式扩展到它支持的类型。 类型方法使用点语法调用，就像实例方法一样。但是，您在类型上调用类型方法，而不是在该类型的实例上调用类型方法。以下是您在名为SomeClass的类上调用类型方法的方法： class SomeClass { ​ class func someTypeMethod() { ​ &#x2F;&#x2F; type method implementation goes here ​ } } SomeClass.someTypeMethod() 在类型方法的主体中，隐式self属性是指类型本身，而不是该类型的实例。这意味着您可以使用self来消除类型属性和类型方法参数之间的歧义，就像您对实例属性和实例方法参数所做的那样。 更一般地说，您在类型方法正文中使用的任何不合格的方法和属性名称都将引用其他类型级方法和属性。类型方法可以调用另一个类型方法，使用另一个方法的名称，而无需将其前缀为类型名称。同样，结构和枚举上的类型方法可以通过使用类型属性的名称来访问类型属性，而无需类型名称前缀。 下面的示例定义了一个名为LevelTracker的结构，该结构跟踪玩家在游戏的不同关卡或阶段的进度。这是一个单人游戏，但可以在一台设备上存储多个玩家的信息。 游戏首次玩游戏时，游戏的所有关卡（除一级外）都已锁定。每次玩家完成关卡时，该关卡都会为设备上的所有玩家解锁。LevelTracker结构使用类型属性和方法来跟踪游戏的哪些关卡已解锁。它还跟踪单个玩家的当前级别。 struct LevelTracker { ​ static var highestUnlockedLevel &#x3D; 1 ​ var currentLevel &#x3D; 1 ​ static func unlock(_ level: Int) { ​ if level &gt; highestUnlockedLevel { highestUnlockedLevel &#x3D; level } ​ } ​ static func isUnlocked(_ level: Int) -&gt; Bool { ​ return level &lt;&#x3D; highestUnlockedLevel ​ } ​ @discardableResult ​ mutating func advance(to level: Int) -&gt; Bool { ​ if LevelTracker.isUnlocked(level) { ​ currentLevel &#x3D; level ​ return true ​ } else { ​ return false ​ } ​ } } The LevelTracker structure keeps track of the highest level that any player has unlocked. This value is stored in a type property called highestUnlockedLevel. LevelTracker还定义了两种类型函数，以使用highestUnlockedLevel属性。第一个是名为unlock(_:)的类型函数，每当解锁新级别时，它都会更新highestUnlockedLevel的值。第二个是名为isUnlocked(_:)的方便类型函数，如果特定级别号已解锁，则返回true。（请注意，这些类型方法可以访问highestUnlockedLevel类型属性，而无需将其写为LevelTracker.highestUnlockedLevel。） 除了其类型属性和类型方法外，LevelTracker还跟踪单个玩家在游戏中的进度。它使用名为currentLevel的实例属性来跟踪玩家当前正在播放的级别。 To help manage the currentLevel property, LevelTracker defines an instance method called advance(to:). Before updating currentLevel, this method checks whether the requested new level is already unlocked. The advance(to:) method returns a Boolean value to indicate whether or not it was actually able to set currentLevel. Because it’s not necessarily a mistake for code that calls the advance(to:) method to ignore the return value, this function is marked with the @discardableResult attribute. For more information about this attribute, see Attributes. LevelTracker结构与如下所示的Player类一起使用，以跟踪和更新单个玩家的进度： class Player { ​ var tracker &#x3D; LevelTracker() ​ let playerName: String ​ func complete(level: Int) { ​ LevelTracker.unlock(level + 1) ​ tracker.advance(to: level + 1) ​ } ​ init(name: String) { ​ playerName &#x3D; name ​ } } The Player class creates a new instance of LevelTracker to track that player’s progress. It also provides a method called complete(level:), which is called whenever a player completes a particular level. This method unlocks the next level for all players and updates the player’s progress to move them to the next level. (The Boolean return value of advance(to:) is ignored, because the level is known to have been unlocked by the call to LevelTracker.unlock(_:) on the previous line.) 您可以为新玩家创建Player类的实例，并查看玩家完成一级时会发生什么： var player &#x3D; Player(name: “Argyrios”) player.complete(level: 1) print(“highest unlocked level is now (LevelTracker.highestUnlockedLevel)”) &#x2F;&#x2F; Prints “highest unlocked level is now 2” 如果您创建了第二个玩家，并试图将该玩家移动到游戏中任何玩家尚未解锁的关卡，则设置玩家当前关卡的尝试失败： player &#x3D; Player(name: “Beto”) if player.tracker.advance(to: 6) { ​ print(“player is now on level 6”) } else { ​ print(“level 6 hasn’t yet been unlocked”) } &#x2F;&#x2F; Prints “level 6 hasn’t yet been unlocked”","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 枚举","slug":"软件开发/技术/编程语言/swift/Swift基础-枚举","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-枚举/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html 枚举为一组相关值定义了通用类型，并使您能够在代码中以类型安全的方式处理这些值。 如果您熟悉C，您将知道C枚举为一组整数值分配相关名称。Swift 中的枚举要灵活得多，不必为每个枚举案例提供值。如果为每个枚举情况提供了一个值（称为原始值），则该值可以是字符串、字符或任何整数或浮点类型的值。 或者，枚举大小写可以指定要存储的任何类型的关联值，以及每个不同的大小写值，就像其他语言中的联合或变体一样。您可以将一组常见的相关情况定义为一个枚举的一部分，每个枚举都有与之关联的不同类型值集。 Swift 中的枚举本身就是一流的类型。它们采用了许多传统上仅由类支持的功能，例如计算属性以提供有关枚举当前值的更多信息，以及实例方法，以提供与枚举所代表的值相关的功能。枚举还可以定义初始化器以提供初始大小写值；可以扩展其功能，使其功能超出原始实现；并且可以遵守协议以提供标准功能。 有关这些功能的更多信息，请参阅属性、方法、初始化、扩展和协议。 枚举语法您使用enum关键字引入枚举，并将它们的整个定义放在一对大括号中： 123enum SomeEnumeration &#123; // enumeration definition goes here&#125; 以下是指南针四个要点的示例： 123456enum CompassPoint &#123; case north case south case east case west&#125; 枚举中定义的值（如north、south、east和west）是其枚举情况。您可以使用case关键字来引入新的枚举案例。 注意 与C和Objective-C等语言不同，Swift枚举案例默认没有设置整数值。在上面的CompassPoint示例中，north、south、east和west不隐含等于0、1、2和3。相反，不同的枚举情况本身就是值，具有明确定义的CompassPoint类型。 多个案例可以出现在一行上，用逗号分隔： 123enum Planet &#123; case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 每个枚举定义都定义了一种新类型。与Swift中的其他类型一样，他们的名字（如CompassPoint和Planet）以大写字母开头。给出枚举类型单数而不是复数名称，以便它们读起来不言而喻： 1var directionToHead = CompassPoint.west ‘ directionToHead ‘的类型在它被’ compaspoint ‘的可能值之一初始化时被推断出来。一旦’ directionToHead ‘被声明为’ compaspoint ‘，你可以使用一个更短的点语法将它设置为一个不同的’ compaspoint ‘值: 1directionToHead = .east directionToHead的类型已经知道，因此您可以在设置其值时删除该类型。这使得在处理显式类型的枚举值时具有高度可读性的代码。 将枚举值与Switch语句匹配您可以将单个枚举值与switch语句匹配： 123456789101112directionToHead = .southswitch directionToHead &#123;case .north: print(&quot;Lots of planets have a north&quot;)case .south: print(&quot;Watch out for penguins&quot;)case .east: print(&quot;Where the sun rises&quot;)case .west: print(&quot;Where the skies are blue&quot;)&#125;// Prints &quot;Watch out for penguins&quot; 您可以将此代码读取为： 考虑directionToHead的价值。在它等于.north的情况下，打印&quot;Lotsplanetshavenorth&quot;在它等于.south的情况下，打印&quot;Watchoutpenguins&quot; …等等。 如Control Flow中所述，在考虑枚举的情况时，switch语句必须详尽无遗。如果省略.west``case，此代码不会编译，因为它不考虑CompassPoint案例的完整列表。要求详尽无遗，确保枚举案例不会被意外省略。 如果不适合为每个枚举案例提供case，您可以提供default案例来涵盖任何未明确解决的案例： 12345678let somePlanet = Planet.earthswitch somePlanet &#123;case .earth: print(&quot;Mostly harmless&quot;)default: print(&quot;Not a safe place for humans&quot;)&#125;// Prints &quot;Mostly harmless&quot; 迭代枚举案例对于某些枚举，收集所有枚举的案例是有用的。您通过在枚举名称后写入:CaseIterable来启用此功能。Swift将所有案例的集合公开为枚举类型的allCases属性。这里有一个例子： 123456enum Beverage: CaseIterable &#123; case coffee, tea, juice&#125;let numberOfChoices = Beverage.allCases.countprint(&quot;\\(numberOfChoices) beverages available&quot;)// Prints &quot;3 beverages available&quot; 在上面的示例中，您编写Beverage.allCases来访问包含Beverage枚举所有案例的集合。您可以像使用任何其他集合一样使用allCases——集合的元素是枚举类型的实例，因此在这种情况下，它们是Beverage值。上面的示例计算了有多少个案例，下面的示例使用for-in循环来迭代所有案例。 123456for beverage in Beverage.allCases &#123; print(beverage)&#125;// coffee// tea// juice 上面示例中使用的语法将枚举标记为符合CaseIterable协议。有关协议的信息，请参阅协议。 关联值上一节中的示例显示了枚举的情况本身是如何定义（和键入）的值。您可以为Planet.earth设置常量或变量，稍后检查此值。然而，有时将其他类型的值与这些大小写值一起存储是有用的。此附加信息称为关联值，每次您将该情况用作代码中的值时，它都会有所不同。 您可以定义Swift枚举来存储任何给定类型的关联值，如果需要，每个枚举情况下的值类型可能不同。类似的枚举被称为歧视联合、标记联合或其他编程语言的变体。 例如，假设库存跟踪系统需要通过两种不同类型的条形码跟踪产品。一些产品以UPC格式标有1D条形码，使用数字0到9。每个条形码都有一个数字系统数字，然后是五个制造商代码数字和五个产品代码数字。后面跟着一个检查数字，以验证代码是否已正确扫描： 其他产品以二维码格式标有二维条形码，可以使用任何ISO 8859-1字符，并可以对长度高达2953个字符的字符串进行编码： 库存跟踪系统可以方便地将UPC条形码存储为四个整数的元组，并将二维码条形码存储为任何长度的字符串。 在 Swift 中，用于定义任一类型的产品条形码的枚举可能如下所示： 1234enum Barcode &#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125; 这可以理解为： “定义一个名为‘Barcode’的枚举类型，它可以接受一个带有类型关联值(‘Int’，‘Int’，‘Int’，‘Int’)的‘upc’值，或者一个带有类型关联值(‘String’)的‘qrCode’值。” 此定义不提供任何实际的Int或String值——它只是定义了Barcode常量和变量在等于Barcode.upc或Barcode.qrCode时可以存储的关联值类型。 然后，您可以使用任一类型创建新条形码： 1var productBarcode = Barcode.upc(8, 85909, 51226, 3) 下面的例子创建了一个名为“productBarcode”的新变量，并将其赋值为“Barcode”。Upc ‘，关联元组值为’(8,85909,51226,3)’。 您可以为同一产品分配不同类型的条形码： 1productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;) 此时，原始Barcode.upc及其整数值将被newBarcodeBarcode.qrCode及其字符串值取代。Barcode类型的常量和变量可以存储.upc或.qrCode（及其相关值），但它们在任何给定时间只能存储其中之一。 您可以使用开关语句检查不同的条形码类型，类似于将枚举值与交换机语句匹配中的示例。然而，这一次，关联值作为开关语句的一部分提取。您可以将每个关联值提取为常量（带有let前缀）或变量（带有var前缀），以便在switch大小写的正文中使用： 1234567switch productBarcode &#123;case .upc(let numberSystem, let manufacturer, let product, let check): print(&quot;UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).&quot;)case .qrCode(let productCode): print(&quot;QR code: \\(productCode).&quot;)&#125;// Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot; 如果枚举情况的所有关联值都被提取为常量，或者所有关联值都被提取为变量，为了简洁起义，您可以在案例名称之前放置单个var或let注释： 1234567switch productBarcode &#123;case let .upc(numberSystem, manufacturer, product, check): print(&quot;UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).&quot;)case let .qrCode(productCode): print(&quot;QR code: \\(productCode).&quot;)&#125;// Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot; 原始值关联值中的条形码示例显示了枚举案例如何声明它们存储不同类型的关联值。作为关联值的替代品，枚举情况可以预先填充默认值（称为原始值），这些值都是同一类型。 以下是将原始ASCII值与命名枚举案例一起存储的示例： 12345enum ASCIIControlCharacter: Character &#123; case tab = &quot;\\t&quot; case lineFeed = &quot;\\n&quot; case carriageReturn = &quot;\\r&quot;&#125; 在这里，名为ASCIIControlCharacter的枚举的原始值被定义为Character类型，并设置为一些更常见的ASCII控制字符。Character值在字符串和字符中描述。 原始值可以是字符串、字符或任何整数或浮点数类型。每个原始值在其枚举声明中必须是唯一的。 注意 原始值与关联值不同。当您首次在代码中定义枚举时，原始值设置为预填充值，如上面的三个ASCII代码。特定枚举情况的原始值始终相同。当您根据枚举的一个情况创建新常量或变量时，会设置关联值，并且每次这样做时都可能不同。 隐式分配的原始值当您处理存储整数或字符串原始值的枚举时，您不必为每个案例显式分配原始值。当您不这样做时，Swift会自动为您分配值。 例如，当整数用于原始值时，每种情况下的隐式值比上一个大小写多一个。如果第一个案例没有值集，则其值为0。 以下枚举是对早期Planet枚举的细化，其整数原始值表示每颗行星与太阳的顺序： 123enum Planet: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 在上面的示例中，Planet.mercury的显式原始值为1，Planet.venus的隐式原始值为2，以此类推。 当字符串用于原始值时，每个案例的隐式值是该案例名称的文本。 下面的枚举是对早期CompassPoint枚举的细化，字符串原始值表示每个方向的名称： 123enum CompassPoint: String &#123; case north, south, east, west&#125; 在上面的示例中，CompassPoint.south具有&quot;south&quot;等隐式原始值。 您可以使用其rawValue属性访问枚举案例的原始值： 12345let earthsOrder = Planet.earth.rawValue// earthsOrder is 3let sunsetDirection = CompassPoint.west.rawValue// sunsetDirection is &quot;west&quot; 从原始值初始化如果您使用原始值类型定义枚举，枚举会自动收到一个初始化器，该初始化器接受原始值类型的值（作为称为rawValue的参数），并返回枚举大小写或nil。您可以使用此初始化器尝试创建枚举的新实例。 此示例从原始值7中识别天王星： 12let possiblePlanet = Planet(rawValue: 7)// possiblePlanet is of type Planet? and equals Planet.uranus 然而，并不是所有可能的“Int”值都能找到匹配的行星。因此，原始值初始化器总是返回一个可选的枚举情况。在上面的例子中，“可能行星”的类型是“行星?”或者“可选的‘行星’。” 注意 原始值初始化器是一个失败的初始化器，因为并非每个原始值都会返回一个枚举情况。有关更多信息，请参阅失败的初始化器。 如果您试图找到位置为11的行星，原始值初始化器返回的可选Planet值将为nil： 123456789101112let positionToFind = 11if let somePlanet = Planet(rawValue: positionToFind) &#123; switch somePlanet &#123; case .earth: print(&quot;Mostly harmless&quot;) default: print(&quot;Not a safe place for humans&quot;) &#125;&#125; else &#123; print(&quot;There isn&#x27;t a planet at position \\(positionToFind)&quot;)&#125;// Prints &quot;There isn&#x27;t a planet at position 11&quot; 这个例子使用了可选的绑定来访问一个原始值为’ 11 ‘的行星。语句’ if let somePlanet &#x3D; Planet(rawValue: 11) ‘创建了一个可选的’ Planet ‘，并将’ somePlanet ‘设置为可选的’ Planet ‘的值，如果它可以被检索。在这种情况下，不可能检索位置为“11”的行星，所以执行“else”分支。 递归枚举递归枚举是一种枚举，其枚举的另一个实例作为一个或多个枚举案例的关联值。您通过在枚举前indirect写入来指示枚举情况是递归的，这告诉编译器插入必要的间接层。 例如，这里有一个存储简单算术表达式的枚举： 12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 你也可以在枚举的开始之前写’ indirect ‘来为所有有关联值的枚举情况启用间接: 12345indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 此枚举可以存储三种算术表达式:普通数字、两个表达式的加法和两个表达式的乘法。“加法”和“乘法”的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式’(5 + 4)* 2 ‘在乘法运算的右边有一个数字，在乘法运算的左边有另一个表达式。因为数据是嵌套的，所以用于存储数据的枚举也需要支持嵌套——这意味着 12341. let five = ArithmeticExpression.number(5)2. let four = ArithmeticExpression.number(4)3. let sum = ArithmeticExpression.addition(five, four)4. let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2)) 递归函数是处理具有递归结构的数据的一种简单方法。例如，这里有一个计算算术表达式的函数： 12345678910111213func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125;print(evaluate(product))// Prints &quot;18&quot; 此函数只需返回相关值即可计算纯数。它通过评估左侧的表达式，在右侧评估表达式，然后将它们添加或乘以它们来计算加法或乘法。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 类型铸造","slug":"软件开发/技术/编程语言/swift/Swift基础-类型铸造","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-类型铸造/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E9%93%B8%E9%80%A0/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html 类型转换是一种检查实例类型的方法，或将该实例视为与自身类层次结构中其他地方不同的超类或子类。 Swift中的类型转换是用is``as运算符实现的。这两个运算符提供了一种简单而富有表现力的方式来检查值的类型或将值转换为其他类型。 您还可以使用类型转换来检查类型是否符合协议，如“检查协议一致性”中所述。 定义类型铸造的类层次结构您可以使用带有类和子类层次结构的类型转换来检查特定类实例的类型，并将该实例转换为同一层次结构中的另一个类。下面的三个代码片段定义了类的层次结构和包含这些类实例的数组，用于类型转换示例。 第一个片段定义了一个名为MediaItem的新基类。该类为数字媒体库中出现的任何类型的项目提供基本功能。具体来说，它声明String类型的name属性和initname初始化器。（假设所有媒体项目，包括所有电影和歌曲，都将有一个名称。） class MediaItem { ​ var name: String ​ init(name: String) { ​ self.name &#x3D; name ​ } } 下一个片段定义了MediaItem的两个子类。第一个子类“Movie会封装有关某部或某部电影的其他信息。它在基础MediaItem类之上添加了一个director属性，并带有相应的初始化器。第二个子类Song在基类之上添加了artist属性和初始化器： class Movie: MediaItem { ​ var director: String ​ init(name: String, director: String) { ​ self.director &#x3D; director ​ super.init(name: name) ​ } } class Song: MediaItem { ​ var artist: String ​ init(name: String, artist: String) { ​ self.artist &#x3D; artist ​ super.init(name: name) ​ } } 最后一个片段创建一个名为library的常量数组，其中包含两个Movie实例和三个Song实例。通过使用数组文字的内容初始化库数组来推断library数组的类型。Swift的类型检查器能够推断Movie和Song具有常见的MediaItem超类，因此它推断出库数组的[MediaItem]类型： let library &#x3D; [ ​ Movie(name: “Casablanca”, director: “Michael Curtiz”), ​ Song(name: “Blue Suede Shoes”, artist: “Elvis Presley”), ​ Movie(name: “Citizen Kane”, director: “Orson Welles”), ​ Song(name: “The One And Only”, artist: “Chesney Hawkes”), ​ Song(name: “Never Gonna Give You Up”, artist: “Rick Astley”) ] &#x2F;&#x2F; the type of “library” is inferred to be [MediaItem] 存储在library中的项目仍然是幕后Movie和Song实例。但是，如果您迭代此数组的内容，则您收到的项目被键入为MediaItem，而不是Movie或Song。为了将他们作为他们的原生类型，您需要检查他们的类型，或将他们降为其他类型，如下所述。 检查类型使用类型检查运算符（is）来检查实例是否属于特定子类类型。如果实例属于该子类类型，类型检查运算符返回true，如果不是该子类类型，则返回false。 以下示例定义了两个变量，movieCount和songCount，它们计算library数组中的Movie和Song实例数量： var movieCount &#x3D; 0 var songCount &#x3D; 0 for item in library { ​ if item is Movie { ​ movieCount +&#x3D; 1 ​ } else if item is Song { ​ songCount +&#x3D; 1 ​ } } print(“Media library contains (movieCount) movies and (songCount) songs”) &#x2F;&#x2F; Prints “Media library contains 2 movies and 3 songs” 此示例迭代library数组中的所有项目。在每次传递中，for-in循环将item常量设置为数组中的下一个MediaItem。 item is Movie如果当前MediaItem是Movie实例，则返回true，如果不是，则返回false。同样，itemisSong，检查项目是否是Song实例。在for-in循环的末尾，movieCount和songCount的值包含每种类型的MediaItem实例数量。 压倒特定类类型的常量或变量实际上可能指幕后子类的实例。如果您认为情况就是这样，您可以尝试使用类型转换运算符**降到子类类型（as?或者as!）。 由于下调可能会失败，类型转换运算符有两种不同的形式。条件形式as?返回您试图向下转换的类型的可选值。强迫形式，as!，尝试压倒和强迫将结果包装为单个复合动作。 使用类型转换运算符的条件形式（as?）当你不确定沮丧的人是否会成功时。这种形式的运算符将始终返回一个可选值，如果无法进行向下转换，该值将为nil。这使您能够检查是否成功下调。 使用类型转换运算符的强制形式（as!）只有当你确信沮丧的人会永远成功的时候。如果您尝试将这种形式的运算符降到错误的类类型，将触发运行时错误。 以下示例对library中的每个MediaItem迭代，并为每个项目打印适当的描述。要做到这一点，它需要将每个项目作为真正的Movie或Song访问，而不仅仅是作为MediaItem。这是必要的，这样它才能访问Movie或Song的director或artist属性，以便在描述中使用。 在本例中，数组中的每个项目可能是Movie，也可能是Song。您事先不知道每个项目应使用哪个实际类，因此使用类型转换运算符的条件形式是合适的（as?）每次通过循环检查降压： for item in library { ​ if let movie &#x3D; item as? Movie { ​ print(“Movie: (movie.name), dir. (movie.director)”) ​ } else if let song &#x3D; item as? Song { ​ print(“Song: (song.name), by (song.artist)”) ​ } } &#x2F;&#x2F; Movie: Casablanca, dir. Michael Curtiz &#x2F;&#x2F; Song: Blue Suede Shoes, by Elvis Presley &#x2F;&#x2F; Movie: Citizen Kane, dir. Orson Welles &#x2F;&#x2F; Song: The One And Only, by Chesney Hawkes &#x2F;&#x2F; Song: Never Gonna Give You Up, by Rick Astley 该示例首先尝试将当前item降为Movie。因为item是MediaItem实例，所以它可能是一部Movie；同样，它也可能是一首Song，甚至只是一个基本的MediaItem。因为这种不确定性，as?当尝试将类型转换为子类类型时，类型转换运算符的形式返回一个可选值。item的结果as?Movie类型为Movie?，或“可选Movie”。 当应用于库数组中Song实例时，将向下转换到Movie失败。为了应对这种情况，上面的示例使用可选绑定来检查可选Movie是否真的包含一个值（即找出被关闭的版本是否成功）。这个可选绑定写为“ifletmovie=itemas?Movie”，可以读作： “尝试将item作为Movie访问。如果成功，请将名为movie的新临时常量设置为存储在返回的可选Movie中的值。” 如果压制成功，则使用movie的属性来打印该Movie实例的描述，包括其director的姓名。类似的原则用于检查Song实例，并在库中找到Song时打印适当的描述（包括artist姓名）。 注意 铸造实际上不会修改实例或更改其值。基础实例保持不变；它只是作为其被转换到的类型的实例进行处理和访问。 任何和AnyObject的类型铸造Swift 提供了两种特殊类型，用于处理非特定类型： Any可以表示任何类型的实例，包括函数类型。 AnyObject可以表示任何类类型的实例。 仅当您明确需要它们提供的行为和功能时，才使用Any和AnyObject。最好具体说明您希望在代码中使用的类型。 以下是使用Any处理不同类型组合的示例，包括函数类型和非类类型。该示例创建一个名为things的数组，可以存储类型为Any的值： var things: [Any] &#x3D; [] things.append(0) things.append(0.0) things.append(42) things.append(3.14159) things.append(“hello”) things.append((3.0, 5.0)) things.append(Movie(name: “Ghostbusters”, director: “Ivan Reitman”)) things.append({ (name: String) -&gt; String in “Hello, (name)” }) things数组包含两个Int值、两个Double值、一个String值、一个类型的元组(Double,Double)电影“Ghostbusters”和一个接受String值并返回另一个String值的闭包表达式。 To discover the specific type of a constant or variable that’s known only to be of type Any or AnyObject, you can use an is or as pattern in a switch statement’s cases. The example below iterates over the items in the things array and queries the type of each item with a switch statement. Several of the switch statement’s cases bind their matched value to a constant of the specified type to enable its value to be printed: for thing in things { ​ switch thing { ​ case 0 as Int: ​ print(“zero as an Int”) ​ case 0 as Double: ​ print(“zero as a Double”) ​ case let someInt as Int: ​ print(“an integer value of (someInt)”) ​ case let someDouble as Double where someDouble &gt; 0: ​ print(“a positive double value of (someDouble)”) ​ case is Double: ​ print(“some other double value that I don’t want to print”) ​ case let someString as String: ​ print(“a string value of &quot;(someString)&quot;“) ​ case let (x, y) as (Double, Double): ​ print(“an (x, y) point at (x), (y)”) ​ case let movie as Movie: ​ print(“a movie called (movie.name), dir. (movie.director)”) ​ case let stringConverter as (String) -&gt; String: ​ print(stringConverter(“Michael”)) ​ default: ​ print(“something else”) ​ } } &#x2F;&#x2F; zero as an Int &#x2F;&#x2F; zero as a Double &#x2F;&#x2F; an integer value of 42 &#x2F;&#x2F; a positive double value of 3.14159 &#x2F;&#x2F; a string value of “hello” &#x2F;&#x2F; an (x, y) point at 3.0, 5.0 &#x2F;&#x2F; a movie called Ghostbusters, dir. Ivan Reitman &#x2F;&#x2F; Hello, Michael 注意 Any类型表示任何类型的值，包括可选类型。如果您使用可选值，其中需要Any类型的值，Swift会向您发出警告。如果您确实需要将可选值用作Any值，您可以使用as运算符将可选值显式转换为Any，如下所示。 let optionalNumber: Int? &#x3D; 3 things.append(optionalNumber) &#x2F;&#x2F; Warning things.append(optionalNumber as Any) &#x2F;&#x2F; No warning","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 结构和类","slug":"软件开发/技术/编程语言/swift/Swift基础-结构和类","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-结构和类/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html 结构和类是通用的、灵活的结构，成为程序代码的构建块。您定义属性和方法，使用定义常量、变量和函数的相同语法为结构和类添加功能。 与其他编程语言不同，Swift不要求您为自定义结构和类创建单独的接口和实现文件。在Swift中，您在单个文件中定义结构或类，该类或结构的外部接口会自动供其他代码使用。 注意 类的实例传统上被称为对象。然而，与其他语言相比，Swift结构和类的功能要接近得多，本章的大部分内容描述了适用于类或结构类型的实例的功能。因此，使用了更通用的术语实例。 比较结构和类Swift中的结构和类有很多共同点。两者都可以： 定义属性以存储值 定义提供功能的方法 定义下标，以使用下标语法提供对其值的访问 定义初始化器以设置其初始状态 扩展以将其功能扩展到默认实现之外 符合协议，提供某种类型的标准功能 有关更多信息，请参阅属性、方法、下标、初始化、扩展和协议。 类具有结构所没有的额外功能： 继承使一个类继承另一个类的特征。 类型转换使您可以在运行时检查和解释类实例的类型。 去初始化器使类的实例能够释放其分配的任何资源。 引用计数允许对类实例进行多个引用。 有关更多信息，请参阅继承、类型铸造、去初始化和自动引用计数。 类支持的额外功能以增加复杂性为代价。作为一般准则，更喜欢结构，因为它们更容易推理，并在适当或必要时使用类。在实践中，这意味着您定义的大多数自定义数据类型将是结构和枚举。有关更详细的比较，请参阅在结构和类之间进行选择。 注意 班级和演员有许多相同的特征和行为。有关演员的信息，请参阅并发。 定义语法结构和类具有相似的定义语法。您引入了带有struct关键字的结构和带有class关键字的类。两者都将整个定义放在一对大括号中： 123456struct SomeStructure &#123; // structure definition goes here&#125;class SomeClass &#123; // class definition goes here&#125; 注意 无论何时定义一个新的结构或类，都要定义一个新的Swift类型。给类型命名为‘UpperCamelCase’(比如这里的‘SomeStructure’和‘SomeClass’)，以匹配标准Swift类型(比如‘String’，‘Int’和‘Bool’)的大小写。将属性和方法命名为“lowerCamelCase”(例如“frameRate”和“incrementCount”)，以区别于类型名称。 以下是结构定义和类定义的示例： 12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 上面的示例定义了一个名为Resolution的新结构，以描述基于像素的显示分辨率。这种结构有两个存储属性，称为width和height。存储属性是捆绑并作为结构或类的一部分存储的常量或变量。通过将这两个属性设置为初始整数值为0，可以推断为Int类型。 上面的示例还定义了一个名为VideoMode的新类，以描述视频显示的特定视频模式。该类有四个变量存储属性。第一个，resolution，用一个新的Resolution结构实例初始化，该实例推断出Resolution的属性类型。对于其他三个属性，新的VideoMode实例将初始化为false的interlaced设置（意思是“非隔行视频”），播放帧速率为0.0，以及名为name的可选String值。name属性会自动被赋予nil的默认值或“无name值”，因为它是可选类型。 结构和类实例‘ Resolution ‘结构定义和’ VideoMode ‘类定义只描述了’ Resolution ‘或’ VideoMode ‘的外观。它们本身并不描述特定的分辨率或视频模式。为此，您需要创建结构或类的实例。 创建实例的语法对结构和类都非常相似： 12let someResolution = Resolution()let someVideoMode = VideoMode() 结构和类都对新实例使用初始化器语法。最简单的初始化器语法形式使用类或结构的类型名称，后跟空括号，如Resolution()或VideoMode()。这会创建一个类或结构的新实例，任何属性都初始化为默认值。类和结构初始化在初始化中进行了更详细的描述。 访问属性您可以使用点语法访问实例的属性。在点语法中，您立即在实例名称之后写入属性名称，用句点（.）分隔，没有任何空格： 12print(&quot;The width of someResolution is \\(someResolution.width)&quot;)// Prints &quot;The width of someResolution is 0&quot; 在本例中，someResolution.width引用someResolution的width属性，并返回其默认初始值0。 您可以深入了解子属性，例如VideoMode``resolution属性中的width属性： 12print(&quot;The width of someVideoMode is \\(someVideoMode.resolution.width)&quot;)// Prints &quot;The width of someVideoMode is 0&quot; 您还可以使用点语法为变量属性分配新值： 123someVideoMode.resolution.width = 1280print(&quot;The width of someVideoMode is now \\(someVideoMode.resolution.width)&quot;)// Prints &quot;The width of someVideoMode is now 1280&quot; 结构类型的成员初始化器所有结构都有一个自动生成的按成员初始化器，您可以使用它初始化新结构实例的成员属性。新实例属性的初始值可以通过名称传递给成员初始化器： 1let vga = Resolution(width: 640, height: 480) 与结构不同，类实例不会收到默认的按成员初始化器。初始化器在初始化中进行了更详细的描述。 结构和枚举是值类型值类型是一种类型，其值在分配给变量或常量时，或当传递给函数时被复制。 在前几章中，您实际上一直在广泛使用值类型。事实上，Swift中的所有基本类型——整数、浮点数、布尔值、字符串、数组和字典——都是值类型，并作为幕后结构实现。 所有结构和枚举都是Swift中的值类型。这意味着，您创建的任何结构和枚举实例，以及它们作为属性的任何值类型，在代码中传递时，总是会被复制。 注意 标准库定义的集合，如数组、字典和字符串，使用优化来降低复制的性能成本。这些集合不是立即复制，而是共享内存，其中元素存储在原始实例和任何副本之间。如果集合的副本之一被修改，则在修改前复制元素。您在代码中看到的行为总是像是立即复制一样。 考虑这个例子，它使用上一个示例中的Resolution结构： 12let hd = Resolution(width: 1920, height: 1080)var cinema = hd 此示例声明一个名为hd常量，并将其设置为使用全高清视频的宽度和高度初始化的Resolution实例（1920像素宽，高1080像素）。 然后，它声明一个名为cinema的变量，并将其设置为hd的当前值。因为Resolution是一个结构，所以制作了现有实例的副本，并将这个新副本分配给cinema。尽管hd``cinema现在具有相同的宽度和高度，但它们是幕后两个完全不同的实例。 接下来，cinema的width属性被修改为用于数字影院投影的稍宽的2K标准的宽度（宽2048像素，高1080像素）： 1cinema.width = 2048 检查cinema的width属性表明，它确实变成了2048： 12print(&quot;cinema is now \\(cinema.width) pixels wide&quot;)// Prints &quot;cinema is now 2048 pixels wide&quot; 然而，原始hd实例的width属性仍然具有1920年的旧值： 12print(&quot;hd is still \\(hd.width) pixels wide&quot;)// Prints &quot;hd is still 1920 pixels wide&quot; 当给cinema当前hd值时，存储在hd中的值被复制到新的cinema实例中。最终结果是两个完全独立的实例，其中包含相同的数字值。然而，由于它们是单独的实例，将cinema的宽度设置为2048不会影响存储在hd中的宽度，如下图所示： 同样的行为也适用于枚举： 1234567891011121314enum CompassPoint &#123; case north, south, east, west mutating func turnNorth() &#123; self = .north &#125;&#125;var currentDirection = CompassPoint.westlet rememberedDirection = currentDirectioncurrentDirection.turnNorth()print(&quot;The current direction is \\(currentDirection)&quot;)print(&quot;The remembered direction is \\(rememberedDirection)&quot;)// Prints &quot;The current direction is north&quot;// Prints &quot;The remembered direction is west&quot; 当rememberedDirection被分配到currentDirection的值时，它实际上被设置为该值的副本。此后更改currentDirection的值不会影响存储在rememberedDirection中的原始值的副本。 类是参考类型与值类型不同，引用类型在分配给变量或常量或传递给函数时不会复制。使用对相同现有实例的引用，而不是副本。 以下是使用上面定义的VideoMode类的示例： 12345let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = &quot;1080i&quot;tenEighty.frameRate = 25.0 这个例子声明了一个名为’ ten80 ‘的新常量，并将其设置为指向’ VideoMode ‘类的一个新实例。视频模式被分配一个以前的高清分辨率“1920”到“1080”的副本。它被设置为交错，它的名称被设置为‘1080i’，它的帧速率被设置为‘25.0’帧每秒。 接下来，tenEighty分配给一个新的常量，称为alsoTenEighty，并修改了alsoTenEighty帧速率： 12let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0 由于类是引用类型，tenEighty和alsoTenEighty实际上都引用同一个VideoMode实例。实际上，它们只是同一单个实例的两个不同名称，如下图所示： 检查tenEighty的frameRate属性表明，它从底层VideoMode实例正确报告了30.0的新帧速率： 12print(&quot;The frameRate property of tenEighty is now \\(tenEighty.frameRate)&quot;)// Prints &quot;The frameRate property of tenEighty is now 30.0&quot; 这个例子还展示了引用类型如何更难推理。如果tenEighty和alsoTenEighty程序的代码中相距甚远，可能很难找到更改视频模式的所有方式。无论你在哪里使用tenEighty，你还必须考虑使用alsoTenEighty的代码，反之亦然。相比之下，值类型更容易推理，因为所有与相同值交互的代码都在源文件中紧密相连。 请注意，tenEighty和alsoTenEighty被声明为常量，而不是变量。但是，您仍然可以更改tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty常量本身的值实际上没有变化。tenEighty和alsoTenEighty本身不会“存储”VideoMode实例，相反，它们都指幕后VideoMode实例。更改的是底层VideoMode的frameRate属性，而不是对该VideoMode的常量引用的值。 身份运算符由于类是引用类型，因此多个常量和变量可以在幕后引用类的同一单个实例。（结构和枚举并非如此，因为它们在分配给常量或变量或传递给函数时总是被复制。） 有时，找出两个常量或变量是否引用一个类的完全相同的实例是有用的。为了实现这一点，Swift提供了两个身份运算符： 相同到（===) Not identical to (!==) 使用这些运算符检查两个常量或变量是否引用同一个实例： 1234if tenEighty === alsoTenEighty &#123; print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;)&#125;// Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot; 请注意，相同于（由三个相等符号表示，或===并不意味着等于（由两个相等符号表示，或==相同。与类类型的两个常量或变量引用完全相同的类实例相同。等于意味着两个实例在值上被认为是相等或等价的，对于类型设计器定义的相等的适当含义。 当您定义自己的自定义结构和类时，您有责任决定什么符合两个相等的条件。定义自己实现==和的过程!=运算符在等效运算符中描述。 指针如果您有使用C、C++或Objective-C的经验，您可能知道这些语言使用指针来引用内存中的地址。引用某些引用类型的实例的Swift常量或变量类似于C中的指针，但不是指向内存中地址的直接指针，并且不需要您编写星号（*）来指示您正在创建引用。相反，这些引用的定义与Swift中的任何其他常量或变量一样。标准库提供了指针和缓冲区类型，如果您需要直接与指针交互，您可以使用这些类型，请参阅手动内存管理。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 继承","slug":"软件开发/技术/编程语言/swift/Swift基础-继承","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-继承/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html 一个类可以从另一个类继承方法、属性和其他特征。当一个类从另一个类继承时，继承类被称为子类，它继承的类被称为其超类。继承是一种基本行为，可以将类与 Swift 中的其他类型区分开来。 Swift中的类可以调用和访问属于其超类的方法、属性和下标，并可以提供这些方法、属性和下标的覆盖版本，以细化或修改其行为。Swift通过检查覆盖定义是否具有匹配的超类定义来帮助确保您的覆盖正确。 类还可以将属性观察者添加到继承的属性中，以便在属性值发生变化时收到通知。属性观察者可以添加到任何属性中，无论它最初是否被定义为存储或计算属性。 定义基类任何不从另一个类继承的类都被称为基类。 注意 Swift类不会从通用基类继承。您在不指定超类的情况下定义的类会自动成为供您构建的基类。 下面的示例定义了一个名为Vehicle的基类。该基类定义了一个名为currentSpeed存储属性，默认值为0.0（推断Double的属性类型）。currentSpeed属性的值被称为description的只读计算String属性用于创建车辆的描述。 Vehicle基类还定义了一个名为makeNoise的方法。此方法实际上对基本Vehicle实例不起作用，但稍后将由Vehicle子类自定义： class Vehicle { ​ var currentSpeed &#x3D; 0.0 ​ var description: String { ​ return “traveling at (currentSpeed) miles per hour” ​ } ​ func makeNoise() { ​ &#x2F;&#x2F; do nothing - an arbitrary vehicle doesn’t necessarily make a noise ​ } } 您创建一个带有初始化器语法的新Vehicle实例，该语法写为类型名称，后跟空括号： let someVehicle &#x3D; Vehicle() 创建新的Vehicle实例后，您可以访问其description属性，以打印车辆当前速度的人类可读描述： print(“Vehicle: (someVehicle.description)”) &#x2F;&#x2F; Vehicle: traveling at 0.0 miles per hour Vehicle类定义了任意车辆的常见特征，但其本身没有多大用处。为了使其更有用，您需要对其进行细化，以描述更具体的车辆类型。 子分类子类是将新类建立在现有类的基础上的行为。子类继承了现有类的特征，然后您可以对其进行细化。您还可以为子类添加新特征。 要指示子类有一个超类，请在超类名称之前写下子类名称，用冒号分隔： class SomeSubclass: SomeSuperclass { ​ &#x2F;&#x2F; subclass definition goes here } 以下示例定义了一个名为Bicycle的子类，具有超类Vehicle： class Bicycle: Vehicle { ​ var hasBasket &#x3D; false } 新的Bicycle类会自动获得Vehicle的所有特征，例如其currentSpeed和description属性及其makeNoise()方法。 除了继承的特征外，Bicycle类还定义了一个新的存储属性hasBasket，默认值为false（为该属性推断一种Bool类型）。 默认情况下，您创建的任何新Bicycle实例都不会有篮子。创建特定Bicycle实例后，您可以将该实例的hasBasket属性设置为true： let bicycle &#x3D; Bicycle() bicycle.hasBasket &#x3D; true 您还可以修改Bicycle实例的继承的currentSpeed属性，并查询实例的继承description属性： bicycle.currentSpeed &#x3D; 15.0 print(“Bicycle: (bicycle.description)”) &#x2F;&#x2F; Bicycle: traveling at 15.0 miles per hour 子类本身可以被子类。下一个示例为被称为“串联”的双座自行车创建Bicycle子类： class Tandem: Bicycle { ​ var currentNumberOfPassengers &#x3D; 0 } Tandem inherits all of the properties and methods from Bicycle, which in turn inherits all of the properties and methods from Vehicle. The Tandem subclass also adds a new stored property called currentNumberOfPassengers, with a default value of 0. 如果您创建Tandem实例，您可以处理其任何新的和继承的属性，并查询它从Vehicle继承的只读description属性： let tandem &#x3D; Tandem() tandem.hasBasket &#x3D; true tandem.currentNumberOfPassengers &#x3D; 2 tandem.currentSpeed &#x3D; 22.0 print(“Tandem: (tandem.description)”) &#x2F;&#x2F; Tandem: traveling at 22.0 miles per hour 压倒一切的子类可以提供实例方法、类型方法、实例属性、类型属性或下标的自定义实现，否则它将从超类继承。这被称为压倒一切。 要覆盖否则会继承的特征，请在覆盖定义前加上override关键字。这样做会澄清您打算提供重写，并且没有错误地提供匹配的定义。意外覆盖可能会导致意外行为，任何没有override关键字的覆盖都会在编译代码时被诊断为错误。 override关键字还会提示Swift编译器检查重写类的超类（或其父类之一）的声明是否与您为重写提供的声明相匹配。此检查可确保您的重写定义正确无误。 访问超类方法、属性和下标当您为子类提供方法、属性或下标覆盖时，有时使用现有的超类实现作为重写的一部分非常有用。例如，您可以细化该现有实现的行为，或将修改后的值存储在现有继承的变量中。 在适当的情况下，您可以使用super前缀访问方法、属性或下标的超类版本： 名为someMethod()重写方法可以通过在重写方法实现中调用super.someMethod()来调用someMethod()的超类版本。 名为someProperty的重写属性可以在重写getter或setter实现中以super.someProperty的形式访问someProperty的超类版本。 someIndex的重写下标可以从重写下标实现中访问与super[someIndex]相同的下标的超类版本。 压倒一切的方法您可以重写继承的实例或类型方法，以便在子类中提供方法的定制或替代实现。 以下示例定义了一个名为Train的新Vehicle子类，该子类覆盖了Train从Vehicle继承的makeNoise()方法： class Train: Vehicle { ​ override func makeNoise() { ​ print(“Choo Choo”) ​ } } 如果您创建一个新的Train实例并调用其makeNoise()方法，您可以看到该方法的Train子类版本被调用： let train &#x3D; Train() train.makeNoise() &#x2F;&#x2F; Prints “Choo Choo” 压倒一切的属性您可以重写继承的实例或类型属性，为该属性提供自己的自定义获取器和设置器，或添加属性观察器，以使重写属性能够观察基础属性值何时更改。 压倒一切的财产获取者和设定者您可以提供自定义获取器（如果适用，并酌情提供设置器）来覆盖任何继承的属性，无论继承的属性是在源代码中实现为存储的还是计算属性。子类不知道继承属性的存储或计算性质——它只知道继承属性具有特定的名称和类型。您必须始终声明要重写的属性的名称和类型，以使编译器能够检查您的重写是否与具有相同名称和类型的超类属性匹配。 您可以通过在子类属性重写中同时提供获取器和设置器来将继承的只读属性呈现为读写属性。但是，您不能将继承的读写属性显示为只读属性。 注意 如果您提供设置器作为属性覆盖的一部分，您还必须为该覆盖提供获取器。如果您不想在覆盖getter中修改继承属性的值，只需从getter返回super.someProperty来传递继承的值，其中someProperty是您要重写的属性的名称。 以下示例定义了一个名为Car的新类，这是Vehicle的一个子类。TheCar类引入了一个新的存储属性，称为gear，默认整数值为1。TheCar类还覆盖了它从Vehicle继承的description属性，以提供包含当前齿轮的自定义描述： class Car: Vehicle { ​ var gear &#x3D; 1 ​ override var description: String { ​ return super.description + “ in gear (gear)” ​ } } The override of the description property starts by calling super.description, which returns the Vehicle class’s description property. The Car class’s version of descriptionthen adds some extra text onto the end of this description to provide information about the current gear. 如果您创建Car类的实例并设置其gear和currentSpeed属性，您可以看到它的description属性返回在Car类中定义的定制描述： let car &#x3D; Car() car.currentSpeed &#x3D; 25.0 car.gear &#x3D; 3 print(“Car: (car.description)”) &#x2F;&#x2F; Car: traveling at 25.0 miles per hour in gear 3 压倒一切的财产观察者您可以使用属性重写将属性观察者添加到继承的属性中。这使您能够在继承属性的值发生变化时收到通知，无论该属性最初是如何实现的。有关财产观察员的更多信息，请参阅财产观察员。 注意 您无法将属性观察者添加到继承的常量存储属性或继承的只读计算属性。无法设置这些属性的值，因此不宜提供将willSet或didSet实现作为重写的一部分。 另请注意，您无法同时提供同一属性的重写设置器和重写属性观察器。如果您想观察属性值的变化，并且您已经在为该属性提供自定义设置器，您可以简单地从自定义设置器中观察任何值更改。 以下示例定义了一个名为AutomaticCar的新类，这是Car的一个子类。AutomaticCar类表示带有自动变速箱的汽车，该变速箱根据当前速度自动选择要使用的适当齿轮： class AutomaticCar: Car { ​ override var currentSpeed: Double { ​ didSet { ​ gear &#x3D; Int(currentSpeed &#x2F; 10.0) + 1 ​ } ​ } } 每当您设置AutomaticCar实例的currentSpeed属性时，该属性的sdidSet观察器都会将实例的gear属性设置为新速度的适当齿轮选择。具体来说，属性观察者选择一个新的currentSpeed值除以10的齿轮，四舍五入到最近的整数，加上1。35.0的速度产生4的齿轮： let automatic &#x3D; AutomaticCar() automatic.currentSpeed &#x3D; 35.0 print(“AutomaticCar: (automatic.description)”) &#x2F;&#x2F; AutomaticCar: traveling at 35.0 miles per hour in gear 4 防止重写You can prevent a method, property, or subscript from being overridden by marking it as final. Do this by writing the final modifier before the method, property, or subscript’s introducer keyword (such as final var, final func, final class func, and final subscript). 任何在子类中重写最终方法、属性或下标的尝试都将报告为编译时错误。您添加到扩展类的方法、属性或下标也可以在扩展的定义中标记为最终。 您可以通过在类定义（finalclass）中的class关键字之前编写final修饰符，将整个类标记为最终修饰语。任何对最终类进行子类的尝试都将报告为编译时错误。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 自动参考计数","slug":"软件开发/技术/编程语言/swift/Swift基础-自动参考计数","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-自动参考计数/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E8%87%AA%E5%8A%A8%E5%8F%82%E8%80%83%E8%AE%A1%E6%95%B0/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html Swift 使用自动参考计数 (ARC) 来跟踪和管理 app 的内存使用情况。在大多数情况下，这意味着内存管理在Swift中“有效”，您无需自己考虑内存管理。当不再需要类实例时，ARC会自动释放类实例使用的内存。 然而，在少数情况下，ARC需要有关代码部分之间关系的更多信息，以便为您管理内存。本章介绍了这些情况，并展示了如何启用ARC来管理应用程序的所有内存。在Swift中使用ARC与过渡到ARC发布说明中描述的将ARC与Objective-C一起使用的方法非常相似。 引用计数仅适用于类实例。结构和枚举是值类型，而不是引用类型，不会通过引用存储和传递。 ARC的工作原理每次您创建类的新实例时，ARC都会分配一大块内存来存储有关该实例的信息。此内存包含有关实例类型的信息，以及与该实例关联的任何存储属性的值。 此外，当不再需要实例时，ARC会释放该实例使用的内存，以便将内存用于其他目的。这确保了类实例在不再需要时不会占用内存空间。 但是，如果ARC要处理仍在使用的实例，将无法再访问该实例的属性或调用该实例的方法。事实上，如果您尝试访问该实例，您的应用程序很可能会崩溃。 为了确保实例在仍然需要时不会消失，ARC跟踪当前引用每个类实例的属性、常量和变量数量。只要至少存在对实例的至少一个活动引用，ARC就不会处理该实例。 为了做到这一点，每当您将类实例分配给属性、常量或变量时，该属性、常量或变量都会强烈引用该实例。该引用被称为“强”引用，因为它牢牢抓住该实例，只要该强引用仍然存在，就不允许将其交易。 ARC在行动以下是自动引用计数工作原理的示例。此示例从一个名为Person的简单类开始，该类定义了一个名为name的存储常量属性： class Person { ​ let name: String ​ init(name: String) { ​ self.name &#x3D; name ​ print(“(name) is being initialized”) ​ } ​ deinit { ​ print(“(name) is being deinitialized”) ​ } } Person类有一个初始化器，可以设置实例的name属性，并打印一条消息来指示初始化正在进行中。Person类还有一个去初始化器，当类的实例被释放时，它会打印消息。 下一个代码片段定义了类型为Person?的三个变量，用于在后续代码片段中设置对新Person实例的多个引用。由于这些变量是可选类型（Person?，而不是Person），它们会自动初始化，值为nil，目前不引用Person实例。 var reference1: Person? var reference2: Person? var reference3: Person? 您现在可以创建一个新的Person实例，并将其分配给以下三个变量之一： reference1 &#x3D; Person(name: “John Appleseed”) &#x2F;&#x2F; Prints “John Appleseed is being initialized” Note that the message &quot;John Appleseed is being initialized&quot; is printed at the point that you call the Person class’s initializer. This confirms that initialization has taken place. 由于新的Person实例已分配给reference1变量，因此现在reference1对新Person实例有强烈引用。由于至少有一个强有力的参考，ARC确保这个人被保存在记忆中，并且没有被释放。 如果您将同一Person实例分配给另外两个变量，则会建立对该实例的两个更强引用： reference2 &#x3D; reference1 reference3 &#x3D; reference1 现在有三个强烈的引用这个单一Person实例。 如果您通过将nil配给其中两个变量来破坏其中两个强引用（包括原始引用），则将保留一个强引用，并且Person实例未被释放： reference1 &#x3D; nil reference2 &#x3D; nil 在第三个也是最后一个强引用被破坏之前，ARC不会处理Person实例，此时很明显您不再使用Person实例： reference3 &#x3D; nil &#x2F;&#x2F; Prints “John Appleseed is being deinitialized” 类实例之间的较强参考周期在上面的示例中，ARC能够跟踪您创建的新Person实例的引用数量，并在不再需要时处理该Person实例。 然而，可以编写类实例永远不会达到零强引用的代码。如果两个类实例彼此保持强烈引用，这样每个实例都会保持另一个实例的活力，则会发生这种情况。这被称为强参考周期。 您通过将类之间的一些关系定义为弱引用或无名引用而不是强引用来解决强引用周期。这个过程在解决类实例之间的强引用周期中进行了描述。然而，在您学习如何解决强参考周期之前，了解这种周期是如何导致的非常有用。 Here’s an example of how a strong reference cycle can be created by accident. This example defines two classes called Person and Apartment, which model a block of apartments and its residents: class Person { ​ let name: String ​ init(name: String) { self.name &#x3D; name } ​ var apartment: Apartment? ​ deinit { print(“(name) is being deinitialized”) } } class Apartment { ​ let unit: String ​ init(unit: String) { self.unit &#x3D; unit } ​ var tenant: Person? ​ deinit { print(“Apartment (unit) is being deinitialized”) } } 每个Person实例都有一个String类型的name属性和一个最初为nil可选apartment属性。apartment物业是可选的，因为一个人可能并不总是有公寓。 同样，每个Apartment实例都有一个String类型的unit属性，并且有一个最初为nil的可选tenant属性。租户物业是可选的，因为公寓可能并不总是有租户。 这两个类还定义了一个去初始化器，该初始化器打印了该类的实例正在被非初始化的事实。这使您能够查看Person和Apartment的实例是否按预期进行处理。 下一个代码片段定义了两个可选类型的变量，称为john和unit4A，这些变量将设置为下面的特定Apartment和Person实例。由于是可选的，这两个变量的初始值为nil： var john: Person? var unit4A: Apartment? 您现在可以创建特定的Person实例和Apartment实例，并将这些新实例分配给john和unit4A变量： john &#x3D; Person(name: “John Appleseed”) unit4A &#x3D; Apartment(unit: “4A”) 以下是创建和分配这两个实例后强引用的外观。john变量现在强烈引用新的Person实例，unit4A变量强烈引用新的Apartment实例： 您现在可以将这两个实例链接在一起，以便该人拥有公寓，而公寓则拥有租户。请注意，感叹号 (!)用于解开和访问存储在john和unit4A可选变量中的实例，以便可以设置这些实例的属性： john!.apartment &#x3D; unit4A unit4A!.tenant &#x3D; john 以下是将两个实例链接在一起后强引用的外观： 不幸的是，将这两个实例联系起来会在它们之间产生强大的参考周期。Person实例现在强烈引用Apartment实例，Apartment实例强烈引用Person实例。因此，当您打破john和unit4A变量持有的强引用时，引用计数不会降至零，并且实例也不会由ARC分配： john &#x3D; nil unit4A &#x3D; nil 请注意，当您将这两个变量设置为nil时，两者都不调用非初始化器。强大的参考周期可防止Person和Apartment实例被释放，导致应用程序内存泄漏。 以下是将john和unit4A变量设置为nil后强引用的外观： Person实例和Apartment实例之间的强烈引用仍然存在，不能被打破。 解决类实例之间的强引用周期当您处理类类型的属性时，Swift提供了两种解决强引用周期的方法：弱引用和无名引用。 弱和无拥有引用使参考周期中的一个实例能够引用另一个实例，而无需强势控制它。然后，这些实例可以相互引用，而不会创建强大的参考周期。 当另一个实例的生命周期较短时，即当另一个实例可以首先进行交易时，请使用弱引用。在上面的Apartment示例中，公寓在其生命周期的某个阶段没有租户是合适的，因此在这种情况下，弱参考是打破参考周期的适当方式。相比之下，当另一个实例具有相同的生命周期或更长的生命周期时，请使用非拥有的引用。 弱引用弱引用是一种引用，它不会强烈保留它所指的实例，因此不会阻止ARC处理引用的实例。此行为阻止引用成为强引用周期的一部分。您可以通过将weak关键字放在属性或变量声明之前来指示弱引用。 由于弱引用不能强力保留其引用的实例，因此当弱引用仍在引用时，该实例可能会被释放。因此，当它引用的实例被释放时，ARC会自动将弱引用设置为nil。而且，由于弱引用需要允许其值在运行时更改为nil，因此它们总是声明为可选类型的变量，而不是常量。 您可以像任何其他可选值一样，检查弱引用中是否存在值，并且您永远不会引用不再存在的无效实例。 注意 当ARC将弱引用设置为nil时，不会调用属性观察者。 下面的示例与上面的Person和Apartment示例相同，有一个重要的区别。这一次，Apartment类型的tenant物业被宣布为薄弱的参考： class Person { ​ let name: String ​ init(name: String) { self.name &#x3D; name } ​ var apartment: Apartment? ​ deinit { print(“(name) is being deinitialized”) } } class Apartment { ​ let unit: String ​ init(unit: String) { self.unit &#x3D; unit } ​ weak var tenant: Person? ​ deinit { print(“Apartment (unit) is being deinitialized”) } } 来自两个变量（john和unit4A）的强引用以及两个实例之间的联系与以前一样创建： var john: Person? var unit4A: Apartment? john &#x3D; Person(name: “John Appleseed”) unit4A &#x3D; Apartment(unit: “4A”) john!.apartment &#x3D; unit4A unit4A!.tenant &#x3D; john 现在您已将这两个实例链接在一起，参考资料的外观如下： Person实例仍然对Apartment实例有很强的引用，但Apartment实例现在对Person实例的引用很弱。这意味着，当您通过将john变量设置为nil来破坏其持有的强引用时，对Person实例不再有更强引用： john &#x3D; nil &#x2F;&#x2F; Prints “John Appleseed is being deinitialized” 由于没有更强烈的引用Person实例，因此它被分配，tenant属性设置为nil： 对Apartment实例的唯一强烈引用来自unit4A变量。如果您打破了该强引用，则不再有对Apartment实例的强引用： unit4A &#x3D; nil &#x2F;&#x2F; Prints “Apartment 4A is being deinitialized” 由于没有更强烈的Apartment实例，所以它也被分配了： 注意 在使用垃圾收集的系统中，有时使用弱指针来实现简单的缓存机制，因为只有当内存压力触发垃圾收集时，才会释放没有强引用的对象。然而，对于ARC，值在删除其最后一个强引用后立即进行分配，这使得弱引用不适合此目的。 未知参考资料与弱引用一样，无拥有引用不会强烈保留其引用的实例。然而，与弱引用不同，当另一个实例具有相同或更长的生命周期时，会使用非拥有引用。您可以通过将非unowned关键字放在属性或变量声明之前来指示非所有引用。 与弱引用不同，无拥有引用应该始终具有值。因此，将值标记为非所有值并不使其成为可选的，ARC永远不会将无拥有引用的值设置为nil。 重要 仅当您确定引用总是引用未被释放的实例时，才使用非拥有的引用。 如果您在实例被释放后尝试访问该实例的值，您将收到一个运行时错误。 以下示例定义了两个类别，Customer和CreditCard，它们为银行客户建模，并为该客户建模可能的信用卡。这两个类都存储另一个类的实例作为属性。这种关系有可能创造一个强大的参考周期。 Customer和CreditCard之间的关系与上面薄弱的参考示例中看到的Apartment和Person之间的关系略有不同。在这种数据模型中，客户可能有也可能没有信用卡，但信用卡将始终与客户相关联。CreditCard实例永远不会比它所指Customer长寿。为了表示这一点，Customer类有一个可选的card属性，但CreditCard类有一个非拥有（和非可选）customer属性。 此外，新的CreditCard实例只能通过将number值和customer实例传递给自定义CreditCard初始化器来创建。这确保了在创建信用卡实例时，CreditCard实例始终有一个customer实例相关联。 由于信用卡总是有客户，因此您可以将其customer财产定义为非所有权参考，以避免强大的参考周期： class Customer { ​ let name: String ​ var card: CreditCard? ​ init(name: String) { ​ self.name &#x3D; name ​ } ​ deinit { print(“(name) is being deinitialized”) } } class CreditCard { ​ let number: UInt64 ​ unowned let customer: Customer ​ init(number: UInt64, customer: Customer) { ​ self.number &#x3D; number ​ self.customer &#x3D; customer ​ } ​ deinit { print(“Card #(number) is being deinitialized”) } } 注意 CreditCard类number属性使用UInt64而不是Int来定义，以确保number属性的容量足够大，可以在32位和64位系统上存储16位卡号。 下一个代码片段定义了一个名为john可选Customer变量，该变量将用于存储对特定客户的引用。由于该变量是可选的，其初始值为零： var john: Customer? 您现在可以创建一个Customer实例，并使用它来初始化和分配一个新的CreditCard实例作为该客户的card属性： john &#x3D; Customer(name: “John Appleseed”) john!.card &#x3D; CreditCard(number: 1234_5678_9012_3456, customer: john!) 现在您已经链接了这两个实例，参考资料的外观如下： Customer实例现在对CreditCard实例有强烈引用，CreditCard实例对Customer实例有非所有引用。 由于非拥有customer引用，当您破坏john变量持有的强引用时，对Customer实例没有更强的引用： 由于没有对Customer实例的更强烈引用，因此它被交易了。发生这种情况后，没有对CreditCard实例的更强烈引用，它也被交易： john &#x3D; nil &#x2F;&#x2F; Prints “John Appleseed is being deinitialized” &#x2F;&#x2F; Prints “Card #1234567890123456 is being deinitialized” 上面的最终代码片段显示，Customer实例和CreditCard实例的去初始化器都在john变量设置为吨位后打印其“非初始化”消息。 注意 上面的示例展示了如何使用安全的非所有引用。Swift 还针对需要停用运行时安全检查（例如出于性能原因）的情形，提供了不安全的不拥有的参考。与所有不安全操作一样，您有责任检查该代码是否安全。 您通过写无unowned(unsafe)表示不安全的无名引用。如果您在引用的实例被释放后尝试访问不安全的无有引用，您的程序将尝试访问实例曾经所在的内存位置，这是一个不安全的操作。 未拥有的可选参考资料您可以将类的可选引用标记为非拥有。就ARC所有权模型而言，无主可选引用和弱引用都可以在同一上下文中使用。区别在于，当您使用非拥有的可选引用时，您有责任确保它始终引用有效对象或设置为nil。 以下是跟踪学校特定部门提供的课程的示例： class Department { ​ var name: String ​ var courses: [Course] ​ init(name: String) { ​ self.name &#x3D; name ​ self.courses &#x3D; [] ​ } } class Course { ​ var name: String ​ unowned var department: Department ​ unowned var nextCourse: Course? ​ init(name: String, in department: Department) { ​ self.name &#x3D; name ​ self.department &#x3D; department ​ self.nextCourse &#x3D; nil ​ } } Department对部门提供的每门课程都保持强有力的参考。在ARC所有权模式中，一个部门拥有自己的课程。Course有两个非自主参考资料，一个是系参考资料，另一个是学生应该参加的下一门课程；一门课程不拥有其中任何一个对象。每门课程都是某个部门的一部分，因此department属性不是可选的。然而，由于一些课程没有推荐的后续课程，nextCourse属性是可选的。 以下是使用这些类的示例： let department &#x3D; Department(name: “Horticulture”) let intro &#x3D; Course(name: “Survey of Plants”, in: department) let intermediate &#x3D; Course(name: “Growing Common Herbs”, in: department) let advanced &#x3D; Course(name: “Caring for Tropical Plants”, in: department) intro.nextCourse &#x3D; intermediate intermediate.nextCourse &#x3D; advanced department.courses &#x3D; [intro, intermediate, advanced] 上面的代码创建了一个部门及其三门课程。入门课程和中级课程都有一个建议的下一门课程存储在nextCourse属性中，该属性保留了学生在完成该课程后应该学习的课程的无选择参考。 无人任用引用不会强烈保留其包装的类实例，因此不会阻止ARC对实例进行交易。它的行为与ARC下的无名引用相同，只是无拥有的可选引用可以benil。 Like non-optional unowned references, you’re responsible for ensuring that nextCoursealways refers to a course that hasn’t been deallocated. In this case, for example, when you delete a course from department.courses you also need to remove any references to it that other courses might have. 注意 可选值的基础类型是Optional，这是Swift标准库中的枚举。然而，可选是值类型不能用unowned标记的规则的例外。 包装类的可选内容不使用引用计数，因此您不需要对可选的强烈引用。 未拥有的引用和隐式解开的可选属性上面弱引用和无名引用的示例涵盖了两个更常见的场景，在这两个场景中，有必要打破强引用周期。 Person和Apartment示例显示了两种财产（均为nil）可能导致强烈参考周期的情况。最好在参考较弱的情况下解决此情景。 Customer和CreditCard示例显示了一种情况，即一个允许为nil的属性和另一个不能为nil的属性可能会导致强大的参考周期。最好通过非自有参考来解决这个问题。 然而，还有第三种情况，在这种情况下，两个属性都应该始终有一个值，一旦初始化完成，这两个属性都不应该为nil。在这种情况下，将一个类上的非所有属性与另一个类上隐式解包装的可选属性相结合是有用的。 这使初始化完成后可以直接访问两个属性（无需可选的展开），同时仍然避免引用周期。本节向您展示如何建立这种关系。 以下示例定义了两个类，Country和City，每个类都存储另一个类的实例作为属性。在这个数据模型中，每个国家必须始终拥有一个首都，每个城市必须始终属于一个国家。为了代表这一点，Country级有一个capitalCity财产，City阶级有一个country财产： class Country { ​ let name: String ​ var capitalCity: City! ​ init(name: String, capitalName: String) { ​ self.name &#x3D; name ​ self.capitalCity &#x3D; City(name: capitalName, country: self) ​ } } class City { ​ let name: String ​ unowned let country: Country ​ init(name: String, country: Country) { ​ self.name &#x3D; name ​ self.country &#x3D; country ​ } } 为了在两个类之间建立相互依存关系，City的初始化器采用一个国家实例，并将该实例存储在其country属性中。 City的初始化器从Country的初始化器中调用。但是，在新的Country实例完全初始化之前，Country的初始化器无法将self传递给City初始化器，如两阶段初始化中所述。 为了满足这一要求，您声明Country的capitalCity财产为隐式未包装的可选属性，由其类型注释（City!）末尾的感叹号表示。这意味着，与任何其他可选属性一样，capitalCity属性的默认值为nil，但无需按照隐式未包装选项所述打开其值即可访问。 Because capitalCity has a default nil value, a new Country instance is considered fully initialized as soon as the Country instance sets its name property within its initializer. This means that the Country initializer can start to reference and pass around the implicit selfproperty as soon as the name property is set. The Country initializer can therefore pass selfas one of the parameters for the City initializer when the Country initializer is setting its own capitalCity property. 所有这些都意味着您可以在单个语句中创建Country和City实例，而无需创建强大的参考周期，并且可以直接访问capitalCity属性，而无需使用感叹号来解开其可选值： var country &#x3D; Country(name: “Canada”, capitalName: “Ottawa”) print(“(country.name)’s capital city is called (country.capitalCity.name)”) &#x2F;&#x2F; Prints “Canada’s capital city is called Ottawa” 在上面的示例中，使用隐式未包装的可选选项意味着满足所有两相类初始化器要求。一旦初始化完成，capitalCity属性可以像非可选值一样使用和访问，同时仍然避免了强大的参考周期。 关闭的强参考周期您在上面看到了当两个类实例属性相互保持强引用时，如何创建强引用周期。您还看到了如何使用弱引用和无名引用来打破这些强引用周期。 如果您为类实例的属性分配闭包，并且该闭包的主体捕获实例，也可能发生强引用周期。发生此捕获可能是因为闭包的主体访问实例的属性，如self.someProperty，或者因为闭包调用实例上的方法，如self.someMethod()。无论哪种情况，这些访问都会导致闭包“捕获”self，从而创建一个强大的参考周期。 出现这种强大的参考周期是因为闭包与类一样是引用类型。当您为属性分配闭包时，您将为该闭包分配引用。从本质上讲，这是与上面相同的问题——两个强有力的引用让彼此保持活力。然而，这次不是两个类实例，而是一个类实例和一个闭包，它们让彼此保持活力。 Swift为这个问题提供了一个优雅的解决方案，称为闭包捕获列表。然而，在您学习如何通过闭包捕获列表打破强大的参考周期之前，了解如何导致这样的循环是有用的。 下面的示例展示了在使用引用self的闭包时如何创建强引用周期。此示例定义了一个名为HTMLElement类，该类为HTML文档中的单个元素提供了一个简单的模型： class HTMLElement { ​ let name: String ​ let text: String? ​ lazy var asHTML: () -&gt; String &#x3D; { ​ if let text &#x3D; self.text { ​ return “&lt;(self.name)&gt;(text)&lt;&#x2F;(self.name)&gt;” ​ } else { ​ return “&lt;(self.name) &#x2F;&gt;” ​ } ​ } ​ init(name: String, text: String? &#x3D; nil) { ​ self.name &#x3D; name ​ self.text &#x3D; text ​ } ​ deinit { ​ print(“(name) is being deinitialized”) ​ } } HTMLElement类定义了一个name属性，该属性指示元素的名称，例如标题元素的&quot;h1&quot;”，段落元素的&quot;p&quot;换行符元素的&quot;br&quot;”。HTMLElement还定义了一个可选的text属性，您可以将其设置为表示在该HTML元素中渲染的文本的字符串。 除了这两个简单的属性外，HTMLElement类还定义了一个名为asHTML惰性属性。此属性引用将name和text组合成HTML字符串片段的闭包。asHTML属性类型为()-&gt;String，或“不接受参数并返回String值的函数”。 By default, the asHTML property is assigned a closure that returns a string representation of an HTML tag. This tag contains the optional text value if it exists, or no text content if textdoesn’t exist. For a paragraph element, the closure would return &quot;&lt;p&gt;some text&lt;/p&gt;&quot; or &quot;&lt;p /&gt;&quot;, depending on whether the text property equals &quot;some text&quot; or nil. asHTML属性的命名和使用有点像实例方法。但是，由于asHTML是一个闭包属性，而不是实例方法，如果您想更改特定HTML元素的HTML渲染，您可以将asHTML属性的默认值替换为自定义闭包。 例如，如果text属性为nil，则可以将asHTML属性设置为默认为某些文本的闭包，以防止表示返回空的HTML标签： let heading &#x3D; HTMLElement(name: “h1”) let defaultText &#x3D; “some default text” heading.asHTML &#x3D; { ​ return “&lt;(heading.name)&gt;(heading.text ?? defaultText)&lt;&#x2F;(heading.name)&gt;” } print(heading.asHTML()) &#x2F;&#x2F; Prints “some default text“ 注意 asHTML属性被声明为惰性属性，因为只有当元素实际上需要渲染为某些HTML输出目标的字符串值时，才需要它。asHTML是一个惰性属性，这意味着您可以在默认闭包中引用self，因为在初始化完成并已知self存在之前，才会访问惰性属性。 HTMLElement类提供了一个初始化器，它使用name参数和（如果需要）text参数来初始化新元素。该类还定义了一个去初始化器，该初始化器打印一条消息，以便在HTMLElement实例被释放时显示。 以下是您如何使用HTMLElement类创建和打印新实例的方法： var paragraph: HTMLElement? &#x3D; HTMLElement(name: “p”, text: “hello, world”) print(paragraph!.asHTML()) &#x2F;&#x2F; Prints “hello, world“ 注意 上面的paragraph变量被定义为可选的HTMLElement，因此可以将其设置为nil，以证明存在强引用周期。 不幸的是，如上所述，HTMLElement类在HTMLElement实例和用于其默认为asHTML值的闭包之间创建了强大的参考周期。以下是周期的外观： 实例的asHTML属性对其闭包有很强的引用。然而，由于闭包在其主体内引用self（作为引用self.name和self.text的一种方式），闭包捕获self，这意味着它具有对HTMLElement实例的强烈引用。两者之间创造了一个强大的参考周期。（有关在闭包中捕获值的更多信息，请参阅捕获值。） 注意 尽管闭包多次引用self，但它只捕获一个对HTMLElement实例的强烈引用。 如果您将paragraph变量设置为nil并破坏其对HTMLElement实例的强引用，则由于强引用周期，HTMLElement实例及其闭包都不会被释放： paragraph &#x3D; nil Note that the message in the HTMLElement deinitializer isn’t printed, which shows that the HTMLElement instance isn’t deallocated. 解决关闭的强参考周期通过定义捕获列表作为闭包定义的一部分，您可以解决闭包和类实例之间的强引用周期。捕获列表定义了在闭包主体中捕获一个或多个引用类型时使用的规则。与两个类实例之间的强引用周期一样，您将每个捕获的引用声明为弱引用或非自有引用，而不是强引用。弱或无权的适当选择取决于代码不同部分之间的关系。 注意 每当您引用闭包中的self成员时，Swift要求您编写self.someProperty或self.someMethod()（而不是justsomeProperty或someMethod()）。这有助于你记住，偶然捕捉self是可能的。 定义捕获列表Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate). These pairings are written within a pair of square braces, separated by commas. 将捕获列表放在闭包的参数列表之前，如果提供了它们，则返回类型： lazy var someClosure &#x3D; { ​ [unowned self, weak delegate &#x3D; self.delegate] ​ (index: Int, stringToProcess: String) -&gt; String in ​ &#x2F;&#x2F; closure body goes here } 如果闭包没有指定参数列表或返回类型，因为它们可以从上下文中推断出来，请将捕获列表放在闭包的开头，后跟关键字： lazy var someClosure &#x3D; { ​ [unowned self, weak delegate &#x3D; self.delegate] in ​ &#x2F;&#x2F; closure body goes here } 弱引用和无所有引用当闭包及其捕获的实例始终相互引用时，将闭包中的捕获定义为非自引用，并且始终同时被释放。 相反，当捕获的引用在未来某个时候可能变成nil，将捕获定义为弱引用。弱引用始终是可选类型，当它们引用的实例被释放时，它们会自动变成nil。这使您能够检查它们是否存在于闭合体中。 注意 如果捕获的引用永远不会变成nil，则应始终将其捕获为非拥有的引用，而不是弱引用。 无自有引用是从上面的强引用周期到上文的HTMLElement示例中解析强引用周期的适当捕获方法。以下是您编写HTMLElement类以避免循环的方法： class HTMLElement { ​ let name: String ​ let text: String? ​ lazy var asHTML: () -&gt; String &#x3D; { ​ [unowned self] in ​ if let text &#x3D; self.text { ​ return “&lt;(self.name)&gt;(text)&lt;&#x2F;(self.name)&gt;” ​ } else { ​ return “&lt;(self.name) &#x2F;&gt;” ​ } ​ } ​ init(name: String, text: String? &#x3D; nil) { ​ self.name &#x3D; name ​ self.text &#x3D; text ​ } ​ deinit { ​ print(“(name) is being deinitialized”) ​ } } 除了在asHTML闭包中添加捕获列表外，HTMLElement的实现与之前的实现相同。在这种情况下，捕获列表是[unownedself]，这意味着“捕获自我作为非自有参考，而不是强引用”。 您可以像以前一样创建和打印HTMLElement实例： var paragraph: HTMLElement? &#x3D; HTMLElement(name: “p”, text: “hello, world”) print(paragraph!.asHTML()) &#x2F;&#x2F; Prints “hello, world“ 以下是捕获列表到位后参考资料的外观： 这一次，闭包捕获self是一个非拥有的引用，并且不会强烈保留它捕获的HTMLElement实例。如果您将paragraph变量的强引用设置为nil，则HTMLElement实例将被释放，从以下示例中打印其去初始化器消息中可以看出： paragraph &#x3D; nil &#x2F;&#x2F; Prints “p is being deinitialized” 有关捕获列表的更多信息，请参阅捕获列表。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 访问控制","slug":"软件开发/技术/编程语言/swift/Swift基础-访问控制","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-访问控制/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html 访问控制限制从其他源文件和模块中的代码访问部分代码。此功能使您能够隐藏代码的实现详细信息，并指定可以访问和使用该代码的首选界面。 您可以为单个类型（类、结构和枚举）以及属于这些类型的属性、方法、初始化器和下标分配特定的访问级别。协议可以限制在特定上下文中，全局常量、变量和函数也是如此。 除了提供不同级别的访问控制外，Swift还通过为典型场景提供默认访问级别来减少指定显式访问控制级别的需求。事实上，如果您正在编写单个目标应用程序，您可能根本不需要指定显式访问控制级别。 注意 代码中可以对其应用访问控制的各个方面（属性、类型、函数等）在以下章节中称为“实体”，以方便简洁。 模块和源文件Swift的访问控制模型基于模块和源文件的概念。 模块是代码分发的单个单元，即一个框架或应用程序，作为单个单元构建和发布，并且可以通过另一个具有Swiftimport关键字的模块导入。 Xcode 中的每个构建目标（如 app 套装或框架）在 Swift 中被视为一个单独的模块。如果您将应用程序代码的各个方面作为一个独立的框架组合在一起——也许是为了在多个应用程序中封装和重用该代码——那么您在该框架中定义的所有内容都将在应用程序中导入和使用时，或者在另一个框架中使用时，都将成为单独模块的一部分。 源文件是模块中的单个Swift源代码文件（实际上，是应用程序或框架中的单个文件）。虽然在单独的源文件中定义单个类型很常见，但单个源文件可以包含多种类型、函数等的定义。 访问级别Swift为您的代码中的实体提供了五个不同的访问级别。这些访问级别相对于定义实体的源文件，也相对于源文件所属的模块。 开放访问**和公共访问使实体能够在其定义模块的任何源文件中使用，也可以在导入定义模块的另一个模块的源文件中使用。在指定框架的公共接口时，您通常使用开放或公共访问。开放接入和公共访问之间的区别如下。 内部访问使实体能够在其定义模块的任何源文件中使用，但不能在该模块以外的任何源文件中使用。在定义应用程序或框架的内部结构时，您通常使用内部访问。 文件专用访问将实体的使用限制在自己的定义源文件上。当这些详细信息在整个文件中使用时，使用文件专用访问来隐藏特定功能的实现细节。 私人访问将实体的使用限制为封闭声明，以及同一文件中该声明的扩展名。当特定功能的实现细节仅在单个声明中使用时，使用私有访问来隐藏这些功能的实现细节。 开放访问是最高（限制最少）的访问级别，私人访问是最低（限制最强）的访问级别。 开放访问仅适用于类和类成员，它与公共访问不同，允许模块外的代码子类和重写，如下文在子类中讨论。将类标记为开放明确表示您考虑了使用该类作为超类的其他模块代码的影响，并且您相应地设计了类的代码。 访问级别的指导原则Swift中的访问级别遵循一个总体指导原则：任何实体都不能用另一个访问级别较低（限制性更强）的实体来定义。 例如： 公共变量不能定义为具有内部、文件私有或私有类型，因为该类型可能并非在使用公共变量的任何地方都可用。 函数的访问级别不能高于其参数类型和返回类型，因为该函数可以在其组成类型对周围代码不可用的情况下使用。 下文详细介绍了该指导原则对语言不同方面的具体影响。 默认访问级别如果您自己没有指定显式访问级别，代码中的所有实体（如本章后面所述，有几个特定例外）都有内部的默认访问级别。因此，在许多情况下，您不需要在代码中指定显式访问级别。 单目标应用程序的访问级别当您编写一个简单的单目标应用程序时，应用程序中的代码通常在应用程序中独立，不需要在应用程序模块之外提供。内部的默认访问级别已经符合此要求。因此，您不需要指定自定义访问级别。但是，您可能希望将代码的某些部分标记为私有或私有文件，以便从应用程序模块中的其他代码中隐藏其实现详细信息。 框架的访问级别当您开发框架时，请将该框架的面向公众的界面标记为开放或公共，以便其他模块（例如导入框架的应用程序）可以查看和访问。这个面向公众的界面是框架的应用程序编程接口（或API）。 注意 框架的任何内部实现详细信息仍然可以使用内部的默认访问级别，或者如果您想从框架内部代码的其他部分隐藏它们，可以标记为私有或文件私有。只有当您希望实体成为框架API的一部分时，您才需要将其标记为开放或公共实体。 单元测试目标的访问级别当您编写具有单元测试目标的应用程序时，应用程序中的代码需要提供给该模块才能进行测试。默认情况下，其他模块只能访问标记为开放或公共的实体。但是，如果您使用@testable属性标记产品模块的导入声明，并在启用测试的情况下编译该产品模块，则单元测试目标可以访问任何内部实体。 访问控制语法通过在实体声明的开头放置一个open、public、internal、fileprivate或private修饰符来定义实体的访问级别。 public class SomePublicClass {} internal class SomeInternalClass {} fileprivate class SomeFilePrivateClass {} private class SomePrivateClass {} public var somePublicVariable &#x3D; 0 internal let someInternalConstant &#x3D; 0 fileprivate func someFilePrivateFunction() {} private func somePrivateFunction() {} 除非另有说明，否则默认访问级别是内部的，如默认访问级别所述。这意味着SomeInternalClass和someInternalConstant可以在没有显式访问级修饰符的情况下编写，并且仍然具有内部访问级别： class SomeInternalClass {} &#x2F;&#x2F; implicitly internal let someInternalConstant &#x3D; 0 &#x2F;&#x2F; implicitly internal 自定义类型如果您想为自定义类型指定显式访问级别，请在定义类型时指定。然后，这种新型可以在访问级别允许的任何地方使用。例如，如果您定义文件私有类，该类只能用作属性的类型，或在定义文件私有类的源文件中用作函数参数或返回类型。 类型的访问控制级别也会影响该类型成员的默认访问级别（其属性、方法、初始化器和下标）。如果您将类型的访问级别定义为私有或文件私有，则其成员的默认访问级别也将是私有或文件私有。如果您将类型的访问级别定义为内部或公共（或使用内部的默认访问级别，而不显式指定访问级别），则该类型成员的默认访问级别将是内部的。 重要 公共类型默认为有内部成员，而不是公共成员。如果您希望类型成员公开，则必须明确将其标记为公开成员。此要求确保类型面向公众的API是您选择发布的内容，并避免错误地将类型的内部工作显示为公共API。 public class SomePublicClass { &#x2F;&#x2F; explicitly public class ​ public var somePublicProperty &#x3D; 0 &#x2F;&#x2F; explicitly public class member ​ var someInternalProperty &#x3D; 0 &#x2F;&#x2F; implicitly internal class member ​ fileprivate func someFilePrivateMethod() {} &#x2F;&#x2F; explicitly file-private class member ​ private func somePrivateMethod() {} &#x2F;&#x2F; explicitly private class member } class SomeInternalClass { &#x2F;&#x2F; implicitly internal class ​ var someInternalProperty &#x3D; 0 &#x2F;&#x2F; implicitly internal class member ​ fileprivate func someFilePrivateMethod() {} &#x2F;&#x2F; explicitly file-private class member ​ private func somePrivateMethod() {} &#x2F;&#x2F; explicitly private class member } fileprivate class SomeFilePrivateClass { &#x2F;&#x2F; explicitly file-private class ​ func someFilePrivateMethod() {} &#x2F;&#x2F; implicitly file-private class member ​ private func somePrivateMethod() {} &#x2F;&#x2F; explicitly private class member } private class SomePrivateClass { &#x2F;&#x2F; explicitly private class ​ func somePrivateMethod() {} &#x2F;&#x2F; implicitly private class member } 元组类型元组类型的访问级别是该元组中使用的所有类型的访问级别中最严格的。例如，如果您从两种不同类型的元组组成元组，一种具有内部访问，另一种具有私有访问，则该复合元组类型的访问级别将是私有的。 注意 元组类型没有像类、结构、枚举和函数那样具有独立的定义。元组类型的访问级别是从构成元组类型的类型自动确定的，并且无法显式指定。 功能类型函数类型的访问级别计算为函数参数类型和返回类型的最严格的访问级别。如果函数的计算访问级别与上下文默认值不匹配，则必须显式指定访问级别作为函数定义的一部分。 下面的示例定义了一个名为someFunction()的全局函数，但没有为函数本身提供特定的访问级修饰符。您可能希望此功能具有“内部”的默认访问级别，但事实并非如此。事实上，someFunction()不会按以下内容编译： func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) { ​ &#x2F;&#x2F; function implementation goes here } 该函数的返回类型是由上面自定义类型中定义的两个自定义类组成的元组类型。其中一类被定义为内部，另一类被定义为私有。因此，复合元组类型的整体访问级别是私有的（元组组成部分类型的最小访问级别）。 由于函数的返回类型是私有的，因此您必须用private修饰符标记函数的整体访问级别，以便函数声明有效： private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) { ​ &#x2F;&#x2F; function implementation goes here } 使用public或internal修饰符标记someFunction()的定义或使用内部的默认设置无效，因为函数的公共或内部用户可能无法适当访问函数返回类型中使用的私有类。 枚举类型枚举的单个案例会自动获得与它们所属枚举相同的访问级别。您无法为单个枚举案例指定不同的访问级别。 在下面的示例中，CompassPoint枚举具有明确的公共访问级别。因此，north、south、east和west列举案例也有公众的准入级别： public enum CompassPoint { ​ case north ​ case south ​ case east ​ case west } 原始值和相关值用于枚举定义中任何原始值或相关值的类型必须具有至少与枚举访问级别相同的访问级别。例如，您不能使用私有类型作为具有内部访问级别的枚举的原始值类型。 嵌套类型嵌套类型的访问级别与其包含类型相同，除非包含类型是公共的。在公共类型中定义的嵌套类型具有内部的自动访问级别。如果您希望公共类型中的嵌套类型公开可用，则必须显式声明嵌套类型为公共类型。 子分类您可以对可以在当前访问上下文中访问的任何类进行子类，该类与子类在同一模块中定义。您还可以对其他模块中定义的任何开放类进行子类。一个子类不能比其超类具有更高的访问级别——例如，您不能编写内部超类的公共子类。 此外，对于在同一模块中定义的类，您可以覆盖在特定访问上下文中可见的任何类成员（方法、属性、初始化器或下标）。对于在另一个模块中定义的类，您可以覆盖任何打开的类成员。 重写可以使继承的类成员比其超类版本更容易访问。在下面的示例中，类A是一个公共类，其文件私有方法称为someMethod()。B类是A的子类，访问级别为“内部”。尽管如此，B类提供了someMethod()的重写，访问级别为“内部”，高于someMethod()的原始实现： public class A { ​ fileprivate func someMethod() {} } internal class B: A { ​ override internal func someMethod() {} } 子类成员甚至可以调用访问权限低于子类成员的超类成员，只要对超类成员的调用是在允许的访问级别上下文中（即在与文件私有成员调用的超类相同的源文件中，或在与内部成员调用的超类相同的模块中）： public class A { ​ fileprivate func someMethod() {} } internal class B: A { ​ override internal func someMethod() { ​ super.someMethod() ​ } } 由于超类A和子类B在同一源文件中定义，因此someMethod()的B实现调用super.someMethod()是有效的。 常量、变量、属性和下标常量、变量或属性不能比其类型更公开。例如，使用私有类型写入公共财产是无效的。同样，下标不能比其索引类型或返回类型更公开。 如果常量、变量、属性或下标使用私有类型，则常量、变量、属性或下标也必须标记为private： private var privateInstance &#x3D; SomePrivateClass() 获取者和设置者常量、变量、属性和下标的获取者和设置器会自动接收与他们所属的常量、变量、属性或下标相同的访问级别。 您可以给设置器比其对应的获取器更低的访问级别，以限制该变量、属性或下标的读写范围。您可以通过在var或subscript介绍器之前编写fileprivate(set)``private(set)或internal(set)分配较低的访问级别。 注意 此规则适用于存储属性以及计算属性。即使您没有为存储的属性编写显式获取器和设置器，Swift仍然会合成隐式获取器和设置器，以提供对存储属性备份存储的访问。使用fileprivate(set)``private(set)和internal(set)以与计算属性中的显式setter完全相同的方式更改此合成设置器的访问级别。 以下示例定义了一个名为TrackedString结构，该结构跟踪字符串属性被修改的次数： struct TrackedString { ​ private(set) var numberOfEdits &#x3D; 0 ​ var value: String &#x3D; “” { ​ didSet { ​ numberOfEdits +&#x3D; 1 ​ } ​ } } TrackedString结构定义了一个名为value的存储字符串属性，初始值为&quot;&quot;”（空字符串）。该结构还定义了一个名为numberOfEdits的存储整数属性，用于跟踪该value被修改的次数。此修改跟踪通过value属性上的didSet属性观察器实现，该观察器每次将value属性设置为新值时都会增加numberOfEdits。 TrackedString结构和value属性不提供显式访问级修饰符，因此它们都接收内部的默认访问级别。然而，numberOfEdits属性的访问级别用private(set)修饰符标记，以指示属性的获取器仍然具有内部的默认访问级别，但该属性只能从作为TrackedString结构一部分的代码中设置。这使TrackedString能够在内部修改numberOfEdits属性，但当该属性在结构定义之外使用时，将其显示为只读属性。 如果您创建TrackedString实例并修改其字符串值几次，您可以看到numberOfEdits属性值更新，以匹配修改次数： var stringToEdit &#x3D; TrackedString() stringToEdit.value &#x3D; “This string will be tracked.” stringToEdit.value +&#x3D; “ This edit will increment numberOfEdits.” stringToEdit.value +&#x3D; “ So will this one.” print(“The number of edits is (stringToEdit.numberOfEdits)”) &#x2F;&#x2F; Prints “The number of edits is 3” Although you can query the current value of the numberOfEdits property from within another source file, you can’t modify the property from another source file. This restriction protects the implementation details of the TrackedString edit-tracking functionality, while still providing convenient access to an aspect of that functionality. 请注意，如果需要，您可以为获取器和设置器分配显式访问级别。下面的示例显示了TrackedString结构的一个版本，其中该结构以公共的显式访问级别定义。因此，结构的成员（包括numberOfEdits属性）默认具有内部访问级别。您可以通过组合public和private(set)访问级修饰符，使结构的numberOfEdits属性获取器公开，其属性设置器为私有： public struct TrackedString { ​ public private(set) var numberOfEdits &#x3D; 0 ​ public var value: String &#x3D; “” { ​ didSet { ​ numberOfEdits +&#x3D; 1 ​ } ​ } ​ public init() {} } 初始化器自定义初始化器可以分配小于或等于其初始化类型的访问级别。唯一的例外是必需的初始化器（如必需初始化器中定义）。所需的初始化器必须具有与它所属类相同的访问级别。 与函数和方法参数一样，初始化器参数的类型不能比初始化器自己的访问级别更私密。 默认初始化器如默认初始化器所述，Swift会自动提供默认初始化器，没有任何结构或基类的参数，这些结构或基类为其所有属性提供默认值，并且本身也不提供至少一个初始化器。 默认初始化器具有与初始化的类型相同的访问级别，除非该类型被定义为public。对于定义为public的类型，默认初始化器被视为内部初始化器。如果您希望公共类型在另一个模块中使用无参数初始化器进行初始化，则必须自己显式提供公共无参数初始化器，作为类型定义的一部分。 结构类型的默认成员初始化器如果结构的任何存储属性是私有的，则结构类型的默认成员初始化器被视为私有。同样，如果结构的任何存储属性是文件私有的，则初始化器是文件私有的。否则，初始化器具有内部访问级别。 与上面的默认初始化器一样，如果您希望公共结构类型在另一个模块中使用成员初始化器时可以初始化，则必须自己提供公共成员初始化器，作为类型定义的一部分。 协议如果您想为协议类型分配显式访问级别，请在定义协议时这样做。这使您能够创建只能在特定访问上下文中采用的协议。 协议定义中每个需求的访问级别会自动设置为与协议相同的访问级别。您无法将协议要求设置为与其支持的协议不同的访问级别。这确保了协议的所有要求在任何采用该协议的类型上都可见。 注意 如果您定义了公共协议，则协议的要求在实现时需要这些要求的公共访问级别。这种行为与其他类型不同，在这些类型中，公共类型定义意味着类型成员的内部访问级别。 协议继承如果您定义了从现有协议继承的新协议，则新协议最多可以具有与它继承的协议相同的访问级别。例如，您无法编写从内部协议继承的公共协议。 协议一致性类型可以符合比类型本身更低访问级别的协议。例如，您可以定义一种公共类型，该类型可以在其他模块中使用，但其与内部协议的一致性只能在内部协议的定义模块中使用。 类型符合特定协议的上下文是类型访问级别和协议访问级别的最低值。例如，如果一种类型是公开的，但它遵守的协议是内部的，则该类型与该协议的一致性也是内部的。 当您编写或扩展类型以符合协议时，您必须确保该类型对每个协议要求的实现至少与该类型对该协议的一致性具有相同的访问级别。例如，如果公共类型符合内部协议，则该类型对每个协议要求的实现必须至少是内部的。 注意 在Swift中，就像在Objective-C中一样，协议一致性是全局的——类型不可能在同一程序中以两种不同的方式遵守协议。 扩展您可以在类、结构或枚举可用的任何访问上下文中扩展类、结构或枚举。在扩展中添加的任何类型成员的默认访问级别与正在扩展的原始类型中声明的类型成员具有相同的默认访问级别。如果您扩展公共或内部类型，您添加的任何新类型成员都有默认的内部访问级别。如果您扩展文件私有类型，则您添加的任何新类型成员都有文件私有的默认访问级别。如果您扩展私有类型，则您添加的任何新类型成员都有默认的私有访问级别。 或者，您可以使用显式访问级别修饰符（例如private）标记扩展，为扩展中定义的所有成员设置新的默认访问级别。这个新的默认值仍然可以在单个类型成员的扩展中重写。 如果您使用扩展来添加协议一致性，则无法为扩展提供显式访问级修饰符。相反，协议自己的访问级别用于为扩展中的每个协议需求实现提供默认访问级别。 扩展中的私人成员与它们扩展的类、结构或枚举位于同一文件中的扩展名的行为就像扩展中的代码是作为原始类型声明的一部分编写的。因此，您可以： 在原始声明中声明一个私人成员，并从同一文件中的扩展名访问该成员。 在一个扩展中声明一个私有成员，并从同一文件中的另一个扩展名访问该成员。 在扩展名中声明一个私有成员，并从同一文件中的原始声明访问该成员。 此行为意味着无论您的类型是否有私有实体，您都可以以同样的方式使用扩展来组织代码。例如，给定以下简单的协议： protocol SomeProtocol { ​ func doSomething() } 您可以使用扩展来添加协议一致性，如下所示： struct SomeStruct { ​ private var privateVariable &#x3D; 12 } extension SomeStruct: SomeProtocol { ​ func doSomething() { ​ print(privateVariable) ​ } } 通用泛型类型或泛型函数的访问级别是泛型类型或函数本身的访问级别及其类型参数上任何类型约束的访问级别的最低值。 类型别名为了访问控制的目的，您定义的任何类型别名都被视为不同的类型。类型别名的访问级别可以小于或等于其别名类型的访问级别。例如，私有类型别名可以别名私有、文件私有、内部、公共或开放类型，但公共类型别名不能别名内部、文件私有或私有类型。 注意 此规则也适用于用于满足协议一致性的关联类型的类型别名。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 通用","slug":"软件开发/技术/编程语言/swift/Swift基础-通用","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-通用/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E9%80%9A%E7%94%A8/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/Generics.html 通用代码使您能够编写灵活、可重用的函数和类型，这些函数和类型可以根据您定义的要求适用于任何类型。您可以编写避免重复的代码，并以清晰、抽象的方式表达其意图。 通用是Swift最强大的功能之一，Swift标准库的大部分都是用通用代码构建的。事实上，即使您没有意识到这一点，您也一直在使用整个语言指南中的泛型。例如，Swift的Array和Dictionary类型都是通用集合。您可以创建一个包含Int值的数组，或包含String值的数组，或者为可以在Swift中创建的任何其他类型的数组。同样，您可以创建一个字典来存储任何指定类型的值，并且该类型没有限制。 通用解决的问题这里有一个名为swapTwoInts(_:_:)的标准非通用函数，它交换了两个Int值： func swapTwoInts(_ a: inout Int, _ b: inout Int) { ​ let temporaryA &#x3D; a ​ a &#x3D; b ​ b &#x3D; temporaryA } 此函数使用输入输出参数来交换a和b的值，如In-Out参数所述。 swapTwoInts(_:_:)函数将b的原始值交换为a，将a的原始值交换为b。您可以调用此函数来交换两个Int变量中的值： var someInt &#x3D; 3 var anotherInt &#x3D; 107 swapTwoInts(&amp;someInt, &amp;anotherInt) print(“someInt is now (someInt), and anotherInt is now (anotherInt)”) &#x2F;&#x2F; Prints “someInt is now 107, and anotherInt is now 3” swapTwoInts(_:_:)函数非常有用，但它只能与Int值一起使用。如果您想交换两个String值或两个Double值，则必须编写更多函数，例如swapTwoStringsswapTwoStrings(_:_:)和swapTwoDoubles(_:_:)函数如下所示： func swapTwoStrings(_ a: inout String, _ b: inout String) { ​ let temporaryA &#x3D; a ​ a &#x3D; b ​ b &#x3D; temporaryA } func swapTwoDoubles(_ a: inout Double, _ b: inout Double) { ​ let temporaryA &#x3D; a ​ a &#x3D; b ​ b &#x3D; temporaryA } 您可能已经注意到，swapTwoIntsswapTwoInts(_:_:)``swapTwoStrings(_:_:)和swapTwoDoubles(_:_:)函数的主体是相同的。唯一的区别是他们接受的值的类型（Int、String和Double）。 编写一个交换任何类型两个值的单个函数更有用，也更灵活。通用代码使您能够编写这样的函数。（这些函数的通用版本定义如下。） 注意 在所有三个函数中，a和b的类型必须相同。如果a和b不是同一类型，则无法交换它们的值。Swift 是一种类型安全的语言，不允许（例如）String类型的变量和类型Double的变量相互交换值。尝试这样做会导致编译时错误。 通用函数通用函数可以适用于任何类型。这是上面theswapTwoIntsswapTwoInts(_:_:)函数的通用版本，称为swapTwoValues(_:_:) 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoValues(_:_:)函数的主体与theswapTwoIntsswapTwoInts(_:_:)函数的主体相同。然而，swapTwoValuesswapTwoValues(_:_:)的第一行与swapTwoInts(_:_:)略有不同。以下是第一行的比较方式： func swapTwoInts(_ a: inout Int, _ b: inout Int) func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) 该函数的通用版本使用占位符类型名称（在本例中称为T）而不是实际类型名称（如Int、String或Double）。占位符类型名称没有说明T必须是什么，但它确实说a和b必须是相同的类型T，无论T代表什么。每次调用swapTwoValues(_:_:)函数时，都会确定代替T的实际类型。 The other difference between a generic function and a nongeneric function is that the generic function’s name (swapTwoValues(_:_:)) is followed by the placeholder type name (T) inside angle brackets (&lt;T&gt;). The brackets tell Swift that T is a placeholder type name within the swapTwoValues(_:_:) function definition. Because T is a placeholder, Swift doesn’t look for an actual type called T. swapTwoValues(_:_:)函数现在可以以与swapTwoInts相同的方式调用，但只要这两个值彼此具有相同的类型，就可以传递任何类型的两个值。每次调用swapTwoValues(_:_:)时，都会从传递给函数的值类型推断T的类型。 在下面的两个示例中，推断T分别为Int和String： var someInt &#x3D; 3 var anotherInt &#x3D; 107 swapTwoValues(&amp;someInt, &amp;anotherInt) &#x2F;&#x2F; someInt is now 107, and anotherInt is now 3 var someString &#x3D; “hello” var anotherString &#x3D; “world” swapTwoValues(&amp;someString, &amp;anotherString) &#x2F;&#x2F; someString is now “world”, and anotherString is now “hello” 注意 上面定义的swapTwoValues(_:_:)函数的灵感来自一个名为swap的通用函数，该函数是Swift标准库的一部分，并自动供您在应用程序中使用。如果您需要在自己的代码中使用swapTwoValues(_:_:)函数的行为，您可以使用Swift现有的swapswap(_:_:)函数，而不是提供自己的实现。 类型参数在上面的swapTwoValues(_:_:)示例中，占位符类型T是类型参数的示例。类型参数指定并命名占位符类型，并立即写在函数名称之后，在一对匹配的角度括号（如&lt;T&gt;）之间。 指定类型参数后，您可以使用它来定义函数参数的类型（例如swapTwoValuesswapTwoValues(_:_:)函数的a和b参数），或作为函数的返回类型，或作为函数主体中的类型注释。在每种情况下，每当调用函数时，类型参数都会替换为实际类型。（在上面的swapTwoValues(_:_:)示例中，第一次调用函数时将T替换为Int，第二次调用时替换为String。） 您可以通过在角括号内写入多个类型参数名称，用逗号分隔来提供多个类型参数。 命名类型参数In most cases, type parameters have descriptive names, such as Key and Value in Dictionary&lt;Key, Value&gt; and Element in Array&lt;Element&gt;, which tells the reader about the relationship between the type parameter and the generic type or function it’s used in. However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as T, U, and V, such as T in the swapTwoValues(_:_:) function above. 注意 始终给出类型参数上骆驼大小写名称（如T和MyTypeParameter），以指示它们是类型而不是值的占位符。 通用类型除了通用函数外，Swift还允许您定义自己的通用类型。这些是自定义类、结构和枚举，可以与任何类型一起工作，类似于Array和Dictionary。 本节向您展示了如何编写名为Stack的通用集合类型。堆栈是一组有序的值，类似于数组，但与Swift的Array类型相比，操作集更受限。数组允许在数组的任何位置插入和删除新项目。然而，堆栈只允许将新项目附加到集合的末尾（称为将新值推送到堆栈）。同样，堆栈只允许从集合的末尾删除项目（称为从堆栈中弹出一个值）。 注意 The concept of a stack is used by the UINavigationController class to model the view controllers in its navigation hierarchy. You call the UINavigationController class pushViewController(_:animated:) method to add (or push) a view controller on to the navigation stack, and its popViewControllerAnimated(_:) method to remove (or pop) a view controller from the navigation stack. A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection. 下面的插图显示了堆栈的推送和弹出行为： 堆栈上目前有三个值。 第四个值被推到堆栈的顶部。 堆栈现在包含四个值，最近的一个值在顶部。 堆栈中的顶部项目被弹出。 弹出一个值后，堆栈再次包含三个值。 以下是编写堆栈的非通用版本的方法，在这种情况下，对于Int值的堆栈： struct IntStack { ​ var items: [Int] &#x3D; [] ​ mutating func push(_ item: Int) { ​ items.append(item) ​ } ​ mutating func pop() -&gt; Int { ​ return items.removeLast() ​ } } 该结构使用称为items的Array属性来存储堆栈中的值。Stack提供了两种方法，push和pop，用于在堆栈上和下推送和弹出值。这些方法被标记为mutating，因为它们需要修改（或突变）结构items组。 然而，上面显示的IntStack类型只能与Int值一起使用。定义一个通用的Stack结构会更有用，它可以管理任何类型值的堆栈。 以下是同一代码的通用版本： 1234567891. struct Stack&lt;Element&gt; &#123;2. ​ var items: [Element] = []3. ​ mutating func push(_ item: Element) &#123;4. ​ items.append(item)5. ​ &#125;6. ​ mutating func pop() -&gt; Element &#123;7. ​ return items.removeLast()8. ​ &#125;9. &#125; 请注意，Stack的通用版本本质上与非通用版本相同，但具有名为Element的类型参数，而不是实际类型的Int。此类型参数写在结构名称后的一对角括号（&lt;Element&gt;）中。 Element定义稍后要提供的类型的占位符名称。这种未来类型可以在结构定义的任何地方被称为Element。在这种情况下，Element在三个地方用作占位符： 创建一个名为items属性，该属性使用空类型的值数组初始化Element 要指定push(_:)方法有一个名为item的单个参数，该参数必须是类型Element 指定pop()方法返回的值将是类型的值Element 由于它是一种通用类型，Stack可用于在Swift中创建任何有效类型的堆栈，其方式类似于Array和Dictionary。 您可以通过在角度括号内写入要存储在堆栈中的类型来创建一个新的Stack实例。例如，要创建新的字符串堆栈，请编写Stack&lt;String&gt;()： 1234561. var stackOfStrings = Stack&lt;String&gt;()2. stackOfStrings.push(&quot;uno&quot;)3. stackOfStrings.push(&quot;dos&quot;)4. stackOfStrings.push(&quot;tres&quot;)5. stackOfStrings.push(&quot;cuatro&quot;)6. // the stack now contains 4 strings 以下是stackOfStrings在将这四个值推送到堆栈后的样子： 从堆栈中弹出一个值将删除并返回最高值&quot;cuatro&quot;： let fromTheTop &#x3D; stackOfStrings.pop() &#x2F;&#x2F; fromTheTop is equal to “cuatro”, and the stack now contains 3 strings 以下是堆栈弹出其最高值后的样子： 扩展通用类型当您扩展泛型类型时，您不会提供类型参数列表作为扩展定义的一部分。相反，原始类型定义的类型参数列表在扩展的正文中可用，原始类型参数名称用于引用原始定义中的类型参数。 以下示例扩展了通用Stack类型，以添加名为topItem的只读计算属性，该属性返回堆栈上的顶部项目，而不会从堆栈中弹出它： extension Stack { ​ var topItem: Element? { ​ return items.isEmpty ? nil : items[items.count - 1] ​ } } topItem属性返回Element类型的可选值。如果堆栈为空，topItem返回nil；如果堆栈不是空的，topItem返回items组中的最后一个项目。 请注意，此扩展没有定义类型参数列表。相反，在扩展中使用Stack类型的现有类型参数名称Element来指示topItem计算属性的可选类型。 topItem计算属性现在可以与任何Stack实例一起使用，以访问和查询其顶部项目，而无需删除它。 if let topItem &#x3D; stackOfStrings.topItem { ​ print(“The top item on the stack is (topItem).”) } &#x2F;&#x2F; Prints “The top item on the stack is tres.” 泛型类型的扩展还可以包括扩展类型的实例必须满足的要求，以获得新功能，如下文中带有通用Where子句的扩展中所述。 类型约束swapTwoValues(_:_:)函数和Stack类型可以与任何类型配合使用。然而，对可以与泛型函数和泛型类型一起使用的类型执行某些类型约束有时是有用的。类型约束指定类型参数必须从特定类继承，或符合特定的协议或协议组合。 例如，Swift的Dictionary类型对可以用作字典键的类型施加了限制。如字典中所述，字典键的类型必须可哈希。也就是说，它必须提供一种使自己具有独特代表性的方法。Dictionary需要其键可哈希，以便可以检查它是否已经包含特定密钥的值。没有这个要求，Dictionary就无法判断它是否应该插入或替换特定密钥的值，也无法为已经在字典中的给定密钥找到值。 此要求由Dictionary键类型的类型约束强制执行，该约束指定键类型必须符合Hashable协议，Hashable协议是Swift标准库中定义的特殊协议。Swift的所有基本类型（如String、Int、Double和Bool）默认都是可散列的。有关使您自己的自定义类型符合Hashable协议的信息，请参阅符合哈希协议。 您可以在创建自定义泛型类型时定义自己的类型约束，这些约束提供了泛型编程的大部分功能。像Hashable抽象概念根据概念特征而不是具体类型来描述类型。 类型约束语法您可以通过在类型参数名称后放置单个类或协议约束来编写类型约束，并用冒号分隔，作为类型参数列表的一部分。泛型函数类型约束的基本语法如下所示（尽管泛型类型的语法相同）： func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) { ​ &#x2F;&#x2F; function body goes here } 上面的假设函数有两个类型参数。第一个类型参数T有一个类型约束，要求T是SomeClass的子类。第二个类型参数U有一个类型约束，要求U符合协议SomeProtocol。 操作中的类型约束这是一个名为findIndex(ofString:in:)的非通用函数，它给出了一个要查找的String值和一个要查找的String值数组。ThefindIndexfindIndex(ofString:in:)函数返回一个可选的Int值，如果找到，它将是数组中第一个匹配字符串的索引，如果找不到字符串，则为nil： func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? { ​ for (index, value) in array.enumerated() { ​ if value &#x3D;&#x3D; valueToFind { ​ return index ​ } ​ } ​ return nil } findIndex(ofString:in:)函数可用于查找字符串数组中的字符串值： let strings &#x3D; [“cat”, “dog”, “llama”, “parakeet”, “terrapin”] if let foundIndex &#x3D; findIndex(ofString: “llama”, in: strings) { ​ print(“The index of llama is (foundIndex)”) } &#x2F;&#x2F; Prints “The index of llama is 2” 然而，在数组中查找值索引的原理并不仅适用于字符串。您可以通过将任何提及的字符串替换为某种类型T的值来编写与泛型函数相同的功能。 以下是您如何期望编写findIndex(ofString:in:)称为findIndex(of:in:)的通用版本。请注意，此函数的返回类型仍然是Int?，因为该函数返回可选索引号，而不是数组中的可选值。不过，请注意——由于示例后解释的原因，此函数不会编译： 123456781. func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123;2. ​ for (index, value) in array.enumerated() &#123;3. ​ if value == valueToFind &#123;4. ​ return index5. ​ &#125;6. ​ &#125;7. ​ return nil8. &#125; This function doesn’t compile as written above. The problem lies with the equality check, “if value == valueToFind”. Not every type in Swift can be compared with the equal to operator (==). If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure isn’t something that Swift can guess for you. Because of this, it isn’t possible to guarantee that this code will work for every possible type T, and an appropriate error is reported when you try to compile the code. All is not lost, however. The Swift standard library defines a protocol called Equatable, which requires any conforming type to implement the equal to operator (==) and the not equal to operator (!=) to compare any two values of that type. All of Swift’s standard types automatically support the Equatable protocol. 任何Equatable类型都可以安全地与findIndex(of:in:)函数一起使用，因为它保证支持等于运算符。为了表达这一事实，当您定义函数时，您可以编写一个Equatable的类型约束，作为类型参数定义的一部分： func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? { ​ for (index, value) in array.enumerated() { ​ if value &#x3D;&#x3D; valueToFind { ​ return index ​ } ​ } ​ return nil } The single type parameter for findIndex(of:in:) is written as T: Equatable, which means “any type T that conforms to the Equatable protocol.” findIndex(of:in:)函数现在可以成功编译，并且可以与任何Equatable类型一起使用，例如Double或String： let doubleIndex &#x3D; findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) &#x2F;&#x2F; doubleIndex is an optional Int with no value, because 9.3 isn’t in the array let stringIndex &#x3D; findIndex(of: “Andrea”, in: [“Mike”, “Malcolm”, “Andrea”]) &#x2F;&#x2F; stringIndex is an optional Int containing a value of 2 相关类型在定义协议时，声明一个或多个关联类型作为协议定义的一部分有时是有用的。关联类型为用作协议一部分的类型提供了占位符名称。在采用协议之前，不会指定用于该关联类型的实际类型。关联类型使用associatedtype关键字指定。 操作中的关联类型以下是名为Container的协议示例，该协议声明了一个名为Item的关联类型： protocol Container { ​ associatedtype Item ​ mutating func append(_ item: Item) ​ var count: Int { get } ​ subscript(i: Int) -&gt; Item { get } } Container协议定义了任何容器必须提供的三种所需功能： 必须能够使用append(_:)方法向容器添加新项目。 必须能够通过返回Int值的count属性访问容器中项目的计数。 必须能够使用接受Int索引值的下标检索容器中的每个项目。 该协议没有指定容器中的项目应该如何存储或允许它们的类型。该协议仅指定任何类型必须提供的三个位功能才能被视为Container。符合要求的类型可以提供额外的功能，只要它满足这三项要求。 任何符合Container协议的类型都必须能够指定它存储的值类型。具体而言，它必须确保只将正确类型的项目添加到容器中，并且必须明确其下标返回的项目类型。 为了定义这些要求，Container协议需要一种方法来引用容器将持有的元素的类型，而不知道该类型适用于特定容器。Container协议需要指定传递给append(_:)方法的任何值必须具有与容器元素类型相同的类型，并且容器下标返回的值将与容器的元素类型相同。 To achieve this, the Container protocol declares an associated type called Item, written as associatedtype Item. The protocol doesn’t define what Item is—that information is left for any conforming type to provide. Nonetheless, the Item alias provides a way to refer to the type of the items in a Container, and to define a type for use with the append(_:) method and subscript, to ensure that the expected behavior of any Container is enforced. 以下是上述通用类型的非通用IntStack类型的版本，适合符合Container协议： struct IntStack: Container { ​ &#x2F;&#x2F; original IntStack implementation ​ var items: [Int] &#x3D; [] ​ mutating func push(_ item: Int) { ​ items.append(item) ​ } ​ mutating func pop() -&gt; Int { ​ return items.removeLast() ​ } ​ &#x2F;&#x2F; conformance to the Container protocol ​ typealias Item &#x3D; Int ​ mutating func append(_ item: Int) { ​ self.push(item) ​ } ​ var count: Int { ​ return items.count ​ } ​ subscript(i: Int) -&gt; Int { ​ return items[i] ​ } } IntStack类型实现了Container协议的所有三个需求，并在每种情况下包装IntStack类型的部分现有功能以满足这些要求。 Moreover, IntStack specifies that for this implementation of Container, the appropriate Item to use is a type of Int. The definition of typealias Item = Int turns the abstract type of Item into a concrete type of Int for this implementation of the Container protocol. Thanks to Swift’s type inference, you don’t actually need to declare a concrete Item of Int as part of the definition of IntStack. Because IntStack conforms to all of the requirements of the Container protocol, Swift can infer the appropriate Item to use, simply by looking at the type of the append(_:) method’s item parameter and the return type of the subscript. Indeed, if you delete the typealias Item = Int line from the code above, everything still works, because it’s clear what type should be used for Item. 您还可以使通用Stack类型符合Container协议： 12345678910111213141516171819201. struct Stack&lt;Element&gt;: Container &#123;2. ​ // original Stack&lt;Element&gt; implementation3. ​ var items: [Element] = []4. ​ mutating func push(_ item: Element) &#123;5. ​ items.append(item)6. ​ &#125;7. ​ mutating func pop() -&gt; Element &#123;8. ​ return items.removeLast()9. ​ &#125;10. ​ // conformance to the Container protocol11. ​ mutating func append(_ item: Element) &#123;12. ​ self.push(item)13. ​ &#125;14. ​ var count: Int &#123;15. ​ return items.count16. ​ &#125;17. ​ subscript(i: Int) -&gt; Element &#123;18. ​ return items[i]19. ​ &#125;20. &#125; 这一次，类型参数Element被用作append(_:)方法item参数的类型和下标的返回类型。因此，Swift可以推断Element是用作此特定容器Item的合适类型。 扩展现有类型以指定关联类型您可以扩展现有类型以添加协议一致性，如在添加扩展协议一致性中所述。这包括具有关联类型的协议。 Swift的Array类型已经提供了一个append(_:)方法、count属性和一个带有Int索引的下标来检索其元素。这三项功能符合Container协议的要求。这意味着，只需声明Array采用该协议，您就可以扩展Array以符合Container协议。您使用空扩展程序执行此操作，如使用扩展声明协议采用中所述： extension Array: Container {} Array现有的append(_:)方法和下标使Swift能够推断用于Item的适当类型，就像上面通用Stack类型一样。定义此扩展后，您可以将任何Array用作Container。 向关联类型添加约束您可以向协议中的关联类型添加类型约束，以要求符合这些约束的类型满足这些约束。例如，以下代码定义了一个Container版本，要求容器中的项是可等的。 protocol Container { ​ associatedtype Item: Equatable ​ mutating func append(_ item: Item) ​ var count: Int { get } ​ subscript(i: Int) -&gt; Item { get } } 要符合此版本的Container，容器Item类型必须符合Equatable协议。 在关联类型的约束中使用协议协议可以作为其自身要求的一部分出现。例如，这里有一个完善Container协议的协议，添加了suffix(_:)方法的要求。suffix(_:)方法从容器末尾返回给定数量的元素，并将其存储在Suffix类型的实例中。 protocol SuffixableContainer: Container { ​ associatedtype Suffix: SuffixableContainer where Suffix.Item &#x3D;&#x3D; Item ​ func suffix(_ size: Int) -&gt; Suffix } 在此协议中，Suffix是一个关联的类型，就像上面Container示例中的Item类型一样。Suffix有两个约束：它必须符合SuffixableContainer协议（当前定义的协议），其Item类型必须与容器Item类型相同。Item的约束是一个通用的where子句，在关联类型中与下面的通用where子句讨论。 以下是上述通用类型的Stack类型的扩展，该扩展增加了对SuffixableContainer协议的一致性： 123456789101112131415161. extension Stack: SuffixableContainer &#123;2. ​ func suffix(_ size: Int) -&gt; Stack &#123;3. ​ var result = Stack()4. ​ for index in (count-size)..&lt;count &#123;5. ​ result.append(self[index])6. ​ &#125;7. ​ return result8. ​ &#125;9. ​ // Inferred that Suffix is Stack.10. &#125;11. var stackOfInts = Stack&lt;Int&gt;()12. stackOfInts.append(10)13. stackOfInts.append(20)14. stackOfInts.append(30)15. let suffix = stackOfInts.suffix(2)16. // suffix contains 20 and 30 在上面的示例中，Stack的Suffix关联类型也是Stack，因此Stack上的后缀操作返回另一个Stack。或者，符合SuffixableContainer的类型可以具有与自身不同的Suffix类型——这意味着后缀操作可以返回不同的类型。例如，这是非genericIntStack类型的扩展，该类型添加了SuffixableContainer一致性，使用Stack&lt;Int&gt;作为其后缀类型，而不是IntStack： 123456789101. extension IntStack: SuffixableContainer &#123;2. ​ func suffix(_ size: Int) -&gt; Stack&lt;Int&gt; &#123;3. ​ var result = Stack&lt;Int&gt;()4. ​ for index in (count-size)..&lt;count &#123;5. ​ result.append(self[index])6. ​ &#125;7. ​ return result8. ​ &#125;9. ​ // Inferred that Suffix is Stack&lt;Int&gt;.10. &#125; 通用的其中子句类型约束，如类型约束中所述，使您能够定义与泛型函数、下标或类型关联的类型参数的要求。 定义关联类型的要求也很有用。你通过定义年龄语where子句来做到这一点。一个通用where子句允许您要求关联类型必须符合特定协议，或者某些类型参数和相关类型必须相同。一个通用where子句以where关键字开头，然后是关联类型的约束或类型与关联类型之间的等式关系。您就在类型或函数主体的开花括号之前编写一个泛型where子句。 下面的示例定义了一个名为allItemsMatch的通用函数，该函数检查两个Container实例是否以相同的顺序包含相同的项目。如果所有项目匹配，该函数返回true的布尔值，如果它们不匹配，则返回false值。 要检查的两个容器不必是相同类型的容器（尽管可以），但它们必须容纳相同类型的物品。此要求通过类型约束和通用子句的组合来表达： func allItemsMatch&lt;C1: Container, C2: Container&gt; ​ (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool ​ where C1.Item &#x3D;&#x3D; C2.Item, C1.Item: Equatable { ​ &#x2F;&#x2F; Check that both containers contain the same number of items. ​ if someContainer.count !&#x3D; anotherContainer.count { ​ return false ​ } ​ &#x2F;&#x2F; Check each pair of items to see if they’re equivalent. ​ for i in 0..&lt;someContainer.count { ​ if someContainer[i] !&#x3D; anotherContainer[i] { ​ return false ​ } ​ } ​ &#x2F;&#x2F; All items match, so return true. ​ return true } 此函数需要两个参数，称为someContainer和anotherContainer。ThesomeContainer参数为C1类型，anotherContainer参数为C2类型。C1和C2都是调用函数时要确定的两个容器类型的类型参数。 对函数的两个类型参数提出了以下要求： C1必须符合Container协议（写为C1:Container）。 C2还必须符合Container协议（写为C2:Container）。 The Item for C1 must be the same as the Item for C2 (written as C1.Item == C2.Item). C1``Item必须符合Equatable协议（写为C1.Item:Equatable）。 第一个和第二个要求在函数的类型参数列表中定义，第三个和第四个要求在函数的通用where子句中定义。 这些要求意味着： someContainer是C1型容器。 anotherContainer是C2型容器。 someContainer``anotherContainer包含相同类型的项目。 The items in someContainer can be checked with the not equal operator (!=) to see if they’re different from each other. 第三和第四个要求结合在一起，这意味着anotherContainer中的物品也可以与!=运算符，因为它们与insomeContainer中的项目完全相同。 这些要求使allItemsMatch(_:_:)函数能够比较两个容器，即使它们是不同的容器类型。 allItemsMatch(_:_:)函数首先检查两个容器是否包含相同数量的项目。如果它们包含不同数量的项目，则无法匹配，并且函数返回false。 After making this check, the function iterates over all of the items in someContainer with a for-in loop and the half-open range operator (..&lt;). For each item, the function checks whether the item from someContainer isn’t equal to the corresponding item in anotherContainer. If the two items aren’t equal, then the two containers don’t match, and the function returns false. 如果循环结束时没有发现不匹配，则两个容器匹配，并且函数返回true。 以下是allItemsMatch(_:_:)函数在操作中的样子： 12345678910111213 var stackOfStrings = Stack&lt;String&gt;() stackOfStrings.push(&quot;uno&quot;) stackOfStrings.push(&quot;dos&quot;) stackOfStrings.push(&quot;tres&quot;) var arrayOfStrings = [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;] if allItemsMatch(stackOfStrings, arrayOfStrings) &#123; ​ print(&quot;All items match.&quot;) &#125; else &#123; ​ print(&quot;Not all items match.&quot;) &#125;// Prints &quot;All items match.&quot; 上面的示例创建一个Stack实例来存储String值，并将三个字符串推送到堆栈上。该示例还创建一个Array实例，该实例使用包含与堆栈相同的三个字符串的数组文字初始化。尽管堆栈和数组类型不同，但它们都符合Container协议，并且都包含相同类型的值。因此，您可以使用这两个容器作为参数调用allItemsMatch(_:_:)函数。在上面的示例中，allItemsMatch(_:_:)函数正确报告两个容器中的所有项目都匹配。 带有通用Where子句的扩展您还可以使用泛型where子句作为扩展的一部分。以下示例从前面的示例中扩展了通用Stack结构，以添加isTop(_:)方法。 extension Stack where Element: Equatable { ​ func isTop(_ item: Element) -&gt; Bool { ​ guard let topItem &#x3D; items.last else { ​ return false ​ } ​ return topItem &#x3D;&#x3D; item ​ } } 这个新的isTop(_:)方法首先检查堆栈不是空的，然后将给定的项目与堆栈的最上面的项目进行比较。如果您尝试在没有泛型where子句的情况下执行此操作，您将遇到问题：isTop(_:)的实现使用==运算符，但Stack的定义不要求其项是可等的，因此使用==运算符会导致编译时错误。使用通用where子句，您可以向扩展添加新要求，以便扩展仅在堆栈中的项目可等时添加isTop(_:)方法。 以下是isTop(_:)方法在操作中的样子： if stackOfStrings.isTop(“tres”) { ​ print(“Top element is tres.”) } else { ​ print(“Top element is something else.”) } &#x2F;&#x2F; Prints “Top element is tres.” 如果您尝试在元素不可等同的堆栈上调用isTop(_:)方法，您将收到编译时错误。 12345struct NotEquatable &#123; &#125;var notEquatableStack = Stack&lt;NotEquatable&gt;()let notEquatableValue = NotEquatable()notEquatableStack.push(notEquatableValue)notEquatableStack.isTop(notEquatableValue) // Error` You can use a generic where clause with extensions to a protocol. The example below extends the Container protocol from the previous examples to add a startsWith(_:)method. extension Container where Item: Equatable { ​ func startsWith(_ item: Item) -&gt; Bool { ​ return count &gt;&#x3D; 1 &amp;&amp; self[0] &#x3D;&#x3D; item ​ } } startsWith(_:)方法首先确保容器至少有一个项目，然后检查容器中的第一个项目是否与给定项目匹配。只要容器的项目是等同的，此newstartsWithstartsWith(_:)方法可以与符合Container协议的任何类型一起使用，包括上面使用的堆栈和数组。 if [9, 9, 9].startsWith(42) { ​ print(“Starts with 42.”) } else { ​ print(“Starts with something else.”) } &#x2F;&#x2F; Prints “Starts with something else.” 上面示例中的泛型where子句要求Item符合协议，但您也可以编写一个泛型where子句，要求Item是特定类型。例如： extension Container where Item &#x3D;&#x3D; Double { ​ func average() -&gt; Double { ​ var sum &#x3D; 0.0 ​ for index in 0..&lt;count { ​ sum +&#x3D; self[index] ​ } ​ return sum &#x2F; Double(count) ​ } } print([1260.0, 1200.0, 98.6, 37.0].average()) &#x2F;&#x2F; Prints “648.9” 此示例为Item类型为Double的容器添加了average()方法。它迭代容器中的项目以将其相加，并除以容器计数以计算平均值。它显式将计数从Int转换为Double，以便能够进行浮点除法。 您可以在作为扩展一部分的泛型where子句中包含多个要求，就像您可以在其他地方编写的泛型where子句一样。用逗号分隔列表中的每个要求。 上下文，其中条款当您已经在泛型类型上下文中工作时，您可以编写一个泛型where子句，作为声明的一部分，该声明没有自己的泛型类型约束。例如，您可以在泛型类型的下标或泛型类型扩展中的方法上编写泛型子句。Container结构是通用的，以下示例中的where子句指定了必须满足哪些类型约束才能在容器上提供这些新方法。 extension Container { ​ func average() -&gt; Double where Item &#x3D;&#x3D; Int { ​ var sum &#x3D; 0.0 ​ for index in 0..&lt;count { ​ sum +&#x3D; Double(self[index]) ​ } ​ return sum &#x2F; Double(count) ​ } ​ func endsWith(_ item: Item) -&gt; Bool where Item: Equatable { ​ return count &gt;&#x3D; 1 &amp;&amp; self[count-1] &#x3D;&#x3D; item ​ } } let numbers &#x3D; [1260, 1200, 98, 37] print(numbers.average()) &#x2F;&#x2F; Prints “648.75” print(numbers.endsWith(37)) &#x2F;&#x2F; Prints “true” 当项目为整数时，此示例向Container添加average()方法，当项为等同时，它会添加endsWith(_:)方法。这两个函数都包括一个泛型where子句，该子句从Container的原始声明中向通用Item类型参数添加类型约束。 如果您想在不使用上下文where子句的情况下编写此代码，则编写两个扩展，每个泛型where子句一个。上面的示例和下面的示例具有相同的行为。 extension Container where Item &#x3D;&#x3D; Int { ​ func average() -&gt; Double { ​ var sum &#x3D; 0.0 ​ for index in 0..&lt;count { ​ sum +&#x3D; Double(self[index]) ​ } ​ return sum &#x2F; Double(count) ​ } } extension Container where Item: Equatable { ​ func endsWith(_ item: Item) -&gt; Bool { ​ return count &gt;&#x3D; 1 &amp;&amp; self[count-1] &#x3D;&#x3D; item ​ } } In the version of this example that uses contextual where clauses, the implementation of average() and endsWith(_:) are both in the same extension because each method’s generic where clause states the requirements that need to be satisfied to make that method available. Moving those requirements to the extensions’ generic where clauses makes the methods available in the same situations, but requires one extension per requirement. 与通用Where子句关联的类型您可以在关联类型上包含一个泛型where子句。例如，假设您想制作一个包含迭代器的Container版本，就像Sequence协议在标准库中使用的一样。您是这样写的： protocol Container { ​ associatedtype Item ​ mutating func append(_ item: Item) ​ var count: Int { get } ​ subscript(i: Int) -&gt; Item { get } ​ associatedtype Iterator: IteratorProtocol where Iterator.Element &#x3D;&#x3D; Item ​ func makeIterator() -&gt; Iterator } Iterator上的通用where子句要求迭代器必须遍历与容器项目相同的项目类型的元素，无论迭代器的类型如何。ThemakeIteratormakeIterator()函数提供对容器迭代器的访问。 对于从另一个协议继承的协议，您可以通过在协议声明中包含泛型where子句来向继承的关联类型添加约束。例如，以下代码声明了一个ComparableContainer协议，该协议要求Item符合Comparable： protocol ComparableContainer: Container where Item: Comparable { } 通用下标下标可以是通用的，它们可以包括通用的where子句。您在subscript后角括号内写入占位符类型名称，并在下标正文的开花括号前写一个泛型where子句。例如： extension Container { ​ subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item] ​ where Indices.Iterator.Element &#x3D;&#x3D; Int { ​ var result: [Item] &#x3D; [] ​ for index in indices { ​ result.append(self[index]) ​ } ​ return result ​ } } Container协议的扩展添加了一个下标，该下标接受一系列索引，并返回一个包含每个给定索引项目项的数组。此通用下标受以下限制： 角括号中的通用参数Indices必须是符合标准库中的Sequence协议的类型。 下标取单个参数，即indices，这是该Indices类型的实例。 通用where子句要求序列的迭代器必须遍历Int类型的元素。这确保了序列中的索引与容器中使用的索引类型相同。 总而言之，这些约束意味着为indices参数传递的值是整数序列。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 错误处理","slug":"软件开发/技术/编程语言/swift/Swift基础-错误处理","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-错误处理/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html 错误处理是响应程序中的错误条件并从中恢复的过程。Swift为在运行时抛出、捕获、传播和操作可恢复错误提供一流的支持。 一些操作不能保证总是完成执行或产生有用的输出。可选用于表示值的缺失，但当操作失败时，了解导致故障的原因通常是有用的，以便您的代码可以做出相应的响应。 例如，考虑从磁盘上的文件中读取和处理数据的任务。此任务有多种方式可能失败，包括文件在指定路径上不存在，文件没有读取权限，或文件没有以兼容格式编码。区分这些不同情况允许程序解决一些错误，并向用户传达任何无法解决的错误。 注意 Swift中的错误处理与Cocoa和Objective-C中使用NSError类的错误处理模式互操作。有关本课程的更多信息，请参阅在Swift中处理可可错误。 表示和抛出错误在 Swift 中，错误由符合Error协议的类型值表示。这个空协议表示一种类型可用于错误处理。 Swift枚举特别适合对一组相关错误条件进行建模，相关值允许传达有关错误性质的额外信息。例如，以下是您如何表示在游戏中操作自动售货机的错误条件： enum VendingMachineError: Error { ​ case invalidSelection ​ case insufficientFunds(coinsNeeded: Int) ​ case outOfStock } 抛出错误可以让您表明发生了意想不到的事情，正常的执行流程无法继续。您使用throw出语句抛出错误。例如，以下代码会抛出一个错误，表明自动售货机还需要五枚硬币： throw VendingMachineError.insufficientFunds(coinsNeeded: 5) 处理错误当抛出错误时，一些周围的代码必须负责处理错误——例如，通过纠正问题、尝试替代方法或通知用户故障。 有四种方法可以处理 Swift 中的错误。您可以将错误从函数传播到调用该函数的代码，使用do-catch语句处理错误，将错误作为可选值处理，或断言不会发生错误。每种方法都在下面的一节中描述。 当函数抛出错误时，它会改变程序的流程，因此您可以快速识别代码中可能抛出错误的地方非常重要。要识别代码中的这些位置，请编写try关键字或try?或者try!变化—在调用可能抛出错误的函数、方法或初始化器的代码之前。以下各节介绍了这些关键词。 注意 Swift中的错误处理类似于其他语言中的异常处理，使用try、catch和throw关键字。与包括Objective-C在内的许多语言中的异常处理不同，Swift中的错误处理不涉及解开调用堆栈，这个过程在计算上可能很昂贵。因此，throw语句的性能特征与return语句的性能特征相当。 使用抛出函数传播错误要指示函数、方法或初始化器可以抛出错误，您可以在函数的声明中在其参数后面写入throws关键字。标有throws函数称为抛出函数。如果函数指定了返回类型，则在返回箭头（-&gt;）之前写入throws关键字。 func canThrowErrors() throws -&gt; String func cannotThrowErrors() -&gt; String 抛出函数将抛出在其中的错误传播到调用它的范围。 注意 只有抛出函数才能传播错误。在非投掷函数内抛出的任何错误都必须在函数内处理。 在下面的示例中，VendingMachine类有一个vend(itemNamed:)方法，如果请求的项目不可用、缺货或成本超过当前存款金额，则抛出适当的VendingMachineError： struct Item { ​ var price: Int ​ var count: Int } class VendingMachine { ​ var inventory &#x3D; [ ​ “Candy Bar”: Item(price: 12, count: 7), ​ “Chips”: Item(price: 10, count: 4), ​ “Pretzels”: Item(price: 7, count: 11) ​ ] ​ var coinsDeposited &#x3D; 0 ​ func vend(itemNamed name: String) throws { ​ guard let item &#x3D; inventory[name] else { ​ throw VendingMachineError.invalidSelection ​ } ​ guard item.count &gt; 0 else { ​ throw VendingMachineError.outOfStock ​ } ​ guard item.price &lt;&#x3D; coinsDeposited else { ​ throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited) ​ } ​ coinsDeposited -&#x3D; item.price ​ var newItem &#x3D; item ​ newItem.count -&#x3D; 1 ​ inventory[name] &#x3D; newItem ​ print(“Dispensing (name)”) ​ } } vend(itemNamed:)方法的实现使用guard语句提前退出方法，如果不符合购买零食的任何要求，则会抛出适当的错误。由于throw出语句会立即传输程序控制，因此只有在满足所有这些要求的情况下才会对项目进行修改。 由于vend(itemNamed:)方法传播它抛出的任何错误，因此任何调用此方法的代码都必须使用do-catch语句、try?或try!处理错误，或继续传播它们。例如，以下示例中的buyFavoriteSnack(person:vendingMachine:)也是一个抛出函数，vend(itemNamed:)方法抛出的任何错误都将传播到调用buyFavoriteSnack(person:vendingMachine:)函数的点。 let favoriteSnacks &#x3D; [ ​ “Alice”: “Chips”, ​ “Bob”: “Licorice”, ​ “Eve”: “Pretzels”, ] func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws { ​ let snackName &#x3D; favoriteSnacks[person] ?? “Candy Bar” ​ try vendingMachine.vend(itemNamed: snackName) } 在本例中，buyFavoriteSnack(person:vendingMachine:)功能查找给定人最喜欢的零食，并尝试通过调用vend(itemNamed:)方法为他们购买。由于vend(itemNamed:)方法可能会抛出错误，因此在前面用try关键字调用它。 抛出初始化器可以像抛出函数一样传播错误。例如，以下列表中PurchasedSnack结构的初始化器调用抛出函数作为初始化过程的一部分，并通过将它们传播到调用者来处理遇到的任何错误。 struct PurchasedSnack { ​ let name: String ​ init(name: String, vendingMachine: VendingMachine) throws { ​ try vendingMachine.vend(itemNamed: name) ​ self.name &#x3D; name ​ } } 使用Do-Catch处理错误您可以使用do-catch语句通过运行代码块来处理错误。如果do子句中的代码抛出错误，它将与catch子句匹配，以确定其中哪一个可以处理错误。 以下是do-catch声明的一般形式： do { ​ try expression ​ statements } catch pattern 1 { ​ statements } catch pattern 2 where condition { ​ statements } catch pattern 3, pattern 4 where condition { ​ statements } catch { ​ statements } 您在catch后编写一个模式，以指示该子句可以处理哪些错误。如果catch子句没有模式，该子句将匹配任何错误，并将错误绑定到名为error的本地常量。有关模式匹配的更多信息，请参阅模式。 例如，以下代码与VendingMachineError枚举的所有三种情况相匹配。 var vendingMachine &#x3D; VendingMachine() vendingMachine.coinsDeposited &#x3D; 8 do { ​ try buyFavoriteSnack(person: “Alice”, vendingMachine: vendingMachine) ​ print(“Success! Yum.”) } catch VendingMachineError.invalidSelection { ​ print(“Invalid Selection.”) } catch VendingMachineError.outOfStock { ​ print(“Out of Stock.”) } catch VendingMachineError.insufficientFunds(let coinsNeeded) { ​ print(“Insufficient funds. Please insert an additional (coinsNeeded) coins.”) } catch { ​ print(“Unexpected error: (error).”) } &#x2F;&#x2F; Prints “Insufficient funds. Please insert an additional 2 coins.” 在上面的示例中，buyFavoriteSnack(person:vendingMachine:)函数在try表达式中调用，因为它可能会抛出错误。如果抛出错误，执行将立即转移到catch子句，该子句决定是否允许继续传播。如果没有匹配模式，错误将被最终的catch子句捕获，并绑定到局部error常量。如果没有抛出错误，则执行do语句中的其余语句。 catch子句不必处理do子句中的代码可以抛出的所有可能错误。如果没有一个catch子句处理错误，则错误会传播到周围的范围。然而，传播的错误必须由周围的一些范围处理。在非投掷函数中，封闭的do-catch语句必须处理错误。在抛出函数中，封闭的do-catch语句或调用者必须处理错误。如果错误在没有处理的情况下传播到顶级范围，您将收到一个运行时错误。 例如，可以写上一个示例，这样任何不是aVendingMachineError的错误都会被调用函数捕获： func nourish(with item: String) throws { ​ do { ​ try vendingMachine.vend(itemNamed: item) ​ } catch is VendingMachineError { ​ print(“Couldn’t buy that from the vending machine.”) ​ } } do { ​ try nourish(with: “Beet-Flavored Chips”) } catch { ​ print(“Unexpected non-vending-machine-related error: (error)”) } &#x2F;&#x2F; Prints “Couldn’t buy that from the vending machine.” 在nourish(with:)函数中，如果vend(itemNamed:)抛出作为VendingMachineError枚举之一的错误，nourish(with:)通过打印消息来处理错误。否则，nourish(with:)将错误传播到其调用站点。然后，错误被一般catch子句捕获。 捕获几个相关错误的另一种方法是在catch后列出它们，用逗号分隔。例如： func eat(item: String) throws { ​ do { ​ try vendingMachine.vend(itemNamed: item) ​ } catch VendingMachineError.invalidSelection, VendingMachineError.insufficientFunds, VendingMachineError.outOfStock { ​ print(“Invalid selection, out of stock, or not enough money.”) ​ } } eat(item:)函数列出了要捕获的自动售货机错误，其错误文本对应于该列表中的项目。如果抛出列出的三个错误中的任何一个，此catch子句通过打印消息来处理它们。任何其他错误都会传播到周围范围内，包括稍后可能会添加的任何自动售货机错误。 将错误转换为可选值You use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the try? expression, the value of the expression is nil. For example, in the following code x and y have the same value and behavior: func someThrowingFunction() throws -&gt; Int { ​ &#x2F;&#x2F; … } let x &#x3D; try? someThrowingFunction() let y: Int? do { ​ y &#x3D; try someThrowingFunction() } catch { ​ y &#x3D; nil } 如果someThrowingFunction()抛出错误，x和y的值为nil。否则，x和y的值是函数返回的值。请注意，x和y是someThrowingFunction()返回的任何类型的可选。在这里，函数返回一个整数，因此x和y是可选整数。 使用try?当您想以相同的方式处理所有错误时，允许您编写简洁的错误处理代码。例如，以下代码使用几种方法来获取数据，如果所有方法都失败，则返回nil。 func fetchData() -&gt; Data? { ​ if let data &#x3D; try? fetchDataFromDisk() { return data } ​ if let data &#x3D; try? fetchDataFromServer() { return data } ​ return nil } 禁用错误传播Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write try! before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error. 例如，以下代码使用loadImage(atPath:)函数，该函数在给定路径上加载图像资源，如果无法加载图像，则抛出错误。在这种情况下，由于图像随应用程序一起发送，因此在运行时不会抛出错误，因此禁用错误传播是合适的。 let photo &#x3D; try! loadImage(atPath: “.&#x2F;Resources&#x2F;John Appleseed.jpg”) 指定清理操作在代码执行离开当前代码块之前，您可以使用defer语句执行一组语句。此语句允许您进行任何必要的清理，无论执行如何离开当前代码块，无论是因为抛出错误还是因为return或break等语句而离开。例如，您可以使用defer语句来确保文件描述符关闭并释放手动分配的内存。 defer语句会推迟执行，直到当前范围退出。此语句由defer关键字和稍后要执行的语句组成。延迟语句不得包含任何将控制权从语句中转移出去的代码，例如break或a areturn语句，或通过抛出错误。延迟操作的执行顺序与源代码中写入的顺序相反。也就是说，第一个defer语句中的代码最后执行，第二个defer语句中的代码执行秒到最后，以此类推。源代码顺序的最后一个defer语句首先执行。 func processFile(filename: String) throws { ​ if exists(filename) { ​ let file &#x3D; open(filename) ​ defer { ​ close(file) ​ } ​ while let line &#x3D; try file.readline() { ​ &#x2F;&#x2F; Work with the file. ​ } ​ &#x2F;&#x2F; close(file) is called here, at the end of the scope. ​ } } 上面的示例使用defer语句来确保open(_:)函数具有相应的调用 close(_:) 注意 即使不涉及错误处理代码，您也可以使用defer语句。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 集合类型","slug":"软件开发/技术/编程语言/swift/Swift基础-集合类型","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-集合类型/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html Swift提供了三种主要集合类型，称为数组、集合和字典，用于存储值集合。数组是有序的值集合。集合是唯一值的无序集合。字典是键值关联的无序集合。 Swift 中的数组、集合和字典始终清楚可以存储的值和键的类型。这意味着您不能错误地将错误类型的值插入集合中。这也意味着您可以对从集合中检索的值类型有信心。 注意 Swift的数组、集合和字典类型作为通用集合实现。有关泛型类型和集合的更多信息，请参阅泛型。 收藏品的可变性如果您创建一个数组、集合或字典，并将其分配给变量，则创建的集合将是可变的。这意味着您可以在集合创建后通过添加、删除或更改集合中的项目来更改（或突变）。如果您将数组、集合或字典分配给常量，则该集合是不可变的，其大小和内容无法更改。 注意 在集合不需要更改的所有情况下，创建不可变集合是良好做法。这样做使您更容易对代码进行推理，并使Swift编译器能够优化您创建的集合的性能。 数组(Arrays)数组将相同类型的值存储在有序列表中。相同的值可以在不同位置多次出现在数组中。 注意 Swift的Array类型与Foundation的NSArray类桥接。 有关将Array与Foundation和Cocoa一起使用的更多信息，请参阅Array和NSArray之间的桥接。 数组类型速记语法Swift数组的类型被完整写成Array&lt;Element&gt;，其中Element是允许数组存储的值类型。您还可以将数组的类型以速记形式写为[Element]虽然这两种形式在功能上相同，但速记形式是首选，并在参考数组类型时在整个指南中使用。 创建空数组您可以使用初始化器语法创建特定类型的空数组： 123var someInts: [Int] = []print(&quot;someInts is of type [Int] with \\(someInts.count) items.&quot;)// Prints &quot;someInts is of type [Int] with 0 items.&quot; 请注意，从初始化器的类型推断出someInts变量的类型为[Int]。 或者，如果上下文已经提供了类型信息，例如函数参数或已经键入的变量或常量，您可以创建一个带有空数组文字的空数组，该数组写为[]（一对空的方括号）： 1234someInts.append(3)// someInts now contains 1 value of type IntsomeInts = []// someInts is now an empty array, but is still of type [Int] 创建具有默认值的数组Swift的Array类型还提供了一个初始化器，用于创建特定大小的数组，其所有值都设置为相同的默认值。您向此初始化器传递适当类型的默认值（称为repeating）：以及该值在新数组中重复的次数（称为count）： 12var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0] 通过将两个数组一起创建数组您可以通过添加两个具有兼容类型的现有数组与加法运算符（+）来创建新数组。新数组的类型从您添加的两个数组的类型推断出来： 12345var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 使用数组字面创建数组您还可以使用数组文字初始化数组，这是将一个或多个值写入数组集合的简写方式。数组文字写为值列表，用逗号分隔，周围是一对方括号： [value 1, value 2, value 3] 下面的示例创建一个名为shoppingList的数组来存储String值： 12var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]// shoppingList has been initialized with two initial items shoppingList变量被声明为“字符串值数组”，写为[String]由于此特定数组指定了String的值类型，因此仅允许存储String值。在这里，shoppingList数组用两个String值（“&quot;Eggs&quot;和&quot;Milk&quot;初始化，写在数组文字中。 注意 shoppingList数组被声明为变量（使用var介绍器），而不是常量（使用let介绍器），因为在下面的示例中，购物列表中添加了更多项目。 在这种情况下，数组字面包含两个String值，没有其他值。这与shoppingList变量声明的类型（只能包含String值的数组）匹配，因此允许分配数组文字作为使用两个初始项初始化shoppingList的一种方式。 由于Swift的类型推断，如果您使用包含相同类型值的数组文字初始化数组，则不必编写数组的类型。shoppingList的初始化可以以较短的形式编写： 1var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] 由于数组文字中的所有值都是相同的类型，Swift可以推断[String]是用于shoppingList变量的正确类型。 访问和修改数组您可以通过数组的方法和属性或使用下标语法访问和修改数组。 要查找数组中的项目数量，请检查其只读count属性： 12print(&quot;The shopping list contains \\(shoppingList.count) items.&quot;)// Prints &quot;The shopping list contains 2 items.&quot; 使用布尔为isEmpty属性作为快捷方式，以检查count属性是否等于0： 123456if shoppingList.isEmpty &#123; print(&quot;The shopping list is empty.&quot;)&#125; else &#123; print(&quot;The shopping list isn&#x27;t empty.&quot;)&#125;// Prints &quot;The shopping list isn&#x27;t empty.&quot; 您可以通过调用数组的append(_:)方法将新项添加到数组的末尾： 12shoppingList.append(&quot;Flour&quot;)// shoppingList now contains 3 items, and someone is making pancakes 或者，将一个或多个兼容项的数组附加到加法赋值运算符（+=： 1234shoppingList += [&quot;Baking Powder&quot;]// shoppingList now contains 4 itemsshoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]// shoppingList now contains 7 item 使用下标语法从数组中检索值，在数组名称后立即传递要在方括号内检索的值的索引： 12var firstItem = shoppingList[0]// firstItem is equal to &quot;Eggs&quot; 注意 数组中的第一个项目的索引为0，而不是1。Swift中的数组总是零索引。 您可以使用下标语法更改给定索引的现有值： 12shoppingList[0] = &quot;Six eggs&quot;// the first item in the list is now equal to &quot;Six eggs&quot; rather than &quot;Eggs&quot; 使用下标语法时，指定的索引必须是有效的。例如，写 shoppingList[shoppingList.count] = &quot;Salt&quot; 将一个项添加到数组的末尾会导致运行时错误。 您还可以使用下标语法一次更改值范围，即使替换值集的长度与您要替换的范围不同。以下示例将&quot;ChocolateSpread&quot; &quot;Cheese&quot;和&quot;Butter&quot;替换为&quot;Bananas&quot;和&quot;Apples&quot;： 12shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]// shoppingList now contains 6 items 要在指定的索引处将项目插入数组，请调用数组的insert(_:at:)方法： 123shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)// shoppingList now contains 7 items// &quot;Maple Syrup&quot; is now the first item in the list 对insert(_:at:)方法的调用在购物清单开头插入一个值为&quot;MapleSyrup&quot;的新项目，索引为0。 同样，您使用remove(at:)方法从数组中删除项目。此方法在指定索引处删除项目并返回已删除的项目（尽管如果您不需要，您可以忽略返回的值）： 1234let mapleSyrup = shoppingList.remove(at: 0)// the item that was at index 0 has just been removed// shoppingList now contains 6 items, and no Maple Syrup// the mapleSyrup constant is now equal to the removed &quot;Maple Syrup&quot; string 注意 如果您尝试访问或修改超出数组现有边界的索引的值，您将触发运行时错误。您可以通过将索引与数组的count属性进行比较，在使用索引之前检查索引是否有效。数组中最大的有效索引是count1，因为数组从零开始索引——然而，当count为0（这意味着数组为空），没有有效的索引。 当删除项目时，数组中的任何间隙都会关闭，因此索引0的值再次等于&quot;Sixeggs&quot;： 12firstItem = shoppingList[0]// firstItem is now equal to &quot;Six eggs&quot; 如果你想从数组中删除最后一项，使用’ removeLast() ‘方法，而不是’ remove(at:) ‘方法，以避免需要查询数组的’ count ‘属性。像’ remove(at:) ‘方法一样，’ removeLast() ‘返回被删除的项: 1234let apples = shoppingList.removeLast()// the last item in the array has just been removed// shoppingList now contains 5 items, and no apples// the apples constant is now equal to the removed &quot;Apples&quot; string 在数组上迭代您可以使用for-in循环迭代数组中的整组值： 12345678for item in shoppingList &#123; print(item)&#125;// Six eggs// Milk// Flour// Baking Powder// Bananas 如果您需要每个项目的整数索引及其值，请使用enumerated()方法迭代数组。对于数组中的每个项目，enumerated()方法返回由整数和项组成的元组。整数从零开始，每个项目数一个；如果您在整个数组中枚举，这些整数与项目的索引匹配。您可以将元组分解为临时常量或变量，作为迭代的一部分： 12345678for (index, value) in shoppingList.enumerated() &#123; print(&quot;Item \\(index + 1): \\(value)&quot;)&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 有关for-in循环的更多信息，请参阅for-in循环。 Sets集合在集合中存储相同类型的不同值，没有定义的顺序。当项目顺序不重要时，或者当您需要确保项目只出现一次时，您可以使用集合而不是数组。 注意 Swift的Set类型与Foundation的NSSet类桥接。 For more information about using Set with Foundation and Cocoa, see Bridging Between Set and NSSet. 集合类型的哈希值为了存储在集合中，类型必须是“哈希”的——也就是说，类型必须为自己提供一种计算“哈希值”的方法。哈希值是一个’ Int ‘值，它对所有相等比较的对象都是相同的，例如，如果’ A &#x3D;&#x3D; b ‘， ‘ A ‘的哈希值等于’ b ‘的哈希值。 Swift的所有基本类型（如String、Int、Double和Bool）默认都是可散列的，并且可以用作设置值类型或字典键类型。默认情况下，没有关联值的枚举案例值（如枚举中所述）也是可散列的。 注意 您可以使用自己的自定义类型作为设置值类型或字典键类型，使其符合Swift标准库中的Hashable协议。有关实现所需hash(into:)方法的信息，请参阅Hashable。有关遵守协议的信息，请参阅协议。 设置类型语法Swift集的类型写为Set&lt;Element&gt;，其中Element是允许该集存储的类型。与数组不同，集合没有等效的速记形式。 创建和初始化空集您可以使用初始化器语法创建特定类型的空集： 123var letters = Set&lt;Character&gt;()print(&quot;letters is of type Set&lt;Character&gt; with \\(letters.count) items.&quot;)// Prints &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot; 注意 从初始化器的类型推断letters变量的类型为Set&lt;Character&gt;。 或者，如果上下文已经提供了类型信息，例如函数参数或已经键入的变量或常量，您可以创建一个带有空数组文字的空集： 1234letters.insert(&quot;a&quot;)// letters now contains 1 value of type Characterletters = []// letters is now an empty set, but is still of type Set&lt;Character&gt; 使用数组字面创建集合您还可以使用数组文字初始化集合，作为将一个或多个值写入集合的速记方式。 下面的示例创建一个名为 favoriteGenres集合来存储String值： 12var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]// favoriteGenres has been initialized with three initial items favoritegenre 变量被声明为”一组 String 值”，写成 set &lt;String&gt; 。因为这个特定的集合指定了一个值类型 String ，它只允许存储 String 值。在这里， favoritegenre 集合被初始化为三个 String 值( Rock ， Classical 和 Hip hop )，写入一个数组文字。 注意 favoriteGenres集被声明为变量（使用var引入器），而不是常量（使用let介绍器），因为在下面的示例中添加了和删除了项目。 仅凭数组字面值无法推断集合类型，因此必须显式声明类型Set。但是，由于Swift的类型推断，如果您使用仅包含一种类型的值的数组文字初始化集元素的类型，则不必编写该集合元素的类型。favoriteGenres的初始化可以以较短的形式编写： 1var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] 由于数组文字中的所有值都是相同的类型，Swift可以推断Set&lt;String&gt;是用于favoriteGenres变量的正确类型。 访问和修改一组您通过其方法和属性访问和修改集合。 要了解集合中的项目数量，请检查其只读count属性： 12print(&quot;I have \\(favoriteGenres.count) favorite music genres.&quot;)// Prints &quot;I have 3 favorite music genres.&quot; 使用布尔为isEmpty属性作为快捷方式，以检查count属性是否等于0： 123456if favoriteGenres.isEmpty &#123; print(&quot;As far as music goes, I&#x27;m not picky.&quot;)&#125; else &#123; print(&quot;I have particular music preferences.&quot;)&#125;// Prints &quot;I have particular music preferences.&quot; 您可以通过调用集合的insert(_:)方法将新项目添加到集合中： 12favoriteGenres.insert(&quot;Jazz&quot;)// favoriteGenres now contains 4 items 您可以通过调用集合的remove(_:)方法从集合中删除项目，如果项目是集合的成员，则删除项目，并返回删除的值，如果集合不包含它，则返回nil。或者，集合中的所有项目都可以使用其removeAll()方法删除。 123456if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) &#123; print(&quot;\\(removedGenre)? I&#x27;m over it.&quot;)&#125; else &#123; print(&quot;I never much cared for that.&quot;)&#125;// Prints &quot;Rock? I&#x27;m over it.&quot; 要检查集合是否包含特定项，请使用contains(_:)方法。 123456if favoriteGenres.contains(&quot;Funk&quot;) &#123; print(&quot;I get up on the good foot.&quot;)&#125; else &#123; print(&quot;It&#x27;s too funky in here.&quot;)&#125;// Prints &quot;It&#x27;s too funky in here.&quot; 在一组上迭代您可以使用for-in循环迭代集合中的值。 123456for genre in favoriteGenres &#123; print(&quot;\\(genre)&quot;)&#125;// Classical// Jazz// Hip hop 有关for-in循环的更多信息，请参阅for-in循环。 Swift的Set类型没有定义的顺序。要按特定顺序迭代集合的值，请使用sorted()方法，该方法将集合的元素作为使用&lt;运算符排序的数组返回。 123456for genre in favoriteGenres.sorted() &#123; print(&quot;\\(genre)&quot;)&#125;// Classical// Hip hop// Jazz 执行集合操作您可以高效地执行基本集合操作，例如将两个集合组合在一起，确定两个集合具有共同值，或确定两个集合是否包含所有、部分或不包含相同的值。 基本集操作下面的插图描绘了两个集合——a和b——以及由阴影区域表示的各种集合操作的结果。 使用intersection(_:)方法创建一个新集合，其中只有两个集合共有的值。 使用symmetricDifference(_:)方法创建一个新集合，其中两个集合都有值，但不是两者。 使用union(_:)方法创建一个包含两个集合中所有值的新集合。 使用subtracting(_:)方法创建一个值不在指定集合中的新集合。 123456789101112let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9] 设定成员资格和平等下图描述了三个集合——a、b和c，其中重叠的区域表示集合之间共享的元素。设置一个是集的超集b,因为包含了所有元素b。相反地,b是集的一个子集,因为所有元素b也包含一组。b, c是不相交的,因为他们没有共同之处。 使用“相等”运算符(==)确定两个集合是否包含所有相同的值。 Use the isSubset(of:) 方法确定一个集合的所有值是否包含在指定的集合中。 Use the isSuperset(of:) 方法确定一个集合是否包含指定集合中的所有值。 Use the isStrictSubset(of:) or isStrictSuperset(of:) 方法确定一个集合是子集还是超集，但不等于指定的集合。 使用isDisjoint(with:)方法确定两个集合是否没有共同值。 12345678910let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true 字典(Dictionaries)字典在集合中存储相同类型的键和相同类型的值之间的关联，没有定义的顺序。每个值都与一个唯一的键相关联，该键充当字典中该值的标识符。与数组中的项目不同，字典中的项目没有指定的顺序。当您需要根据它们的标识符查找值时，您可以使用字典，就像使用现实世界的字典来查找特定单词的定义一样。 注意 Swift的Dictionary类型与Foundation的NSDictionary类相连。 有关使用Dictionary与基金会和可可的更多信息，请参阅词典和NS词典之间的衔接。 字典类型速记语法Swift字典的类型完整地写成‘dictionary &lt;Key, Value&gt;’，其中‘Key’是可以用作字典键的值的类型，而‘Value’是字典为这些键存储的值的类型。 注意 字典Key类型必须符合Hashable协议，就像集合的值类型一样。 您还可以以速记形式将字典类型写为[Key:Value]虽然这两种形式在功能上相同，但简写形式是首选，并在参考词典类型时在整个指南中使用。 创建空字典与数组一样，您可以使用初始化器语法创建特定类型的空Dictionary： 12var namesOfIntegers: [Int: String] = [:]// namesOfIntegers is an empty [Int: String] dictionary 这个例子创建了一个“[Int: String]”类型的空字典来存储人类可读的整数值名称。它的键的类型是’ Int ‘，它的值的类型是’ String ‘。 如果上下文已经提供了类型信息，您可以创建一个带有空字典文字的空字典，该字典写为[:]（一对方括号内的冒号）： 1234namesOfIntegers[16] = &quot;sixteen&quot;// namesOfIntegers now contains 1 key-value pairnamesOfIntegers = [:]// namesOfIntegers is once again an empty dictionary of type [Int: String] 使用字典创建词典您还可以使用字典文字初始化字典，该字典的语法与前面看到的数组文字相似。字典文字是将一个或多个键值对写成Dictionary集合的简写方式。 键值对是键和值的组合。在字典文字中，每个键值对中的键和值由冒号分隔。键值对写成列表，用逗号分隔，周围是一对方括号： [key 1: value 1, key 2: value 2, key 3: value 3] 下面的示例创建了一本词典来存储国际机场的名称。在本词典中，键是三个字母的国际航空运输协会代码，值是机场名称： 1var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;] airports词典被声明为具有[String:String]的类型，意思是“键为String类型，其值也为String类型的Dictionary”。 注意 airports词典被声明为变量（使用var介绍器），而不是常量（使用let介绍器），因为在下面的示例中，词典中添加了更多的机场。 airports词典以包含两个键值对的字典字面进行初始化。第一对有&quot;YYZ&quot;的键和&quot;TorontoPearson&quot;的值。第二对有&quot;DUB&quot;的键和&quot;Dublin&quot;的值。 这本词典的文字包含两个String:String对。此键值类型与airports变量声明的类型匹配（仅具有String键和仅String值的字典），因此允许分配字典文字，作为用两个初始项初始化airports字典的一种方式。 与数组一样，如果您使用键和值具有一致类型的字典字典初始化，则不必编写字典类型。airports的初始化可以以较短的形式书写： 1var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;] 因为字面值中的所有键都是彼此相同的类型，同样的，所有值也都是彼此相同的类型，Swift可以推断’ [String: String] ‘是’ airports ‘字典的正确类型。 访问和修改词典您通过字典的方法和属性或使用下标语法访问和修改字典。 与数组一样，您可以通过检查字典的只读count属性来查找Dictionary中的项目数量： 12print(&quot;The airports dictionary contains \\(airports.count) items.&quot;)// Prints &quot;The airports dictionary contains 2 items.&quot; 使用布尔为isEmpty属性作为快捷方式，以检查count属性是否等于0： 123456if airports.isEmpty &#123; print(&quot;The airports dictionary is empty.&quot;)&#125; else &#123; print(&quot;The airports dictionary isn&#x27;t empty.&quot;)&#125;// Prints &quot;The airports dictionary isn&#x27;t empty.&quot; 您可以将新项目添加到带有下标语法的字典中。使用适当类型的新键作为下标索引，并分配适当类型的新值： 12airports[&quot;LHR&quot;] = &quot;London&quot;// the airports dictionary now contains 3 items 您还可以使用下标语法来更改与特定键关联的值： 12airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;// the value for &quot;LHR&quot; has been changed to &quot;London Heathrow&quot; 作为下标的替代方案，使用字典的updateValue(_:forKey:)方法来设置或更新特定键的值。与上面的下标示例一样，updateValue(_:forKey:)方法为键设置值（如果没有，则为该键设置值，如果该键已经存在，则更新该值。然而，与下标不同，updateValue(_:forKey:)方法在执行更新后返回旧值。这使您能够检查是否进行了更新。 updateValue(_:forKey:)方法返回字典值类型的可选值。例如，对于存储String值的字典，该方法返回String?或“可选String”类型的值。如果更新前存在该键，则此可选值包含该键的旧值，如果没有值，则nil： 1234if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) &#123; print(&quot;The old value for DUB was \\(oldValue).&quot;)&#125;// Prints &quot;The old value for DUB was Dublin.&quot; 您还可以使用下标语法从字典中检索特定键的值。由于可以请求一个不存在值的键，字典的下标返回字典值类型的可选值。如果字典包含请求键的值，则下标返回一个可选值，其中包含该键的现有值。否则，下标返回nil： 123456if let airportName = airports[&quot;DUB&quot;] &#123; print(&quot;The name of the airport is \\(airportName).&quot;)&#125; else &#123; print(&quot;That airport isn&#x27;t in the airports dictionary.&quot;)&#125;// Prints &quot;The name of the airport is Dublin Airport.&quot; 您可以使用下标语法通过为该键分配nil的值从字典中删除键值对： 1234airports[&quot;APL&quot;] = &quot;Apple International&quot;// &quot;Apple International&quot; isn&#x27;t the real airport for APL, so delete itairports[&quot;APL&quot;] = nil// APL has now been removed from the dictionary 或者，使用removeValue(forKey:)方法从字典中删除键值对。如果存在键值对，此方法将删除并返回删除的值，如果没有值，则返回nil： 123456if let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) &#123; print(&quot;The removed airport&#x27;s name is \\(removedValue).&quot;)&#125; else &#123; print(&quot;The airports dictionary doesn&#x27;t contain a value for DUB.&quot;)&#125;// Prints &quot;The removed airport&#x27;s name is Dublin Airport.&quot; 在字典上迭代您可以使用for-in循环迭代字典中的键值对。字典中的每个项目都作为(key,value)元组返回，您可以将元组的成员分解为临时常量或变量，作为迭代的一部分： 12345for (airportCode, airportName) in airports &#123; print(&quot;\\(airportCode): \\(airportName)&quot;)&#125;// LHR: London Heathrow// YYZ: Toronto Pearson 有关for-in循环的更多信息，请参阅for-in循环。 您还可以通过访问字典的键和values属性来检索字典键或值keys迭代集合： 1234567891011for airportCode in airports.keys &#123; print(&quot;Airport code: \\(airportCode)&quot;)&#125;// Airport code: LHR// Airport code: YYZfor airportName in airports.values &#123; print(&quot;Airport name: \\(airportName)&quot;)&#125;// Airport name: London Heathrow// Airport name: Toronto Pearson 如果您需要将字典的键或值与采用Array实例的API一起使用，请使用keys或values属性初始化新数组： 12345let airportCodes = [String](airports.keys)// airportCodes is [&quot;LHR&quot;, &quot;YYZ&quot;]let airportNames = [String](airports.values)// airportNames is [&quot;London Heathrow&quot;, &quot;Toronto Pearson&quot;] Swift的Dictionary类型没有定义的顺序。要按特定顺序迭代字典的键或值，请在其keys或values属性上使用sorted()方法。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Swift基础 高级操作员","slug":"软件开发/技术/编程语言/swift/Swift基础-高级操作员","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.294Z","comments":true,"path":"2022/07/Swift基础-高级操作员/","link":"","permalink":"https://guoshunfa.com/2022/07/Swift%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E5%91%98/","excerpt":"","text":"翻译自：https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html 除了基本运算符中描述的运算符外，Swift还提供了几个高级运算符来执行更复杂的值操作。这些包括您将熟悉的C和Objective-C的所有位和位移位运算符。 与C中的算术运算符不同，Swift中的算术运算符默认不会溢出。溢出行为被困住，并报告为错误。要选择溢出行为，请使用Swift的第二组默认溢出的算术运算符，例如溢出加法运算符（&amp;+）。所有这些溢出运算符都以安培和（&amp;）开头。 当您定义自己的结构、类和枚举时，为这些自定义类型提供您自己的标准Swift运算符的实现可能会很有用。Swift可以轻松提供这些运算符的定制实现，并准确确定它们对您创建的每个类型的行为。 您不限于预定义的运算符。Swift允许您自由定义自己的自定义内缀、前缀、后缀和赋值运算符，并具有自定义优先级和关联性值。这些运算符可以像任何预定义运算符一样在您的代码中使用和采用，您甚至可以扩展现有类型以支持您定义的自定义运算符。 按位运算符按位运算符使您能够操作数据结构中的单个原始数据位。它们通常用于低级编程，例如图形编程和设备驱动程序创建。当您处理来自外部来源的原始数据时，例如编码和解码数据以通过自定义协议进行通信时，按位运算符也很有用。 Swift支持C中的所有按位运算符，如下所述。 Bitwise NOT运算符按位不算符（~）反转数字中的所有位： 按位NOt运算符是一个前缀运算符，并显示在其操作的值之前，没有任何空格： let initialBits: UInt8 &#x3D; 0b00001111 let invertedBits &#x3D; ~initialBits &#x2F;&#x2F; equals 11110000 UInt8整数有8位，可以存储0到255之间的任何值。此示例初始化二进制值00001111的UInt8整数，其前四位设置为0，后四位设置为1。这相当于小数点后15。 然后，按位NOt运算符创建一个名为invertedBits的新常量，该常量等于initialBits，但所有位都倒置。零变成1，1变成零。invertedBits的值为11110000，等于240的无符号小数值。 位和运算符按位和运算符（&amp;）结合了两个数字的位。只有当两个输入数字中的位等于1时，它才会返回一个新数字，其位设置为1： 在下面的示例中，firstSixBits和lastSixBits的值都有四个中间位等于1。按位和运算符将它们组合成数字00111100，等于60的无符号小数值： let firstSixBits: UInt8 &#x3D; 0b11111100 let lastSixBits: UInt8 &#x3D; 0b00111111 let middleFourBits &#x3D; firstSixBits &amp; lastSixBits &#x2F;&#x2F; equals 00111100 Bitwise OR运算符按位OR运算符（|）比较两个数字的位。如果任一输入号中的位等于1运算符返回一个新数字，其位设置为1： 在下面的示例中，someBits和moreBits的值将不同的位设置为1。按位或运算符将它们组合成数字11111110，等于254的无符号小数点： let someBits: UInt8 &#x3D; 0b10110010 let moreBits: UInt8 &#x3D; 0b01011110 let combinedbits &#x3D; someBits | moreBits &#x2F;&#x2F; equals 11111110 位XOR运算符按位XOR运算符，或“排他性OR运算符”（^），比较两个数字的位。运算符返回一个新数字，其位设置为1，其中输入位不同，并设置为0，其中输入位相同： 在下面的示例中，firstBits和otherBits的值在另一个没有的位置上都设置为1。按位XOR运算符将这两个位的输出值设置为1。firstBits``otherBits中的所有其他位都匹配，并在输出值中设置为0： let firstBits: UInt8 &#x3D; 0b00010100 let otherBits: UInt8 &#x3D; 0b00000101 let outputBits &#x3D; firstBits ^ otherBits &#x2F;&#x2F; equals 00010001 逐位左移和右移运算符根据下面定义的规则，按位左移运算符（&lt;&lt;）和按位右移运算符（&gt;&gt;）将数字中的所有位向左或向右移动一定数量的位置。 位左移和右移具有整数乘以或除以二倍的效果。将整数的位向左移动一个位置会使其值翻倍，而将其向右移动一个位置会将其值减半。 无符号整数的移动行为无符号整数的位移位行为如下： 现有位按请求的位数向左或向右移动。 任何移动到整数存储边界之外的位都会被丢弃。 在原始位向左或向右移动后，零插入后面的空间。 这种方法被称为逻辑转变。 The illustration below shows the results of 11111111 &lt;&lt; 1 (which is 11111111 shifted to the left by 1 place), and 11111111 &gt;&gt; 1 (which is 11111111 shifted to the right by 1 place). Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted: 以下是 Swift 代码中位移的外观： let shiftBits: UInt8 &#x3D; 4 &#x2F;&#x2F; 00000100 in binary shiftBits &lt;&lt; 1 &#x2F;&#x2F; 00001000 shiftBits &lt;&lt; 2 &#x2F;&#x2F; 00010000 shiftBits &lt;&lt; 5 &#x2F;&#x2F; 10000000 shiftBits &lt;&lt; 6 &#x2F;&#x2F; 00000000 shiftBits &gt;&gt; 2 &#x2F;&#x2F; 00000001 您可以使用位移来编码和解码其他数据类型中的值： let pink: UInt32 &#x3D; 0xCC6699 let redComponent &#x3D; (pink &amp; 0xFF0000) &gt;&gt; 16 &#x2F;&#x2F; redComponent is 0xCC, or 204 let greenComponent &#x3D; (pink &amp; 0x00FF00) &gt;&gt; 8 &#x2F;&#x2F; greenComponent is 0x66, or 102 let blueComponent &#x3D; pink &amp; 0x0000FF &#x2F;&#x2F; blueComponent is 0x99, or 153 此示例使用名为pink的UInt32常量来存储粉红色的级联样式表颜色值。CSS颜色值#CC6699在Swift的十六进制数字表示中写为0xCC6699。然后，按位AND运算符（&amp;）和按位右移运算符（&gt;&gt;）分解为红色（CC）、绿色（66）和蓝色（99）组件。 红色分量是通过在数字0xCC6699和0xFF0000之间执行按位AND获得的。0xFF0000中的零有效地“屏蔽”了0xCC6699的第二和第三个字节，导致6699被忽略，并因此留下0xCC0000。 This number is then shifted 16 places to the right (&gt;&gt; 16). Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert 0xCC0000 into 0x0000CC. This is the same as 0xCC, which has a decimal value of 204. 同样，绿色分量是通过在数字0xCC6699和0x00FF00之间执行按位AND获得的，输出值为0x006600。然后，该输出值向右移动八个位置，给出的值为0x66，小数值为102。 最后，通过在数字0xCC6699和0x0000FF之间执行按位AND获得蓝色分量，输出值为0x000099。由于0x000099已经等于0x99，其小数值为153，因此使用此值时不会将其向右移动， 有符号整数的移动行为有符号整数的移位行为比无符号整数更复杂，因为有符号整数在二进制中表示的方式。（为了简单起见，以下示例基于8位有符号整数，但同样的原则适用于任何大小的有符号整数。） 有符号整数使用它们的第一个位（称为符号位）来指示整数是正数还是负数。0的符号位表示正值，1的符号位表示负数。 剩余的位（称为值位）存储实际值。正数的存储方式与无符号整数完全相同，从0向上计数。以下是Int8中的位如何查找数字4： 符号位为0（意为“正”），七个值位只是数字4，用二进制符号书写。 然而，负数的存储方式不同。它们通过从2减去n的绝对值来存储，其中n是值位数。八位数字有7个值位，这意味着2到7或128的功率。 以下是Int8内部的位如何查找数字-4： 这一次，符号位为1（意为“负”），七个值位的二进制值为124（即1284）： 这种负数编码被称为二的补数表示。这可能看起来是一种不寻常的表示负数的方式，但它有几个优点。 首先，您可以添加-1到-4，只需对所有8位（包括符号位）进行标准二进制添加，并在完成后丢弃任何不适合8位的东西： 其次，两者的补码表示还允许您像正数一样将负数位移到左侧和右侧，并且最终在向左移动的每移动时将其翻倍，或者在向右移动的每移动时将其减半。为了实现这一目标，当有符号整数向右移动时，会使用额外的规则：当您向右移动有符号整数时，请应用与无符号整数相同的规则，但用符号位而不是用零填充左侧的任何空位。 此操作确保有符号整数在向右移动后具有相同的符号，并被称为算术移位。 由于正数和负数的存储方式特殊，将它们中的任何一个移动到右边会使它们接近于零。在这种转变期间保持符号位不变意味着负整数在值接近于零时保持负数。 溢出运算符如果您尝试将数字插入无法保存该值的整数常量或变量中，默认情况下，Swift会报告错误，而不是允许创建无效值。当您处理太大或太小的数字时，这种行为会带来额外的安全性。 例如，Int16整数类型可以保存-32768和32767之间的任何有符号整数。尝试将Int16常量或变量设置为此范围之外的数字会导致错误： var potentialOverflow &#x3D; Int16.max &#x2F;&#x2F; potentialOverflow equals 32767, which is the maximum value an Int16 can hold potentialOverflow +&#x3D; 1 &#x2F;&#x2F; this causes an error 当值太大或太小时提供错误处理，使您在编码边界值条件时具有更大的灵活性。 但是，当您特别希望溢出条件截断可用位数时，您可以选择此行为，而不是触发错误。Swift提供了三个算法溢出运算符，这些运算符选择溢出行为进行整数计算。这些运算符都以安培数（&amp;）开头： 溢出添加（&amp;+） 溢出减法（&amp;-） 溢出乘法（&amp;*） 价值溢出数字可以向正向和负方向溢出。 以下是一个示例，说明当允许无符号整数使用溢出加法运算符（&amp;+）向正方向溢出时会发生什么： var unsignedOverflow &#x3D; UInt8.max &#x2F;&#x2F; unsignedOverflow equals 255, which is the maximum value a UInt8 can hold unsignedOverflow &#x3D; unsignedOverflow &amp;+ 1 &#x2F;&#x2F; unsignedOverflow is now equal to 0 变量unsignedOverflow初始化为UInt8可以持有的最大值（255，二进制为11111111）。然后使用溢出加法运算符（&amp;+）将其增加1。这使其二进制表示略高于UInt8可以容纳的大小，导致其溢出超出其界限，如下图所示。溢出加法后保持在UInt8范围内的值为00000000或零。 当允许无符号整数向负方向溢出时，也会发生类似的事情。以下是使用溢出减法运算符（&amp;-）的示例： var unsignedOverflow &#x3D; UInt8.min &#x2F;&#x2F; unsignedOverflow equals 0, which is the minimum value a UInt8 can hold unsignedOverflow &#x3D; unsignedOverflow &amp;- 1 &#x2F;&#x2F; unsignedOverflow is now equal to 255 UInt8可以持有的最低值为零，或二进制中的00000000。如果您使用溢出减法运算符（&amp;-）从00000000中减去1，该数字将溢出并包装为11111111，或小数255。 签名整数也会发生溢出。有符号整数的所有加法和减法都以按位方式执行，符号位包含在数字中添加或减去中，如按位左移和右移运算符中所述。 var signedOverflow &#x3D; Int8.min &#x2F;&#x2F; signedOverflow equals -128, which is the minimum value an Int8 can hold signedOverflow &#x3D; signedOverflow &amp;- 1 &#x2F;&#x2F; signedOverflow is now equal to 127 Int8可以持有的最低值为-128，或二进制中的10000000。使用溢出运算符从这个二进制数中减去1，二进制值为01111111，这会切换符号位并给出正127，即Int8可以持有的最大正值。 对于有符号整数和非有符号整数，正方向的溢出从最大有效整数值回最小值，负方向的溢出从最小值到最大值。 优先级和关联性运算符优先级赋予一些运算符比其他运算符更高的优先级；这些运算符首先应用。 运算符结合性定义了具有相同优先级的运算符如何分组在一起——要么从左分组，要么从右分组。把它想象成“他们与左边的表达式相关联想”，或“他们与右边的表达式相关联”。 在计算复合表达式的顺序时，重要的是要考虑每个算子的优先级和关联性。例如，运算符优先级解释了为什么以下表达式等于17。 2 + 3 % 4 * 5 &#x2F;&#x2F; this equals 17 如果您严格从左到右阅读，您可能会期望表达式计算如下： 2加3等于5 5剩余的4等于1 1乘以5等于5 然而，实际答案是17，而不是5。高优先级算子在低优先级运算符之前进行评估。在Swift中，与C一样，余数运算符（%）和乘法运算符（*）的优先级高于加法运算符（+）。因此，在考虑添加之前，它们都会被评估。 然而，余数和乘法具有相同的优先级。要确定要使用的确切评估顺序，您还需要考虑它们的关联性。剩余和乘法都与左边的表达式相关联。将其视为从左侧开始，在表达式的这些部分周围添加隐式括号： 2 + ((3 % 4) * 5) (3 % 4)是3，所以这相当于： 2 + (3 * 5) (3 * 5)是15，所以这相当于： 2 + 15 这一计算得出了17的最终答案。 有关Swift标准库提供的运算符的信息，包括运算符优先级组和关联性设置的完整列表，请参阅运算符声明。 注意 Swift的运算符优先级和结合性规则比C和Objective-C更简单、更可预测。然而，这意味着它们与基于C的语言并不完全相同。在将现有代码移植到Swift时，请务必确保运营商交互的行为仍然像您希望的方式。 运算符方法类和结构可以提供现有运算符自己的实现。这被称为使现有运算符超载。 下面的示例展示了如何为自定义结构实现算术加法运算符（+）。算术加法运算符是一个二进制运算符，因为它在两个目标上运行，而它是一个内缀运算符，因为它出现在这两个目标之间。 该示例为二维位置向量(x,y)定义了Vector2D结构，然后是将Vector2D结构实例相加的运算符方法的定义： struct Vector2D { ​ var x &#x3D; 0.0, y &#x3D; 0.0 } extension Vector2D { ​ static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D { ​ return Vector2D(x: left.x + right.x, y: left.y + right.y) ​ } } 运算符方法被定义为Vector2D上的类型方法，其方法名称与要重载的运算符（+）匹配。由于加法不是向量基本行为的一部分，因此类型方法在Vector2D的扩展中定义，而不是在Vector2D的主结构声明中定义。由于算术加法运算符是二进制运算符，因此该运算符方法接受Vector2D类型的两个输入参数，并返回一个输出值，也是Vector2D类型的输出值。 在这个实现中，输入参数被命名为left和right，以表示位于+运算符左侧和右侧的Vector2D实例。该方法返回一个新的Vector2D实例，其x和y属性使用添加到在一起的两个Vector2D实例的x和y属性的总和初始化。 类型方法可以用作现有Vector2D实例之间的修复运算符： let vector &#x3D; Vector2D(x: 3.0, y: 1.0) let anotherVector &#x3D; Vector2D(x: 2.0, y: 4.0) let combinedVector &#x3D; vector + anotherVector &#x2F;&#x2F; combinedVector is a Vector2D instance with values of (5.0, 5.0) 此示例将矢量(3.0,1.0)和(2.0,4.0)组合在一起，使矢量(5.0,5.0)如下所示。 前缀和后缀运算符上面显示的示例演示了二进制修复运算符的自定义实现。类和结构还可以提供标准一元运算符的实现。单一运算符在单个目标上运行。如果它们在目标（如-a）之前，它们是前缀，如果他们遵循目标（如b!则为后缀运算符。 在声明运算符方法时，您可以通过在func关键字之前写入prefix或postfix修饰符来实现前缀或后缀一元运算符： extension Vector2D { ​ static prefix func - (vector: Vector2D) -&gt; Vector2D { ​ return Vector2D(x: -vector.x, y: -vector.y) ​ } } 上面的示例实现了Vector2D实例的一元减运算符（-a）。一元减算符是前缀运算符，因此这种方法必须用prefix修饰符限定。 对于简单的数值，一元减算符将正数转换为负等价数，反之亦然。Vector2D实例的相应实现对x和y属性执行此操作： let positive &#x3D; Vector2D(x: 3.0, y: 4.0) let negative &#x3D; -positive &#x2F;&#x2F; negative is a Vector2D instance with values of (-3.0, -4.0) let alsoPositive &#x3D; -negative &#x2F;&#x2F; alsoPositive is a Vector2D instance with values of (3.0, 4.0) 复合分配运算符复合赋值运算符将赋值（&#x3D;）与另一个运算相结合。例如，加法赋值运算符（+=将加法和赋值组合成一个运算。您可以将复合赋值运算符的左输入参数类型标记为inout，因为参数的值将直接从运算符方法中修改。 以下示例实现了Vector2D实例的加法赋值运算符方法： extension Vector2D { ​ static func +&#x3D; (left: inout Vector2D, right: Vector2D) { ​ left &#x3D; left + right ​ } } 由于添加运算符是早些时候定义的，因此您无需在这里重新实现添加过程。相反，加法赋值运算符方法利用了现有的加法运算符方法，并使左值设置为左值加右值： var original &#x3D; Vector2D(x: 1.0, y: 2.0) let vectorToAdd &#x3D; Vector2D(x: 3.0, y: 4.0) original +&#x3D; vectorToAdd &#x2F;&#x2F; original now has values of (4.0, 6.0) 注意 It isn’t possible to overload the default assignment operator (=). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (a ? b : c) can’t be overloaded. 等效运算符默认情况下，自定义类和结构没有等价运算符的实现，称为等于运算符（==，不等于运算符（!=）。您通常实现==运算符，并使用标准库的默认实现!=否定==运算符结果的运算符。有两种方法可以实现==运算符：您可以自己实现它，或者对于许多类型，您可以让Swift为您合成实现。在这两种情况下，您都会添加与标准库的Equatable协议的一致性。 您以与实现其他修复运算符相同的方式提供==运算符的实现： extension Vector2D: Equatable { ​ static func &#x3D;&#x3D; (left: Vector2D, right: Vector2D) -&gt; Bool { ​ return (left.x &#x3D;&#x3D; right.x) &amp;&amp; (left.y &#x3D;&#x3D; right.y) ​ } } 上面的示例实现了==运算符来检查两个Vector2D实例是否具有等效值。在Vector2D的上下文中，将“相等”视为“这两个实例具有相同的x值和y值”是有道理的，因此这是运算符实现使用的逻辑。 您现在可以使用此运算符检查两个Vector2D实例是否等效： let twoThree &#x3D; Vector2D(x: 2.0, y: 3.0) let anotherTwoThree &#x3D; Vector2D(x: 2.0, y: 3.0) if twoThree &#x3D;&#x3D; anotherTwoThree { ​ print(“These two vectors are equivalent.”) } &#x2F;&#x2F; Prints “These two vectors are equivalent.” 在许多简单的情况下，您可以要求Swift为您提供等效运算符的合成实现，如《采用使用合成实现的协议》中所述。 自定义操作员除了Swift提供的标准运算符外，您还可以声明和实现自己的自定义运算符。有关可用于定义自定义运算符的字符列表，请参阅运算符。 新运算符使用operator关键字在全局级别声明，并标有prefix、infix或postfix修饰符： prefix operator +++ 上面的示例定义了一个名为+++的新前缀运算符。此运算符在Swift中没有现有含义，因此在使用Vector2D实例的特定上下文中，它在下面被赋予了自己的自定义含义。在本例中，+++被视为一个新的“前缀加倍”运算符。它通过使用前面定义的加法赋值运算符将向量添加到自身，将Vector2D实例的x和y值翻倍。要实现+++运算符，请在Vector2D中添加一个名为+++的类型方法，如下所示： extension Vector2D { ​ static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D { ​ vector +&#x3D; vector ​ return vector ​ } } var toBeDoubled &#x3D; Vector2D(x: 1.0, y: 4.0) let afterDoubling &#x3D; +++toBeDoubled &#x2F;&#x2F; toBeDoubled now has values of (2.0, 8.0) &#x2F;&#x2F; afterDoubling also has values of (2.0, 8.0) 自定义Infix运算符的优先级每个自定义修复运算符都属于优先级组。优先级组指定运算符相对于其他内缀运算符的优先级，以及运算符的关联性。有关这些特征如何影响内缀运算符与其他内缀运算符的交互的说明，请参阅优先级和关联性。 没有显式放置在优先级组中的自定义内缀运算符将获得一个默认优先级组，其优先级直接高于三元条件运算符的优先级。 以下示例定义了一个名为+-的新自定义内缀运算符，该运算符属于优先级组 AdditionPrecedence： infix operator +-: AdditionPrecedence extension Vector2D { ​ static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D { ​ return Vector2D(x: left.x + right.x, y: left.y - right.y) ​ } } let firstVector &#x3D; Vector2D(x: 1.0, y: 2.0) let secondVector &#x3D; Vector2D(x: 3.0, y: 4.0) let plusMinusVector &#x3D; firstVector +- secondVector &#x2F;&#x2F; plusMinusVector is a Vector2D instance with values of (4.0, -2.0) 这个运算符将两个向量的x值加在一起，并从第一个向量中减去第二个向量的y值。因为它本质上是一个“加法”运算符，所以它被赋予了与+和-等加性内缀运算符相同的优先级组。有关Swift标准库提供的运算符的信息，包括运算符优先级组和关联性设置的完整列表，请参阅运算符声明。有关优先级组的更多信息，以及查看定义您自己的运算符和优先级组的语法，请参阅运算符声明。 注意 在定义前缀或后缀运算符时，您不会指定优先级。但是，如果您同时将前缀和后缀运算符应用于同一操作数，则首先应用后缀运算符。 结果建设者结果生成器是您定义的一种类型，它以自然、声明的方式添加用于创建嵌套数据（如列表或树）的语法。使用结果构建器的代码可以包括普通的Swift语法，例如if和for，以处理条件或重复的数据。 以下代码定义了使用星星和文本在单行上绘制的几种类型。 protocol Drawable { ​ func draw() -&gt; String } struct Line: Drawable { ​ var elements: [Drawable] ​ func draw() -&gt; String { ​ return elements.map { $0.draw() }.joined(separator: “”) ​ } } struct Text: Drawable { ​ var content: String ​ init(_ content: String) { self.content &#x3D; content } ​ func draw() -&gt; String { return content } } struct Space: Drawable { ​ func draw() -&gt; String { return “ “ } } struct Stars: Drawable { ​ var length: Int ​ func draw() -&gt; String { return String(repeating: “*”, count: length) } } struct AllCaps: Drawable { ​ var content: Drawable ​ func draw() -&gt; String { return content.draw().uppercased() } } Drawable协议定义了对可以绘制的东西的要求，例如线条或形状：类型必须实现draw()方法。Line结构代表单线绘图，它为大多数绘图的顶层容器服务。要绘制一条Line，结构在每行的组件上调用draw()，然后将生成的字符串连接成单个字符串。Text结构包裹字符串使其成为绘图的一部分。AllCaps结构包装和修改另一张绘图，将绘图中的任何文本转换为大写。 可以通过调用初始化器来使用这些类型绘制绘图： let name: String? &#x3D; “Ravi Patel” let manualDrawing &#x3D; Line(elements: [ ​ Stars(length: 3), ​ Text(“Hello”), ​ Space(), ​ AllCaps(content: Text((name ?? “World”) + “!”)), ​ Stars(length: 2), ​ ]) print(manualDrawing.draw()) &#x2F;&#x2F; Prints “*Hello RAVI PATEL!“ 这个代码有效，但有点尴尬。AllCaps之后的深嵌套括号很难阅读。当name为nil使用“世界”的后备逻辑必须使用??完成操作员，如果更复杂，那就很难了。如果您需要包含开关或循环来构建部分绘图，则无法做到这一点。结果生成器允许您像这样重写代码，使其看起来像普通的Swift代码。 要定义结果构建器，请在类型声明上写入@resultBuilder属性。例如，此代码定义了一个名为DrawingBuilder的结果构建器，它允许您使用声明语法来描述绘图： @resultBuilder struct DrawingBuilder { ​ static func buildBlock(_ components: Drawable…) -&gt; Drawable { ​ return Line(elements: components) ​ } ​ static func buildEither(first: Drawable) -&gt; Drawable { ​ return first ​ } ​ static func buildEither(second: Drawable) -&gt; Drawable { ​ return second ​ } } DrawingBuilder结构定义了实现结果构建器语法部分的三种方法。buildBlock(_:)方法增加了对在代码块中写入一系列行的支持。它将该块中的组件组合成一条Line。ThebuildEitherbuildEither(first:)和buildEither(second:)方法增加了对if-else的支持。 您可以将@DrawingBuilder属性应用于函数的参数，该参数将传递给函数的闭包转换为结果构建器从该闭包创建的值。例如： func draw(@DrawingBuilder content: () -&gt; Drawable) -&gt; Drawable { ​ return content() } func caps(@DrawingBuilder content: () -&gt; Drawable) -&gt; Drawable { ​ return AllCaps(content: content()) } func makeGreeting(for name: String? &#x3D; nil) -&gt; Drawable { ​ let greeting &#x3D; draw { ​ Stars(length: 3) ​ Text(“Hello”) ​ Space() ​ caps { ​ if let name &#x3D; name { ​ Text(name + “!”) ​ } else { ​ Text(“World!”) ​ } ​ } ​ Stars(length: 2) ​ } ​ return greeting } let genericGreeting &#x3D; makeGreeting() print(genericGreeting.draw()) &#x2F;&#x2F; Prints “*Hello WORLD!“ let personalGreeting &#x3D; makeGreeting(for: “Ravi Patel”) print(personalGreeting.draw()) &#x2F;&#x2F; Prints “*Hello RAVI PATEL!“ makeGreeting(for:)函数使用name参数，并用它来绘制个性化的问候语。draw(_:)和caps(_:)函数都以单个闭包作为参数，该闭包标有@DrawingBuilder属性。当您调用这些函数时，您使用DrawingBuilder定义的特殊语法。Swift将绘图的声明性描述转换为对DrawingBuilder上方法的一系列调用，以建立作为函数参数传递的值。例如，Swift将该示例中的对caps(_:)调用转换为以下代码： let capsDrawing &#x3D; caps { ​ let partialDrawing: Drawable ​ if let name &#x3D; name { ​ let text &#x3D; Text(name + “!”) ​ partialDrawing &#x3D; DrawingBuilder.buildEither(first: text) ​ } else { ​ let text &#x3D; Text(“World!”) ​ partialDrawing &#x3D; DrawingBuilder.buildEither(second: text) ​ } ​ return partialDrawing } Swift将if-else块转换为对buildEither(first:)和buildEither(second:)方法的调用。虽然您不会在自己的代码中调用这些方法，但当您使用DrawingBuilder语法时，显示转换结果可以更容易地查看Swift如何转换代码。 要在特殊绘图语法中添加for循环写入的支持，请添加buildArray(_:)方法。 extension DrawingBuilder { ​ static func buildArray(_ components: [Drawable]) -&gt; Drawable { ​ return Line(elements: components) ​ } } let manyStars &#x3D; draw { ​ Text(“Stars:”) ​ for length in 1…3 { ​ Space() ​ Stars(length: length) ​ } } 在上面的代码中，for循环创建一个绘图数组，buildArray(_:)方法将该数组转换为Line。 有关Swift如何将构建器语法转换为对构建器类型方法的调用的完整列表，请参阅结果构建器。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"RESTful 架构详解","slug":"软件开发/技术/软件技术框架/理论/RESTful架构详解","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/07/RESTful架构详解/","link":"","permalink":"https://guoshunfa.com/2022/07/RESTful%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"转载自：https://www.runoob.com/w3cnote/restful-architecture.html 1. 什么是REST REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。 REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。 2. 理解RESTful要理解RESTful架构，需要理解Representational State Transfer这个词组到底是什么意思，它的每一个词都有些什么涵义。 下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。 资源与URI 统一资源接口 资源的表述 资源的链接 状态的转移 2. 1 资源与URIREST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子： 某用户的手机号码 某用户的个人信息 最多用户订购的GPRS套餐 两个产品之间的依赖关系 某用户可以办理的优惠套餐 某手机号码的潜在价值 要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。 URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI： https://github.com/git https://github.com/git/git https://github.com/git/git/blob/master/block-sha1/sha1.h https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08 https://github.com/git/git/pulls https://github.com/git/git/pulls?state=closed https://github.com/git/git/compare/master…next 下面让我们来看看URI设计上的一些技巧: 使用_或-来让URI可读性更好 曾经Web上的URI都是冰冷的数字或者无意义的字符串，但现在越来越多的网站使用_或-来分隔一些单词，让URI看上去更为人性化。 例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格， 如http://www.oschina.net/news/38119/oschina-translate-reward-plan。 使用&#x2F;来表示资源的层级关系 例如上述&#x2F;git&#x2F;git&#x2F;commit&#x2F;e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源， 指的是git用户的git项目的某次提交记录，又例如&#x2F;orders&#x2F;2012&#x2F;10可以用来表示2012年10月的订单记录。 使用?用来过滤资源 很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如&#x2F;git&#x2F;git&#x2F;pulls用来表示git项目的所有推入请求，而&#x2F;pulls?state&#x3D;closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。 ,或;可以用来表示同级资源的关系 有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用&#x2F;git&#x2F;git &#x2F;block-sha1&#x2F;sha1.h&#x2F;compare&#x2F;e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如&#x2F;git&#x2F;git&#x2F;compare&#x2F;master…next。 2. 2 统一资源接口RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。 如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。 下面列出了GET，DELETE，PUT和POST的典型用法: GET 安全且幂等 获取表示 变更时获取表示（缓存） 200（OK） - 表示已在响应中发出 204（无内容） - 资源有空表示 301（Moved Permanently） - 资源的URI已被更新 303（See Other） - 其他（如，负载均衡） 304（not modified）- 资源未更改（缓存） 400 （bad request）- 指代坏请求（如，参数错误） 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 POST 不安全且不幂等 使用服务端管理的（自动产生）的实例号创建资源 创建子资源 部分更新资源 如果没有被修改，则不过更新资源（乐观锁） 200（OK）- 如果现有资源已被更改 201（created）- 如果新资源被创建 202（accepted）- 已接受处理请求但尚未完成（异步处理） 301（Moved Permanently）- 资源的URI被更新 303（See Other）- 其他（如，负载均衡） 400（bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 PUT 不安全但幂等 用客户端管理的实例号创建一个资源 通过替换的方式更新资源 如果未被修改，则更新资源（乐观锁） 200 （OK）- 如果已存在资源被更改 201 （created）- 如果新资源被创建 301（Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他（如，负载均衡） 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 DELETE 不安全但幂等 删除资源 200 （OK）- 资源已被删除 301 （Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他，如负载均衡 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 409 （conflict）- 通用冲突 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 下面我们来看一些实践中常见的问题: POST和PUT用于创建资源时有什么区别? POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名&#x2F;categories&#x2F;java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。 我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。 客户端不一定都支持这些HTTP方法吧? 的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法。 在实践上，客户端和服务端都可能需要做一些妥协。例如rails框架就支持通过隐藏参数_method&#x3D;DELETE来传递真实的请求方法， 而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。 统一接口是否意味着不能扩展带特殊语义的方法? 统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。 像WebDAV就对HTTP方法进行了扩展，增加了LOCK、UPLOCK等方法。而github的API则支持使用PATCH方法来进行issue的更新，例如: 1PATCH /repos/:owner/:repo/issues/:number 不过，需要注意的是，像PATCH这种不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题。 统一资源接口对URI有什么指导意义? 统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。 通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI: GET &#x2F;getUser&#x2F;1 POST &#x2F;createUser PUT &#x2F;updateUser&#x2F;1 DELETE &#x2F;deleteUser&#x2F;1 如果GET请求增加计数器，这是否违反安全性? 安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。 但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端”自作主张”的。 另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。 直接忽视缓存可取吗? 即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。 对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。 响应代码的处理有必要吗? HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。 例如，201（”Created”）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。 假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。 如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。 2. 3 资源的表述上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。 资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。 那么客户端如何知道服务端提供哪种表述形式呢? 答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。 以github为例，请求某组织资源的json格式的表述形式: 假如github也能够支持xml格式的表述格式，那么结果就是这样的: 下面我们来看一些实践上常见的设计: 在URI里边带上版本号有些API在URI里边带上版本号，例如: http://api.example.com/1.0/foo http://api.example.com/1.2/foo http://api.example.com/2.0/foo 如果我们把版本号理解成资源的不同表述形式的话，就应该只是用一个URL，并通过Accept头部来区分，还是以github为例，它的Accept的完整格式是:application&#x2F;vnd.github[.version].param[+json] 对于v3版本的话，就是Accept: application&#x2F;vnd.github.v3。对于上面的例子，同理可以使用使用下面的头部: Accept: vnd.example-com.foo+json; version&#x3D;1.0 Accept: vnd.example-com.foo+json; version&#x3D;1.2 Accept: vnd.example-com.foo+json; version&#x3D;2.0 使用URI后缀来区分表述格式像rails框架，就支持使用&#x2F;users.xml或&#x2F;users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用内容协商来区分表述格式。 如何处理不支持的表述格式当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。下面以github为例，展示了一个请求XML表述资源的结果： 2. 4 资源的链接我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。 这种反模式忽略了一个核心概念：”超媒体即应用状态引擎（hypermedia as the engine of application state）”。 超媒体是什么? 当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来. 要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。 下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。 又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。 上面的例子展示了如何使用超媒体来增强资源的连通性。很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于”资源的CRUD”。 2. 5 状态的转移有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。 不过，我们先来讨论一下REST原则中的无状态通信原则。初看一下，好像自相矛盾了，既然无状态，何来状态转移一说? 其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。 2. 5.1 应用状态与资源状态实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。 客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。 服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。 这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。 在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。 但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。 这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。 当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。 2. 5.2 应用状态的转移状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。 这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。 3. 总结现在广东XXX版本、XXX等项目中均使用传统的RPC、SOAP方式的Web服务，而移动南方基地XXXX项目的后台， 虽然采用了JSON格式进行交互，但还是属于RPC风格的。本文从资源的定义、获取、表述、关联、状态变迁等角度， 试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同，希望本文能对各位理解REST有所帮助。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://guoshunfa.com/tags/RESTful/"}]},{"title":"Electron框架 介绍","slug":"软件开发/技术/软件技术框架/各大框架/Electron/Electron框架-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/Electron框架-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Electron%E6%A1%86%E6%9E%B6-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Electron 官网 | Electron 中文网 1. 简介​ Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。 2. 快速入门本指南将会通过使用Electron创建一个极简的 Hello World 应用一步步的带你了解，该应用与electron/electron-quick-start类似。 通过这个教程，你的app将会打开一个浏览器窗口，来展示包含当前正在运行的 Chromium, Node.js与 Electronweb等版本信息的web界面 2.1. Prerequisites在使用Electron进行开发之前，您需要安装 Node.js。 我们建议您使用最新的LTS版本。 请使用为你平台预构建的 Node.js 安装器来进行安装， 否则，您可能会遇到与不同开发工具不兼容的问题。 要检查 Node.js 是否正确安装，请在您的终端输入以下命令： 12node -vnpm -v 这两个命令应输出了 Node.js 和 npm 的版本信息。 注意 因为 Electron 将 Node.js 嵌入到其二进制文件中，你应用运行时的 Node.js 版本与你系统中运行的 Node.js 版本无关。 2.2. 创建你的应用程序2.2.1. 使用脚手架创建Electron 应用程序遵循与其他 Node.js 项目相同的结构。 首先创建一个文件夹并初始化 npm 包。 npm Yarn 12mkdir my-electron-app &amp;&amp; cd my-electron-appyarn init init初始化命令会提示您在项目初始化配置中设置一些值 为本教程的目的，有几条规则需要遵循： entry point 应为 main.js. author 与 description 可为任意值，但对于应用打包是必填项。 你的 package.json 文件应该像这样： 12345678&#123; &quot;name&quot;: &quot;my-electron-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Hello World!&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;author&quot;: &quot;Jane Doe&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 然后，将 electron 包安装到应用的开发依赖中。 npm Yarn 1yarn add --dev electron 注意：如果您在安装 Electron 时遇到任何问题，请 参见 高级安装 指南。 最后，您希望能够执行 Electron 如下所示，在您的 package.json配置文件中的scripts字段下增加一条start命令： 12345&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; &#125;&#125; start命令能让您在开发模式下打开您的应用 npm Yarn 12yarn start# couldn&#x27;t auto-convert command 注意：此脚本将告诉 Electron 在您项目根目录运行 此时，您的应用将立即抛出一个错误提示您它无法找到要运行的应用 2.2.2. 运行主进程任何 Electron 应用程序的入口都是 main 文件。 这个文件控制了主进程，它运行在一个完整的Node.js环境中，负责控制您应用的生命周期，显示原生界面，执行特殊操作并管理渲染器进程(稍后详细介绍)。 执行期间，Electron 将依据应用中 package.json配置下main字段中配置的值查找此文件，您应该已在应用脚手架步骤中配置。 要初始化这个main文件，需要在您项目的根目录下创建一个名为main.js的空文件。 注意：如果您此时再次运行start命令，您的应用将不再抛出任何错误！ 然而，它不会做任何事因为我们还没有在main.js中添加任何代码。 2.2.3. 创建页面在可以为我们的应用创建窗口前，我们需要先创建加载进该窗口的内容。 在 Electron 中，每个窗口中无论是本地的HTML文件还是远程URL都可以被加载显示。 此教程中，您将采用本地HTML的方式。 在您的项目根目录下创建一个名为index.html的文件： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;&gt; &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;, Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;, and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;. &lt;/body&gt;&lt;/html&gt; 注意：在这个HTML文本中，您会发现主体文本中丢失了版本编号。 稍后我们将使用 JavaScript 动态插入它们。 2.2.4. 在窗口中打开您的页面现在您有了一个页面，将它加载进应用窗口中。 要做到这一点，你需要 两个Electron模块： app 模块，它控制应用程序的事件生命周期。 BrowserWindow 模块，它创建和管理应用程序 窗口。 因为主进程运行着Node.js，您可以在文件头部将他们导入作为公共JS模块： 1const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;) 然后，添加一个createWindow()方法来将index.html加载进一个新的BrowserWindow实例。 12345678function createWindow () &#123; const win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) win.loadFile(&#x27;index.html&#x27;)&#125; 接着，调用createWindow()函数来打开您的窗口。 在 Electron 中，只有在 app 模块的 ready 事件被激发后才能创建浏览器窗口。 您可以通过使用 app.whenReady() API来监听此事件。 在whenReady()成功后调用createWindow()。 123app.whenReady().then(() =&gt; &#123; createWindow()&#125;) 注意：此时，您的电子应用程序应当成功 打开显示您页面的窗口！ 2.2.5. 管理窗口的生命周期虽然你现在可以打开一个浏览器窗口，但你还需要一些额外的模板代码使其看起来更像是各平台原生的。 应用程序窗口在每个OS下有不同的行为，Electron将在app中实现这些约定的责任交给开发者们。 一般而言，你可以使用 进程 全局的 platform 属性来专门为某些操作系统运行代码。 2.2.5.1. 关闭所有窗口时退出应用 (Windows &amp; Linux)在Windows和Linux上，关闭所有窗口通常会完全退出一个应用程序。 To implement this, listen for the app module’s &#39;window-all-closed&#39; event, and call app.quit() if the user is not on macOS (darwin). 123app.on(&#x27;window-all-closed&#x27;, function () &#123; if (process.platform !== &#x27;darwin&#x27;) app.quit()&#125;) 2.2.5.2. 如果没有窗口打开则打开一个窗口 (macOS)当 Linux 和 Windows 应用在没有窗口打开时退出了，macOS 应用通常即使在没有打开任何窗口的情况下也继续运行，并且在没有窗口可用的情况下激活应用时会打开新的窗口。 为了实现这一特性，监听 app 模块的 activate 事件。如果没有任何浏览器窗口是打开的，则调用 createWindow() 方法。 因为窗口无法在 ready 事件前创建，你应当在你的应用初始化后仅监听 activate 事件。 通过在您现有的 whenReady() 回调中附上您的事件监听器来完成这个操作。 1234567app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, function () &#123; if (BrowserWindow.getAllWindows().length === 0) createWindow() &#125;)&#125;) 注意：此时，您的窗口控件应功能齐全！ 2.2.6. 通过预加载脚本从渲染器访问Node.js。现在，最后要做的是输出Electron的版本号和它的依赖项到你的web页面上。 在主进程通过Node的全局 process 对象访问这个信息是微不足道的。 然而，你不能直接在主进程中编辑DOM，因为它无法访问渲染器 文档 上下文。 它们存在于完全不同的进程！ 注意：如果您需要更深入地了解Electron进程，请参阅 进程模型 文档。 这是将 预加载 脚本连接到渲染器时派上用场的地方。 预加载脚本在渲染器进程加载之前加载，并有权访问两个 渲染器全局 (例如 window 和 document) 和 Node.js 环境。 创建一个名为 preload.js 的新脚本如下： 12345678910window.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; const replaceText = (selector, text) =&gt; &#123; const element = document.getElementById(selector) if (element) element.innerText = text &#125; for (const dependency of [&#x27;chrome&#x27;, &#x27;node&#x27;, &#x27;electron&#x27;]) &#123; replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency]) &#125;&#125;) 上面的代码访问 Node.js process.versions 对象，并运行一个基本的 replaceText 辅助函数将版本号插入到 HTML 文档中。 要将此脚本附加到渲染器流程，请在你现有的 BrowserWindow 构造器中将路径中的预加载脚本传入 webPreferences.preload 选项。 12345678910111213141516// 在文件头部引入 Node.js 中的 path 模块const path = require(&#x27;path&#x27;)// 修改现有的 createWindow() 函数function createWindow () &#123; const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) win.loadFile(&#x27;index.html&#x27;)&#125;// ... 这里使用了两个Node.js概念： __dirname 字符串指向当前正在执行脚本的路径 (在本例中，它指向你的项目的根文件夹)。 path.join API 将多个路径联结在一起，创建一个跨平台的路径字符串。 我们使用一个相对当前正在执行JavaScript文件的路径，这样您的相对路径将在开发模式和打包模式中都将有效。 2.2.7. 额外：将功能添加到您的网页内容此刻，您可能想知道如何为您的应用程序添加更多功能。 对于与您的网页内容的任何交互，您想要将脚本添加到您的渲染器进程中。 由于渲染器运行在正常的 Web 环境中，因此您可以在 index.html 文件关闭 &lt;/body&gt; 标签之前添加一个 &lt;script&gt; 标签，来包括您想要的任意脚本： 1&lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt; 复制 然后，renderer.js 中包含的代码可以使用与典型前端开发相同的 JavaScript API 和工具，例如使用 webpack 来捆绑和缩小您的代码或使用 React 来管理您的用户界面。 2.2.8. 回顾完成上述步骤后，您应该有一个功能齐全的Electron程序，如下所示： 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// main.js// 控制应用生命周期和创建原生浏览器窗口的模组const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;)function createWindow () &#123; // 创建浏览器窗口 const mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) // 加载 index.html mainWindow.loadFile(&#x27;index.html&#x27;) // 加载 url // mainWindow.loadURL(&#x27;https://pandacode.cn&#x27;) // 打开开发工具 // mainWindow.webContents.openDevTools()&#125;// 这段程序将会在 Electron 结束初始化// 和创建浏览器窗口的时候调用// 部分 API 在 ready 事件触发后才能使用。app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, function () &#123; // 通常在 macOS 上，当点击 dock 中的应用程序图标时，如果没有其他 // 打开的窗口，那么程序会重新创建一个窗口。 if (BrowserWindow.getAllWindows().length === 0) createWindow() &#125;)&#125;)// 除了 macOS 外，当所有窗口都被关闭的时候退出程序。 因此，通常对程序和它们在// 任务栏上的图标来说，应当保持活跃状态，直到用户使用 Cmd + Q 退出。app.on(&#x27;window-all-closed&#x27;, function () &#123; if (process.platform !== &#x27;darwin&#x27;) app.quit()&#125;)// 在这个文件中，你可以包含应用程序剩余的所有部分的代码，// 也可以拆分成几个文件，然后用 require 导入。 1234567891011121314// preload.js// 所有Node.js API都可以在预加载过程中使用。// 它拥有与Chrome扩展一样的沙盒。window.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; const replaceText = (selector, text) =&gt; &#123; const element = document.getElementById(selector) if (element) element.innerText = text &#125; for (const dependency of [&#x27;chrome&#x27;, &#x27;node&#x27;, &#x27;electron&#x27;]) &#123; replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency]) &#125;&#125;) 123456789101112131415161718192021&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP --&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;&gt; &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;, Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;, and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;. &lt;！-- 您也可以此进程中运行其他文件 --&gt; &lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结我们所做的所有步骤： 我们启动了一个Node.js程序，并将Electron添加为依赖。 我们创建了一个 main.js 脚本来运行我们的主要进程，它控制我们的应用程序 并且在 Node.js 环境中运行。 在此脚本中， 我们使用 Electron 的 app 和 BrowserWindow 模块来创建一个浏览器窗口，在一个单独的进程(渲染器)中显示网页内容。 为了访问渲染器中的Node.js的某些功能，我们在 BrowserWindow 的构造函数上附加了一个预加载脚本。 3. 安装指导安装淘宝镜像 1npm install cnpm -g --registry=http://registry.npm.taobao.org 使用cnpm安装electron 1cnpm install electron -g 使用cnpm安装electron-packager 1cnpm install electron-packager -g","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://guoshunfa.com/tags/Electron/"}]},{"title":"Electron框架 打包","slug":"软件开发/技术/软件技术框架/各大框架/Electron/Electron框架打包","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/Electron框架打包/","link":"","permalink":"https://guoshunfa.com/2022/07/Electron%E6%A1%86%E6%9E%B6%E6%89%93%E5%8C%85/","excerpt":"","text":"1. electron-packager 打包命令说明： 1electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt; &lt;optional options&gt; location of project：项目所在路径 name of project：打包的项目名字 platform：确定了你要构建哪个平台的应用（Windows、Mac 还是 Linux），可用值：darwin、linux、mas、win32。 architecture：决定了使用 x86 还是 x64 还是两个架构都用 （x64,ia32） electron version：electron 的版本 optional options：可选选项（ –overwrite覆盖原文件） | –out 输出目录 | –extra-resource 需要打包的外部资源 overwrite：已有打包文件则替换。 例： 1electron-packager ./ pandacode --platform=mas --arch=x64 --overwrite","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://guoshunfa.com/tags/Electron/"}]},{"title":"Maven框架 pom文件详解","slug":"软件开发/技术/软件技术框架/各大框架/Maven/Maven框架-pom文件详解","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.298Z","comments":true,"path":"2022/07/Maven框架-pom文件详解/","link":"","permalink":"https://guoshunfa.com/2022/07/Maven%E6%A1%86%E6%9E%B6-pom%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"maven仓库官网 1. 简单介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- pom模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 项目信息 --&gt; &lt;groupId&gt;com.panda&lt;/groupId&gt;&lt;!-- 包名 --&gt; &lt;artifactId&gt;pandacode&lt;/artifactId&gt;&lt;!-- 项目名 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!-- 版本 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;!-- 打包方式 （pom,war,jar） --&gt; &lt;name&gt;springboot&lt;/name&gt;&lt;!-- 项目的名称， Maven 产生的文档用 --&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;!-- 项目的描述, Maven 产生的文档用 --&gt; &lt;!-- 父级项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!-- 属性设置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;!-- 编译字符编码为utf-8 --&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;!-- 输出字符编码为UTF-8 --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;!-- jdK版本 --&gt; &lt;/properties&gt; &lt;!-- 依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jpa(持久层) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql(数据库) --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 统一版本控制 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 编译 --&gt; &lt;build&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;!-- maven插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2. 详细描述2.1. dependencyManagement节点 dependencyManagement 应用场景 ​ Maven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式,通常会在一个组织或者项目的最顶层的POM中看到dependencyManagement 元素，在pom.xml 中使用dependencyManagement 元素能让所有子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用在这个dependencyManagement 元素中指定的版本号。 ​ 在 pom 中指明 dependency management 元素的方式 maven 结合项目继承来管理依赖，这样做的好处就是：如果有多个子项目都引用依赖项的同一版本，确保应用的各个项目的依赖项和版本一致，才能保证测试的和发布的是相同的成果，因此，应在顶层的 pom 中定义共同的依赖关系。同时可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改；另外如果某个子项目需要另外的一个版本，只需要在dependencies中声明version即可。 dependencyManagement和dependencies的区别 dependencies，即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项。dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显式的声明需要用的依赖。如果在子项目中不写该依赖项，那么子项目中是不会从父项目继承该依赖项的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version 和 scope 都读取自父pom。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"},{"name":"pom.xml","slug":"pom-xml","permalink":"https://guoshunfa.com/tags/pom-xml/"}]},{"title":"Maven框架 Nexus私服配置","slug":"软件开发/技术/软件技术框架/各大框架/Maven/Maven框架Nexus私服配置","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.299Z","comments":true,"path":"2022/07/Maven框架Nexus私服配置/","link":"","permalink":"https://guoshunfa.com/2022/07/Maven%E6%A1%86%E6%9E%B6Nexus%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Nexus 安装请查看 进入 1. 上传项目到私服上去1.1. 配置setting.xmldemo: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.2.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.2.0 http://maven.apache.org/xsd/settings-1.2.0.xsd&quot;&gt; &lt;!-- 本地仓库的路径。默认值为$&#123;user.home&#125;/.m2/repository。 --&gt; &lt;localRepository&gt;/Library/work/java/apache-maven-3.6.3/resource&lt;/localRepository&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 maven会根据id对镜像排序，当前一个镜像不可用时，连接后一个镜像 --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;https://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 1.2. 配置项目pom.xml123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Releases&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Snapshot&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 1.3. 上传deploy maven项目即可。 参考资料 Maven私服Nexus的搭建和使用","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"},{"name":"Nexus","slug":"Nexus","permalink":"https://guoshunfa.com/tags/Nexus/"}]},{"title":"Maven框架 settings详解","slug":"软件开发/技术/软件技术框架/各大框架/Maven/Maven框架settings详解","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.299Z","comments":true,"path":"2022/07/Maven框架settings详解/","link":"","permalink":"https://guoshunfa.com/2022/07/Maven%E6%A1%86%E6%9E%B6settings%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1. 概述1.1. 作用用来设置Maven参数的配置文件，在Maven中提供了一个settings.xml文件来定义Maven的全局配置信息。我们通过这个文件来定义本地仓库、远程仓库和联网使用的代理信息等配置。 1.2. 文件位置一般存在于两个位置： 全局配置：Maven的安装目录的conf子目录下面（$&#123;M2_HOME&#125;/conf/settings.xml）用户目录的的.m2子目录下面（&#123;user.home&#125;/.m2/settings.xml）。当前用户的独享配置。 当我们使用一些工具时（IDEA），可以直接指定settings.xml文件的位置。 1.3. 配置文件优先级局部配置高于全局配置 配置优先级从高到低：pom.xml&gt; user settings &gt; global settings如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级低的。 1.4. Maven依赖搜索顺序当我们执行Maven命令时，maven开始按照以下顺序查找依赖库： 步骤 1：在本地仓库搜索，如果找不到，执行步骤 2，找到了则执行其他操作 步骤 2：在中央仓库搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中引用。 步骤 3：如果远程仓库没有被设置, 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4：在一个或多个远程仓库中搜索依赖的文件, 如果找到则下载到本地仓库已被将来引用, 否则将停止处理并抛出错误（无法找到依赖的文件）。 2. 元素详解2.1. 顶级元素2.1.1. LocalRepository12&lt;!-- 作用：该值表示构建系统本地仓库的路径。 默认值：$&#123;user.home&#125;/.m2/repository --&gt;&lt;localRepository&gt;$&#123;user.home&#125;/.m2/repository&lt;/localRepository&gt; 2.1.2. InteractiveMode12&lt;!-- 作用：表示maven是否需要和用户交互以获得输入。 默认值：true --&gt;&lt;interactiveMode&gt;true&lt;/interactiveMode&gt; 2.1.3. offline12&lt;!-- 作用：表示maven是否需要在离线模式下运行。 默认值：false 当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt;&lt;offline&gt;false&lt;/offline&gt; 2.1.4. pluginGroups12345678&lt;!-- 作用：当插件的组织id（groupId）没有显式提供时，供搜寻插件groupId的列表。 默认值：默认情况下，maven会自动把org.apache.maven.plugins和org.codehaus.mojo添加到pluginGroups下。--&gt;&lt;pluginGroups&gt; &lt;pluginGroup&gt;com.your1.plugins&lt;/pluginGroup&gt; &lt;pluginGroup&gt;com.your2.plugins&lt;/pluginGroup&gt;&lt;/pluginGroups&gt; 2.1.5. proxies1234567891011121314151617181920212223&lt;!-- 作用：用来配置不同的代理, 多代理 profiles 可以应对笔记本或移动设备的工作环境: 通过简单的设置 profile id 就可以很容易的更换整个代理配置 --&gt;&lt;!-- 可以配置多个 --&gt;&lt;proxies&gt; &lt;!-- 代理元素包含配置代理时需要的信息 --&gt; &lt;proxy&gt; &lt;!-- 代理的唯一定义符, 用来区分不同的代理元素 --&gt; &lt;id&gt;optional&lt;/id&gt; &lt;!-- 该代理是否是激活的那个。true则激活代理。当我们声明了一组代理, 而某个时候只需要激活一个代理的时候, 该元素就可以派上用处 --&gt; &lt;active&gt;true&lt;/active&gt; &lt;!-- 代理的协议 --&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;!-- 代理服务器认证的登录名 --&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;!-- 代理服务器认证登录密码 --&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;!-- 代理的主机名 --&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;!-- 代理的端口 --&gt; &lt;port&gt;80&lt;/port&gt; &lt;!-- 不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符, 使用逗号分隔也很常见 --&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; 2.1.6. servers123456789101112131415161718&lt;!-- 作用：进行远程服务器访问时所需的授权配置信息。通过系统唯一的 server id 进行唯一关联 注意：您应该指定用户名/密码或私钥/密码，因为这些配对是一起使用。 --&gt;&lt;servers&gt; &lt;server&gt; &lt;!-- 服务的唯一定义符, 用来区分不同的代理元素 --&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;!-- 鉴权用户名 --&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;!-- 鉴权密码 --&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;!-- 鉴权时的私钥位置 --&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;!-- 鉴权时的私钥密码 --&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt;&lt;/servers&gt; 2.1.7. mirrors12345678910111213141516171819202122232425&lt;!--作用：用于替代指定远程仓库的镜像服务器配置，例如当您无法连接上国外的仓库是, 可以指定连接到国内的镜像服务器，同时还可以缓解镜像仓库的压力 注意：pom.xml 和 setting.xml 中配置的仓库和镜像优先级关系（``mirror优先级高于repository`） repository（setting.xml） &lt; repository（pom.xml） &lt; mirror（setting.xml） mirror匹配顺序：多个mirror按照id字母顺序进行排列，与编写顺序无关 在第一个mirror找不到artifact，不会继续找下一个镜像 只有当mirror无法链接的时候，才会尝试找下一个镜像，类似容灾备份--&gt;&lt;mirrors&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;!--用来表示该mirror是关联的哪一个仓库，其值为其关联仓库的id。 --&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;!-- 镜像名称, 无特殊作用, 可视为简述 --&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;!-- 镜像地址 --&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; mirrorOf配置语法： *：匹配所有远程仓库。相当于一个拦截器，它会拦截远程仓库的相关请求，把请求里的远程仓库地址，重定向到mirror里配置的地址。 external:* ： 匹配除 localhost、使用 file:&#x2F;&#x2F; 协议外的所有远程仓库 repo1,repo2：匹配仓库 repo1 和 repo2 *,!repo1： 匹配所有远程仓库, repo1 除外 2.1.7. profiles作用：构建方法的配置清单, maven 将根据不同环境参数来使用这些构建配置。 注意：settings.xml 中的 profile元素是 pom.xml中 profile元素的裁剪版本。 settings.xml负责的是整体的构建过程, pom.xml负责单独的项目对象构建过程。 settings.xml 只包含了id, activation, repositories, pluginRepositories 和 properties 元素。 如果 settings中的 profile 被激活, 它的值会覆盖任何其它定义在 pom.xml中或 profile.xml中的相同 id 的 profile。 查看当前激活的 profile 1mvn help:active-profiles 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;profiles&gt; &lt;profile&gt; &lt;!-- 该配置的唯一标识符 --&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt; &lt;!--如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。--&gt; &lt;!--activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。--&gt; &lt;!--profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识 --&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。--&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;!-- 快照策略 --&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。--&gt; &lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!-- 如果这个profile被激活，那么属性$&#123;tomcatPath&#125;就可以被访问了 --&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 2.1.8. activeProfiles123456789&lt;!-- 作用：手动激活profiles的列表，按照profile被应用的顺序定义activeProfile 说明： 任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活 如果没有匹配的profile，则什么都不会发生。 如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。--&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 参考资料 Maven settings.xml 详解 Maven系列二setting.xml 配置详解","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"},{"name":"settings.xml","slug":"settings-xml","permalink":"https://guoshunfa.com/tags/settings-xml/"}]},{"title":"Maven框架 命令记录","slug":"软件开发/技术/软件技术框架/各大框架/Maven/Maven框架命令记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.299Z","comments":true,"path":"2022/07/Maven框架命令记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Maven%E6%A1%86%E6%9E%B6%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","excerpt":"","text":"命令 描述 mvn clean 对项目进行清理，删除target目录下编译的内容 mvn compile 编译项目源代码 mvn test 对项目进行运行测试 mvn package 打包文件并存放到项目的target目录下，打包好的文件通常都是编译后的class文件 mvn install 在本地仓库生成仓库的安装包，可供其他项目引用，同时打包后的文件放到项目的target目录下 mvn archetype:generate 使用命令创建maven项目，执行命令后会通过交互形式的描述进行构建项目。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"}]},{"title":"Maven框架 引入外部Jar","slug":"软件开发/技术/软件技术框架/各大框架/Maven/Maven框架引入外部Jar","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.299Z","comments":true,"path":"2022/07/Maven框架引入外部Jar/","link":"","permalink":"https://guoshunfa.com/2022/07/Maven%E6%A1%86%E6%9E%B6%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8Jar/","excerpt":"","text":"首先描述一下，如果项目引入外部Jar，但是没有在Maven中进行控制，会出现什么问题。 Maven 打包时，外部引入的Jar会检测不到，导致***不存在的错误。 step 1: pom.xml 逐个引入外部Jar包123456789101112131415&lt;!--引入外部jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.1&lt;/groupId&gt; &lt;artifactId&gt;out-jar-1&lt;/artifactId&gt; &lt;version&gt;1.45&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/resources/lib/bcprov-jdk16-1.45.jar&lt;/systemPath&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.2&lt;/groupId&gt; &lt;artifactId&gt;out-jar-2&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/resources/lib/commons-codec-1.6.jar&lt;/systemPath&gt;&lt;/dependency&gt; 其中 groupId 和 artifactId 可以随便填，注意 artifactId 不要重复了，version 版本号jar包是什么版本就是什么版本，否则可以随便填。 step 2: 如果是SpringBoot项目还要加如下配置12345678&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt;&lt;/plugin&gt; 参考文档 maven项目打包时外部引入jar包无法打到项目中的解决方案","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"},{"name":"Jar","slug":"Jar","permalink":"https://guoshunfa.com/tags/Jar/"}]},{"title":"MyBatis Java API","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis-Java-API","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.299Z","comments":true,"path":"2022/07/MyBatis-Java-API/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis-Java-API/","excerpt":"","text":"转载自：MyBatis 官网(Java API) 既然你已经知道如何配置 MyBatis 以及如何创建映射，是时候来尝点甜头了。MyBatis 的 Java API 就是这个甜头。稍后你将看到，和 JDBC 相比，MyBatis 大幅简化你的代码并力图保持其简洁、容易理解和维护。为了使得 SQL 映射更加优秀，MyBatis 3 引入了许多重要的改进。 目录结构在我们深入 Java API 之前，理解关于目录结构的最佳实践是很重要的。MyBatis 非常灵活，你可以随意安排你的文件。但和其它框架一样，目录结构有一种最佳实践。 让我们看一下典型的应用目录结构： 1234567891011121314151617181920212223242526/my_application /bin /devlib /lib &lt;-- MyBatis *.jar 文件在这里。 /src /org/myapp/ /action /data &lt;-- MyBatis 配置文件在这里，包括映射器类、XML 配置、XML 映射文件。 /mybatis-config.xml /BlogMapper.java /BlogMapper.xml /model /service /view /properties &lt;-- 在 XML 配置中出现的属性值在这里。 /test /org/myapp/ /action /data /model /service /view /properties /web /WEB-INF /web.xml 当然，这是推荐的目录结构，并非强制要求，但使用一个通用的目录结构将更有利于大家沟通。 本章接下来的示例将假定你遵循这种目录结构。 SqlSession使用 MyBatis 的主要 Java 接口就是 SqlSession。你可以通过这个接口来执行命令，获取映射器实例和管理事务。在介绍 SqlSession 接口之前，我们先来了解如何获取一个 SqlSession 实例。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象包含创建 SqlSession 实例的各种方法。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或 Java 配置代码来创建 SqlSessionFactory。 提示 当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）搭配使用时，SqlSession 将被依赖注入框架创建并注入，所以你不需要使用 SqlSessionFactoryBuilder 或者 SqlSessionFactory，可以直接阅读 SqlSession 这一节。请参考 Mybatis-Spring 或者 Mybatis-Guice 手册以了解更多信息。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder 有五个 build() 方法，每一种都允许你从不同的资源中创建一个 SqlSessionFactory 实例。 12345SqlSessionFactory build(InputStream inputStream)SqlSessionFactory build(InputStream inputStream, String environment)SqlSessionFactory build(InputStream inputStream, Properties properties)SqlSessionFactory build(InputStream inputStream, String env, Properties props)SqlSessionFactory build(Configuration config) 第一种方法是最常用的，它接受一个指向 XML 文件（也就是之前讨论的 mybatis-config.xml 文件）的 InputStream 实例。可选的参数是 environment 和 properties。environment 决定加载哪种环境，包括数据源和事务管理器。比如： 1234567891011121314&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; ... &lt;dataSource type=&quot;POOLED&quot;&gt; ... &lt;/environment&gt; &lt;environment id=&quot;production&quot;&gt; &lt;transactionManager type=&quot;MANAGED&quot;&gt; ... &lt;dataSource type=&quot;JNDI&quot;&gt; ... &lt;/environment&gt;&lt;/environments&gt; 如果你调用了带 environment 参数的 build 方法，那么 MyBatis 将使用该环境对应的配置。当然，如果你指定了一个无效的环境，会收到错误。如果你调用了不带 environment 参数的 build 方法，那么就会使用默认的环境配置（在上面的示例中，通过 default&#x3D;”development” 指定了默认环境）。 如果你调用了接受 properties 实例的方法，那么 MyBatis 就会加载这些属性，并在配置中提供使用。绝大多数场合下，可以用 ${propName} 形式引用这些配置值。 回想一下，在 mybatis-config.xml 中，可以引用属性值，也可以直接指定属性值。因此，理解属性的优先级是很重要的。在之前的文档中，我们已经介绍过了相关内容，但为了方便查阅，这里再重新介绍一下： 如果一个属性存在于下面的多个位置，那么 MyBatis 将按照以下顺序来加载它们： 首先，读取在 properties 元素体中指定的属性； 其次，读取在 properties 元素的类路径 resource 或 url 指定的属性，且会覆盖已经指定了的重复属性； 最后，读取作为方法参数传递的属性，且会覆盖已经从 properties 元素体和 resource 或 url 属性中加载了的重复属性。 因此，通过方法参数传递的属性的优先级最高，resource 或 url 指定的属性优先级中等，在 properties 元素体中指定的属性优先级最低。 总结一下，前四个方法很大程度上是相同的，但提供了不同的覆盖选项，允许你可选地指定 environment 和&#x2F;或 properties。以下给出一个从 mybatis-config.xml 文件创建 SqlSessionFactory 的示例： 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(inputStream); 注意，这里我们使用了 Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类正如其名，会帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。在略读该类的源代码或用 IDE 查看该类信息后，你会发现一整套相当实用的方法。这里给出一个简表： 1234567891011121314URL getResourceURL(String resource)URL getResourceURL(ClassLoader loader, String resource)InputStream getResourceAsStream(String resource)InputStream getResourceAsStream(ClassLoader loader, String resource)Properties getResourceAsProperties(String resource)Properties getResourceAsProperties(ClassLoader loader, String resource)Reader getResourceAsReader(String resource)Reader getResourceAsReader(ClassLoader loader, String resource)File getResourceAsFile(String resource)File getResourceAsFile(ClassLoader loader, String resource)InputStream getUrlAsStream(String urlString)Reader getUrlAsReader(String urlString)Properties getUrlAsProperties(String urlString)Class classForName(String className) 最后一个 build 方法接受一个 Configuration 实例。Configuration 类包含了对一个 SqlSessionFactory 实例你可能关心的所有内容。在检查配置时，Configuration 类很有用，它允许你查找和操纵 SQL 映射（但当应用开始接收请求时不推荐使用）。你之前学习过的所有配置开关都存在于 Configuration 类，只不过它们是以 Java API 形式暴露的。以下是一个简单的示例，演示如何手动配置 Configuration 实例，然后将它传递给 build() 方法来创建 SqlSessionFactory。 12345678910111213141516DataSource dataSource = BaseDataTest.createBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.setLazyLoadingEnabled(true);configuration.setEnhancementEnabled(true);configuration.getTypeAliasRegistry().registerAlias(Blog.class);configuration.getTypeAliasRegistry().registerAlias(Post.class);configuration.getTypeAliasRegistry().registerAlias(Author.class);configuration.addMapper(BoundBlogMapper.class);configuration.addMapper(BoundAuthorMapper.class);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(configuration); 现在你就获得一个可以用来创建 SqlSession 实例的 SqlSessionFactory 了。 SqlSessionFactorySqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点： 事务处理：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和&#x2F;或 JDBC 驱动来说，等同于关闭事务支持） 数据库连接：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？ 语句执行：你希望 MyBatis 复用 PreparedStatement 和&#x2F;或批量更新语句（包括插入语句和删除语句）吗？ 基于以上需求，有下列已重载的多个 openSession() 方法供使用。 123456789SqlSession openSession()SqlSession openSession(boolean autoCommit)SqlSession openSession(Connection connection)SqlSession openSession(TransactionIsolationLevel level)SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)SqlSession openSession(ExecutorType execType)SqlSession openSession(ExecutorType execType, boolean autoCommit)SqlSession openSession(ExecutorType execType, Connection connection)Configuration getConfiguration(); 默认的 openSession() 方法没有参数，它会创建具备如下特性的 SqlSession： 事务作用域将会开启（也就是不自动提交）。 将由当前环境配置的 DataSource 实例中获取 Connection 对象。 事务隔离级别将会使用驱动或数据源的默认设置。 预处理语句不会被复用，也不会批量处理更新。 相信你已经能从方法签名中知道这些方法的区别。向 autoCommit 可选参数传递 true 值即可开启自动提交功能。若要使用自己的 Connection 实例，传递一个 Connection 实例给 connection 参数即可。注意，我们没有提供同时设置 Connection 和 autoCommit 的方法，这是因为 MyBatis 会依据传入的 Connection 来决定是否启用 autoCommit。对于事务隔离级别，MyBatis 使用了一个 Java 枚举包装器来表示，称为 TransactionIsolationLevel，事务隔离级别支持 JDBC 的五个隔离级别（NONE、READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ 和 SERIALIZABLE），并且与预期的行为一致。 你可能对 ExecutorType 参数感到陌生。这个枚举类型定义了三个值: ExecutorType.SIMPLE：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。 ExecutorType.REUSE：该类型的执行器会复用预处理语句。 ExecutorType.BATCH：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。 提示 在 SqlSessionFactory 中还有一个方法我们没有提及，就是 getConfiguration()。这个方法会返回一个 Configuration 实例，你可以在运行时使用它来检查 MyBatis 的配置。 提示 如果你使用过 MyBatis 的旧版本，可能还记得 session、事务和批量操作是相互独立的。在新版本中则不是这样。上述三者都包含在 session 作用域内。你不必分别处理事务或批量操作就能得到想要的全部效果。 SqlSession正如之前所提到的，SqlSession 在 MyBatis 中是非常强大的一个类。它包含了所有执行语句、提交或回滚事务以及获取映射器实例的方法。 SqlSession 类的方法超过了 20 个，为了方便理解，我们将它们分成几种组别。 语句执行方法这些方法被用来执行定义在 SQL 映射 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。你可以通过名字快速了解它们的作用，每一方法都接受语句的 ID 以及参数对象，参数可以是原始类型（支持自动装箱或包装类）、JavaBean、POJO 或 Map。 1234567&lt;T&gt; T selectOne(String statement, Object parameter)&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter)&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey)int insert(String statement, Object parameter)int update(String statement, Object parameter)int delete(String statement, Object parameter) selectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象或 null 值。如果返回值多于一个，就会抛出异常。如果你不知道返回对象会有多少，请使用 selectList。如果需要查看某个对象是否存在，最好的办法是查询一个 count 值（0 或 1）。selectMap 稍微特殊一点，它会将返回对象的其中一个属性作为 key 值，将对象作为 value 值，从而将多个结果集转为 Map 类型值。由于并不是所有语句都需要参数，所以这些方法都具有一个不需要参数的重载形式。 游标（Cursor）与列表（List）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载。 12345try (Cursor&lt;MyEntity&gt; entities = session.selectCursor(statement, param)) &#123; for (MyEntity entity:entities) &#123; // 处理单个实体 &#125;&#125; insert、update 以及 delete 方法返回的值表示受该语句影响的行数。 1234567&lt;T&gt; T selectOne(String statement)&lt;E&gt; List&lt;E&gt; selectList(String statement)&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, String mapKey)int insert(String statement)int update(String statement)int delete(String statement) 最后，还有 select 方法的三个高级版本，它们允许你限制返回行数的范围，或是提供自定义结果处理逻辑，通常在数据集非常庞大的情形下使用。 12345&lt;E&gt; List&lt;E&gt; selectList (String statement, Object parameter, RowBounds rowBounds)&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter, RowBounds rowBounds)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)void select (String statement, Object parameter, ResultHandler&lt;T&gt; handler)void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler) RowBounds 参数会告诉 MyBatis 略过指定数量的记录，并限制返回结果的数量。RowBounds 类的 offset 和 limit 值只有在构造函数时才能传入，其它时候是不能修改的。 123int offset = 100;int limit = 25;RowBounds rowBounds = new RowBounds(offset, limit); 数据库驱动决定了略过记录时的查询效率。为了获得最佳的性能，建议将 ResultSet 类型设置为 SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE（换句话说：不要使用 FORWARD_ONLY）。 ResultHandler 参数允许自定义每行结果的处理过程。你可以将它添加到 List 中、创建 Map 和 Set，甚至丢弃每个返回值，只保留计算后的统计结果。你可以使用 ResultHandler 做很多事，这其实就是 MyBatis 构建 结果列表的内部实现办法。 从版本 3.4.6 开始，ResultHandler 会在存储过程的 REFCURSOR 输出参数中传递使用的 CALLABLE 语句。 它的接口很简单： 1234package org.apache.ibatis.session;public interface ResultHandler&lt;T&gt; &#123; void handleResult(ResultContext&lt;? extends T&gt; context);&#125; ResultContext 参数允许你访问结果对象和当前已被创建的对象数目，另外还提供了一个返回值为 Boolean 的 stop 方法，你可以使用此 stop 方法来停止 MyBatis 加载更多的结果。 使用 ResultHandler 的时候需要注意以下两个限制： 使用带 ResultHandler 参数的方法时，收到的数据不会被缓存。 当使用高级的结果映射集（resultMap）时，MyBatis 很可能需要数行结果来构造一个对象。如果你使用了 ResultHandler，你可能会接收到关联（association）或者集合（collection）中尚未被完整填充的对象。 立即批量更新方法当你将 ExecutorType 设置为 ExecutorType.BATCH 时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。 1List&lt;BatchResult&gt; flushStatements() 事务控制方法有四个方法用来控制事务作用域。当然，如果你已经设置了自动提交或你使用了外部事务管理器，这些方法就没什么作用了。然而，如果你正在使用由 Connection 实例控制的 JDBC 事务管理器，那么这四个方法就会派上用场： 1234void commit()void commit(boolean force)void rollback()void rollback(boolean force) 默认情况下 MyBatis 不会自动提交事务，除非它侦测到调用了插入、更新或删除方法改变了数据库。如果你没有使用这些方法提交修改，那么你可以在 commit 和 rollback 方法参数中传入 true 值，来保证事务被正常提交（注意，在自动提交模式或者使用了外部事务管理器的情况下，设置 force 值对 session 无效）。大部分情况下你无需调用 rollback()，因为 MyBatis 会在你没有调用 commit 时替你完成回滚操作。不过，当你要在一个可能多次提交或回滚的 session 中详细控制事务，回滚操作就派上用场了。 提示 MyBatis-Spring 和 MyBatis-Guice 提供了声明式事务处理，所以如果你在使用 Mybatis 的同时使用了 Spring 或者 Guice，请参考它们的手册以获取更多的内容。 本地缓存Mybatis 使用到了两种缓存：本地缓存（local cache）和二级缓存（second level cache）。 每当一个新 session 被创建，MyBatis 就会创建一个与之相关联的本地缓存。任何在 session 执行过的查询结果都会被保存在本地缓存中，所以，当再次执行参数相同的相同查询时，就不需要实际查询数据库了。本地缓存将会在做出修改、事务提交或回滚，以及关闭 session 时清空。 默认情况下，本地缓存数据的生命周期等同于整个 session 的周期。由于缓存会被用来解决循环引用问题和加快重复嵌套查询的速度，所以无法将其完全禁用。但是你可以通过设置 localCacheScope&#x3D;STATEMENT 来只在语句执行时使用缓存。 注意，如果 localCacheScope 被设置为 SESSION，对于某个对象，MyBatis 将返回在本地缓存中唯一对象的引用。对返回的对象（例如 list）做出的任何修改将会影响本地缓存的内容，进而将会影响到在本次 session 中从缓存返回的值。因此，不要对 MyBatis 所返回的对象作出更改，以防后患。 你可以随时调用以下方法来清空本地缓存： 1void clearCache() 确保 SqlSession 被关闭1void close() 对于你打开的任何 session，你都要保证它们被妥善关闭，这很重要。保证妥善关闭的最佳代码模式是这样的： 12345678SqlSession session = sqlSessionFactory.openSession();try (SqlSession session = sqlSessionFactory.openSession()) &#123; // 假设下面三行代码是你的业务逻辑 session.insert(...); session.update(...); session.delete(...); session.commit();&#125; 提示 和 SqlSessionFactory 一样，你可以调用当前使用的 SqlSession 的 getConfiguration 方法来获得 Configuration 实例。 1Configuration getConfiguration() 使用映射器1&lt;T&gt; T getMapper(Class&lt;T&gt; type) 上述的各个 insert、update、delete 和 select 方法都很强大，但也有些繁琐，它们并不符合类型安全，对你的 IDE 和单元测试也不是那么友好。因此，使用映射器类来执行映射语句是更常见的做法。 我们已经在之前的入门章节中见到过一个使用映射器的示例。一个映射器类就是一个仅需声明与 SqlSession 方法相匹配方法的接口。下面的示例展示了一些方法签名以及它们是如何映射到 SqlSession 上的。 123456789101112131415public interface AuthorMapper &#123; // (Author) selectOne(&quot;selectAuthor&quot;,5); Author selectAuthor(int id); // (List&lt;Author&gt;) selectList(“selectAuthors”) List&lt;Author&gt; selectAuthors(); // (Map&lt;Integer,Author&gt;) selectMap(&quot;selectAuthors&quot;, &quot;id&quot;) @MapKey(&quot;id&quot;) Map&lt;Integer, Author&gt; selectAuthors(); // insert(&quot;insertAuthor&quot;, author) int insertAuthor(Author author); // updateAuthor(&quot;updateAuthor&quot;, author) int updateAuthor(Author author); // delete(&quot;deleteAuthor&quot;,5) int deleteAuthor(int id);&#125; 总之，每个映射器方法签名应该匹配相关联的 SqlSession 方法，字符串参数 ID 无需匹配。而是由方法名匹配映射语句的 ID。 此外，返回类型必须匹配期望的结果类型，返回单个值时，返回类型应该是返回值的类，返回多个值时，则为数组或集合类，另外也可以是游标（Cursor）。所有常用的类型都是支持的，包括：原始类型、Map、POJO 和 JavaBean。 提示 映射器接口不需要去实现任何接口或继承自任何类。只要方法签名可以被用来唯一识别对应的映射语句就可以了。 提示 映射器接口可以继承自其他接口。在使用 XML 来绑定映射器接口时，保证语句处于合适的命名空间中即可。唯一的限制是，不能在两个具有继承关系的接口中拥有相同的方法签名（这是潜在的危险做法，不可取）。 你可以传递多个参数给一个映射器方法。在多个参数的情况下，默认它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等。如果你想（在有多个参数时）自定义参数的名称，那么你可以在参数上使用 @Param(“paramName”) 注解。 你也可以给方法传递一个 RowBounds 实例来限制查询结果。 映射器注解设计初期的 MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，映射语句也是定义在 XML 中的。而在 MyBatis 3 中，我们提供了其它的配置方式。MyBatis 3 构建在全面且强大的基于 Java 语言的配置 API 之上。它是 XML 和注解配置的基础。注解提供了一种简单且低成本的方式来实现简单的映射语句。 提示 不幸的是，Java 注解的表达能力和灵活性十分有限。尽管我们花了很多时间在调查、设计和试验上，但最强大的 MyBatis 映射并不能用注解来构建——我们真没开玩笑。而 C# 属性就没有这些限制，因此 MyBatis.NET 的配置会比 XML 有更大的选择余地。虽说如此，基于 Java 注解的配置还是有它的好处的。 注解如下表所示： 注解 使用对象 XML 等价形式 描述 @CacheNamespace 类 &lt;cache&gt; 为给定的命名空间（比如类）配置缓存。属性：implemetation、eviction、flushInterval、size、readWrite、blocking、properties。 @Property N&#x2F;A &lt;property&gt; 指定参数值或占位符（placeholder）（该占位符能被 mybatis-config.xml 内的配置属性替换）。属性：name、value。（仅在 MyBatis 3.4.2 以上可用） @CacheNamespaceRef 类 &lt;cacheRef&gt; 引用另外一个命名空间的缓存以供使用。注意，即使共享相同的全限定类名，在 XML 映射文件中声明的缓存仍被识别为一个独立的命名空间。属性：value、name。如果你使用了这个注解，你应设置 value 或者 name 属性的其中一个。value 属性用于指定能够表示该命名空间的 Java 类型（命名空间名就是该 Java 类型的全限定类名），name 属性（这个属性仅在 MyBatis 3.4.2 以上可用）则直接指定了命名空间的名字。 @ConstructorArgs 方法 &lt;constructor&gt; 收集一组结果以传递给一个结果对象的构造方法。属性：value，它是一个 Arg 数组。 @Arg N&#x2F;A &lt;arg&gt;``&lt;idArg&gt; ConstructorArgs 集合的一部分，代表一个构造方法参数。属性：id、column、javaType、jdbcType、typeHandler、select、resultMap。id 属性和 XML 元素 &lt;idArg&gt; 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。从版本 3.5.4 开始，该注解变为可重复注解。 @TypeDiscriminator 方法 &lt;discriminator&gt; 决定使用何种结果映射的一组取值（case）。属性：column、javaType、jdbcType、typeHandler、cases。cases 属性是一个 Case 的数组。 @Case N&#x2F;A &lt;case&gt; 表示某个值的一个取值以及该取值对应的映射。属性：value、type、results。results 属性是一个 Results 的数组，因此这个注解实际上和 ResultMap 很相似，由下面的 Results 注解指定。 @Results 方法 &lt;resultMap&gt; 一组结果映射，指定了对某个特定结果列，映射到某个属性或字段的方式。属性：value、id。value 属性是一个 Result 注解的数组。而 id 属性则是结果映射的名称。从版本 3.5.4 开始，该注解变为可重复注解。 @Result N&#x2F;A &lt;result&gt;``&lt;id&gt; 在列和属性或字段之间的单个结果映射。属性：id、column、javaType、jdbcType、typeHandler、one、many。id 属性和 XML 元素 &lt;id&gt; 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。one 属性是一个关联，和 &lt;association&gt; 类似，而 many 属性则是集合关联，和 &lt;collection&gt; 类似。这样命名是为了避免产生名称冲突。 @One N&#x2F;A &lt;association&gt; 复杂类型的单个属性映射。属性： select，指定可加载合适类型实例的映射语句（也就是映射器方法）全限定名； fetchType，指定在该映射中覆盖全局配置参数 lazyLoadingEnabled； resultMap（3.5.5以上可用）, 结果集的完全限定名，该结果映射到查询结果中的集合对象； columnPrefix（3.5.5以上可用），在嵌套的结果集中对所查询的列进行分组的列前缀。 提示 注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。 @Many N&#x2F;A &lt;collection&gt; 复杂类型的集合属性映射。属性： select，指定可加载合适类型实例集合的映射语句（也就是映射器方法）全限定名； fetchType，指定在该映射中覆盖全局配置参数 lazyLoadingEnabled ； resultMap（3.5.5以上可用），结果集的完全限定名，该结果映射到查询结果中的集合对象； columnPrefix（3.5.5以上可用），在嵌套的结果集中对所查询的列进行分组的列前缀。 提示 注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。 @MapKey 方法 供返回值为 Map 的方法使用的注解。它使用对象的某个属性作为 key，将对象 List 转化为 Map。属性：value，指定作为 Map 的 key 值的对象属性名。 @Options 方法 映射语句的属性 该注解允许你指定大部分开关和配置选项，它们通常在映射语句上作为属性出现。与在注解上提供大量的属性相比，Options 注解提供了一致、清晰的方式来指定选项。属性：useCache=true、flushCache=FlushCachePolicy.DEFAULT、resultSetType=DEFAULT、statementType=PREPARED、fetchSize=-1、timeout=-1、useGeneratedKeys=false、keyProperty=&quot;&quot;、keyColumn=&quot;&quot;、resultSets=&quot;&quot;, databaseId=&quot;&quot;。注意，Java 注解无法指定 null 值。因此，一旦你使用了 Options 注解，你的语句就会被上述属性的默认值所影响。要注意避免默认值带来的非预期行为。 databaseId（3.5.5以上可用）, 如果有一个配置好的 DatabaseIdProvider, MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。如果同时存在带 databaseId 和不带 databaseId 属性的相同语句，则后者会被舍弃。 注意：keyColumn 属性只在某些数据库中有效（如 Oracle、PostgreSQL 等）。要了解更多关于 keyColumn 和 keyProperty 可选值信息，请查看“insert, update 和 delete”一节。 @Insert``@Update``@Delete``@Select 方法 &lt;insert&gt;``&lt;update&gt;``&lt;delete&gt;``&lt;select&gt; 每个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串数组会被连接成单个完整的字符串，每个字符串之间加入一个空格。这有效地避免了用 Java 代码构建 SQL 语句时产生的“丢失空格”问题。当然，你也可以提前手动连接好字符串。属性：value，指定用来组成单个 SQL 语句的字符串数组。 databaseId（3.5.5以上可用）, 如果有一个配置好的 DatabaseIdProvider, MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。如果同时存在带 databaseId 和不带 databaseId 属性的相同语句，则后者会被舍弃。 @InsertProvider``@UpdateProvider``@DeleteProvider``@SelectProvider 方法 &lt;insert&gt;``&lt;update&gt;``&lt;delete&gt;``&lt;select&gt; 允许构建动态 SQL。这些备选的 SQL 注解允许你指定返回 SQL 语句的类和方法，以供运行时执行。（从 MyBatis 3.4.6 开始，可以使用 CharSequence 代替 String 来作为返回类型）。当执行映射语句时，MyBatis 会实例化注解指定的类，并调用注解指定的方法。你可以通过 ProviderContext 传递映射方法接收到的参数、”Mapper interface type” 和 “Mapper method”（仅在 MyBatis 3.4.5 以上支持）作为参数。（MyBatis 3.4 以上支持传入多个参数） 属性：value、type、method、databaseId。 value and type 属性用于指定类名 (type 属性是 value 的别名, 你必须指定任意一个。 但是你如果在全局配置中指定 defaultSqlProviderType ，两个属性都可以忽略)。 method 用于指定该类的方法名（从版本 3.5.1 开始，可以省略 method 属性，MyBatis 将会使用 ProviderMethodResolver 接口解析方法的具体实现。如果解析失败，MyBatis 将会使用名为 provideSql 的降级实现）。提示 接下来的“SQL 语句构建器”一章将会讨论该话题，以帮助你以更清晰、更便于阅读的方式构建动态 SQL。 databaseId（3.5.5以上可用）, 如果有一个配置好的 DatabaseIdProvider, MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。如果同时存在带 databaseId 和不带 databaseId 属性的相同语句，则后者会被舍弃。 @Param 参数 N&#x2F;A 如果你的映射方法接受多个参数，就可以使用这个注解自定义每个参数的名字。否则在默认情况下，除 RowBounds 以外的参数会以 “param” 加参数位置被命名。例如 #&#123;param1&#125;, #&#123;param2&#125;。如果使用了 @Param(&quot;person&quot;)，参数就会被命名为 #&#123;person&#125;。 @SelectKey 方法 &lt;selectKey&gt; 这个注解的功能与 &lt;selectKey&gt; 标签完全一致。该注解只能在 @Insert 或 @InsertProvider 或 @Update 或 @UpdateProvider 标注的方法上使用，否则将会被忽略。如果标注了 @SelectKey 注解，MyBatis 将会忽略掉由 @Options 注解所设置的生成主键或设置（configuration）属性。属性：statement 以字符串数组形式指定将会被执行的 SQL 语句，keyProperty 指定作为参数传入的对象对应属性的名称，该属性将会更新成新的值，before 可以指定为 true 或 false 以指明 SQL 语句应被在插入语句的之前还是之后执行。resultType 则指定 keyProperty 的 Java 类型。statementType 则用于选择语句类型，可以选择 STATEMENT、PREPARED 或 CALLABLE 之一，它们分别对应于 Statement、PreparedStatement 和 CallableStatement。默认值是 PREPARED。 databaseId（3.5.5以上可用）, 如果有一个配置好的 DatabaseIdProvider, MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。如果同时存在带 databaseId 和不带 databaseId 属性的相同语句，则后者会被舍弃。 @ResultMap 方法 N&#x2F;A 这个注解为 @Select 或者 @SelectProvider 注解指定 XML 映射中 &lt;resultMap&gt; 元素的 id。这使得注解的 select 可以复用已在 XML 中定义的 ResultMap。如果标注的 select 注解中存在 @Results 或者 @ConstructorArgs 注解，这两个注解将被此注解覆盖。 @ResultType 方法 N&#x2F;A 在使用了结果处理器的情况下，需要使用此注解。由于此时的返回类型为 void，所以 Mybatis 需要有一种方法来判断每一行返回的对象类型。如果在 XML 有对应的结果映射，请使用 @ResultMap 注解。如果结果类型在 XML 的 &lt;select&gt; 元素中指定了，就不需要使用其它注解了。否则就需要使用此注解。比如，如果一个标注了 @Select 的方法想要使用结果处理器，那么它的返回类型必须是 void，并且必须使用这个注解（或者 @ResultMap）。这个注解仅在方法返回类型是 void 的情况下生效。 @Flush 方法 N&#x2F;A 如果使用了这个注解，定义在 Mapper 接口中的方法就能够调用 SqlSession#flushStatements() 方法。（Mybatis 3.3 以上可用） 映射注解示例这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值： 123@Insert(&quot;insert into table3 (id, name) values(#&#123;nameId&#125;, #&#123;name&#125;)&quot;)@SelectKey(statement=&quot;call next value for TestSequence&quot;, keyProperty=&quot;nameId&quot;, before=true, resultType=int.class)int insertTable3(Name name); 这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库自增列的值： 123@Insert(&quot;insert into table2 (name) values(#&#123;name&#125;)&quot;)@SelectKey(statement=&quot;call identity()&quot;, keyProperty=&quot;nameId&quot;, before=false, resultType=int.class)int insertTable2(Name name); 这个例子展示了如何使用 @Flush 注解来调用 SqlSession#flushStatements()： 12@FlushList&lt;BatchResult&gt; flush(); 这些例子展示了如何通过指定 @Result 的 id 属性来命名结果集： 123456789101112131415@Results(id = &quot;userResult&quot;, value = &#123; @Result(property = &quot;id&quot;, column = &quot;uid&quot;, id = true), @Result(property = &quot;firstName&quot;, column = &quot;first_name&quot;), @Result(property = &quot;lastName&quot;, column = &quot;last_name&quot;)&#125;)@Select(&quot;select * from users where id = #&#123;id&#125;&quot;)User getUserById(Integer id);@Results(id = &quot;companyResults&quot;)@ConstructorArgs(&#123; @Arg(column = &quot;cid&quot;, javaType = Integer.class, id = true), @Arg(column = &quot;name&quot;, javaType = String.class)&#125;)@Select(&quot;select * from company where id = #&#123;id&#125;&quot;)Company getCompanyById(Integer id); 这个例子展示了如何使用单个参数的 @SqlProvider 注解： 123456789101112131415@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)List&lt;User&gt; getUsersByName(String name);class UserSqlBuilder &#123; public static String buildGetUsersByName(final String name) &#123; return new SQL()&#123;&#123; SELECT(&quot;*&quot;); FROM(&quot;users&quot;); if (name != null) &#123; WHERE(&quot;name like #&#123;value&#125; || &#x27;%&#x27;&quot;); &#125; ORDER_BY(&quot;id&quot;); &#125;&#125;.toString(); &#125;&#125; 这个例子展示了如何使用多个参数的 @SqlProvider 注解： 123456789101112131415161718192021222324252627@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)List&lt;User&gt; getUsersByName( @Param(&quot;name&quot;) String name, @Param(&quot;orderByColumn&quot;) String orderByColumn);class UserSqlBuilder &#123; // 如果不使用 @Param，就应该定义与 mapper 方法相同的参数 public static String buildGetUsersByName( final String name, final String orderByColumn) &#123; return new SQL()&#123;&#123; SELECT(&quot;*&quot;); FROM(&quot;users&quot;); WHERE(&quot;name like #&#123;name&#125; || &#x27;%&#x27;&quot;); ORDER_BY(orderByColumn); &#125;&#125;.toString(); &#125; // 如果使用 @Param，就可以只定义需要使用的参数 public static String buildGetUsersByName(@Param(&quot;orderByColumn&quot;) final String orderByColumn) &#123; return new SQL()&#123;&#123; SELECT(&quot;*&quot;); FROM(&quot;users&quot;); WHERE(&quot;name like #&#123;name&#125; || &#x27;%&#x27;&quot;); ORDER_BY(orderByColumn); &#125;&#125;.toString(); &#125;&#125; 这是一个在全局配置下让所有映射方法在同一个 sql provider 类里面的例子（3.5.6 后可用）: 12345678910111213141516171819Configuration configuration = new Configuration();configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); // 让所有映射方法在同一个 sql provider 类里面// ...// 在 sql provider 注解上可以省略 type/value 属性// 如果省略，MyBatis 将使用 defaultSqlProviderType 所指定的类public interface UserMapper &#123; @SelectProvider // 等价于 @SelectProvider(TemplateFilePathProvider.class) User findUser(int id); @InsertProvider // 等价于 @InsertProvider(TemplateFilePathProvider.class) void createUser(User user); @UpdateProvider // 等价于 @UpdateProvider(TemplateFilePathProvider.class) void updateUser(User user); @DeleteProvider // 等价于 @DeleteProvider(TemplateFilePathProvider.class) void deleteUser(int id);&#125; 以下例子展示了 ProviderMethodResolver（3.5.1 后可用）的默认实现使用方法： 1234567891011121314151617@SelectProvider(UserSqlProvider.class)List&lt;User&gt; getUsersByName(String name);// 在你的 provider 类中实现 ProviderMethodResolver 接口class UserSqlProvider implements ProviderMethodResolver &#123; // 默认实现中，会将映射器方法的调用解析到实现的同名方法上 public static String getUsersByName(final String name) &#123; return new SQL()&#123;&#123; SELECT(&quot;*&quot;); FROM(&quot;users&quot;); if (name != null) &#123; WHERE(&quot;name like #&#123;value&#125; || &#x27;%&#x27;&quot;); &#125; ORDER_BY(&quot;id&quot;); &#125;&#125;.toString(); &#125;&#125; 这个例子展现了如何在声明注解时使用 databaseId 属性（3.5.5后可用）： 1234@Select(value = &quot;SELECT SYS_GUID() FROM dual&quot;, databaseId = &quot;oracle&quot;) // 如果 DatabaseIdProvider 提供的是 &quot;oracle&quot;，使用这条语句@Select(value = &quot;SELECT uuid_generate_v4()&quot;, databaseId = &quot;postgres&quot;) // 如果 DatabaseIdProvider 提供的是 &quot;postgres&quot;，使用这条语句@Select(&quot;SELECT RANDOM_UUID()&quot;) // 如果 DatabaseIdProvider 没有配置或者没有对应的 databaseId, 使用这条语句String generateId();","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"}]},{"title":"MyBatis SQL语句构建器","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis-SQL语句构建器","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.299Z","comments":true,"path":"2022/07/MyBatis-SQL语句构建器/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis-SQL%E8%AF%AD%E5%8F%A5%E6%9E%84%E5%BB%BA%E5%99%A8/","excerpt":"","text":"转载自：MyBatis 官网(SQL语句构建器) 问题Java 程序员面对的最痛苦的事情之一就是在 Java 代码中嵌入 SQL 语句。这通常是因为需要动态生成 SQL 语句，不然我们可以将它们放到外部文件或者存储过程中。如你所见，MyBatis 在 XML 映射中具备强大的 SQL 动态生成能力。但有时，我们还是需要在 Java 代码里构建 SQL 语句。此时，MyBatis 有另外一个特性可以帮到你，让你从处理典型问题中解放出来，比如加号、引号、换行、格式化问题、嵌入条件的逗号管理及 AND 连接。确实，在 Java 代码中动态生成 SQL 代码真的就是一场噩梦。例如： 1234567891011String sql = &quot;SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, &quot;&quot;P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON &quot; +&quot;FROM PERSON P, ACCOUNT A &quot; +&quot;INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID &quot; +&quot;INNER JOIN COMPANY C on D.COMPANY_ID = C.ID &quot; +&quot;WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) &quot; +&quot;OR (P.LAST_NAME like ?) &quot; +&quot;GROUP BY P.ID &quot; +&quot;HAVING (P.LAST_NAME like ?) &quot; +&quot;OR (P.FIRST_NAME like ?) &quot; +&quot;ORDER BY P.ID, P.FULL_NAME&quot;; 解决方案MyBatis 3 提供了方便的工具类来帮助解决此问题。借助 SQL 类，我们只需要简单地创建一个实例，并调用它的方法即可生成 SQL 语句。让我们来用 SQL 类重写上面的例子： 1234567891011121314151617181920private String selectPersonSql() &#123; return new SQL() &#123;&#123; SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;); SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;); FROM(&quot;PERSON P&quot;); FROM(&quot;ACCOUNT A&quot;); INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;); INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;); WHERE(&quot;P.ID = A.ID&quot;); WHERE(&quot;P.FIRST_NAME like ?&quot;); OR(); WHERE(&quot;P.LAST_NAME like ?&quot;); GROUP_BY(&quot;P.ID&quot;); HAVING(&quot;P.LAST_NAME like ?&quot;); OR(); HAVING(&quot;P.FIRST_NAME like ?&quot;); ORDER_BY(&quot;P.ID&quot;); ORDER_BY(&quot;P.FULL_NAME&quot;); &#125;&#125;.toString();&#125; 这个例子有什么特别之处吗？仔细看一下你会发现，你不用担心可能会重复出现的 “AND” 关键字，或者要做出用 “WHERE” 拼接还是 “AND” 拼接还是不用拼接的选择。SQL 类已经为你处理了哪里应该插入 “WHERE”、哪里应该使用 “AND” 的问题，并帮你完成所有的字符串拼接工作。 SQL 类这里有一些示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 匿名内部类风格public String deletePersonSql() &#123; return new SQL() &#123;&#123; DELETE_FROM(&quot;PERSON&quot;); WHERE(&quot;ID = #&#123;id&#125;&quot;); &#125;&#125;.toString();&#125;// Builder / Fluent 风格public String insertPersonSql() &#123; String sql = new SQL() .INSERT_INTO(&quot;PERSON&quot;) .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#&#123;id&#125;, #&#123;firstName&#125;&quot;) .VALUES(&quot;LAST_NAME&quot;, &quot;#&#123;lastName&#125;&quot;) .toString(); return sql;&#125;// 动态条件（注意参数需要使用 final 修饰，以便匿名内部类对它们进行访问）public String selectPersonLike(final String id, final String firstName, final String lastName) &#123; return new SQL() &#123;&#123; SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;); FROM(&quot;PERSON P&quot;); if (id != null) &#123; WHERE(&quot;P.ID like #&#123;id&#125;&quot;); &#125; if (firstName != null) &#123; WHERE(&quot;P.FIRST_NAME like #&#123;firstName&#125;&quot;); &#125; if (lastName != null) &#123; WHERE(&quot;P.LAST_NAME like #&#123;lastName&#125;&quot;); &#125; ORDER_BY(&quot;P.LAST_NAME&quot;); &#125;&#125;.toString();&#125;public String deletePersonSql() &#123; return new SQL() &#123;&#123; DELETE_FROM(&quot;PERSON&quot;); WHERE(&quot;ID = #&#123;id&#125;&quot;); &#125;&#125;.toString();&#125;public String insertPersonSql() &#123; return new SQL() &#123;&#123; INSERT_INTO(&quot;PERSON&quot;); VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#&#123;id&#125;, #&#123;firstName&#125;&quot;); VALUES(&quot;LAST_NAME&quot;, &quot;#&#123;lastName&#125;&quot;); &#125;&#125;.toString();&#125;public String updatePersonSql() &#123; return new SQL() &#123;&#123; UPDATE(&quot;PERSON&quot;); SET(&quot;FIRST_NAME = #&#123;firstName&#125;&quot;); WHERE(&quot;ID = #&#123;id&#125;&quot;); &#125;&#125;.toString();&#125; 方法 描述 SELECT(String)``SELECT(String...) 开始新的或追加到已有的 SELECT子句。可以被多次调用，参数会被追加到 SELECT 子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意参数。 SELECT_DISTINCT(String)``SELECT_DISTINCT(String...) 开始新的或追加到已有的 SELECT子句，并添加 DISTINCT 关键字到生成的查询中。可以被多次调用，参数会被追加到 SELECT 子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意参数。 FROM(String)``FROM(String...) 开始新的或追加到已有的 FROM子句。可以被多次调用，参数会被追加到 FROM子句。 参数通常是一个表名或别名，也可以是数据库驱动程序接受的任意参数。 JOIN(String)``JOIN(String...)``INNER_JOIN(String)``INNER_JOIN(String...)``LEFT_OUTER_JOIN(String)``LEFT_OUTER_JOIN(String...)``RIGHT_OUTER_JOIN(String)``RIGHT_OUTER_JOIN(String...) 基于调用的方法，添加新的合适类型的 JOIN 子句。 参数可以包含一个由列和连接条件构成的标准连接。 WHERE(String)``WHERE(String...) 插入新的 WHERE 子句条件，并使用 AND 拼接。可以被多次调用，对于每一次调用产生的新条件，会使用 AND 拼接起来。要使用 OR 分隔，请使用 OR()。 OR() 使用 OR 来分隔当前的 WHERE 子句条件。 可以被多次调用，但在一行中多次调用会生成错误的 SQL。 AND() 使用 AND 来分隔当前的 WHERE子句条件。 可以被多次调用，但在一行中多次调用会生成错误的 SQL。由于 WHERE 和 HAVING都会自动使用 AND 拼接, 因此这个方法并不常用，只是为了完整性才被定义出来。 GROUP_BY(String)``GROUP_BY(String...) 追加新的 GROUP BY 子句，使用逗号拼接。可以被多次调用，每次调用都会使用逗号将新的条件拼接起来。 HAVING(String)``HAVING(String...) 追加新的 HAVING 子句。使用 AND 拼接。可以被多次调用，每次调用都使用AND来拼接新的条件。要使用 OR 分隔，请使用 OR()。 ORDER_BY(String)``ORDER_BY(String...) 追加新的 ORDER BY 子句，使用逗号拼接。可以多次被调用，每次调用会使用逗号拼接新的条件。 LIMIT(String)``LIMIT(int) 追加新的 LIMIT 子句。 仅在 SELECT()、UPDATE()、DELETE() 时有效。 当在 SELECT() 中使用时，应该配合 OFFSET() 使用。（于 3.5.2 引入） OFFSET(String)``OFFSET(long) 追加新的 OFFSET 子句。 仅在 SELECT() 时有效。 当在 SELECT() 时使用时，应该配合 LIMIT() 使用。（于 3.5.2 引入） OFFSET_ROWS(String)``OFFSET_ROWS(long) 追加新的 OFFSET n ROWS 子句。 仅在 SELECT() 时有效。 该方法应该配合 FETCH_FIRST_ROWS_ONLY() 使用。（于 3.5.2 加入） FETCH_FIRST_ROWS_ONLY(String)``FETCH_FIRST_ROWS_ONLY(int) 追加新的 FETCH FIRST n ROWS ONLY 子句。 仅在 SELECT() 时有效。 该方法应该配合 OFFSET_ROWS() 使用。（于 3.5.2 加入） DELETE_FROM(String) 开始新的 delete 语句，并指定删除表的表名。通常它后面都会跟着一个 WHERE 子句！ INSERT_INTO(String) 开始新的 insert 语句，并指定插入数据表的表名。后面应该会跟着一个或多个 VALUES() 调用，或 INTO_COLUMNS() 和 INTO_VALUES() 调用。 SET(String)``SET(String...) 对 update 语句追加 “set” 属性的列表 UPDATE(String) 开始新的 update 语句，并指定更新表的表名。后面都会跟着一个或多个 SET() 调用，通常也会有一个 WHERE() 调用。 VALUES(String, String) 追加数据值到 insert 语句中。第一个参数是数据插入的列名，第二个参数则是数据值。 INTO_COLUMNS(String...) 追加插入列子句到 insert 语句中。应与 INTO_VALUES() 一同使用。 INTO_VALUES(String...) 追加插入值子句到 insert 语句中。应与 INTO_COLUMNS() 一同使用。 ADD_ROW() 添加新的一行数据，以便执行批量插入。（于 3.5.2 引入） 提示 注意，SQL 类将原样插入 LIMIT、OFFSET、OFFSET n ROWS 以及 FETCH FIRST n ROWS ONLY 子句。换句话说，类库不会为不支持这些子句的数据库执行任何转换。 因此，用户应该要了解目标数据库是否支持这些子句。如果目标数据库不支持这些子句，产生的 SQL 可能会引起运行错误。 从版本 3.4.2 开始，你可以像下面这样使用可变长度参数： 12345678910111213141516171819202122232425public String selectPersonSql() &#123; return new SQL() .SELECT(&quot;P.ID&quot;, &quot;A.USERNAME&quot;, &quot;A.PASSWORD&quot;, &quot;P.FULL_NAME&quot;, &quot;D.DEPARTMENT_NAME&quot;, &quot;C.COMPANY_NAME&quot;) .FROM(&quot;PERSON P&quot;, &quot;ACCOUNT A&quot;) .INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;, &quot;COMPANY C on D.COMPANY_ID = C.ID&quot;) .WHERE(&quot;P.ID = A.ID&quot;, &quot;P.FULL_NAME like #&#123;name&#125;&quot;) .ORDER_BY(&quot;P.ID&quot;, &quot;P.FULL_NAME&quot;) .toString();&#125;public String insertPersonSql() &#123; return new SQL() .INSERT_INTO(&quot;PERSON&quot;) .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;) .INTO_VALUES(&quot;#&#123;id&#125;&quot;, &quot;#&#123;fullName&#125;&quot;) .toString();&#125;public String updatePersonSql() &#123; return new SQL() .UPDATE(&quot;PERSON&quot;) .SET(&quot;FULL_NAME = #&#123;fullName&#125;&quot;, &quot;DATE_OF_BIRTH = #&#123;dateOfBirth&#125;&quot;) .WHERE(&quot;ID = #&#123;id&#125;&quot;) .toString();&#125; 从版本 3.5.2 开始，你可以像下面这样构建批量插入语句： 1234567891011public String insertPersonsSql() &#123; // INSERT INTO PERSON (ID, FULL_NAME) // VALUES (#&#123;mainPerson.id&#125;, #&#123;mainPerson.fullName&#125;) , (#&#123;subPerson.id&#125;, #&#123;subPerson.fullName&#125;) return new SQL() .INSERT_INTO(&quot;PERSON&quot;) .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;) .INTO_VALUES(&quot;#&#123;mainPerson.id&#125;&quot;, &quot;#&#123;mainPerson.fullName&#125;&quot;) .ADD_ROW() .INTO_VALUES(&quot;#&#123;subPerson.id&#125;&quot;, &quot;#&#123;subPerson.fullName&#125;&quot;) .toString();&#125; 从版本 3.5.2 开始，你可以像下面这样构建限制返回结果数的 SELECT 语句,： 123456789101112131415161718192021public String selectPersonsWithOffsetLimitSql() &#123; // SELECT id, name FROM PERSON // LIMIT #&#123;limit&#125; OFFSET #&#123;offset&#125; return new SQL() .SELECT(&quot;id&quot;, &quot;name&quot;) .FROM(&quot;PERSON&quot;) .LIMIT(&quot;#&#123;limit&#125;&quot;) .OFFSET(&quot;#&#123;offset&#125;&quot;) .toString();&#125;public String selectPersonsWithFetchFirstSql() &#123; // SELECT id, name FROM PERSON // OFFSET #&#123;offset&#125; ROWS FETCH FIRST #&#123;limit&#125; ROWS ONLY return new SQL() .SELECT(&quot;id&quot;, &quot;name&quot;) .FROM(&quot;PERSON&quot;) .OFFSET_ROWS(&quot;#&#123;offset&#125;&quot;) .FETCH_FIRST_ROWS_ONLY(&quot;#&#123;limit&#125;&quot;) .toString();&#125; SqlBuilder 和 SelectBuilder (已经废弃)在版本 3.2 之前，我们的实现方式不太一样，我们利用 ThreadLocal 变量来掩盖一些对 Java DSL 不太友好的语言限制。现在，现代 SQL 构建框架使用的构建器和匿名内部类思想已被人们所熟知。因此，我们废弃了基于这种实现方式的 SelectBuilder 和 SqlBuilder 类。 下面的方法仅仅适用于废弃的 SqlBuilder 和 SelectBuilder 类。 方法 描述 BEGIN() &#x2F;RESET() 这些方法清空 SelectBuilder 类的 ThreadLocal 状态，并准备好构建一个新的语句。开始新的语句时，BEGIN() 是最名副其实的（可读性最好的）。但如果由于一些原因（比如程序逻辑在某些条件下需要一个完全不同的语句），在执行过程中要重置语句构建状态，就很适合使用 RESET()。 SQL() 该方法返回生成的 SQL() 并重置 SelectBuilder 状态（等价于调用了 BEGIN() 或 RESET()）。因此，该方法只能被调用一次！ SelectBuilder 和 SqlBuilder 类并不神奇，但最好还是知道它们的工作原理。 SelectBuilder 以及 SqlBuilder 借助静态导入和 ThreadLocal 变量实现了对插入条件友好的简洁语法。要使用它们，只需要静态导入这个类的方法即可，就像这样（只能使用其中的一条，不能同时使用）: 12import static org.apache.ibatis.jdbc.SelectBuilder.*;import static org.apache.ibatis.jdbc.SqlBuilder.*; 然后就可以像下面这样创建一些方法： 123456789101112131415161718192021222324252627282930/* 已被废弃 */public String selectBlogsSql() &#123; BEGIN(); // 重置 ThreadLocal 状态变量 SELECT(&quot;*&quot;); FROM(&quot;BLOG&quot;); return SQL();&#125; /* 已被废弃 */private String selectPersonSql() &#123; BEGIN(); // 重置 ThreadLocal 状态变量 SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;); SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;); FROM(&quot;PERSON P&quot;); FROM(&quot;ACCOUNT A&quot;); INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;); INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;); WHERE(&quot;P.ID = A.ID&quot;); WHERE(&quot;P.FIRST_NAME like ?&quot;); OR(); WHERE(&quot;P.LAST_NAME like ?&quot;); GROUP_BY(&quot;P.ID&quot;); HAVING(&quot;P.LAST_NAME like ?&quot;); OR(); HAVING(&quot;P.FIRST_NAME like ?&quot;); ORDER_BY(&quot;P.ID&quot;); ORDER_BY(&quot;P.FULL_NAME&quot;); return SQL();&#125;","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://guoshunfa.com/tags/SQL/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"}]},{"title":"MyBatis 介绍","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.300Z","comments":true,"path":"2022/07/MyBatis-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"转载自：Mybatis 官网(简介) | Mybatis 官网(入门) 什么是 MyBatis？MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 入门安装要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。 如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从 XML 中构建 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:&#x2F;&#x2F; URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。 123String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。 不使用 XML 构建 SqlSessionFactory如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。 123456DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 映射文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 映射文件进行映射。有鉴于此，如果存在一个同名 XML 映射文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。具体细节稍后讨论。 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如： 123try (SqlSession session = sqlSessionFactory.openSession()) &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; 诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。 例如： 1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; 现在我们来探究一下这段代码究竟做了些什么。 探究已映射的 SQL 语句现在你可能很想知道 SqlSession 和 Mapper 到底具体执行了些什么操作，但 SQL 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。 在上面提到的例子中，一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你用过旧版本的 MyBatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 XML 的配置，后面我们会提到这些改进。这里给出一个基于 XML 映射语句的示例，它应该可以满足上个示例中 SqlSession 的调用。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样： 1Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101); 你可能会注意到，这种方式和用全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样： 12BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101); 第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。 提示 对命名空间的一点补充 在之前版本的 MyBatis 中，命名空间（Namespaces）的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。 命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。 命名解析：为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。 对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。 选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 XML 的语句映射方式间自由移植和切换。 作用域（Scope）和生命周期理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 提示 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式： 123try (SqlSession session = sqlSessionFactory.openSession()) &#123; // 你的应用逻辑代码&#125; 在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。 映射器实例映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样： 1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // 你的应用逻辑代码&#125;","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"}]},{"title":"MyBatisPlus 介绍","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatisPlus-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.300Z","comments":true,"path":"2022/07/MyBatisPlus-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatisPlus-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Mybatis Plus 官网 简介MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 官方文档描述的非常好，这里就不进行描述了，有问题直接前往官网进行查看。Mybatis Plus 官网","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://guoshunfa.com/tags/mybatis-plus/"},{"name":"介绍","slug":"介绍","permalink":"https://guoshunfa.com/tags/%E4%BB%8B%E7%BB%8D/"}]},{"title":"MyBatis 动态SQL","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis动态SQL","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.301Z","comments":true,"path":"2022/07/MyBatis动态SQL/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis%E5%8A%A8%E6%80%81SQL/","excerpt":"","text":"转载自：MyBatis 官网(动态SQL) 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach if使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如： 12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。 如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。 12345678910&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim、where、set前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state &#x3D; ‘ACTIVE’” 设置成动态条件，看看会发生什么。 1234567891011121314&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样: 123SELECT * FROM BLOGWHEREAND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。 MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动： 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ...&lt;/trim&gt; prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如： 12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 或者，你可以通过使用trim元素来达到同样的效果： 123&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ...&lt;/trim&gt; 注意，我们覆盖了后缀值设置，并且自定义了前缀值。 foreach动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如： 12345678910&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P &lt;where&gt; &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;ID in (&quot; separator=&quot;,&quot; close=&quot;)&quot; nullable=&quot;true&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。 script要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如: 1234567891011@Update(&#123;&quot;&lt;script&gt;&quot;, &quot;update Author&quot;, &quot; &lt;set&gt;&quot;, &quot; &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;, &quot; &lt;/set&gt;&quot;, &quot;where id=#&#123;id&#125;&quot;, &quot;&lt;/script&gt;&quot;&#125;)void updateAuthorValues(Author author); bindbind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如： 12345&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 多数据库支持如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子： 1234567891011&lt;insert id=&quot;insert&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; &lt;if test=&quot;_databaseId == &#x27;oracle&#x27;&quot;&gt; select seq_users.nextval from dual &lt;/if&gt; &lt;if test=&quot;_databaseId == &#x27;db2&#x27;&quot;&gt; select nextval for seq_users from sysibm.sysdummy1&quot; &lt;/if&gt; &lt;/selectKey&gt; insert into users values (#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt; 动态 SQL 中的插入脚本语言MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。 可以通过实现以下接口来插入一种语言： 12345public interface LanguageDriver &#123; ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql); SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType); SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType);&#125; 实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言： 123456&lt;typeAliases&gt; &lt;typeAlias type=&quot;org.sample.MyLanguageDriver&quot; alias=&quot;myLanguage&quot;/&gt;&lt;/typeAliases&gt;&lt;settings&gt; &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;myLanguage&quot;/&gt;&lt;/settings&gt; 或者，你也可以使用 lang 属性为特定的语句指定语言： 123&lt;select id=&quot;selectBlog&quot; lang=&quot;myLanguage&quot;&gt; SELECT * FROM BLOG&lt;/select&gt; 或者，在你的 mapper 接口上添加 @Lang 注解： 12345public interface Mapper &#123; @Lang(MyLanguageDriver.class) @Select(&quot;SELECT * FROM BLOG&quot;) List&lt;Blog&gt; selectBlog();&#125; 提示 可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。 你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 org.apache.ibatis.scripting.xmltags.XmlLanguageDriver（别名为 xml）所提供。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://guoshunfa.com/tags/SQL/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"}]},{"title":"MyBatis XML映射器","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis-XML映射器","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.300Z","comments":true,"path":"2022/07/MyBatis-XML映射器/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis-XML%E6%98%A0%E5%B0%84%E5%99%A8/","excerpt":"","text":"MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： cache – 该命名空间的缓存配置。 cache-ref – 引用其它命名空间的缓存配置。 resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。 parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。 sql – 可被其它语句引用的可重用语句块。 insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。 下一部分将从语句本身开始来描述每个元素的细节。 select查询语句是 MyBatis 中最常用的元素之一——光能把数据存到数据库中价值并不大，还要能重新取出来才有用，多数应用也都是查询比修改要频繁。 MyBatis 的基本原则之一是：在每个插入、更新或删除操作之间，通常会执行多个查询操作。因此，MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单的。比如： 123&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号： 1#&#123;id&#125; 这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// 近似的 JDBC 代码，非 MyBatis 代码...String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); 当然，使用 JDBC 就意味着使用更多的代码，以便提取结果并将它们映射到对象实例中，而这就是 MyBatis 的拿手好戏。参数和结果映射的详细细节会分别在后面单独的小节中说明。 select 元素允许你配置很多属性来配置每条语句的行为细节。 123456789101112&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; parameterMap=&quot;deprecated&quot; resultType=&quot;hashmap&quot; resultMap=&quot;personResultMap&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot; timeout=&quot;10&quot; fetchSize=&quot;256&quot; statementType=&quot;PREPARED&quot; resultSetType=&quot;FORWARD_ONLY&quot;&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 fetchSize 这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句：如果为 true，则假设结果集以正确顺序（排序后）执行映射，当返回新的主结果行时，将不再发生对以前结果行的引用。 这样可以减少内存消耗。默认值：false。 resultSets 这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。 insert, update 和 delete数据变更语句 insert，update 和 delete 的实现非常接近： 1234567891011121314151617181920212223&lt;insert id=&quot;insertAuthor&quot; parameterType=&quot;domain.blog.Author&quot; flushCache=&quot;true&quot; statementType=&quot;PREPARED&quot; keyProperty=&quot;&quot; keyColumn=&quot;&quot; useGeneratedKeys=&quot;&quot; timeout=&quot;20&quot;&gt;&lt;update id=&quot;updateAuthor&quot; parameterType=&quot;domain.blog.Author&quot; flushCache=&quot;true&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt;&lt;delete id=&quot;deleteAuthor&quot; parameterType=&quot;domain.blog.Author&quot; flushCache=&quot;true&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 下面是 insert，update 和 delete 语句的示例： 1234567891011121314151617&lt;insert id=&quot;insertAuthor&quot;&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id=&quot;updateAuthor&quot;&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=&quot;deleteAuthor&quot;&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，并且提供了多种生成方式。 首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys&#x3D;”true”，然后再把 keyProperty 设置为目标属性就 OK 了。例如，如果上面的 Author 表已经在 id 列上使用了自动生成，那么语句可以修改为： 12345&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 如果你的数据库还支持多行插入, 你也可以传入一个 Author 数组或集合，并返回自动生成的主键。 1234567&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into Author (username, password, email, bio) values &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt; (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;) &lt;/foreach&gt;&lt;/insert&gt; 对于不支持自动生成主键列的数据库和可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。 这里有一个简单（也很傻）的示例，它可以生成一个随机 ID（不建议实际使用，这里只是为了展示 MyBatis 处理问题的灵活性和宽容度）： 123456789&lt;insert id=&quot;insertAuthor&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1 &lt;/selectKey&gt; insert into Author (id, username, password, email,bio, favourite_section) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;, #&#123;favouriteSection,jdbcType=VARCHAR&#125;)&lt;/insert&gt; 在上面的示例中，首先会运行 selectKey 元素中的语句，并设置 Author 的 id，然后才会调用插入语句。这样就实现了数据库自动生成主键类似的行为，同时保持了 Java 代码的简洁。 selectKey 元素描述如下： 12345&lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot; statementType=&quot;PREPARED&quot;&gt; 属性 描述 keyProperty selectKey 语句结果应该被设置到的目标属性。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn 返回结果集中生成列属性的列名。如果生成列不止一个，可以用逗号分隔多个属性名称。 resultType 结果的类型。通常 MyBatis 可以推断出来，但是为了更加准确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果生成列不止一个，则可以使用包含期望属性的 Object 或 Map。 order 可以设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它首先会生成主键，设置 keyProperty 再执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。 statementType 和前面一样，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 类型的映射语句，分别代表 Statement, PreparedStatement 和 CallableStatement 类型。 sql这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如： 1&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以在其它语句中使用，例如： 1234567&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如： 1234567891011121314151617&lt;sql id=&quot;sometable&quot;&gt; $&#123;prefix&#125;Table&lt;/sql&gt;&lt;sql id=&quot;someinclude&quot;&gt; from &lt;include refid=&quot;$&#123;include_target&#125;&quot;/&gt;&lt;/sql&gt;&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt; select field1, field2, field3 &lt;include refid=&quot;someinclude&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt; &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt; &lt;/include&gt;&lt;/select&gt; 参数之前见到的所有语句都使用了简单的参数形式。但实际上，参数是 MyBatis 非常强大的元素。对于大多数简单的使用场景，你都不需要使用复杂的参数，比如： 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select id, username, password from users where id = #&#123;id&#125;&lt;/select&gt; 上面的这个示例说明了一个非常简单的命名参数映射。鉴于参数类型（parameterType）会被自动设置为 int，这个参数可以随意命名。原始类型或简单数据类型（比如 Integer 和 String）因为没有其它属性，会用它们的值来作为参数。 然而，如果传入一个复杂的对象，行为就会有点不一样了。比如： 1234&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; insert into users (id, username, password) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; 如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password 属性，然后将它们的值传入预处理语句的参数中。 对传递语句参数来说，这种方式真是干脆利落。不过参数映射的功能远不止于此。 首先，和 MyBatis 的其它部分一样，参数也可以指定一个特殊的数据类型。 1#&#123;property,javaType=int,jdbcType=NUMERIC&#125; 和 MyBatis 的其它部分一样，几乎总是可以根据参数对象的类型确定 javaType，除非该对象是一个 HashMap。这个时候，你需要显式指定 javaType 来确保正确的类型处理器（TypeHandler）被使用。 提示 JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。阅读 PreparedStatement.setNull()的 JavaDoc 来获取更多信息。 要更进一步地自定义类型处理方式，可以指定一个特殊的类型处理器类（或别名），比如： 1#&#123;age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125; 参数的配置好像越来越繁琐了，但实际上，很少需要如此繁琐的配置。 对于数值类型，还可以设置 numericScale 指定小数点后保留的位数。 1#&#123;height,javaType=double,jdbcType=NUMERIC,numericScale=2&#125; 最后，mode 属性允许你指定 IN，OUT 或 INOUT 参数。如果参数的 mode 为 OUT 或 INOUT，将会修改参数对象的属性值，以便作为输出参数返回。 如果 mode 为 OUT（或 INOUT），而且 jdbcType 为 CURSOR（也就是 Oracle 的 REFCURSOR），你必须指定一个 resultMap 引用来将结果集 ResultSet 映射到参数的类型上。要注意这里的 javaType属性是可选的，如果留空并且 jdbcType 是 CURSOR，它会被自动地被设为 ResultSet。 1#&#123;department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap&#125; MyBatis 也支持很多高级的数据类型，比如结构体（structs），但是当使用 out 参数时，你必须显式设置类型的名称。比如（再次提示，在实际中要像这样不能换行）： 1#&#123;middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap&#125; 尽管上面这些选项很强大，但大多时候，你只须简单指定属性名，顶多要为可能为空的列指定 jdbcType，其他的事情交给 MyBatis 自己去推断就行了。 123#&#123;firstName&#125;#&#123;middleInitial,jdbcType=VARCHAR&#125;#&#123;lastName&#125; 字符串替换默认情况下，使用 #&#123;&#125; 参数语法时，MyBatis 会创建 PreparedStatement 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串。 比如 ORDER BY 子句，这时候你可以： 1ORDER BY $&#123;columnName&#125; 这样，MyBatis 就不会修改或转义该字符串了。 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个例子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678910@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User findById(@Param(&quot;id&quot;) long id);@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)User findByName(@Param(&quot;name&quot;) String name);@Select(&quot;select * from user where email = #&#123;email&#125;&quot;)User findByEmail(@Param(&quot;email&quot;) String email);// 其它的 &quot;findByXxx&quot; 方法 而是可以只写这样一个方法： 12@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 其中 $&#123;column&#125; 会被直接替换，而 #&#123;value&#125; 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;); 这种方式也同样适用于替换表名的情况。 提示 用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。 结果映射resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 之前你已经见过简单映射语句的示例，它们没有显式指定 resultMap。比如： 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 并不是一个很好的领域模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean： 12345678910111213141516171819202122232425package com.someapp.model;public class User &#123; private int id; private String username; private String hashedPassword; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getHashedPassword() &#123; return hashedPassword; &#125; public void setHashedPassword(String hashedPassword) &#123; this.hashedPassword = hashedPassword; &#125;&#125; 基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。 这样的一个 JavaBean 可以被映射到 ResultSet，就像映射到 HashMap 一样简单。 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;com.someapp.model.User&quot;&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如： 123456789&lt;!-- mybatis-config.xml 中 --&gt;&lt;typeAlias type=&quot;com.someapp.model.User&quot; alias=&quot;User&quot;/&gt;&lt;!-- SQL 映射 XML 中 --&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 在这些情况下，MyBatis 会在幕后自动创建一个 ResultMap，再根据属性名来映射列到 JavaBean 的属性上。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如： 12345678&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select user_id as &quot;id&quot;, user_name as &quot;userName&quot;, hashed_password as &quot;hashedPassword&quot; from some_table where id = #&#123;id&#125;&lt;/select&gt; 在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 ResultMap，这就是 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 ResultMap。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 resultMap 会怎样，这也是解决列名不匹配的另外一种方式。 12345&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt; 然后在引用它的语句中设置 resultMap 属性就行了（注意我们去掉了 resultType 属性）。比如: 12345&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 如果这个世界总是这么简单就好了。 高级结果映射MyBatis 创建时的一个思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序，那就太好了，但可惜也没有。 而 ResultMap 就是 MyBatis 对这个问题的答案。 比如，我们如何映射下面这个语句？ 12345678910111213141516171819202122232425262728293031323334&lt;!-- 非常复杂的语句 --&gt;&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。 我们先来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。 不用紧张，我们会一步一步地来说明。虽然它看起来令人望而生畏，但其实非常简单。 1234567891011121314151617181920212223242526272829&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt; &lt;/constructor&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt; &lt;/association&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt; &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt; &lt;/collection&gt; &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt; &lt;/collection&gt; &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt; &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt; &lt;/discriminator&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap 元素有很多子元素和一个值得深入探讨的结构。 下面是resultMap 元素的概念视图。 结果映射（resultMap） constructor 1234567891011121314 \\- 用于在实例化类时，注入结果到构造方法中 - `idArg` - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 - `arg` - 将被注入到构造方法的一个普通结果- `id` – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能- `result` – 注入到字段或 JavaBean 属性的普通结果- ``` association – 一个复杂类型的关联；许多结果将包装成这种类型 - 嵌套结果映射 – 关联可以是 `resultMap` 元素，或是对其它结果映射的引用 collection 123456789 – 一个复杂类型的集合 - 嵌套结果映射 – 集合可以是 `resultMap` 元素，或是对其它结果映射的引用- ``` discriminator – 使用结果值来决定使用哪个 1resultMap - ``` case 12345678910111213141516171819202122 – 基于某些值的结果映射 - 嵌套结果映射 – `case` 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射| 属性 | 描述 || :------------ | :----------------------------------------------------------- || `id` | 当前命名空间中的一个唯一标识，用于标识一个结果映射。 || `type` | 类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。 || `autoMapping` | 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。 |**最佳实践** 最好逐步建立结果映射。单元测试可以在这个过程中起到很大帮助。 如果你尝试一次性创建像上面示例那么巨大的结果映射，不仅容易出错，难度也会直线上升。 所以，从最简单的形态开始，逐步迭代。而且别忘了单元测试！ 有时候，框架的行为像是一个黑盒子（无论是否开源）。因此，为了确保实现的行为与你的期望相一致，最好编写单元测试。 并且单元测试在提交 bug 时也能起到很大的作用。下一部分将详细说明每个元素。#### id &amp; result```xml&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; 这些元素是结果映射的基础。id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。 这两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 两个元素都有一些属性： 属性 描述 property 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。 支持的 JDBC 类型为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY 构造方法通过修改对象属性的方式，可以满足大多数的数据传输对象（Data Transfer Object, DTO）以及绝大部分领域模型的要求。但有些情况下你想使用不可变类。 一般来说，很少改变或基本不变的包含引用或数据的表，很适合使用不可变类。 构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBean 属性来完成注入，但有一些人更青睐于通过构造方法进行注入。 constructor 元素就是为此而生的。 看看下面这个构造方法: 1234567public class User &#123; //... public User(Integer id, String username, int age) &#123; //... &#125;//...&#125; 为了将结果注入构造方法，MyBatis 需要通过某种方式定位相应的构造方法。 在下面的例子中，MyBatis 搜索一个声明了三个形参的构造方法，参数类型以 java.lang.Integer, java.lang.String 和 int 的顺序给出。 12345&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot;/&gt;&lt;/constructor&gt; 当你在处理一个带有多个形参的构造方法时，很容易搞乱 arg 元素的顺序。 从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。 为了通过名称来引用构造方法参数，你可以添加 @Param 注解，或者使用 ‘-parameters’ 编译选项并启用 useActualParamName 选项（默认开启）来编译项目。下面是一个等价的例子，尽管函数签名中第二和第三个形参的顺序与 constructor 元素中参数声明的顺序不匹配。 12345&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot; /&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot; /&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;username&quot; /&gt;&lt;/constructor&gt; 如果存在名称和类型相同的属性，那么可以省略 javaType 。 剩余的属性和规则和普通的 id 和 result 元素是一样的。 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性中指定的列检索数据，作为参数传递给此 select 语句。具体请参考关联元素。 resultMap 结果映射的 ID，可以将嵌套的结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的ResultSet。这样的 ResultSet 将会将包含重复或部分数据重复的结果集。为了将结果集正确地映射到嵌套的对象树中，MyBatis 允许你 “串联”结果映射，以便解决嵌套结果集的问题。想了解更多内容，请参考下面的关联元素。 name 构造方法形参的名字。从 3.4.3 版本开始，通过指定具体的参数名，你可以以任意顺序写入 arg 元素。参看上面的解释。 关联1234&lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;&lt;/association&gt; 关联（association）元素处理“有一个”类型的关系。 比如，在我们的示例中，一个博客有一个用户。关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的javaType（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 JDBC 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。 关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联： 嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。 嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。 首先，先让我们来看看这个元素的属性。你将会发现，和普通的结果映射相比，它只在 select 和 resultMap 属性上有所不同。 属性 描述 property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 关联的嵌套 Select 查询 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 fetchType 可选的。有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 示例： 1234567891011&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。 其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。 这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的： 你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。 对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。 这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。 好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。 所以还有另外一种方法。 关联的嵌套结果映射 属性 描述 resultMap 结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。 columnPrefix 当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。 notNullColumn 默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列中任意一列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。 autoMapping 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 select 或 resultMap 元素使用。默认值：未设置（unset）。 之前，你已经看到了一个非常复杂的嵌套关联的例子。 下面的例子则是一个非常简单的例子，用于演示嵌套结果映射如何工作。 现在我们将博客表和作者表连接在一起，而不是执行一个独立的查询语句，就像这样： 12345678910111213&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio from Blog B left outer join Author A on B.author_id = A.id where B.id = #&#123;id&#125;&lt;/select&gt; 注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。 这使得进行映射非常简单。现在我们可以映射这个结果： 12345678910111213&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;&lt;/resultMap&gt; 在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为 “authorResult” 的结果映射来加载作者对象的实例。 非常重要： id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。 现在，上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用。 然而，如果你不打算重用它，或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。 你可以直接将结果映射作为子元素嵌套在内。这里给出使用这种方式的等效例子： 1234567891011&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 那如果博客（blog）有一个共同作者（co-author）该怎么办？select 语句看起来会是这样的： 12345678910111213141516171819&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; select B.id as blog_id, B.title as blog_title, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, CA.id as co_author_id, CA.username as co_author_username, CA.password as co_author_password, CA.email as co_author_email, CA.bio as co_author_bio from Blog B left outer join Author A on B.author_id = A.id left outer join Author CA on B.co_author_id = CA.id where B.id = #&#123;id&#125;&lt;/select&gt; 回忆一下，Author 的结果映射定义如下： 1234567&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;&lt;/resultMap&gt; 由于结果中的列名与结果映射中的列名不同。你需要指定 columnPrefix 以便重复使用该结果映射来映射 co-author 的结果。 123456789&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; resultMap=&quot;authorResult&quot; /&gt; &lt;association property=&quot;coAuthor&quot; resultMap=&quot;authorResult&quot; columnPrefix=&quot;co_&quot; /&gt;&lt;/resultMap&gt; 关联的多结果集（ResultSet） 属性 描述 column 当使用多个结果集时，该属性指定结果集中用于与 foreignColumn 匹配的列（多个列名以逗号隔开），以识别关系中的父类型与子类型。 foreignColumn 指定外键对应的列名，指定的列将与父类型中 column 的给出的列进行匹配。 resultSet 指定用于加载复杂类型的结果集名字。 从版本 3.2.3 开始，MyBatis 提供了另一种解决 N+1 查询问题的方法。 某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集。 我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。 在例子中，存储过程执行下面的查询并返回两个结果集。第一个结果集会返回博客（Blog）的结果，第二个则返回作者（Author）的结果。 123SELECT * FROM BLOG WHERE ID = #&#123;id&#125;SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125; 在映射语句中，必须通过 resultSets 属性为每个结果集指定一个名字，多个名字使用逗号隔开。 123&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,authors&quot; resultMap=&quot;blogResult&quot; statementType=&quot;CALLABLE&quot;&gt; &#123;call getBlogsAndAuthors(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;&lt;/select&gt; 现在我们可以指定使用 “authors” 结果集的数据来填充 “author” 关联： 1234567891011&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot; resultSet=&quot;authors&quot; column=&quot;author_id&quot; foreignColumn=&quot;id&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;bio&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 你已经在上面看到了如何处理“有一个”类型的关联。但是该怎么处理“有很多个”类型的关联呢？这就是我们接下来要介绍的。 集合12345&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;&lt;/collection&gt; 集合元素和关联元素几乎是一样的，它们相似的程度之高，以致于没有必要再介绍集合元素的相似部分。 所以让我们来关注它们的不同之处吧。 我们来继续上面的示例，一个博客（Blog）只有一个作者（Author)。但一个博客有很多文章（Post)。 在博客类中，这可以用下面的写法来表示： 1private List&lt;Post&gt; posts; 要像上面这样，映射嵌套结果集合到一个 List 中，可以使用集合元素。 和关联元素一样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。 集合的嵌套 Select 查询首先，让我们看看如何使用嵌套 Select 查询来为博客加载文章。 1234567891011&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt; SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;&lt;/select&gt; 你可能会立刻注意到几个不同，但大部分都和我们上面学习过的关联元素非常相似。 首先，你会注意到我们使用的是集合元素。 接下来你会注意到有一个新的 “ofType” 属性。这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。 所以你可以按照下面这样来阅读映射： 1&lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; 读作： “posts 是一个存储 Post 的 ArrayList 集合” 在一般情况下，MyBatis 可以推断 javaType 属性，因此并不需要填写。所以很多时候你可以简略成： 1&lt;collection property=&quot;posts&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; 集合的嵌套结果映射现在你可能已经猜到了集合的嵌套结果映射是怎样工作的——除了新增的 “ofType” 属性，它和关联的完全相同。 首先, 让我们看看对应的 SQL 语句： 123456789101112&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, P.id as post_id, P.subject as post_subject, P.body as post_body, from Blog B left outer join Post P on B.id = P.blog_id where B.id = #&#123;id&#125;&lt;/select&gt; 我们再次连接了博客表和文章表，并且为每一列都赋予了一个有意义的别名，以便映射保持简单。 要映射博客里面的文章集合，就这么简单： 123456789&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 再提醒一次，要记得上面 id 元素的重要性，如果你不记得了，请阅读关联部分的相关部分。 如果你喜欢更详略的、可重用的结果映射，你可以使用下面的等价形式： 1234567891011&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultMap=&quot;blogPostResult&quot; columnPrefix=&quot;post_&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;blogPostResult&quot; type=&quot;Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt; &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;&lt;/resultMap&gt; 集合的多结果集（ResultSet）像关联元素那样，我们可以通过执行存储过程实现，它会执行两个查询并返回两个结果集，一个是博客的结果集，另一个是文章的结果集： 123SELECT * FROM BLOG WHERE ID = #&#123;id&#125;SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125; 在映射语句中，必须通过 resultSets 属性为每个结果集指定一个名字，多个名字使用逗号隔开。 123&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,posts&quot; resultMap=&quot;blogResult&quot;&gt; &#123;call getBlogsAndPosts(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;&lt;/select&gt; 我们指定 “posts” 集合将会使用存储在 “posts” 结果集中的数据进行填充： 123456789&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt; &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 注意 对关联或集合的映射，并没有深度、广度或组合上的要求。但在映射时要留意性能问题。 在探索最佳实践的过程中，应用的单元测试和性能测试会是你的好帮手。 而 MyBatis 的好处在于，可以在不对你的代码引入重大变更（如果有）的情况下，允许你之后改变你的想法。 高级关联和集合映射是一个深度话题。文档的介绍只能到此为止。配合少许的实践，你会很快了解全部的用法。 鉴别器123&lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt; &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;&lt;/discriminator&gt; 有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。 一个鉴别器的定义需要指定 column 和 javaType 属性。column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试（虽然很多情况下字符串的相等测试都可以工作）。例如： 1234567891011121314&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt; &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt; &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt; &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt; &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt; &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt; &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt; &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt; &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt; &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 在这个示例中，MyBatis 会从结果集中得到每条记录，然后比较它的 vehicle type 值。 如果它匹配任意一个鉴别器的 case，就会使用这个 case 指定的结果映射。 这个过程是互斥的，也就是说，剩余的结果映射将被忽略（除非它是扩展的，我们将在稍后讨论它）。 如果不能匹配任何一个 case，MyBatis 就只会使用鉴别器块外定义的结果映射。 所以，如果 carResult 的声明如下： 123&lt;resultMap id=&quot;carResult&quot; type=&quot;Car&quot;&gt; &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt;&lt;/resultMap&gt; 那么只有 doorCount 属性会被加载。这是为了即使鉴别器的 case 之间都能分为完全独立的一组，尽管和父结果映射可能没有什么关系。在上面的例子中，我们当然知道 cars 和 vehicles 之间有关系，也就是 Car 是一个 Vehicle。因此，我们希望剩余的属性也能被加载。而这只需要一个小修改。 123&lt;resultMap id=&quot;carResult&quot; type=&quot;Car&quot; extends=&quot;vehicleResult&quot;&gt; &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt;&lt;/resultMap&gt; 现在 vehicleResult 和 carResult 的属性都会被加载了。 可能有人又会觉得映射的外部定义有点太冗长了。 因此，对于那些更喜欢简洁的映射风格的人来说，还有另一种语法可以选择。例如： 1234567891011121314151617181920212223&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt; &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt; &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt; &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt; &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt; &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt; &lt;case value=&quot;1&quot; resultType=&quot;carResult&quot;&gt; &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt; &lt;/case&gt; &lt;case value=&quot;2&quot; resultType=&quot;truckResult&quot;&gt; &lt;result property=&quot;boxSize&quot; column=&quot;box_size&quot; /&gt; &lt;result property=&quot;extendedCab&quot; column=&quot;extended_cab&quot; /&gt; &lt;/case&gt; &lt;case value=&quot;3&quot; resultType=&quot;vanResult&quot;&gt; &lt;result property=&quot;powerSlidingDoor&quot; column=&quot;power_sliding_door&quot; /&gt; &lt;/case&gt; &lt;case value=&quot;4&quot; resultType=&quot;suvResult&quot;&gt; &lt;result property=&quot;allWheelDrive&quot; column=&quot;all_wheel_drive&quot; /&gt; &lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 提示 请注意，这些都是结果映射，如果你完全不设置任何的 result 元素，MyBatis 将为你自动匹配列和属性。所以上面的例子大多都要比实际的更复杂。 这也表明，大多数数据库的复杂度都比较高，我们不太可能一直依赖于这种机制。 自动映射正如你在前面一节看到的，在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，你需要构建一个结果映射。 但是在本节中，你将看到，你可以混合使用这两种策略。让我们深入了解一下自动映射是怎样工作的。 当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 这意味着如果发现了 ID 列和 id 属性，MyBatis 会将列 ID 的值赋给 id 属性。 通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将mapUnderscoreToCamelCase 设置为 true。 甚至在提供了结果映射后，自动映射也能工作。在这种情况下，对于每一个结果映射，在 ResultSet 出现的列，如果没有设置手动映射，将被自动映射。在自动映射处理完毕后，再处理手动映射。 在下面的例子中，id 和 userName 列将被自动映射，hashed_password 列将根据配置进行映射。 1234567891011&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id as &quot;id&quot;, user_name as &quot;userName&quot;, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt; 有三种自动映射等级： NONE - 禁用自动映射。仅对手动映射的属性进行映射。 PARTIAL - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射 FULL - 自动映射所有属性。 默认值是 PARTIAL，这是有原因的。当对连接查询的结果使用 FULL 时，连接查询会在同一行中获取多个不同实体的数据，因此可能导致非预期的映射。 下面的例子将展示这种风险： 123456789101112131415&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; select B.id, B.title, A.username, from Blog B left outer join Author A on B.author_id = A.id where B.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; resultMap=&quot;authorResult&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;&lt;/resultMap&gt; 在该结果映射中，Blog 和 Author 均将被自动映射。但是注意 Author 有一个 id 属性，在 ResultSet 中也有一个名为 id 的列，所以 Author 的 id 将填入 Blog 的 id，这可不是你期望的行为。 所以，要谨慎使用 FULL。 无论设置的自动映射等级是哪种，你都可以通过在结果映射上设置 autoMapping 属性来为指定的结果映射设置启用&#x2F;禁用自动映射。 123&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot; autoMapping=&quot;false&quot;&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt; 缓存MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。 默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行： 1&lt;cache/&gt; 基本上就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读&#x2F;写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 提示 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。 这些属性可以通过 cache 元素的属性来修改。比如： 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 可用的清除策略有： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 默认的清除策略是 LRU。 flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。 size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 提示 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache&#x3D;true 的 insert&#x2F;delete&#x2F;update 语句时，缓存会获得更新。 使用自定义缓存除了上述自定义缓存的方式，你也可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。 1&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt; 这个示例展示了如何使用一个自定义的缓存实现。type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器。 这个接口是 MyBatis 框架中许多复杂的接口之一，但是行为却非常简单。 123456789public interface Cache &#123; String getId(); int getSize(); void putObject(Object key, Object value); Object getObject(Object key); boolean hasKey(Object key); Object removeObject(Object key); void clear();&#125; 为了对你的缓存进行配置，只需要简单地在你的缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如，下面的例子将在你的缓存实现上调用一个名为setCacheFile(String file) 的方法： 123&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;&gt; &lt;property name=&quot;cacheFile&quot; value=&quot;/tmp/my-custom-cache.tmp&quot;/&gt;&lt;/cache&gt; 你可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。 你也可以使用占位符（如 $&#123;cache.file&#125;），以便替换成在配置文件属性中定义的值。 从版本 3.4.2 开始，MyBatis 已经支持在所有属性设置完毕之后，调用一个初始化方法。 如果想要使用这个特性，请在你的自定义缓存类里实现org.apache.ibatis.builder.InitializingObject 接口。 123public interface InitializingObject &#123; void initialize() throws Exception;&#125; 提示 上一节中对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存。 请注意，缓存的配置和缓存实例会被绑定到 SQL 映射文件的命名空间中。 因此，同一命名空间中的所有语句和缓存将通过命名空间绑定在一起。 每条语句可以自定义与缓存交互的方式，或将它们完全排除于缓存之外，这可以通过在每条语句上使用两个简单属性来达成。 默认情况下，语句会这样来配置： 1234&lt;select ... flushCache=&quot;false&quot; useCache=&quot;true&quot;/&gt;&lt;insert ... flushCache=&quot;true&quot;/&gt;&lt;update ... flushCache=&quot;true&quot;/&gt;&lt;delete ... flushCache=&quot;true&quot;/&gt; 鉴于这是默认行为，显然你永远不应该以这样的方式显式配置一条语句。但如果你想改变默认的行为，只需要设置 flushCache 和 useCache 属性。比如，某些情况下你可能希望特定 select 语句的结果排除于缓存之外，或希望一条 select 语句清空缓存。类似地，你可能希望某些 update 语句执行时不要刷新缓存。 cache-ref回想一下上一节的内容，对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。 1&lt;cache-ref namespace=&quot;com.someone.application.data.SomeMapper&quot;/&gt;","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"},{"name":"XML","slug":"XML","permalink":"https://guoshunfa.com/tags/XML/"}]},{"title":"MyBatis 日志","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis日志","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.301Z","comments":true,"path":"2022/07/MyBatis日志/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis%E6%97%A5%E5%BF%97/","excerpt":"","text":"转载自：Mybatis 官网(日志) Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一： SLF4J Apache Commons Logging Log4j 2 Log4j （3.5.9 起废弃） JDK logging MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 不少应用服务器（如 Tomcat 和 WebShpere）的类路径中已经包含 Commons Logging，所以在这种配置环境下的 MyBatis 会把它作为日志工具，记住这点非常重要。这将意味着，在诸如 WebSphere 的环境中，它提供了 Commons Logging 的私有实现，你的 Log4J 配置将被忽略。MyBatis 将你的 Log4J 配置忽略掉是相当令人郁闷的（事实上，正是因为在这种配置环境下，MyBatis 才会选择使用 Commons Logging 而不是 Log4J）。如果你的应用部署在一个类路径已经包含 Commons Logging 的环境中，而你又想使用其它日志工具，你可以通过在 MyBatis 配置文件 mybatis-config.xml 里面添加一项 setting 来选择别的日志工具。 1234567&lt;configuration&gt; &lt;settings&gt; ... &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; ... &lt;/settings&gt;&lt;/configuration&gt; logImpl 可选的值有：SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者是实现了接口 org.apache.ibatis.logging.Log 的，且构造方法是以字符串为参数的类的完全限定名。（译者注：可以参考org.apache.ibatis.logging.slf4j.Slf4jImpl.java的实现） 你也可以调用如下任一方法来使用日志工具： 12345org.apache.ibatis.logging.LogFactory.useSlf4jLogging();org.apache.ibatis.logging.LogFactory.useLog4JLogging();org.apache.ibatis.logging.LogFactory.useJdkLogging();org.apache.ibatis.logging.LogFactory.useCommonsLogging();org.apache.ibatis.logging.LogFactory.useStdOutLogging(); 如果你决定要调用以上某个方法，请在调用其它 MyBatis 方法之前调用它。另外，仅当运行时类路径中存在该日志工具时，调用与该日志工具对应的方法才会生效，否则 MyBatis 一概忽略。如你环境中并不存在 Log4J2，你却调用了相应的方法，MyBatis 就会忽略这一调用，转而以默认的查找顺序查找日志工具。 关于 SLF4J、Apache Commons Logging、Apache Log4J 和 JDK Logging 的 API 介绍不在本文档介绍范围内。不过，下面的例子可以作为一个快速入门。关于这些日志框架的更多信息，可以参考以下链接： SLF4J Apache Commons Logging Apache Log4j 1.x and 2.x JDK Logging API 日志配置你可以对包、映射类的全限定名、命名空间或全限定语句名开启日志功能来查看 MyBatis 的日志语句。 再次说明下，具体怎么做，由使用的日志工具决定，这里以 SLF4J(Logback) 为例。配置日志功能非常简单：添加一个或多个配置文件（如 logback.xml），有时需要添加 jar 包。下面的例子将使用 SLF4J(Logback) 来配置完整的日志服务，共两个步骤： 步骤 1：添加 SLF4J + Logback 的 jar 包因为我们使用的是 SLF4J(Logback)，就要确保它的 jar 包在应用中是可用的。要启用 SLF4J(Logback)，只要将 jar 包添加到应用的类路径中即可。SLF4J(Logback) 的 jar 包可以在上面的链接中下载。 对于 web 应用或企业级应用，则需要将 logback-classic.jar, logback-core.jar and slf4j-api.jar 添加到 WEB-INF/lib 目录下；对于独立应用，可以将它添加到JVM 的 -classpath 启动参数中。 如果你使用 maven, 你可以通过在 pom.xml 中添加下面的依赖来下载 jar 文件。 12345&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.x.x&lt;/version&gt;&lt;/dependency&gt; 步骤 2：配置 Logback配置 Logback 比较简单，假如你需要记录这个映射器接口的日志： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; 在应用的类路径中创建一个名称为 logback.xml 的文件，文件的具体内容如下： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration&gt;&lt;configuration&gt; &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%5level [%thread] - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;level value=&quot;trace&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;error&quot;&gt; &lt;appender-ref ref=&quot;stdout&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 添加以上配置后，SLF4J(Logback) 就会记录 org.mybatis.example.BlogMapper 的详细执行操作，且仅记录应用中其它类的错误信息（若有）。 你也可以将日志的记录方式从接口级别切换到语句级别，从而实现更细粒度的控制。如下配置只对 selectBlog 语句记录日志： 123&lt;logger name=&quot;org.mybatis.example.BlogMapper.selectBlog&quot;&gt; &lt;level value=&quot;trace&quot;/&gt;&lt;/logger&gt; 与此相对，可以对一组映射器接口记录日志，只要对映射器接口所在的包开启日志功能即可： 123&lt;logger name=&quot;org.mybatis.example&quot;&gt; &lt;level value=&quot;trace&quot;/&gt;&lt;/logger&gt; 某些查询可能会返回庞大的结果集，此时只想记录其执行的 SQL 语句而不想记录结果该怎么办？为此，Mybatis 中 SQL 语句的日志级别被设为DEBUG（JDK 日志设为 FINE），结果的日志级别为 TRACE（JDK 日志设为 FINER)。所以，只要将日志级别调整为 DEBUG 即可达到目的： 123&lt;logger name=&quot;org.mybatis.example&quot;&gt; &lt;level value=&quot;debug&quot;/&gt;&lt;/logger&gt; 要记录日志的是类似下面的映射器文件而不是映射器接口又该怎么做呢？ 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 如需对 XML 文件记录日志，只要对命名空间增加日志记录功能即可： 123&lt;logger name=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;level value=&quot;trace&quot;/&gt;&lt;/logger&gt; 要记录具体语句的日志可以这样做： 123&lt;logger name=&quot;org.mybatis.example.BlogMapper.selectBlog&quot;&gt; &lt;level value=&quot;trace&quot;/&gt;&lt;/logger&gt; 你应该注意到了，为映射器接口和 XML 文件添加日志功能的语句毫无差别。 注意 如果你使用的是 SLF4J 或 Log4j 2，MyBatis 将以 MYBATIS 这个值进行调用。 配置文件 log4j.properties 的余下内容是针对日志输出源的，这一内容已经超出本文档范围。关于 Logback 的更多内容，可以参考Logback 的网站。不过，你也可以简单地做做实验，看看不同的配置会产生怎样的效果。 Log4j 2 配置示例123456789101112131415161718192021222324pom.xml&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.x.x&lt;/version&gt;&lt;/dependency&gt;log4j2.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration xmlns=&quot;http://logging.apache.org/log4j/2.0/config&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;stdout&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%5level [%t] - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Logger name=&quot;org.mybatis.example.BlogMapper&quot; level=&quot;trace&quot;/&gt; &lt;Root level=&quot;error&quot; &gt; &lt;AppenderRef ref=&quot;stdout&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; Log4j 配置示例1234567891011121314pom.xml&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;log4j.propertieslog4j.rootLogger=ERROR, stdoutlog4j.logger.org.mybatis.example.BlogMapper=TRACElog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n JDK logging 配置示例123456789logging.propertieshandlers=java.util.logging.ConsoleHandler.level=SEVEREorg.mybatis.example.BlogMapper=FINERjava.util.logging.ConsoleHandler.level=ALLjava.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatterjava.util.logging.SimpleFormatter.format=%1$tT.%1$tL %4$s %3$s - %5$s%6$s%n","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"}]},{"title":"SpringBoot框架 启动时输出文案","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架-启动时输出文案","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架-启动时输出文案/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6-%E5%90%AF%E5%8A%A8%E6%97%B6%E8%BE%93%E5%87%BA%E6%96%87%E6%A1%88/","excerpt":"","text":"SpringBoot框架 - 启动时输出文案SpringBoot在启动时，控制台会生成一个默认文案。其实是可以根据个人需要进行调整的。 下面是我调整后显示的内容。 调整的方式有很多，这里介绍一个最简单的方法。 在application.properties同目录下创建一个文件：banner.txt。 将你想要输出的文案，加入到banner.txt中。 这里提供一个线上banner生成网站：https://devops.datenkollektiv.de/banner.txt/index.html 将下面自动生成的文本，cv到banner.txt文件中，重启项目就可以看到变动。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"SpringBoot框架 基础知识","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架-基础知识","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架-基础知识/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"SpringBoot 项目搭建介绍父子项目搭建搭建流程 创建多个springboot项目 配置父项目pom 123456789101112131415161718&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.3.2.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;/parent&gt;&lt;!--包名--&gt;&lt;groupId&gt;com.gsf&lt;/groupId&gt;&lt;!--项目名称--&gt;&lt;artifactId&gt;gsf-parent&lt;/artifactId&gt;&lt;!--版本--&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!--打包方式，pom为父项目--&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 配置子项目pom 12345678910111213141516171819&lt;!--继承父级--&gt;&lt;parent&gt; &lt;!--父项目名--&gt;&lt;artifactId&gt;gsf-parent&lt;/artifactId&gt; &lt;!--父项目包名--&gt;&lt;groupId&gt;com.gsf&lt;/groupId&gt; &lt;!--父项目版本号--&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--指定打包类型--&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;!--项目名称--&gt;&lt;artifactId&gt;gsf-run&lt;/artifactId&gt;&lt;!--项目包名--&gt;&lt;groupId&gt;com.gsf&lt;/groupId&gt;&lt;!--版本号--&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;name&gt;gsf-run&lt;/name&gt; 描述 父项目所引入的依赖，子项目可以使用。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"SpringBoot框架 官方介绍","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架-官方介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架-官方介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6-%E5%AE%98%E6%96%B9%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"SpringBoot 项目官网 | 安装 Spring Boot CLI 概述Spring Boot 可以轻松创建独立的、生产级的基于 Spring 的应用程序，您可以“直接运行”。 我们对 Spring 平台和第三方库有自己的看法，因此您可以轻松上手。大多数 Spring Boot 应用程序需要最少的 Spring 配置。 如果您正在寻找有关特定版本的信息，或有关如何从早期版本升级的说明，请查看我们 wiki 上的项目发行说明部分。 特征 创建独立的 Spring 应用程序 直接嵌入Tomcat、Jetty或Undertow（无需部署WAR文件） 提供自以为是的“入门”依赖项以简化您的构建配置 尽可能自动配置 Spring 和 3rd 方库 提供生产就绪的功能，例如指标、健康检查和外部化配置 绝对没有代码生成，也不需要 XML 配置 入门 超级快——试试快速入门指南。 更通用——尝试使用 Spring Boot 构建应用程序 更具体——尝试构建 RESTful Web 服务。 或者在指南主页上搜索我们所有的指南。 讲座和视频 这是一种魔法：在 Spring Boot 的幕后 Spring Boot 2.0 的新特性 介绍 Spring Boot 2.0 网络研讨会 使用 Spring Boot 进行测试驱动开发 Spring Boot 2.0 从零到英雄 您还可以加入Gitter 上的 Spring Boot 社区！ 学习 版本 参考文档 API文档 2.7.5 参考文档 API文档。 快速启动您的项目使用Spring Initializr 引导您的应用程序 。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"MyBatis 配置","slug":"软件开发/技术/软件技术框架/各大框架/Mybatis/MyBatis配置","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.301Z","comments":true,"path":"2022/07/MyBatis配置/","link":"","permalink":"https://guoshunfa.com/2022/07/MyBatis%E9%85%8D%E7%BD%AE/","excerpt":"","text":"转载自: MyBatis 官网(XML 配置) MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 属性（properties）这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如： 1234&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt; 设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如: 123456&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt; 这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。 也可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值。例如： 12345SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);// ... 或者 ...SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props); 如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载： 首先读取在 properties 元素体内指定的属性。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。 最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource&#x2F;url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。 从 MyBatis 3.4.2 开始，你可以为占位符指定一个默认值。例如： 1234&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username:ut_user&#125;&quot;/&gt; &lt;!-- 如果属性 &#x27;username&#x27; 没有被配置，&#x27;username&#x27; 属性的值将为 &#x27;ut_user&#x27; --&gt;&lt;/dataSource&gt; 这个特性默认是关闭的。要启用这个特性，需要添加一个特定的属性来开启这个特性。例如： 1234&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- 启用默认值特性 --&gt;&lt;/properties&gt; 提示 如果你在属性名中使用了 &quot;:&quot; 字符（如：db:username），或者在 SQL 映射中使用了 OGNL 表达式的三元运算符（如： $&#123;tableName != null ? tableName : &#39;global_constants&#39;&#125;），就需要设置特定的属性来修改分隔属性名和默认值的字符。例如： 12345678&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- 修改默认值的分隔符 --&gt;&lt;/properties&gt;&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;db:username?:ut_user&#125;&quot;/&gt;&lt;/dataSource&gt; 设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false aggressiveLazyLoading 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。 true | false false （在 3.4.1 及之前的版本中默认为 true） multipleResultSetsEnabled 是否允许单个语句返回多结果集（需要数据库驱动支持）。 true | false true useColumnLabel 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 true | false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 true | false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志（&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;的日志等级必须设置为 WARN）FAILING: 映射失败 (抛出 SqlSessionException) NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定数据库驱动等待数据库响应的秒数。 任意正整数 未设置 (null) defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 任意正整数 未设置 (null) defaultResultSetType 指定语句默认的滚动策略。（新增于 3.5.2） FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置） 未设置 (null) safeRowBoundsEnabled 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 true | false False safeResultHandlerEnabled 是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。 true | false True mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 SESSION | STATEMENT SESSION jdbcTypeForNull 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定对象的哪些方法触发一次延迟加载。 用逗号分隔的方法列表。 equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成使用的默认脚本语言。 一个类型别名或全限定类名。 org.apache.ibatis.scripting.xmltags.XMLLanguageDriver defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） 一个类型别名或全限定类名。 org.apache.ibatis.type.EnumTypeHandler callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true | false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） true | false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 未设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 proxyFactory 指定 Mybatis 创建可延迟加载对象所用到的代理工具。 CGLIB （3.5.10 起废弃） | JAVASSIST JAVASSIST （MyBatis 3.3 以上） vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 未设置 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） true | false true configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） 一个类型别名或完全限定类名。 未设置 shrinkWhitespacesInSql 从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5) true | false false defaultSqlProviderType 指定一个拥有 provider 方法的 sql provider 类 （新增于 3.5.6）. 这个类适用于指定 sql provider 注解上的type（或 value） 属性（当这些属性在注解中被忽略时）。 (e.g. @SelectProvider) 类型别名或者全限定名 未设置 nullableOnForEach 为 ‘foreach’ 标签的 ‘nullable’ 属性指定默认值。（新增于 3.5.9） true | false false argNameBasedConstructorAutoMapping 当应用构造器自动映射时，参数名称被用来搜索要映射的列，而不再依赖列的顺序。（新增于 3.5.10） true | false false 一个配置完整的 settings 元素的示例如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt; &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt; &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt; &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt; &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。 别名 映射的类型 _byte byte _char (since 3.5.10) char _character (since 3.5.10) char _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte char (since 3.5.10) Character character (since 3.5.10) Character long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal biginteger BigInteger object Object date[] Date[] decimal[] BigDecimal[] bigdecimal[] BigDecimal[] biginteger[] BigInteger[] object[] Object[] map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 类型处理器（typeHandlers）MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 提示 从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SMALLINT IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 BIGINT FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR 或任何兼容的字符串类型，用来存储枚举的名称（而不是索引序数值） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，用来存储枚举的序数值（而不是名称）。 SqlxmlTypeHandler java.lang.String SQLXML InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR 或 LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE 你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 并且可以（可选地）将它映射到一个 JDBC 类型。比如： 12345678910111213141516171819202122232425262728// ExampleTypeHandler.java@MappedJdbcTypes(JdbcType.VARCHAR)public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125;&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;&lt;/typeHandlers&gt; 使用上述的类型处理器将会覆盖已有的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。 要注意 MyBatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 VARCHAR 类型， 以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。 通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变： 在类型处理器的配置元素（typeHandler 元素）上增加一个 javaType 属性（比如：javaType=&quot;String&quot;）； 在类型处理器的类上增加一个 @MappedTypes 注解指定与其关联的 Java 类型列表。 如果在 javaType 属性中也同时指定，则注解上的配置将被忽略。 可以通过两种方式来指定关联的 JDBC 类型： 在类型处理器的配置元素上增加一个 jdbcType 属性（比如：jdbcType=&quot;VARCHAR&quot;）； 在类型处理器的类上增加一个 @MappedJdbcTypes 注解指定与其关联的 JDBC 类型列表。 如果在 jdbcType 属性中也同时指定，则注解上的配置将被忽略。 当在 ResultMap 中决定使用哪种类型处理器时，此时 Java 类型是已知的（从结果类型中获得），但是 JDBC 类型是未知的。 因此 Mybatis 使用 javaType=[Java 类型], jdbcType=null 的组合来选择一个类型处理器。 这意味着使用 @MappedJdbcTypes 注解可以限制类型处理器的作用范围，并且可以确保，除非显式地设置，否则类型处理器在 ResultMap 中将不会生效。 如果希望能在 ResultMap 中隐式地使用类型处理器，那么设置 @MappedJdbcTypes 注解的 includeNullJdbcType=true 即可。 然而从 Mybatis 3.4.0 开始，如果某个 Java 类型只有一个注册的类型处理器，即使没有设置 includeNullJdbcType=true，那么这个类型处理器也会是 ResultMap 使用 Java 类型时的默认处理器。 最后，可以让 MyBatis 帮你查找类型处理器： 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;package name=&quot;org.mybatis.example&quot;/&gt;&lt;/typeHandlers&gt; 注意在使用自动发现功能的时候，只能通过注解方式来指定 JDBC 的类型。 你可以创建能够处理多个类的泛型类型处理器。为了使用泛型类型处理器， 需要增加一个接受该类的 class 作为参数的构造器，这样 MyBatis 会在构造一个类型处理器实例的时候传入一个具体的类。 12345678910//GenericTypeHandler.javapublic class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; &#123; private Class&lt;E&gt; type; public GenericTypeHandler(Class&lt;E&gt; type) &#123; if (type == null) throw new IllegalArgumentException(&quot;Type argument cannot be null&quot;); this.type = type; &#125; ... EnumTypeHandler 和 EnumOrdinalTypeHandler 都是泛型类型处理器，我们将会在接下来的部分详细探讨。 处理枚举类型若想映射枚举类型 Enum，则需要从 EnumTypeHandler 或者 EnumOrdinalTypeHandler 中选择一个来使用。 比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 EnumTypeHandler 来把 Enum 值转换成对应的名字。 注意 EnumTypeHandler 在某种意义上来说是比较特别的，其它的处理器只针对某个特定的类，而它不同，它会处理任意继承了 Enum 的类。 不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样简单：在配置文件中把 EnumOrdinalTypeHandler 加到 typeHandlers 中即可， 这样每个 RoundingMode 将通过他们的序数值来映射成对应的整形数值。 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;java.math.RoundingMode&quot;/&gt;&lt;/typeHandlers&gt; 但要是你想在一个地方将 Enum 映射成字符串，在另外一个地方映射成整形值呢？ 自动映射器（auto-mapper）会自动地选用 EnumOrdinalTypeHandler 来处理枚举类型， 所以如果我们想用普通的 EnumTypeHandler，就必须要显式地为那些 SQL 语句设置要使用的类型处理器。 （下一节才开始介绍映射器文件，如果你是首次阅读该文档，你可能需要先跳过这里，过会再来看。） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.apache.ibatis.submitted.rounding.Mapper&quot;&gt; &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt; &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUser&quot; resultMap=&quot;usermap&quot;&gt; select * from users &lt;/select&gt; &lt;insert id=&quot;insert&quot;&gt; insert into users (id, name, funkyNumber, roundingMode) values ( #&#123;id&#125;, #&#123;name&#125;, #&#123;funkyNumber&#125;, #&#123;roundingMode&#125; ) &lt;/insert&gt; &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap2&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt; &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUser2&quot; resultMap=&quot;usermap2&quot;&gt; select * from users2 &lt;/select&gt; &lt;insert id=&quot;insert2&quot;&gt; insert into users2 (id, name, funkyNumber, roundingMode) values ( #&#123;id&#125;, #&#123;name&#125;, #&#123;funkyNumber&#125;, #&#123;roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 注意，这里的 select 语句必须指定 resultMap 而不是 resultType。 对象工厂（objectFactory）每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。比如： 12345678910111213141516171819202122232425// ExampleObjectFactory.javapublic class ExampleObjectFactory extends DefaultObjectFactory &#123; @Override public &lt;T&gt; T create(Class&lt;T&gt; type) &#123; return super.create(type); &#125; @Override public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123; return super.create(type, constructorArgTypes, constructorArgs); &#125; @Override public void setProperties(Properties properties) &#123; super.setProperties(properties); &#125; @Override public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) &#123; return Collection.class.isAssignableFrom(type); &#125;&#125;&lt;!-- mybatis-config.xml --&gt;&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt; &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;&lt;/objectFactory&gt; ObjectFactory 接口很简单，它包含两个创建实例用的方法，一个是处理默认无参构造方法的，另外一个是处理带参数的构造方法的。 另外，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。 插件（plugins）MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) 这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。 123456789101112131415161718192021222324252627// ExamplePlugin.java@Intercepts(&#123;@Signature( type= Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; private Properties properties = new Properties(); @Override public Object intercept(Invocation invocation) throws Throwable &#123; // implement pre processing if need Object returnObject = invocation.proceed(); // implement post processing if need return returnObject; &#125; @Override public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125;&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt; &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。 提示 覆盖配置类 除了用插件来修改 MyBatis 核心行为以外，还可以通过完全覆盖配置类来达到目的。只需继承配置类后覆盖其中的某个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会极大影响 MyBatis 的行为，务请慎之又慎。 环境配置（environments）MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单： 每个数据库对应一个 SqlSessionFactory 实例 为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是： 12SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 如果忽略了环境参数，那么将会加载默认环境，如下所示： 12SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties); environments 元素定义了如何配置环境。 12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意一些关键点: 默认使用的环境 ID（比如：default&#x3D;”development”）。 每个 environment 元素定义的环境 ID（比如：id&#x3D;”development”）。 事务管理器的配置（比如：type&#x3D;”JDBC”）。 数据源的配置（比如：type&#x3D;”POOLED”）。 默认环境和环境 ID 顾名思义。 环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。 事务管理器（transactionManager） 在 MyBatis 中有两种类型的事务管理器（也就是 type&#x3D;”[JDBC|MANAGED]”）： JDBC – 这个配置直接使用了 JDBC 的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。默认情况下，为了与某些驱动程序兼容，它在关闭连接时启用自动提交。然而，对于某些驱动程序来说，启用自动提交不仅是不必要的，而且是一个代价高昂的操作。因此，从 3.5.10 版本开始，你可以通过将 “skipSetAutoCommitOnClose” 属性设置为 “true” 来跳过这个步骤。例如： 123&lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;skipSetAutoCommitOnClose&quot; value=&quot;true&quot;/&gt;&lt;/transactionManager&gt; MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如: 123&lt;transactionManager type=&quot;MANAGED&quot;&gt; &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt; 提示 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以用 TransactionFactory 接口实现类的全限定名或类型别名代替它们。 1234567public interface TransactionFactory &#123; default void setProperties(Properties props) &#123; // 从 3.5.2 开始，该方法为默认方法 // 空实现 &#125; Transaction newTransaction(Connection conn); Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);&#125; 在事务管理器实例化后，所有在 XML 中配置的属性将会被传递给 setProperties() 方法。你的实现还需要创建一个 Transaction 接口的实现类，这个接口也很简单： 1234567public interface Transaction &#123; Connection getConnection() throws SQLException; void commit() throws SQLException; void rollback() throws SQLException; void close() throws SQLException; Integer getTimeout() throws SQLException;&#125; 使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。 数据源（dataSource） dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。 有三种内建的数据源类型（也就是 type&#x3D;”[UNPOOLED|POOLED|JNDI]”）： UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性： driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 java.sql.Connection#setNetworkTimeout() 的 API 文档以获取更多信息。 作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如： driver.encoding=UTF8 这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为 UTF8 的 encoding 属性给数据库驱动。 POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。 除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源： poolMaximumActiveConnections – 在任意时间可存在的活动（正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。 poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3（新增于 3.4.5） poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。 poolPingEnabled – 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。 poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性： initial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。 data_source – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。 和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给 InitialContext。比如： env.encoding=UTF8 这就会在 InitialContext 实例化时往它的构造方法传递值为 UTF8 的 encoding 属性。 你可以通过实现接口 org.apache.ibatis.datasource.DataSourceFactory 来使用第三方数据源实现： 1234public interface DataSourceFactory &#123; void setProperties(Properties props); DataSource getDataSource();&#125; org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码： 123456789import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3P0DataSourceFactory extends UnpooledDataSourceFactory &#123; public C3P0DataSourceFactory() &#123; this.dataSource = new ComboPooledDataSource(); &#125;&#125; 为了令其工作，记得在配置文件中为每个希望 MyBatis 调用的 setter 方法增加对应的属性。 下面是一个可以连接至 PostgreSQL 数据库的例子： 123456&lt;dataSource type=&quot;org.myproject.C3P0DataSourceFactory&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql:mydb&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/dataSource&gt; 数据库厂商标识（databaseIdProvider）MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载带有匹配当前数据库 databaseId 属性和所有不带 databaseId 属性的语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性，只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可： 1&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt; databaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为 DatabaseMetaData#getDatabaseProductName() 返回的字符串。 由于通常情况下这些字符串都非常长，而且相同产品的不同版本会返回不同的值，你可能想通过设置属性别名来使其变短： 12345&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt; &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;&lt;/databaseIdProvider&gt; 在提供了属性别名时，databaseIdProvider 的 DB_VENDOR 实现会将 databaseId 设置为数据库产品名与属性中的名称第一个相匹配的值，如果没有匹配的属性，将会设置为 “null”。 在这个例子中，如果 getDatabaseProductName() 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。 你可以通过实现接口 org.apache.ibatis.mapping.DatabaseIdProvider 并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider： 123456public interface DatabaseIdProvider &#123; default void setProperties(Properties p) &#123; // 从 3.5.2 开始，该方法为默认方法 // 空实现 &#125; String getDatabaseId(DataSource dataSource) throws SQLException;&#125; 映射器（mappers）既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。例如： 12345678910111213141516171819202122&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 这些配置会告诉 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，也就是接下来我们要讨论的。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"}]},{"title":"SpringBoot框架 引入外部Jar包","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架-引入外部Jar包","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架-引入外部Jar包/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6-%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8Jar%E5%8C%85/","excerpt":"","text":"转载自：https://blog.csdn.net/m0_67401746/article/details/124035099 在项目中，有时候需要引入外部jar包，启动运行。有两种方式，一种是直接在项目中添加jar包，另一种是在本地maven仓库中添加jar包，然后在pom.xml文件中引入依赖。 第一种方式：在项目中添加jar包step1：在src&#x2F;main&#x2F;resources下创建lib目录，然后将jar包放在该目录下 step2：然后在project structure中引入该lib 第二种方式：在pom.xml文件中引入外部jar包step1：通过命令行方式，在本地maven仓库中添加jar包 打开cmd，执行mvn命令 mvn install:install-file -DgroupId=com.awen.testjar -DartifactId=awen-testjar -Dversion=1.0 -Dpackaging=jar -Dfile=D:developawen-testjar.jar DgroupId：建议为包路径 DartifactId：jar包名称 Dversion：jar包版本号 Dpackaging：jar Dfile：本地jar包地址 step2：在pom.xml文件中引入该依赖 com.awen.testjar awen-testjar 1.0","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Jar","slug":"Jar","permalink":"https://guoshunfa.com/tags/Jar/"}]},{"title":"SpringBoot框架 类的理解与使用","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架-类的理解与使用","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架-类的理解与使用/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6-%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"@RestController 和 @RequestMapping 注解12345678910111213141516171819import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@EnableAutoConfigurationpublic class MyApplication &#123; @RequestMapping(&quot;/&quot;) String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(MyApplication.class, args); &#125;&#125; MyApplication我们班级的第一个注解是@RestController. 这称为构造型注释。它为阅读代码的人和 Spring 提供了该类扮演特定角色的提示。在这种情况下，我们的类是一个 web @Controller，因此 Spring 在处理传入的 web 请求时会考虑它。 @RequestMapping注释提供“路由”信息。它告诉 Spring，任何带有/路径的 HTTP 请求都应该映射到该home方法。注释告诉 Spring将@RestController结果字符串直接呈现给调用者。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"SpringBoot框架 常用类","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架常用类","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架常用类/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6%E5%B8%B8%E7%94%A8%E7%B1%BB/","excerpt":"","text":"记录SpringBoot 常用类，作用和用法。 1. CommandLineRunner(接口) 项目构建 预加载 ApplicationRunner 同理。有时间总结两者的区别。 在使用SpringBoot构建项目时，有一些预先数据的加载。 demo: 1234567891011121314151617@Component@Order(1)public class Run01 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;run01&quot;); &#125;&#125;@Component@Order(2)public class Run02 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;run02&quot;); &#125;&#125; 输出: 12run01run02","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"SpringMVC 前后端传参","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringMVC-前后端传参","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/SpringMVC-前后端传参/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringMVC-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%8F%82/","excerpt":"","text":"ModelAndView + thymeleaf 废话不多说，直接上demo。 properties: 1234567891011121314# ----------------------Springmvc配置-----------------------------# 指定前端页面的前缀spring.mvc.view.prefix=/# 指定前端页面的后缀spring.mvc.view.suffix=.html# ------------------------thymeleaf配置-----------------------------------spring.thymeleaf.servlet.content-type=text/html# 指定文件路径spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.check-template=falsespring.thymeleaf.check-template-location=falsespring.thymeleaf.mode=HTMLspring.thymeleaf.encoding=UTF-8spring.thymeleaf.cache=false maven: 123456&lt;!-- thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- 省略其他springboot包 --&gt; controller: 1234567891011// 页面跳转controller@Controllerpublic class PageController &#123; @RequestMapping(&quot;/&quot;) public ModelAndView index() &#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;testParam&quot;, &quot;欧吼&quot;); mav.setViewName(&quot;index&quot;); return mav; &#125;&#125; html: 12345678&lt;html lang=&quot;zh-CN&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;script th:inline=&quot;javascript&quot;&gt; var testParam = [[$&#123;testParam&#125;]]; console.log(testParam)&lt;/script&gt;&lt;/html&gt; 效果：","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://guoshunfa.com/tags/SpringMVC/"}]},{"title":"SpringBoot框架 项目启动时执行","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringBoot框架-项目启动时执行","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.308Z","comments":true,"path":"2022/07/SpringBoot框架-项目启动时执行/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringBoot%E6%A1%86%E6%9E%B6-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8C/","excerpt":"","text":"有时需要在项目启动时加载一部分数据，这时就要有一部分代码在项目启动时运行。 Springboot项目实现启动时运行代码的方式有四种。 1. PostConstruct注解12345678910111213import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;@Componentpublic class Init1 &#123; @PostConstruct public void init() &#123; System.out.println(&quot;init1&quot;); &#125;&#125; 2. 实现InitializingBean接口12345678910import org.springframework.beans.factory.InitializingBean;import org.springframework.stereotype.Component;@Componentpublic class Init2 implements InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;init2&quot;); &#125;&#125; 3. 实现CommandLineRunner接口可以通过在类型加@Order注解来控制执行顺序。 12345678910import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;@Componentpublic class Init3 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;init3&quot;); &#125;&#125; 4. 放在SpringBoot启动类中123456789@SpringBootApplicationpublic class PandaBaseApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PandaBaseApplication.class, args); System.out.println(&quot;init4&quot;); &#125;&#125;","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"}]},{"title":"SpringSecurity框架 官方介绍","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringSecurity框架官方介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/SpringSecurity框架官方介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringSecurity%E6%A1%86%E6%9E%B6%E5%AE%98%E6%96%B9%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"SpringSecurity 官方 概述Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架。它是保护基于 Spring 的应用程序的事实标准。 Spring Security 是一个专注于为 Java 应用程序提供身份验证和授权的框架。与所有 Spring 项目一样，Spring Security 的真正强大之处在于它可以轻松扩展以满足自定义需求 特征 对身份验证和授权的全面和可扩展支持 防止会话固定、点击劫持、跨站点请求伪造等攻击 Servlet API 集成 可选择与 Spring Web MVC 集成 多得多… 资源 获得帮助 获取 Spring Security 入门 入门（Servlet） 入门 (WebFlux) 贡献 学习 每个Spring 项目都有自己的；它非常详细地解释了如何使用项目功能以及使用它们可以实现什么。 版本 参考文档 API文档 5.7.5 当前的 遗传算法 参考文档 API文档。 6.0.0-快照 快照 参考文档 API文档。 6.0.0-RC1 前 参考文档 API文档。 5.8.0-快照 快照 参考文档 API文档。 5.8.0-RC1 前 参考文档 API文档。 5.7.6-快照 快照 参考文档 API文档。 5.6.10-快照 快照 参考文档 API文档。 5.6.9 遗传算法 参考文档 API文档。 5.5.8 遗传算法 参考文档 API文档。 5.4.10 遗传算法 参考文档 API文档。 5.3.13.发布 遗传算法 参考文档 API文档。 5.2.15.发布 遗传算法 参考文档 API文档。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://guoshunfa.com/tags/SpringSecurity/"}]},{"title":"Spring 介绍","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/Spring介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/Spring介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Spring%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Spring官网 为什么是Spring？Spring 使每个人的 Java 编程更快、更容易、更安全。Spring 对速度、简单性和生产力的关注使其成为世界上最受欢迎的Java框架。 到处都是SpringSpring 的灵活库受到全世界开发人员的信任。Spring 每天为数百万最终用户提供令人愉悦的体验——无论是流媒体电视,网上购物，或无数其他创新解决方案。Spring 也有来自科技界所有知名人士的贡献，包括阿里巴巴、亚马逊、谷歌、微软等。 Spring很灵活Spring 灵活而全面的扩展集和第三方库让开发人员可以构建几乎任何可以想象到的应用程序。Spring Framework 的核心是控制反转 (IoC)和依赖注入（DI）特性为广泛的特性和功能集提供了基础。无论您是为 Web 构建安全、响应式、基于云的微服务，还是为企业构建复杂的流数据流，Spring 都有可以提供帮助的工具。 Spring多产弹簧靴改变您处理 Java 编程任务的方式，从根本上简化您的体验。Spring Boot 结合了应用程序上下文和自动配置的嵌入式 Web 服务器等必需品，使微服务发展不在话下。为了更快地进行，您可以将 Spring Boot 与 Spring Cloud 丰富的支持库、服务器、模式和模板组合，以安全地将整个基于微服务的架构部署到云，创纪录的时间。 Spring快我们的工程师非常关心性能。使用 Spring，您会注意到默认情况下的快速启动、快速关闭和优化执行。越来越多的Spring项目也支持被动的（非阻塞）编程模型以获得更高的效率。开发人员生产力是 Spring 的超能力。Spring Boot 可帮助开发人员轻松构建应用程序，而且与其他竞争范例相比，工作量要少得多。嵌入式 Web 服务器、自动配置和“fat jar”可帮助您快速入门，创新如Spring DevTools 中的 LiveReload意味着开发人员可以比以往更快地进行迭代。您甚至可以在几秒钟内启动一个新的 Spring 项目，使用 Spring Initializr启动.spring.io.","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://guoshunfa.com/tags/Spring/"}]},{"title":"Spring框架 PackageInfo的使用","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/Spring框架PackageInfo的使用","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/Spring框架PackageInfo的使用/","link":"","permalink":"https://guoshunfa.com/2022/07/Spring%E6%A1%86%E6%9E%B6PackageInfo%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"场景以包(package)为范围进行配置。如：将注解直接加到包的维度。 创建package-info.java 使用eclipse进行创建包时，可以勾选“Create package-info.java”按钮，进行创建。 如果创建包时没有创建package-info.java，只能在包对应文件夹里，手动创建一个package-info.java，写上包名，最后刷新ide即可。 package-info.java的使用 提供包级别的类(或接口)，这些类(或接口)只有本包里才能访问，即使是子包也不能访问。 提供包的整体注释说明。 package-info.java 1234567891011121314151617181920212223242526272829303132/** * &lt;b&gt;package-info不是平常类，其作用有三个:&lt;/b&gt;&lt;br&gt; * 1、为标注在包上Annotation提供便利；&lt;br&gt; * 2、声明包的私有类和常量；&lt;br&gt; * 3、提供包的整体注释说明。&lt;br&gt; */ @JyzTargetPackage(version=&quot;1.0&quot;) package com.jyz.study.jdk.annotation; class PackageInfo&#123; public void common()&#123; System.out.println(&quot;sa&quot;); &#125; &#125; class PackageInfoGeneric&lt;T extends Throwable&gt;&#123; private T obj; public void set(T obj)&#123; this.obj = obj; &#125; public void common()&#123; System.out.println(obj + &quot;sa&quot;); &#125; &#125; interface packageInfoInteger&#123; public void test(); &#125; class PackageConstants&#123; public static final String ERROE_CODE = &quot;100001&quot;; &#125; TestPackageInfo.java 1234567891011121314151617181920212223242526272829303132333435363738394041package com.jyz.study.jdk.annotation; import java.io.IOException; /** * 测试package-info.java文件的作用 * 1、为标注在包上Annotation提供便利；&lt;br&gt; * 2、声明包的私有类和常量；&lt;br&gt; * @author JoyoungZhang@gmail.com * */ public class TestPackageInfo &#123; public static void main(String[] args) &#123; //1 Package p = Package.getPackage(&quot;com.jyz.study.jdk.annotation&quot;); if(p != null &amp;&amp; p.isAnnotationPresent(JyzTargetPackage.class))&#123; JyzTargetPackage nav = p.getAnnotation(JyzTargetPackage.class); if(nav != null)&#123; System.out.println(&quot;package version:&quot; + nav.version()); &#125; &#125; //2 PackageInfo packageInfo = new PackageInfo(); packageInfo.common(); //泛型也能很好的工作，在pakcage-info.java里定义的类和普通类没什么区别 PackageInfoGeneric&lt;Exception&gt; packageInfoGeneric = new PackageInfoGeneric&lt;Exception&gt;(); packageInfoGeneric.set(new IOException(&quot;device io&quot;)); packageInfoGeneric.common(); Sub sub = new Sub(); sub.test(); System.out.println(PackageConstants.ERROE_CODE); &#125; &#125; class Sub implements packageInfoInteger&#123; @Override public void test() &#123; System.out.println(&quot;sub&quot;); &#125; &#125; Console output 12345package version:1.0 sa java.io.IOException: device iosa sub 100001 需要注意两点 package-info.java里不能声明public class(或 interface) 刚开始p.isAnnotationPresent(JyzTargetPackage.class)返回false，后来找到原因JyzTargetPackage没有加上@Retention(RetentionPolicy.RUNTIME)。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://guoshunfa.com/tags/Spring/"}]},{"title":"Spring框架 SpringEvent","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/Spring框架SpringEvent","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/Spring框架SpringEvent/","link":"","permalink":"https://guoshunfa.com/2022/07/Spring%E6%A1%86%E6%9E%B6SpringEvent/","excerpt":"","text":"Spring 官方文档翻译如下 ： ApplicationContext 通过 ApplicationEvent 类和 ApplicationListener 接口进行事件处理。 如果将实现 ApplicationListener 接口的 bean 注入到上下文中，则每次使用 ApplicationContext 发布 ApplicationEvent 时，都会通知该 bean。 本质上，这是标准的观察者设计模式。 Spring的事件（Application Event）其实就是一个观察者设计模式，一个 Bean 处理完成任务后希望通知其它 Bean 或者说 一个Bean 想观察监听另一个Bean的行为。 Spring 事件只需要几步： 自定义事件，继承 ApplicationEvent 定义监听器，实现 ApplicationListener 或者通过 @EventListener 注解到方法上 定义发布者，通过 ApplicationEventPublisher 1. 自定义Event1234567891011@Datapublic class DemoEvent extends ApplicationEvent &#123; private Long id; private String message; public DemoEvent(Object source, Long id, String message) &#123; super(source); this.id = id; this.message = message; &#125;&#125; 事件没要处理的监听器，就会被抛弃。 一个事件可以同时被多个监听处理类监听处理。 如果代码结构较复杂，多处发布相同的事件，建议发布事件时将this作为source传递，便于通过分析日志确定发布源。 以上处理事件都是同步的，如果发布事件处的业务存在事务，监听器处理也会在相同的事务中。这个一定要注意！如果对于事件的处理不想受到影响，可以onApplicationEvent方法上加@Aync支持异步(参考taskExecutor的使用)。 原理部分可以参考 博客 事件体系 2. 监听器 监听器分为两种方式，一种是实现ApplicationListener 接口，一种是方法上加@EventListener注解。 实现ApplicationListener 接口 12345678910@Componentpublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123; @Override public void onApplicationEvent(DemoEvent demoEvent) &#123; System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DemoListener&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); System.out.println(&quot;收到了：&quot; + demoEvent.getSource() + &quot;消息;时间：&quot; + demoEvent.getTimestamp()); System.out.println(&quot;消息：&quot; + demoEvent.getId() + &quot;:&quot; + demoEvent.getMessage()); &#125;&#125; 泛型为需要监听的事件类型 如果要实现有序的监听，实现SmartApplicationListener 接口即可。 @EventListener 12345678910@Componentpublic class DemoListener2 &#123; @EventListener public void onApplicationEvent(DemoEvent demoEvent) &#123; System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DemoListener2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); System.out.println(&quot;收到了：&quot; + demoEvent.getSource() + &quot;消息;时间：&quot; + demoEvent.getTimestamp()); System.out.println(&quot;消息：&quot; + demoEvent.getId() + &quot;:&quot; + demoEvent.getMessage()); &#125;&#125; 会根据方法参数类型来自动监听相应事件的发布。 如果要监听多个事件类型的发布，可以在@EventListener(classes &#x3D; {FaceEvent.class,ArmEvent.class})指定，spring会多次调用此方法来处理多个事件。但是注意此时，方法参数不能有多个，否则会发生转换异常，可以将使用多个事件的父类作为唯一的方法参数来接收处理事件，但除非必要否则并不推荐监听多个事件的发布。 ​ 如果有多个监听器监听同一事件，我们可以在方法上使用spring的@order注解来定义多个监听器的顺序，如： 123456789101112131415161718@EventListener @Order(4) public void onApplicationEvent(FaceEvent event) &#123; User user = (User) event.getSource(); LOGGER.info(&quot;===&gt; A 收到人脸事件: &#123;&#125;&quot;,user); &#125; @EventListener(&#123;FaceEvent.class,ArmEvent.class&#125;) @Order(3) public void onApplicationEvent3(Object event) &#123; if(event instanceof FaceEvent)&#123; LOGGER.info(&quot;===&gt; B 收到人脸事件: &#123;&#125;&quot;,((FaceEvent) event).getEventData()); &#125;else if(event instanceof ArmEvent)&#123; ArmEvent armEvent = (ArmEvent) event; LOGGER.info(&quot;===&gt; B 收到臂膀事件: &#123;&#125;&quot;,armEvent.getEventData()); &#125; &#125; @EventListener还有一个属性，condition（）里可以使用SPEL表达式来过滤监听到事件，即只有符合某种条件的才进行接收处理。暂时还用不到。 3. 消息发布者123456789101112131415@Componentpublic class DemoPublisher &#123; private final ApplicationContext applicationContext; @Autowired public DemoPublisher(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; &#125; public void publish(long id, String message) &#123; applicationContext.publishEvent(new DemoEvent(this, id, message)); &#125;&#125; 扩展： 我们可以通过工具类发布来避免在代码耦合注入ApplicationContext，工具类实现ApplicationEventPublisherAware 接口，具体可参考spring的aware学习。 这里有一个小细节，如果通过注入ApplicationContext的方式来发布事件，idea在代码左边会有一个类似耳机的小图标，点击可以跳到监听此发布事件的监听者位置，用工具类发布事件就没有此提示了。 4. 测试方法1234@Testpublic void publisherTest() &#123; demoPublisher.publish(1L, &quot;成功了！&quot;);&#125; 5. 结果123456&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DemoListener2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;收到了：com.jiuxian.publisher.DemoPublisher@3a62c01e消息;时间：1551762322376消息：1:成功了！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;DemoListener&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;收到了：com.jiuxian.publisher.DemoPublisher@3a62c01e消息;时间：1551762322376消息：1:成功了！ 6. 示例源码GitHub https://github.com/Zejun-Liu/SpringBoot2.0/tree/master/springboot-event 7. 扩展 - 监听事件时的事务隔离​ @TransactionalEventListener和@EventListener都可以监听事件，但前者可以对发布事件和监听事件进行一些事务上的隔离。 ​ @TransactionalEventListenerr指不和发布事件的方法在同一个事务内，发布事件的方法事务结束后才会执行本监听方法，监听逻辑内发生异常不会回滚发布事件方法的事务。 12345678910111213@Transactional(rollbackFor = Exception.class)public void handle()&#123; User user = new User(); user.setAge(34); user.setUsername(&quot;人脸事件&quot;); user.setHobby(&quot;抓拍&quot;); //处理完上面的逻辑后，发布事件 EventPublisherUtil.publishEvent(new FaceEvent(user)); //数据库添加操作 Integer integer = deviceAlarmService.addDevice();&#125; 可以看到发布事件的方法处在事务控制中，我们使用@TransactionalEventListener来监听事件： 123456789@TransactionalEventListener(fallbackExecution = true)public void onApplicationEvent(FaceEvent event) &#123; User user = event.getEventData(); LOGGER.info(&quot;===&gt; A 收到人脸事件: &#123;&#125;&#125;&quot;,user); //@TransactionalEventListener指不和发布事件的在同一个事务内，发布事件的方法事务结束后才会执行本方法 // ，本方法发生异常不会回滚发布事件的事务， throw new RuntimeException(&quot;监听事件抛出异常&quot;);&#125; 运行结果，addDevice正常在数据库插入数据，但是修改为@EventListener监听则插入数据失败。 ​ @TransactionalEventListener有一个属性为fallbackExecution，默认为false，指发布事件的方法没有事务控制时，监听器不进行监听事件，此为默认情况！ fallbackExecution&#x3D;true，则指发布事件的方法没有事务控制时，监听方法仍可以监听事件进行处理。 1234/** * Whether the event should be processed if no transaction is running. */ boolean fallbackExecution() default false; ​ 刚才我们说到使用@TransactionalEventListener会在发布事件的方法事务结束后执行监听方法，但其实我们还可以进行细化的控制。它有一个属性为TransactionPhase，默认为TransactionPhase.AFTER_COMMIT，即事务提交后。还可以根据需要选择AFTER_COMPLETION、BEFORE_COMMIT、AFTER_ROLLBACK。​ 但仍需注意，如果fallbackExecution&#x3D;false，且发布事件的方法没有事务控制时，监听器根本不会监听到事件，此处的TransactionPhase也就没有意义了。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://guoshunfa.com/tags/Spring/"},{"name":"SpringEvent","slug":"SpringEvent","permalink":"https://guoshunfa.com/tags/SpringEvent/"}]},{"title":"Spring框架 Spring事务","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/Spring框架Spring事务","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/Spring框架Spring事务/","link":"","permalink":"https://guoshunfa.com/2022/07/Spring%E6%A1%86%E6%9E%B6Spring%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"Spring框架 - Spring事务事务操作（事务概念）1 、什么事务（ 1 ）事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败（ 2 ）典型场景：银行转账 lucy 转账 100 元 给mary lucy少 100 ，mary多 100 2 、事务四个特性（ ACID ）（ 1 ）原子性（ 2 ）一致性（ 3 ）隔离性（ 4 ）持久性 事务操作（搭建事务操作环境）1 、创建数据库表，添加记录 2 、创建 service ，搭建 dao ，完成对象创建和注入关系（ 1 ）service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Servicepublic class UserService &#123;//注入dao@Autowiredprivate UserDao userDao;&#125;@Repositorypublic class UserDaoImpl implements UserDao &#123;@Autowiredprivate JdbcTemplate jdbcTemplate;&#125;**3** 、在 **dao** 创建两个方法：多钱和少钱的方法，在 **service** 创建方法（转账的方法）@Repositorypublic class UserDaoImpl implements UserDao &#123;@Autowiredprivate JdbcTemplate jdbcTemplate;//lucy转账 100 给mary//少钱@Overridepublic void reduceMoney() &#123;String sql = &quot;update t_account set money=money-? where username=?&quot;;jdbcTemplate.update(sql, 100 ,&quot;lucy&quot;);&#125;//多钱@Overridepublic void addMoney() &#123;String sql = &quot;update t_account set money=money+? where username=?&quot;;jdbcTemplate.update(sql, 100 ,&quot;mary&quot;);&#125;&#125;@Servicepublic class UserService &#123;//注入dao@Autowiredprivate UserDao userDao;//转账的方法public void accountMoney() &#123;//lucy少 100userDao.reduceMoney();//mary多 100userDao.addMoney();&#125;&#125; 4 、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常，有问题 （ 1 ）上面问题如何解决呢？ 使用事务进行解决 （ 2 ）事务操作过程 事务操作（ Spring 事务管理介绍）1 、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 2 、在 Spring 进行事务管理操作（ 1 ）有两种方式：编程式事务管理和声明式事务管理（使用） 3 、声明式事务管理（ 1 ）基于注解方式（使用）（ 2 ）基于xml配置文件方式 4 、在 Spring 进行声明式事务管理，底层使用 AOP 原理 5 、 Spring 事务管理 API（ 1 ）提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 事务操作（注解声明式事务管理）1 、在 spring 配置文件配置事务管理器 123456&lt;!--创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!--注入数据源--&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2 、在 spring 配置文件，开启事务注解（ 1 ）在spring配置文件引入名称空间 tx 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans[http://www.springframework.org/schema/beans/spring-beans.xsd](http://www.springframework.org/schema/beans/spring-beans.xsd)[http://www.springframework.org/schema/context](http://www.springframework.org/schema/context)[http://www.springframework.org/schema/context/spring-context.xsd](http://www.springframework.org/schema/context/spring-context.xsd)[http://www.springframework.org/schema/aop](http://www.springframework.org/schema/aop)[http://www.springframework.org/schema/aop/spring-aop.xsd](http://www.springframework.org/schema/aop/spring-aop.xsd)[http://www.springframework.org/schema/tx](http://www.springframework.org/schema/tx)[http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;](http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;) （ 2 ）开启事务注解 123&lt;!--开启事务注解--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 3 、在 service 类上面（或者 service 类里面方法上面）添加事务注解（ 1 ）@Transactional，这个注解添加到类上面，也可以添加方法上面（ 2 ）如果把这个注解添加类上面，这个类里面所有的方法都添加事务（ 3 ）如果把这个注解添加方法上面，为这个方法添加事务 123@Service@Transactionalpublic class UserService &#123; 事务操作（声明式事务管理参数配置）1 、在 service 类上面添加注解 @Transactional ，在这个注解里面可以配置事务相关参数 2 、 propagation ：事务传播行为（ 1 ）多事务方法直接进行调用，这个过程中事务 是如何进行管理的 3 、 ioslation ：事务隔离级别（ 1 ）事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题（ 2 ）有三个读问题：脏读、不可重复读、虚（幻）读（ 3 ）脏读：一个未提交事务读取到另一个未提交事务的数据 （ 4 ）不可重复读：一个未提交事务读取到另一提交事务修改数据 （ 5 ）虚读：一个未提交事务读取到另一提交事务添加数据 （ 6 ）解决：通过设置事务隔离级别，解决读问题 4 、 timeout ：超时时间（ 1 ）事务需要在一定时间内进行提交，如果不提交进行回滚（ 2 ）默认值是 - 1 ，设置时间以秒单位进行计算 5 、 readOnly ：是否只读（ 1 ）读：查询操作，写：添加修改删除操作（ 2 ）readOnly默认值false，表示可以查询，可以添加修改删除操作（ 3 ）设置readOnly值是true，设置成true之后，只能查询 6 、 rollbackFor ：回滚（ 1 ）设置出现哪些异常进行事务回滚 7 、 noRollbackFor ：不回滚（ 1 ）设置出现哪些异常不进行事务回滚 事务操作（ XML 声明式事务管理）1 、在 spring 配置文件中进行配置第一步 配置事务管理器第二步 配置通知 第三步 配置切入点和切面 12345678910111213141516171819202122232425&lt;!-- 1 创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!--注入数据源--&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2 配置通知--&gt;&lt;tx:advice id=&quot;txadvice&quot;&gt;&lt;!--配置事务参数--&gt;&lt;tx:attributes&gt;&lt;!--指定哪种规则的方法上面添加事务--&gt;&lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 3 配置切入点和切面--&gt;&lt;aop:config&gt;&lt;!--配置切入点--&gt;&lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(*com.atguigu.spring5.service.UserService.*(..))&quot;/&gt;&lt;!--配置切面--&gt;&lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt;&lt;/aop:config&gt; 事务操作（完全注解声明式事务管理）1 、创建配置类，使用配置类替代 xml 配置文件 12345678910111213141516171819202122232425262728293031323334@Configuration //配置类@ComponentScan(basePackages = &quot;com.atguigu&quot;) //组件扫描@EnableTransactionManagement //开启事务public class TxConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; //创建JdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123; //到ioc容器中根据类型找到dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125;","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://guoshunfa.com/tags/Spring/"}]},{"title":"SpringSecurity框架 理解与使用","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/SpringSecurity框架理解与使用","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/SpringSecurity框架理解与使用/","link":"","permalink":"https://guoshunfa.com/2022/07/SpringSecurity%E6%A1%86%E6%9E%B6%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"转载自：三更草堂(b站up主) 0. 简介​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 ​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 ​ 一般Web应用的需要进行认证和授权。 ​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 ​ 授权：经过认证后判断当前用户是否有权限进行某个操作 ​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。 1. 快速入门1.1 准备工作​ 我们先要搭建一个简单的SpringBoot工程 ① 设置父工程 添加依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ② 创建启动类 12345678@SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class,args); &#125;&#125; ③ 创建Controller 123456789101112import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 1.2 引入SpringSecurity​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。 ​ 必须登陆之后才能对接口进行访问。 2. 认证2.1 登陆校验流程 2.2 原理初探​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。 2.2.1 SpringSecurity完整流程​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 ​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 FilterSecurityInterceptor：负责权限校验的过滤器。 ​ ​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 2.2.2 认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 2.3 解决问题2.3.1 思路分析登录 ​ ①自定义登录接口 ​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt ​ 把用户信息存入redis中 ​ ②自定义UserDetailsService ​ 在这个实现类中去查询数据库 校验： ​ ①定义Jwt认证过滤器 ​ 获取token ​ 解析token获取其中的userid ​ 从redis中获取用户信息 ​ 存入SecurityContextHolder 2.3.2 准备工作①添加依赖 1234567891011121314151617&lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--jwt依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; ② 添加Redis相关配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 * * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; 123456789101112131415161718192021222324252627282930import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; ③ 响应类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import com.fasterxml.jackson.annotation.JsonInclude;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123; /** * 状态码 */ private Integer code; /** * 提示信息，如果有错误时，前端可以获取该字段进行提示 */ private String msg; /** * 查询到的结果数据， */ private T data; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, T data) &#123; this.code = code; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ResponseResult(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125;&#125; ④工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; 123456789101112131415161718192021222324252627import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ⑤实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.Serializable;import java.util.Date;/** * 用户表(User)实体类 * * @author 三更 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = -40356785423868312L; /** * 主键 */ private Long id; /** * 用户名 */ private String userName; /** * 昵称 */ private String nickName; /** * 密码 */ private String password; /** * 账号状态（0正常 1停用） */ private String status; /** * 邮箱 */ private String email; /** * 手机号 */ private String phonenumber; /** * 用户性别（0男，1女，2未知） */ private String sex; /** * 头像 */ private String avatar; /** * 用户类型（0管理员，1普通用户） */ private String userType; /** * 创建人的用户id */ private Long createBy; /** * 创建时间 */ private Date createTime; /** * 更新人 */ private Long updateBy; /** * 更新时间 */ private Date updateTime; /** * 删除标志（0代表未删除，1代表已删除） */ private Integer delFlag;&#125; 2.3.3 实现2.3.3.1 数据库校验用户​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。 准备工作​ 我们先创建一个用户表， 建表语句如下： 123456789101112131415161718CREATE TABLE `sys_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27; ​ 引入MybatisPuls和mysql驱动的依赖 123456789&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ​ 配置数据库信息 123456spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver ​ 定义Mapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; ​ 修改User实体类 1类名上加@TableName(value = &quot;sys_user&quot;) ,id字段上加 @TableId ​ 配置Mapper扫描 12345678@SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SimpleSecurityApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class); System.out.println(run); &#125;&#125; ​ 添加junit依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; ​ 测试MP是否能正常使用 123456789101112131415/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testUserMapper()&#123; List&lt;User&gt; users = userMapper.selectList(null); System.out.println(users); &#125;&#125; 核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息 12345678910111213141516171819202122232425/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询用户信息 LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); //如果查询不到数据就通过抛出异常来给出提示 if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 //封装成UserDetails对象返回 return new LoginUser(user); &#125;&#125; 因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructor@AllArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如 这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。 2.3.3.2 密码加密存储​ 实际项目中我们不会把密码明文存储在数据库中。 ​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 ​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 12345678910111213/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.3.3.3 登陆接口​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 ​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。 ​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 123456789101112@RestControllerpublic class LoginController &#123; @Autowired private LoginServcie loginServcie; @PostMapping(&quot;/user/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginServcie.login(user); &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; ​ 12345678910111213141516171819202122232425262728@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125;&#125; 2.3.3.4 认证过滤器​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。 ​ 使用userid去redis中获取对应的LoginUser对象。 ​ 然后封装Authentication对象存入SecurityContextHolder 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; //放行 filterChain.doFilter(request, response); return; &#125; //解析token String userid; try &#123; Claims claims = JwtUtil.parseJWT(token); userid = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; //从redis中获取用户信息 String redisKey = &quot;login:&quot; + userid; LoginUser loginUser = redisCache.getCacheObject(redisKey); if(Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication中 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行 filterChain.doFilter(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //把token校验过滤器添加到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 2.3.3.5 退出登陆​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125; @Override public ResponseResult logout() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userid = loginUser.getUser().getId(); redisCache.deleteObject(&quot;login:&quot;+userid); return new ResponseResult(200,&quot;退出成功&quot;); &#125;&#125; 3. 授权3.0 权限系统的作用​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 ​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 ​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 ​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 ​ 3.1 授权基本流程​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。 ​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。 ​ 然后设置我们的资源所需要的权限即可。 3.2 授权实现3.2.1 限制访问资源所需权限​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。 ​ 但是要使用它我们需要先开启相关配置。 1@EnableGlobalMethodSecurity(prePostEnabled = true) ​ 然后就可以使用对应的注解。@PreAuthorize 123456789@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 3.2.2 封装权限信息​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。 ​ 我们先直接把权限信息写死封装到UserDetails中进行测试。 ​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.sangeng.domain;import com.alibaba.fastjson.annotation.JSONField;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user,List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JSONField(serialize = false) private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; ​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sangeng.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;import com.sangeng.domain.LoginUser;import com.sangeng.domain.User;import com.sangeng.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Objects;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,list); &#125;&#125; 3.2.3 从数据库查询权限信息3.2.3.1 RBAC权限模型​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 ​ 3.2.3.2 准备工作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `sg_security`;/*Table structure for table `sys_menu` */DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;菜单表&#x27;;/*Table structure for table `sys_role` */DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;del_flag&#x27;, `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;角色表&#x27;;/*Table structure for table `sys_role_menu` */DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`,`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;/*Table structure for table `sys_user` */DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;/*Table structure for table `sys_user_role` */DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`,`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 1234567891011SELECT DISTINCT m.`perms`FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`WHERE user_id = 2 AND r.`status` = 0 AND m.`status` = 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.sangeng.domain;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;/** * 菜单表(Menu)实体类 * * @author makejava * @since 2021-11-24 15:30:08 */@TableName(value=&quot;sys_menu&quot;)@Data@AllArgsConstructor@NoArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class Menu implements Serializable &#123; private static final long serialVersionUID = -54979041104113736L; @TableId private Long id; /** * 菜单名 */ private String menuName; /** * 路由地址 */ private String path; /** * 组件路径 */ private String component; /** * 菜单状态（0显示 1隐藏） */ private String visible; /** * 菜单状态（0正常 1停用） */ private String status; /** * 权限标识 */ private String perms; /** * 菜单图标 */ private String icon; private Long createBy; private Date createTime; private Long updateBy; private Date updateTime; /** * 是否删除（0未删除 1已删除） */ private Integer delFlag; /** * 备注 */ private String remark;&#125; 3.2.3.3 代码实现​ 我们只需要根据用户id去查询到其所对应的权限信息即可。 ​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。 1234567891011import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.sangeng.domain.Menu;import java.util.List;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; ​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.`perms` FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id` WHERE user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; ​ 在application.yml中配置mapperXML文件的位置 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver redis: host: localhost port: 6379mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml ​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。 1234567891011121314151617181920212223242526/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Autowired private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; List&lt;String&gt; permissionKeyList = menuMapper.selectPermsByUserId(user.getId());// //测试写法// List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,permissionKeyList); &#125;&#125; 4. 自定义失败处理​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 ​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 ​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 ​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 ①自定义实现类 1234567891011@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; 12345678910111213/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; ②配置给SpringSecurity ​ ​ 先注入对应的处理器 12345@Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; ​ 然后我们可以使用HttpSecurity对象的方法去配置。 12http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint). accessDeniedHandler(accessDeniedHandler); 5. 跨域​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 ​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 ​ 所以我们就要处理一下，让前端能进行跨域请求。 ①先对SpringBoot配置，运行跨域请求 12345678910111213141516171819@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; ②开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6. 遗留小问题6.1 其它权限校验方法​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 ​ ​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。 ​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 ​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 ​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 1234@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 6.2 自定义权限校验方法​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。 123456789101112@Component(&quot;ex&quot;)public class SGExpressionRoot &#123; public boolean hasAuthority(String authority)&#123; //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); List&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); &#125;&#125; ​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法 12345@RequestMapping(&quot;/hello&quot;)@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 6.3 基于配置的权限控制​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6.4 CSRF​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。 ​ https://blog.csdn.net/freeking101/article/details/86537087 ​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 ​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。 6.5 认证成功处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 ​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。 123456789@Componentpublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;认证成功了&quot;); &#125;&#125; 1234567891011121314@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 6.6 认证失败处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 ​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。 1234567@Componentpublic class SGFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;认证失败了&quot;); &#125;&#125; 123456789101112131415161718192021@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 6.7 登出成功处理器12345678@Componentpublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;注销成功&quot;); &#125;&#125; 123456789101112131415161718192021222324252627@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125;","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://guoshunfa.com/tags/SpringSecurity/"}]},{"title":"Spring 调度任务","slug":"软件开发/技术/软件技术框架/各大框架/Spring全家桶/Spring调度任务","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/Spring调度任务/","link":"","permalink":"https://guoshunfa.com/2022/07/Spring%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"什么是调度任务@Scheduled将构建一个应用程序，通过使用 Spring 的注释每五秒打印一次当前时间。 前提要求 最喜欢的文本编辑器或 IDE JDK 1.8或更高版本 Gradle 4+或Maven 3.2+ 如何完成调度任务与大多数 Spring入门指南一样，您可以从头开始并完成每个步骤，也可以绕过您已经熟悉的基本设置步骤。无论哪种方式，您最终都会得到有效的代码。 要从头开始，请转到从 Spring Initializr 开始。 要跳过基础知识，请执行以下操作： 下载并解压缩本指南的源存储库，或使用Git克隆它：git clone https://github.com/spring-guides/gs-scheduling-tasks.git 光盘进入gs-scheduling-tasks/initial 跳到创建计划任务。 完成后，您可以根据 中的代码检查结果gs-scheduling-tasks/complete。 从 Spring Initializr 开始您可以使用这个[预初始化的项目](https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=2.5.5&amp;packaging=jar&amp;jvmVersion=11&amp;groupId=com.example&amp;artifactId=scheduling-tasks&amp;name=scheduling-tasks&amp;description=Demo project for Spring Boot&amp;packageName&#x3D;com.example.scheduling-tasks)并单击生成以下载 ZIP 文件。该项目配置为适合本教程中的示例。 手动初始化项目： 导航到https://start.spring.io。该服务会引入应用程序所需的所有依赖项，并为您完成大部分设置。 选择 Gradle 或 Maven 以及您要使用的语言。本指南假定您选择了 Java。 单击生成。 下载生成的 ZIP 文件，它是根据您的选择配置的 Web 应用程序的存档。 如果您的 IDE 集成了 Spring Initializr，您可以从 IDE 中完成此过程。 您还可以从 Github 中 fork 项目并在您的 IDE 或其他编辑器中打开它。 添加awaitility依赖项（可不添加）中的测试complete/src/test/java/com/example/schedulingtasks/ScheduledTasksTest.java需要awaitility库。 库的更高版本awaitility不适用于此测试，因此您必须指定版本 3.1.2。 要将awaitility库添加到 Maven，请添加以下依赖项： 123456&lt;dependency&gt; &lt;groupId&gt;org.awaitility&lt;/groupId&gt; &lt;artifactId&gt;awaitility&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 以下清单显示了完成的pom.xml文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;scheduling-tasks-complete&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;scheduling-tasks-complete&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.awaitility&lt;/groupId&gt; &lt;artifactId&gt;awaitility&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 要将awaitility库添加到 Gradle，请添加以下依赖项： 1testImplementation &#x27;org.awaitility:awaitility:3.1.2&#x27; 以下清单显示了完成的build.gradle文件： 1234567891011121314151617181920212223plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.7.1&#x27; id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.11.RELEASE&#x27; id &#x27;java&#x27;&#125;group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = &#x27;1.8&#x27;repositories &#123; mavenCentral()&#125;dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter&#x27; testImplementation &#x27;org.awaitility:awaitility:3.1.2&#x27; testImplementation(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;)&#125;test &#123; useJUnitPlatform()&#125; 创建计划任务现在您已经设置了您的项目，您可以创建计划任务。以下清单（来自src/main/java/com/example/schedulingtasks/ScheduledTasks.java）显示了如何执行此操作： 1234567891011121314151617181920212223242526272829303132333435363738/* * Copyright 2012-2015 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.example.schedulingtasks;import java.text.SimpleDateFormat;import java.util.Date;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class ScheduledTasks &#123; private static final Logger log = LoggerFactory.getLogger(ScheduledTasks.class); private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;); @Scheduled(fixedRate = 5000) public void reportCurrentTime() &#123; log.info(&quot;The time is now &#123;&#125;&quot;, dateFormat.format(new Date())); &#125;&#125; Scheduled注释定义特定方法何时运行。 此示例使用fixedRate，它指定方法调用之间的间隔，从每次调用的开始时间开始计算。还有其他选项，例如fixedDelay，它指定从任务完成开始计算的调用间隔。您还可以使用@Scheduled(cron=&quot;. . .&quot;)表达式进行更复杂的任务调度。 启用调度尽管计划任务可以嵌入到 Web 应用程序和 WAR 文件中，但更简单的方法（在下一个清单中显示）创建一个独立的应用程序。为此，将所有内容打包到一个可执行的 JAR 文件中，由一个很好的旧 Javamain()方法驱动。以下清单（来自src/main/java/com/example/schedulingtasks/SchedulingTasksApplication.java）显示了应用程序类： 1234567891011121314package com.example.schedulingtasks;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class SchedulingTasksApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SchedulingTasksApplication.class); &#125;&#125; @SpringBootApplication是一个方便的注解，它添加了以下所有内容： @Configuration：将类标记为应用程序上下文的 bean 定义源。 @EnableAutoConfiguration：告诉 Spring Boot 开始添加基于类路径设置、其他 bean 和各种属性设置的 bean。例如，如果spring-webmvc在类路径上，此注释将应用程序标记为 Web 应用程序并激活关键行为，例如设置DispatcherServlet. @ComponentScan：告诉 Spring 在包中寻找其他组件、配置和服务com/example，让它找到控制器。 该main()方法使用 Spring Boot 的SpringApplication.run()方法来启动应用程序。您是否注意到没有一行 XML？也没有web.xml文件。此 Web 应用程序是 100% 纯 Java，您无需处理任何管道或基础设施的配置。 @EnableScheduling注释确保创建后台任务执行器。没有它，什么都无法安排。 构建可执行 JAR您可以使用 Gradle 或 Maven 从命令行运行应用程序。您还可以构建一个包含所有必要依赖项、类和资源的可执行 JAR 文件并运行它。构建可执行 jar 可以轻松地将服务作为应用程序在整个开发生命周期中跨不同环境等进行发布、版本控制和部署。 如果您使用 Gradle，则可以使用./gradlew bootRun. 或者，您可以使用 构建 JAR 文件./gradlew build，然后运行 JAR 文件，如下所示： 1oracle-java -jar build/libs/gs-scheduling-tasks-0.1.0.jar 如果您使用 Maven，则可以使用./mvnw spring-boot:run. 或者，您可以构建 JAR 文件，./mvnw clean package然后运行 JAR 文件，如下所示： 1oracle-java -jar 目标/gs-scheduling-tasks-0.1.0.jar 此处描述的步骤创建了一个可运行的 JAR。您还可以构建经典的 WAR 文件。 显示日志输出，从日志可以看出是在后台线程上。您应该会看到您的计划任务每五秒触发一次。以下清单显示了典型的输出： 123456...2019-10-02 12:07:35.659 INFO 28617 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 12:07:352019-10-02 12:07:40.659 INFO 28617 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 12:07:402019-10-02 12:07:45.659 INFO 28617 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 12:07:452019-10-02 12:07:50.657 INFO 28617 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 12:07:50... 参考文档 spring官网","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://guoshunfa.com/tags/Spring/"}]},{"title":"React框架 介绍","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架-介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.301Z","comments":true,"path":"2022/07/React框架-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"进入 React官网 尚硅谷 React教学视频：b站 | 百度网盘 提取码：c1ac（包含视频、源码、课件） (在网络允许的情况下，可以查看React官网进行了解React。) 1. 什么是React声明式 React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据变动时 React 能高效更新并渲染合适的组件。 以声明式编写 UI，可以让你的代码更加可靠，且方便调试。 组件化 构建管理自身状态的封装组件，然后对其组合以构成复杂的 UI。 由于组件逻辑使用 JavaScript 编写而非模板，因此你可以轻松地在应用中传递数据，并保持状态与 DOM 分离。 一次学习，跨平台编写 无论你现在使用什么技术栈，在无需重写现有代码的前提下，通过引入 React 来开发新功能。 React 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。 2. CDN 链接 可以通过 CDN 获得 React 和 ReactDOM 的 UMD 版本。 12&lt;script crossorigin src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 上述版本仅用于开发环境，不适合用于生产环境。压缩优化后可用于生产的 React 版本可通过如下方式引用： 12&lt;script crossorigin src=&quot;https://unpkg.com/react@17/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; 如果需要加载指定版本的 react 和 react-dom，可以把 17 替换成所需加载的版本号。 babel: 1&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; 参考资料 尚硅谷 React 官方文档","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"}]},{"title":"React框架 Hook API","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架-Hook-API","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.301Z","comments":true,"path":"2022/07/React框架-Hook-API/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6-Hook-API/","excerpt":"","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 React 官方文档 本页面主要描述 React 中内置的 Hook API。 如果你刚开始接触 Hook，那么可能需要先查阅 Hook 概览。你也可以在 Hooks FAQ 章节中获取有用的信息。 基础 Hook useState useEffect useContext 额外的 Hook useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue 基础 HookuseState1const [state, setState] = useState(initialState); 返回一个 state，以及更新 state 的函数。 在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。 setState 函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。 1setState(newState); 在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。 注意 React 会确保 setState 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 setState。 函数式更新如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 setState 的两种用法： 1234567891011function Counter(&#123;initialCount&#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; “+” 和 “-” 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。但是“重置”按钮则采用普通形式，因为它总是把 count 设置回初始值。 如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。 注意 与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。 12345const [state, setState] = useState(&#123;&#125;);setState(prevState =&gt; &#123;// 也可以使用 Object.assignreturn &#123;...prevState, ...updatedValues&#125;;&#125;); useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。 惰性初始 stateinitialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用： 1234const [state, setState] = useState(() =&gt; &#123; const initialState = someExpensiveComputation(props); return initialState;&#125;); 跳过 state 更新调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state。） 需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。 useEffect1useEffect(didUpdate); 该 Hook 接收一个包含命令式、且可能有副作用代码的函数。 在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。 使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。 默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。 清除 effect通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子： 1234567useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; // 清除订阅 subscription.unsubscribe(); &#125;;&#125;); 为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 effect 的执行，请参阅下一小节。 effect 的执行时机与 componentDidMount、componentDidUpdate 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。 然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。 虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。在开始新的更新前，React 总会先清除上一轮渲染的 effect。 effect 的条件执行默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。 然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变时重新创建。 要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下： 123456789useEffect( () =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; subscription.unsubscribe(); &#125;; &#125;, [props.source],); 此时，只有当 props.source 改变后才会重新创建订阅。 注意 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量。请参阅文档，了解更多关于如何处理函数 以及数组频繁变化时的措施 的内容。 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。 如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直持有其初始值。尽管传入 [] 作为第二个参数有点类似于 componentDidMount 和 componentWillUnmount 的思维模式，但我们有 更好的 方式 来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得处理额外操作很方便。 我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。 useContext1const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。 别忘记 useContext 的参数必须是 context 对象本身： 正确： useContext(MyContext) 错误： useContext(MyContext.Consumer) 错误： useContext(MyContext.Provider) 调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。 提示 如果你在接触 Hook 前已经对 context API 比较熟悉，那应该可以理解，useContext(MyContext) 相当于 class 组件中的 static contextType = MyContext 或者 &lt;MyContext.Consumer&gt;。 useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context。 把如下代码与 Context.Provider 放在一起 1234567891011121314151617181920212223242526272829303132333435363738const themes = &#123; light: &#123; foreground: &quot;#000000&quot;, background: &quot;#eeeeee&quot; &#125;, dark: &#123; foreground: &quot;#ffffff&quot;, background: &quot;#222222&quot; &#125;&#125;;const ThemeContext = React.createContext(themes.light);function App() &#123; return ( &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton() &#123; const theme = useContext(ThemeContext); return ( &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; I am styled by theme context! &lt;/button&gt; );&#125; 对先前 Context 高级指南中的示例使用 hook 进行了修改，你可以在链接中找到有关如何 Context 的更多信息。 额外的 Hook以下介绍的 Hook，有些是上一节中基础 Hook 的变体，有些则仅在特殊情况下会用到。不用特意预先学习它们。 useReducer1const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。） 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。 以下是用 reducer 重写 useState 一节的计数器示例： 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; 注意 React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 dispatch。 指定初始 state有两种不同初始化 useReducer state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法： 1234const [state, dispatch] = useReducer( reducer, &#123;count: initialCount&#125;); 注意 React 不使用 state = initialState 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。如果你特别喜欢上述的参数约定，可以通过调用 useReducer(reducer, undefined, reducer) 来模拟 Redux 的行为，但我们不鼓励你这么做。 惰性初始化你可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。 这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利： 12345678910111213141516171819202122232425262728293031function init(initialCount) &#123; return &#123;count: initialCount&#125;;&#125;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; case &#x27;reset&#x27;: return init(action.payload); default: throw new Error(); &#125;&#125;function Counter(&#123;initialCount&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt; Reset &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; 跳过 dispatch如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。） 需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。 useCallback123456const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 返回一个 memoized 回调函数。 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。 注意 依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。 我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 useMemo1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 返回一个 memoized 值。 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。 注意 依赖项数组不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。 我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 useRef1const refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。 一个常见的用例便是命令式地访问子组件： 12345678910111213function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; 本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。 你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 &lt;div ref=&#123;myRef&#125; /&gt; 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。 然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。 这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 &#123;current: ...&#125; 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。 请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。 useImperativeHandle1useImperativeHandle(ref, createHandle, [deps]) useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用： 12345678910function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput); 在本例中，渲染 &lt;FancyInput ref=&#123;inputRef&#125; /&gt; 的父组件可以调用 inputRef.current.focus()。 useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 尽可能使用标准的 useEffect 以避免阻塞视觉更新。 提示 如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的。但是，我们推荐你**一开始先用 useEffect**，只有当它出问题的时候再尝试使用 useLayoutEffect。 如果你使用服务端渲染，请记住，无论 useLayoutEffect 还是 useEffect 都无法在 Javascript 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码时会触发 React 告警。解决这个问题，需要将代码逻辑移至 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 useLayoutEffect 执行之前 HTML 都显示错乱的情况下）。 若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild &amp;&amp; &lt;Child /&gt; 进行条件渲染，并使用 useEffect(() =&gt; &#123; setShowChild(true); &#125;, []) 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。 useDebugValue1useDebugValue(value) useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 例如，“自定义 Hook” 章节中描述的名为 useFriendStatus 的自定义 Hook： 1234567891011function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;); return isOnline;&#125; 提示 我们不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。 延迟格式化 debug 值在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。 因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。 例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用： 1useDebugValue(date, date =&gt; date.toDateString()); 参考文档 React 官方文档","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"},{"name":"Hook","slug":"Hook","permalink":"https://guoshunfa.com/tags/Hook/"}]},{"title":"React框架 - 解决跨域问题","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架-解决跨域问题","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.302Z","comments":true,"path":"2022/07/React框架-解决跨域问题/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"1. 场景React服务的地址是127.0.0.1:3000，接口服务的地址是127.0.0.1:5000。 React服务3000直接调用接口服务5000可能会产生跨域问题。 这里有两种解决方案，一种是直接在package.json中配置，一种是使用单独的配置文件。下面会对这两种进行介绍。 2. 第一种：package.json 配置 缺点： 只能配置一个服务，如有多个服务不能使用。 优点： 配置简单。 配置： 1&quot;proxy&quot;: &quot;http://127.0.0.1:5000&quot; 访问： 正常访问3000服务，会被转发到5000，如：http://127.0.0.1:3000/findUsers。 3. 第二种：使用 http-proxy-middleware 组件包 缺点： 配置繁琐。 接口调用必须加前缀，如&#x2F;api1。 优点： 可配置多个接口服务。 配置： src文件下创建setupProxy.js文件，文件内容如下。 12345678910111213141516const proxy = require(&#x27;http-proxy-middleware&#x27;)module.exports = function(app)&#123; app.use( proxy(&#x27;/api1&#x27;,&#123; //遇见/api1前缀的请求，就会触发该代理配置 target:&#x27;http://localhost:5000&#x27;, //请求转发给谁 changeOrigin:true,//控制服务器收到的请求头中Host的值 pathRewrite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125; //重写请求路径(必须) &#125;), proxy(&#x27;/api2&#x27;,&#123; target:&#x27;http://localhost:5001&#x27;, changeOrigin:true, pathRewrite:&#123;&#x27;^/api2&#x27;:&#x27;&#x27;&#125; &#125;), )&#125; 访问： http://127.0.0.1:3000/api1/findUsers，会被转发到5001服务的http://127.0.0.1:5001/findUsers","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"},{"name":"跨域","slug":"跨域","permalink":"https://guoshunfa.com/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"React框架 Router","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架Router","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.302Z","comments":true,"path":"2022/07/React框架Router/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6Router/","excerpt":"","text":"React框架 - Router 前往 React Router V6 官方文档 react-router-dom为针对web开发的组件库。 1. v6 版本1.1. 版本更新内容 推出了很多好用hooks，但是路由组件内props的三个实用属性去掉了。 &#x3D; &#x3D; &lt;Switch&gt;重命名为&lt;Routes&gt;。 &lt;Route&gt;的新特性变更。 嵌套路由变得更简单。 用useNavigate代替useHistory。 新钩子useRoutes代替react-router-config。 大小减少：从20kb到8kb 1.2. 常用路由组件和hooks 组件名 作用 说明 &lt;Routers&gt; 一组路由 代替原有&lt;Switch&gt;，所有子路由都用基础的Router children来表示 &lt;Router&gt; 基础路由 Router是可以嵌套的，解决原有V5中严格模式，后面与V5区别会详细介绍 &lt;Link&gt; 导航组件 在实际页面中跳转使用 &lt;Outlet/&gt; 自适应渲染组件 根据实际路由url自动选择组件 hooks名 作用 说明 useParams 返回当前参数 根据路径读取参数 useNavigate 返回当前路由 代替原有V5中的 useHistory useOutlet 返回根据路由生成的element useLocation 返回当前的location 对象 useRoutes 同Routers组件一样，只不过是在js中使用 useSearchParams 用来匹配URL中?后面的搜索参数 1.2. 路由的基本使用 导航，使用Link标签。&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; 路由Routes与Route搭配使用。 element直接写入组件，可以传入props。 123&lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt;&lt;/Route&gt;&lt;/Routes&gt; 1.3. 嵌套路由12345678910&lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt; &lt;Route index element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&quot;teams&quot; element=&#123;&lt;Teams /&gt;&#125;&gt; &lt;Route path=&quot;:teamId&quot; element=&#123;&lt;Team /&gt;&#125; /&gt; &lt;Route path=&quot;new&quot; element=&#123;&lt;NewTeamForm /&gt;&#125; /&gt; &lt;Route index element=&#123;&lt;LeagueStandings /&gt;&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt;&lt;/Routes&gt; 1.4. Outlet&lt;Outlet/&gt;根据定义的不同路由参数进行渲染组件。 2. v5 版本2.1. 路由的基本使用​ 1.明确好界面中的导航区、展示区​ 2.导航区的a标签改为Link标签​ &lt;Link to=&quot;/xxxxx&quot;&gt;Demo&lt;/Link&gt;​ 3.展示区写Route标签进行路径的匹配​ &lt;Route path=&#39;/xxxx&#39; component=&#123;Demo&#125;/&gt;​ 4.&lt;App&gt;的最外侧包裹了一个&lt;BrowserRouter&gt;或&lt;HashRouter&gt; 2.2. 路由组件与一般组件​ 1.写法不同：​ 一般组件：&lt;Demo/&gt;​ 路由组件：&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;​ 2.存放位置不同：​ 一般组件：components​ 路由组件：pages​ 3.接收到的props不同：​ 一般组件：写组件标签时传递了什么，就能收到什么​ 路由组件：接收到三个固定的属性 1234567891011121314history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(path, state)location: pathname: &quot;/about&quot; search: &quot;&quot; state: undefinedmatch: params: &#123;&#125; path: &quot;/about&quot; url: &quot;/about&quot; 2.3. NavLink与封装NavLink​ 1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名 2.4. Switch的使用​ 1.通常情况下，path和component是一一对应的关系。​ 2.Switch可以提高路由匹配效率(单一匹配)。 2.5. 解决多级路径刷新页面样式丢失的问题​ 1.public&#x2F;index.html 中 引入样式时不写 .&#x2F; 写 &#x2F; （常用）​ 2.public&#x2F;index.html 中 引入样式时不写 .&#x2F; 写 %PUBLIC_URL% （常用）​ 3.使用HashRouter 2.6. 路由的严格匹配与模糊匹配​ 1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）​ 2.开启严格匹配：&lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;About&#125;/&gt;​ 3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由 2.7. Redirect的使用​ 1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由​ 2.具体编码： 12345&lt;Switch&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt; &lt;Redirect to=&quot;/about&quot;/&gt;&lt;/Switch&gt; ​ 2.8. 嵌套路由​ 1.注册子路由时要写上父路由的path值​ 2.路由的匹配是按照注册路由的顺序进行的 2.9. 向路由组件传递参数12345678910111213141.params参数 路由链接(携带参数)：&lt;Link to=&#x27;/demo/test/tom/18&#x27;&#125;&gt;详情&lt;/Link&gt; 注册路由(声明接收)：&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt; 接收参数：this.props.match.params2.search参数 路由链接(携带参数)：&lt;Link to=&#x27;/demo/test?name=tom&amp;age=18&#x27;&#125;&gt;详情&lt;/Link&gt; 注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt; 接收参数：this.props.location.search 备注：获取到的search是urlencoded编码字符串，需要借助querystring解析3.state参数 路由链接(携带参数)：&lt;Link to=&#123;&#123;pathname:&#x27;/demo/test&#x27;,state:&#123;name:&#x27;tom&#x27;,age:18&#125;&#125;&#125;&gt;详情&lt;/Link&gt; 注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt; 接收参数：this.props.location.state 备注：刷新也可以保留住参数 2.10. 编程式路由导航​ 借助this.prosp.history对象上的API对操作路由跳转、前进、后退 12345-this.prosp.history.push()-this.prosp.history.replace()-this.prosp.history.goBack()-this.prosp.history.goForward()-this.prosp.history.go() 2.11. BrowserRouter与HashRouter的区别​ 1.底层原理不一样：​ BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。​ HashRouter使用的是URL的哈希值。​ 2.path表现形式不一样​ BrowserRouter的路径中没有#,例如：localhost:3000&#x2F;demo&#x2F;test​ HashRouter的路径包含#,例如：localhost:3000&#x2F;#&#x2F;demo&#x2F;test​ 3.刷新后对路由state参数的影响​ (1).BrowserRouter没有任何影响，因为state保存在history对象中。​ (2).HashRouter刷新后会导致路由state参数的丢失！！！​ 4.备注：HashRouter可以用于解决一些路径错误相关的问题。 参考文档 尚硅谷 React-Router V6 使用详解(干货) React-Router v6 新特性解读及迁移指南 什么，React Router已经到V6了 ？？","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"}]},{"title":"React框架 UI组件库","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架UI组件库","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.302Z","comments":true,"path":"2022/07/React框架UI组件库/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6UI%E7%BB%84%E4%BB%B6%E5%BA%93/","excerpt":"","text":"1. material-ui(国外) 官网: http://www.material-ui.com/#/ github: https://github.com/callemall/material-ui 2. ant-design(国内蚂蚁金服) 官网: https://ant.design/index-cn Github: https://github.com/ant-design/ant-design/ 2.1. antd的按需引入+自定主题 安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader 修改package.json 123456789101112131415....&quot;myscripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-myscripts eject&quot;&#125;,.... 根目录下创建config-overrides.js 123456789101112131415//配置具体的修改规则const &#123; override, fixBabelImports,addLessLoader&#125; = require(&#x27;customize-cra&#x27;);module.exports = override( fixBabelImports(&#x27;import&#x27;, &#123; libraryName: &#x27;antd&#x27;, libraryDirectory: &#x27;es&#x27;, style: true, &#125;), addLessLoader(&#123; lessOptions:&#123; javascriptEnabled: true, modifyVars: &#123; &#x27;@primary-color&#x27;: &#x27;green&#x27; &#125;, &#125; &#125;),); 备注：不用在组件里亲自引入样式了，即：import ‘antd&#x2F;dist&#x2F;antd.css’应该删掉","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"},{"name":"UI组件库","slug":"UI组件库","permalink":"https://guoshunfa.com/tags/UI%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"React框架基础","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架基础","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.303Z","comments":true,"path":"2022/07/React框架基础/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"进入 React官网 尚硅谷 React教学视频：b站 | 百度网盘 提取码：c1ac（包含视频、源码、课件） 1. hello react12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;hello_react&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 准备好一个“容器” --&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;!-- 引入react核心库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入react-dom，用于支持react操作DOM --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入babel，用于将jsx转为js --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot; &gt; /* 此处一定要写babel */ //1.创建虚拟DOM const VDOM = &lt;h1&gt;Hello,React&lt;/h1&gt; /* 此处一定不要写引号，因为不是字符串 */ //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. JSX jsx语法规则： ​ 1.定义虚拟DOM时，不要写引号。 ​ 2.标签中混入JS表达式时要用{}。 ​ 3.样式的类名指定不要用class，要用className。 ​ 4.内联样式，要用的⬇️形式去写。 style=&#123;&#123;key:value&#125;&#125; ​ 5.只有一个根标签 ​ 6.标签必须闭合 ​ 7.标签首字母 ​ (1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。 ​ (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。 12345const VDOM = ( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt; ) 3. 组件定义方式函数式组件 123456789101112//1.创建函数式组件function MyComponent()&#123; console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式 return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;&#125;//2.渲染组件到页面ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))/* 执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？ 1.React解析组件标签，找到了MyComponent组件。 2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。 */ 类式组件 必须继承React.Component。 实现render方法，并返回需要展示的组件内容。 1234567891011121314151617//1.创建类式组件class MyComponent extends React.Component &#123; render()&#123; //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。 //render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。 console.log(&#x27;render中的this:&#x27;,this); return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt; &#125;&#125;//2.渲染组件到页面ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))/* 执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？ 1.React解析组件标签，找到了MyComponent组件。 2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。 3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。 */ 4. 组件实例三大属性4.1. props 通过组件的形式传递的参数都会被放到props。 12345678910111213141516//创建组件class Person extends React.Component&#123; render()&#123; // console.log(this); const &#123;name,age,sex&#125; = this.props return ( &lt;ul&gt; &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;//渲染组件到页面ReactDOM.render(&lt;Person name=&quot;jerry&quot; age=&#123;19&#125; sex=&quot;男&quot;/&gt;,document.getElementById(&#x27;test1&#x27;)) 对传入的参数进行限制： 123456789101112131415161718192021222324252627282930//创建组件class Person extends React.Component&#123; render()&#123; // console.log(this); const &#123;name,age,sex&#125; = this.props //props是只读的 //this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的 return ( &lt;ul&gt; &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;//对标签属性进行类型、必要性的限制Person.propTypes = &#123; name:PropTypes.string.isRequired, //限制name必传，且为字符串 sex:PropTypes.string,//限制sex为字符串 age:PropTypes.number,//限制age为数值 speak:PropTypes.func,//限制speak为函数&#125;//指定默认标签属性值Person.defaultProps = &#123; sex:&#x27;男&#x27;,//sex默认值为男 age:18 //age默认值为18&#125;//渲染组件到页面ReactDOM.render(&lt;Person name=&#123;100&#125; speak=&#123;speak&#125;/&gt;,document.getElementById(&#x27;test1&#x27;)) 限制简化（将限制处理放入类）： 12345678910111213141516171819202122232425262728293031323334353637383940//创建组件class Person extends React.Component&#123; constructor(props)&#123; //构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props // console.log(props); super(props) console.log(&#x27;constructor&#x27;,this.props); &#125; //对标签属性进行类型、必要性的限制 static propTypes = &#123; name:PropTypes.string.isRequired, //限制name必传，且为字符串 sex:PropTypes.string,//限制sex为字符串 age:PropTypes.number,//限制age为数值 &#125; //指定默认标签属性值 static defaultProps = &#123; sex:&#x27;男&#x27;,//sex默认值为男 age:18 //age默认值为18 &#125; render()&#123; // console.log(this); const &#123;name,age,sex&#125; = this.props //props是只读的 //this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的 return ( &lt;ul&gt; &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;//渲染组件到页面ReactDOM.render(&lt;Person name=&quot;jerry&quot;/&gt;,document.getElementById(&#x27;test1&#x27;)) 函数组件使用props： 123456789101112131415161718192021222324//创建组件function Person (props)&#123; const &#123;name,age,sex&#125; = props return ( &lt;ul&gt; &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt; &lt;/ul&gt; )&#125;Person.propTypes = &#123; name:PropTypes.string.isRequired, //限制name必传，且为字符串 sex:PropTypes.string,//限制sex为字符串 age:PropTypes.number,//限制age为数值&#125;//指定默认标签属性值Person.defaultProps = &#123; sex:&#x27;男&#x27;,//sex默认值为男 age:18 //age默认值为18&#125;//渲染组件到页面ReactDOM.render(&lt;Person name=&quot;jerry&quot;/&gt;,document.getElementById(&#x27;test1&#x27;)) 4.2. state state: 状态，用于存储组件内数据信息。 constructor: 构造函数，作用是初始化state和绑定事件。 123456789class Weather extends React.Component&#123; //构造器调用几次？ ———— 1次 constructor(props)&#123; console.log(&#x27;constructor&#x27;); super(props) //初始化状态 this.state = &#123;isHot:false,wind:&#x27;微风&#x27;&#125; &#125;&#125; 1234class Weather extends React.Component&#123; //初始化状态 this.state = &#123;isHot:false,wind:&#x27;微风&#x27;&#125;&#125; 4.3. refs 官方不建议过度使用ref。 字符串形式的ref 官方不建议使用。 123456789101112131415161718192021222324//创建组件class Demo extends React.Component&#123; //展示左侧输入框的数据 showData = ()=&gt;&#123; const &#123;input1&#125; = this.refs alert(input1.value) &#125; //展示右侧输入框的数据 showData2 = ()=&gt;&#123; const &#123;input2&#125; = this.refs alert(input2.value) &#125; render()&#123; return( &lt;div&gt; &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp; &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp; &lt;input ref=&quot;input2&quot; onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot;/&gt; &lt;/div&gt; ) &#125;&#125;//渲染组件到页面ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot;/&gt;,document.getElementById(&#x27;test&#x27;)) 回调函数形式的ref 123456789101112131415161718192021222324//创建组件class Demo extends React.Component&#123; //展示左侧输入框的数据 showData = ()=&gt;&#123; const &#123;input1&#125; = this alert(input1.value) &#125; //展示右侧输入框的数据 showData2 = ()=&gt;&#123; const &#123;input2&#125; = this alert(input2.value) &#125; render()&#123; return( &lt;div&gt; &lt;input ref=&#123;c =&gt; this.input1 = c &#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp; &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp; &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;c =&gt; this.input2 = c &#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot;/&gt;&amp;nbsp; &lt;/div&gt; ) &#125;&#125;//渲染组件到页面ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot;/&gt;,document.getElementById(&#x27;test&#x27;)) createRef 的方式构建ref（React提供的方法） 官方推荐使用的方式。 缺陷：React.createRef() 一次只能创建一个ref 123456789101112131415161718192021222324252627//创建组件class Demo extends React.Component&#123; /* React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的 */ myRef = React.createRef() myRef2 = React.createRef() //展示左侧输入框的数据 showData = ()=&gt;&#123; alert(this.myRef.current.value); &#125; //展示右侧输入框的数据 showData2 = ()=&gt;&#123; alert(this.myRef2.current.value); &#125; render()&#123; return( &lt;div&gt; &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp; &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp; &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot;/&gt;&amp;nbsp; &lt;/div&gt; ) &#125;&#125;//渲染组件到页面ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot;/&gt;,document.getElementById(&#x27;test&#x27;)) 5. 生命周期React 新生命周期（React v16之后）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//创建组件class Count extends React.Component&#123; /* 1. 初始化阶段: 由ReactDOM.render()触发---初次渲染 1. constructor() 2. getDerivedStateFromProps 3. render() 4. componentDidMount() =====&gt; 常用 一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息 2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1. getDerivedStateFromProps 2. shouldComponentUpdate() 3. render() 4. getSnapshotBeforeUpdate 5. componentDidUpdate() 3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1. componentWillUnmount() =====&gt; 常用 一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息 */ //构造器 constructor(props)&#123; console.log(&#x27;Count---constructor&#x27;); super(props) //初始化状态 this.state = &#123;count:0&#125; &#125; //加1按钮的回调 add = ()=&gt;&#123; //获取原状态 const &#123;count&#125; = this.state //更新状态 this.setState(&#123;count:count+1&#125;) &#125; //卸载组件按钮的回调 death = ()=&gt;&#123; ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;test&#x27;)) &#125; //强制更新按钮的回调 force = ()=&gt;&#123; this.forceUpdate() &#125; //若state的值在任何时候都取决于props，那么可以使用ge tDerivedStateFromProps static getDerivedStateFromProps(props,state)&#123; console.log(&#x27;getDerivedStateFromProps&#x27;,props,state); return null &#125; //在更新之前获取快照 getSnapshotBeforeUpdate()&#123; console.log(&#x27;getSnapshotBeforeUpdate&#x27;); return &#x27;atguigu&#x27; &#125; //组件挂载完毕的钩子 componentDidMount()&#123; console.log(&#x27;Count---componentDidMount&#x27;); &#125; //组件将要卸载的钩子 componentWillUnmount()&#123; console.log(&#x27;Count---componentWillUnmount&#x27;); &#125; //控制组件更新的“阀门” shouldComponentUpdate()&#123; console.log(&#x27;Count---shouldComponentUpdate&#x27;); return true &#125; //组件更新完毕的钩子 componentDidUpdate(preProps,preState,snapshotValue)&#123; console.log(&#x27;Count---componentDidUpdate&#x27;,preProps,preState,snapshotValue); &#125; render()&#123; console.log(&#x27;Count---render&#x27;); const &#123;count&#125; = this.state return( &lt;div&gt; &lt;h2&gt;当前求和为：&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.add&#125;&gt;点我+1&lt;/button&gt; &lt;button onClick=&#123;this.death&#125;&gt;卸载组件&lt;/button&gt; &lt;button onClick=&#123;this.force&#125;&gt;不更改任何状态中的数据，强制更新一下&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;//渲染组件ReactDOM.render(&lt;Count count=&#123;199&#125;/&gt;,document.getElementById(&#x27;test&#x27;)) React v16 前生命周期： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/* 1. 初始化阶段: 由ReactDOM.render()触发---初次渲染 1. constructor() 2. componentWillMount() 3. render() 4. componentDidMount() =====&gt; 常用 一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息 2. 更新阶段: 由组件内部this.setSate()或父组件render触发 1. shouldComponentUpdate() 2. componentWillUpdate() 3. render() =====&gt; 必须使用的一个 4. componentDidUpdate() 3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1. componentWillUnmount() =====&gt; 常用 一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息 *///创建组件class Count extends React.Component&#123; //构造器 constructor(props)&#123; console.log(&#x27;Count---constructor&#x27;); super(props) //初始化状态 this.state = &#123;count:0&#125; &#125; //加1按钮的回调 add = ()=&gt;&#123; //获取原状态 const &#123;count&#125; = this.state //更新状态 this.setState(&#123;count:count+1&#125;) &#125; //卸载组件按钮的回调 death = ()=&gt;&#123; ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;test&#x27;)) &#125; //强制更新按钮的回调 force = ()=&gt;&#123; this.forceUpdate() &#125; //组件将要挂载的钩子 componentWillMount()&#123; console.log(&#x27;Count---componentWillMount&#x27;); &#125; //组件挂载完毕的钩子 componentDidMount()&#123; console.log(&#x27;Count---componentDidMount&#x27;); &#125; //组件将要卸载的钩子 componentWillUnmount()&#123; console.log(&#x27;Count---componentWillUnmount&#x27;); &#125; //控制组件更新的“阀门” shouldComponentUpdate()&#123; console.log(&#x27;Count---shouldComponentUpdate&#x27;); return true &#125; //组件将要更新的钩子 componentWillUpdate()&#123; console.log(&#x27;Count---componentWillUpdate&#x27;); &#125; //组件更新完毕的钩子 componentDidUpdate()&#123; console.log(&#x27;Count---componentDidUpdate&#x27;); &#125; render()&#123; console.log(&#x27;Count---render&#x27;); const &#123;count&#125; = this.state return( &lt;div&gt; &lt;h2&gt;当前求和为：&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.add&#125;&gt;点我+1&lt;/button&gt; &lt;button onClick=&#123;this.death&#125;&gt;卸载组件&lt;/button&gt; &lt;button onClick=&#123;this.force&#125;&gt;不更改任何状态中的数据，强制更新一下&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;//父组件Aclass A extends React.Component&#123; //初始化状态 state = &#123;carName:&#x27;奔驰&#x27;&#125; changeCar = ()=&gt;&#123; this.setState(&#123;carName:&#x27;奥拓&#x27;&#125;) &#125; render()&#123; return( &lt;div&gt; &lt;div&gt;我是A组件&lt;/div&gt; &lt;button onClick=&#123;this.changeCar&#125;&gt;换车&lt;/button&gt; &lt;B carName=&#123;this.state.carName&#125;/&gt; &lt;/div&gt; ) &#125;&#125;//子组件Bclass B extends React.Component&#123; //组件将要接收新的props的钩子 componentWillReceiveProps(props)&#123; console.log(&#x27;B---componentWillReceiveProps&#x27;,props); &#125; //控制组件更新的“阀门” shouldComponentUpdate()&#123; console.log(&#x27;B---shouldComponentUpdate&#x27;); return true &#125; //组件将要更新的钩子 componentWillUpdate()&#123; console.log(&#x27;B---componentWillUpdate&#x27;); &#125; //组件更新完毕的钩子 componentDidUpdate()&#123; console.log(&#x27;B---componentDidUpdate&#x27;); &#125; render()&#123; console.log(&#x27;B---render&#x27;); return( &lt;div&gt;我是B组件，接收到的车是:&#123;this.props.carName&#125;&lt;/div&gt; ) &#125;&#125;//渲染组件ReactDOM.render(&lt;Count/&gt;,document.getElementById(&#x27;test&#x27;)) 6. 相比于HTML的语法区别HTML的class - &gt; React 的 className HTML的style&#x3D;”” - &gt; React 的 style=&#123;&#123;&#125;&#125; 参考资料 尚硅谷 React 官方文档","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"}]},{"title":"React框架 组件之间通讯","slug":"软件开发/技术/软件技术框架/各大框架/React/React框架组件之间通讯","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.303Z","comments":true,"path":"2022/07/React框架组件之间通讯/","link":"","permalink":"https://guoshunfa.com/2022/07/React%E6%A1%86%E6%9E%B6%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF/","excerpt":"","text":"React框架 - 组件之间通讯React 父子组件、兄弟组件、叔侄应该如何进行通讯，这里描述一下两种方法。 props function 缺点： 操作繁琐，组件关系越复杂代码量越多。 耦合性太强。 消息 订阅与发布 优点： 只需在指定的位置进行订阅消息、发布消息即可。 极大程度上降低耦合性。 1. 通过props function进行通讯原理： 找到父子、兄弟、叔侄组件的共同组件，绑定props function，进行通讯。 1.1. 类式组件用法 123456789101112131415161718192021// 父组件 App.jsximport React, &#123; Component &#125; from &quot;react&quot;;import List from &quot;./compoments/List&quot;;import Search from &quot;./compoments/Search&quot;;export default class App extends Component &#123; state = &#123; datas: [] &#125;; dataChange = (data) =&gt; &#123; let &#123; datas &#125; = this.state; datas.push(data); this.setState(&#123; datas: datas &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;Search dataChange=&#123;this.dataChange&#125; /&gt; &lt;List datas=&#123;this.state.datas&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 1234567891011121314// 子组件 List.jsximport React, &#123; Component &#125; from &quot;react&quot;;export default class List extends Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.datas.map((data) =&gt; &#123; return &lt;div key=&#123;data.id&#125;&gt;&#123;data.name&#125;&lt;/div&gt;; &#125;)&#125; &lt;/div&gt; ); &#125;&#125; 123456789101112131415// 子组件 Search.jsximport React, &#123; Component &#125; from &quot;react&quot;;export default class Search extends Component &#123; dataChange = () =&gt; &#123; this.props.dataChange(&#123; id: Date.now(), name: &quot;加了加了&quot; &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.dataChange&#125;&gt;点击添加一条数据&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 1.2. 函数式组件用法 123456789101112131415161718192021// 父组件 App.jsximport React, &#123; Component &#125; from &quot;react&quot;;import List from &quot;./compoments/List&quot;;import Search from &quot;./compoments/Search&quot;;export default class App extends Component &#123; state = &#123; datas: [] &#125;; dataChange = (data) =&gt; &#123; let &#123; datas &#125; = this.state; datas.push(data); this.setState(&#123; datas: datas &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;Search dataChange=&#123;this.dataChange&#125; /&gt; &lt;List datas=&#123;this.state.datas&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 123456789101112// 子组件 List.jsximport React from &quot;react&quot;;export default function List(props) &#123; return ( &lt;div&gt; &#123;props.datas.map((data) =&gt; &#123; return &lt;div key=&#123;data.id&#125;&gt;&#123;data.name&#125;&lt;/div&gt;; &#125;)&#125; &lt;/div&gt; );&#125; 1234567891011121314// 子组件 Search.jsximport React from &quot;react&quot;;export default function Search(props) &#123; let dataChange = () =&gt; &#123; props.dataChange(&#123; id: Date.now(), name: &quot;加了加了&quot; &#125;); &#125;; return ( &lt;div&gt; &lt;button onClick=&#123;dataChange&#125;&gt;点击添加一条数据&lt;/button&gt; &lt;/div&gt; );&#125; 通过function dataChange进行通信。 操作繁琐，本应跟App.jsx无关的操作，现在代码放到了App.jsx中。 2. 消息 订阅与发布 接着使用上面的例子。通过比较可以直接看出优缺点。 不能直接使用，需要安装额外的组件库。这里使用的是PubSubJS，详细内容请查看PubSubJS笔记。 2.1. 类式组件用法 12345678910111213// 父组件 App.jsximport React, &#123; Component &#125; from &#x27;react&#x27;;import List from &#x27;./compoments/List&#x27;;import Search from &#x27;./compoments/Search&#x27;;export default class App extends Component &#123; render() &#123; return &lt;div&gt; &lt;Search /&gt; &lt;List /&gt; &lt;/div&gt; &#125;&#125; 123456789101112131415161718192021222324252627282930// 子组件 List.jsximport React, &#123; Component &#125; from &#x27;react&#x27;;import PubSub from &#x27;pubsub-js&#x27;;export default class List extends Component &#123; state=&#123;datas:[]&#125; //组件挂载完毕的钩子 componentDidMount()&#123; this.dataChangeToken = PubSub.subscribe(&quot;dataChange&quot;, (msg, data) =&gt; &#123; let &#123; datas &#125; = this.state; datas.push(data); this.setState(&#123; datas: datas &#125;); &#125;); &#125; //组件将要卸载的钩子 componentWillUnmount()&#123; PubSub.unsubscribe(this.dataChangeToken); &#125; render() &#123; return &lt;div&gt; &#123; this.state.datas.map(data=&gt;&#123; return &lt;div key=&#123;data.id&#125;&gt;&#123;data.name&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt; &#125;&#125; 12345678910111213141516// 子组件 Search.jsximport React, &#123; Component &#125; from &#x27;react&#x27;;import PubSub from &#x27;pubsub-js&#x27;;export default class Search extends Component &#123; dataChange=()=&gt;&#123; // 发布消息 PubSub.publish(&quot;dataChange&quot;, &#123; id: Date.now(), name: &quot;加了加了&quot; &#125;); &#125; render() &#123; return &lt;div&gt; &lt;button onClick=&#123;this.dataChange&#125;&gt;我点&lt;/button&gt; &lt;/div&gt; &#125;&#125; 兄弟组件之间通讯直接通过发布、订阅消息，使得父组件App.jsx只需要管理组件摆放位置即可。 这里用到的消息发布订阅的组件包是PubSubJS。 token的管理不能像本文中直接使用字符串，需要设定一个TOKEN工厂来统一进行管理。 3. 集中式管理 redux TODO: 有机会整理 4. conText TODO: 有机会整理","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"}]},{"title":"Vue框架 介绍","slug":"软件开发/技术/软件技术框架/各大框架/Vue/Vue框架介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.309Z","comments":true,"path":"2022/07/Vue框架介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Vue%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"介绍内容包含：Vue.js是什么、Vue项目搭建。 Vue 官方文档 1. Vue.js 是什么​ Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 2. Vue项目搭建2.1. 什么是vue-cliVue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue&#x2F;cli 实现的交互式的项目脚手架。 通过 @vue&#x2F;cli + @vue&#x2F;cli-service-global 实现的零配置原型开发。 一个运行时依赖 (@vue&#x2F;cli-service)，这个依赖：（1）可升级；（2）基于 webpack 构建，并带有合理的默认配置；（3）可以通过项目内的配置文件进行配置；（4）可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 2.2. 快速创建项目（1）如果你还没有安装 VueCLI，请执行下面的命令安装或是升级： 1npm install --global @vue/cli （2）在命令行中输入以下命令创建 Vue 项目： 1vue create 项目名 2.3. 图形化界面创建通过 vue ui 命令以图形化界面创建和管理项目 1vue ui","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://guoshunfa.com/tags/Vue/"}]},{"title":"Vuepress框架 介绍","slug":"软件开发/技术/软件技术框架/各大框架/Vuepress/Vuepress框架介绍","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/07/Vuepress框架介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Vuepress%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"vuepress | vuepress-theme-vdoing | vuepress-theme-reco 主题 介绍VuePress 由两部分组成：第一部分是一个极简静态网站生成器 (opens new window)，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。 它是如何工作的？事实上，一个 VuePress 网站是一个由 Vue (opens new window)、Vue Router (opens new window)和 webpack (opens new window)驱动的单页应用。如果你以前使用过 Vue 的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用 Vue DevTools 去调试你的自定义主题。 在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于 Nuxt (opens new window)的 nuxt generate 命令，以及其他的一些项目，比如 Gatsby (opens new window)。 2. 插件包收藏 vuepress-plugin-mermaidjs 流程图、时序图、类图、状态图 …… vuepress-plugin-baidu-autopush 百度推送 vuepress-plugin-thirdparty-search 第三方搜索链接 vuepress-plugin-one-click-copy 代码块复制按钮 vuepress-plugin-zooming 放大图片 vuepress-plugin-comment Valine方式加入评论 | Valine-Admin 加入邮箱通知 vuepress-plugin-element-uiElement UI 站点信息模块 私密文章功能 首页大图模块 3. 其他GitHub Actions 定时运行代码：每天定时百度链接推送","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vuepress","slug":"Vuepress","permalink":"https://guoshunfa.com/tags/Vuepress/"}]},{"title":"Vuepress框架 插件包收藏","slug":"软件开发/技术/软件技术框架/各大框架/Vuepress/Vuepress框架插件包收藏","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/07/Vuepress框架插件包收藏/","link":"","permalink":"https://guoshunfa.com/2022/07/Vuepress%E6%A1%86%E6%9E%B6%E6%8F%92%E4%BB%B6%E5%8C%85%E6%94%B6%E8%97%8F/","excerpt":"","text":"一、插件包收藏 vuepress-plugin-mermaidjs 流程图、时序图、类图、状态图 …… vuepress-plugin-baidu-autopush 百度推送 vuepress-plugin-thirdparty-search 第三方搜索链接 vuepress-plugin-one-click-copy 代码块复制按钮 vuepress-plugin-zooming 放大图片 vuepress-plugin-comment Valine方式加入评论 | Valine-Admin 加入邮箱通知 vuepress-plugin-element-ui Element UI 站点信息模块 私密文章功能 首页大图模块 二、各插件包使用说明2.1. vuepress-plugin-comment 平台评论先放官网链接：https://github.com/dongyuanxin/vuepress-plugin-comment Features Support Gitalk, Valine Dynamic Import Response router change and refresh automatic User can use passage’s $frontmatter UsageInstallWith npm: 1npm install --save vuepress-plugin-comment With yarn: 1yarn add vuepress-plugin-comment -D With cnpm: 1cnpm i --save vuepress-plugin-comment ⚠️Route object propertiesDon’t use window object directly to get route information. Plugin has registered correct route information in frontmatter.to object and frontmatter.from object. Their properties are the same as vue-router’s route object. Use in GitalkThe options is exactly the same as Gitalk configuration. 123456789101112131415161718module.exports = &#123; plugins: [ [ &#x27;vuepress-plugin-comment&#x27;, &#123; choosen: &#x27;gitalk&#x27;, options: &#123; clientID: &#x27;GitHub Application Client ID&#x27;, clientSecret: &#x27;GitHub Application Client Secret&#x27;, repo: &#x27;GitHub repo&#x27;, owner: &#x27;GitHub repo owner&#x27;, admin: [&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;], distractionFreeMode: false &#125; &#125; ] ]&#125; If you want to access variables, such as $frontmatter and window, please use EJS syntax. 123456789101112131415161718192021module.exports = &#123; plugins: [ [ &#x27;vuepress-plugin-comment&#x27;, &#123; choosen: &#x27;gitalk&#x27;, options: &#123; id: &#x27;&lt;%- frontmatter.commentid || frontmatter.permalink %&gt;&#x27;, title: &#x27;「Comment」&lt;%- frontmatter.title %&gt;&#x27;, body: &#x27;&lt;%- frontmatter.title %&gt;：&lt;%-window.location.origin %&gt;&lt;%- frontmatter.to.path || window.location.pathname %&gt;&#x27;, clientID: &#x27;GitHub Application Client ID&#x27;, clientSecret: &#x27;GitHub Application Client Secret&#x27;, repo: &#x27;GitHub repo&#x27;, owner: &#x27;GitHub repo owner&#x27;, admin: [&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;], distractionFreeMode: false, &#125; &#125; ] ]&#125; Note: Never use callback function in plugin configuration, that will be filtered by vuepress. So I have to support EJS syntax. Use in Valine https://github.com/DesertsP/Valine-Admin The options is exactly the same as Valine configuration. 123456789101112131415module.exports = &#123; plugins: [ [ &#x27;vuepress-plugin-comment&#x27;, &#123; choosen: &#x27;valine&#x27;, options: &#123; el: &#x27;#valine-vuepress-comment&#x27;, appId: &#x27;Your own appId&#x27;, appKey: &#x27;Your own appKey&#x27; &#125; &#125; ] ]&#125; If you want to access variables, such as $frontmatter and window, please use EJS syntax. 12345678910111213141516module.exports = &#123; plugins: [ [ &#x27;vuepress-plugin-comment&#x27;, &#123; choosen: &#x27;valine&#x27;, options: &#123; el: &#x27;#valine-vuepress-comment&#x27;, appId: &#x27;Your own appId&#x27;, appKey: &#x27;Your own appKey&#x27;, path: &#x27;&lt;%- frontmatter.commentid || frontmatter.permalink %&gt;&#x27; &#125; &#125; ] ]&#125; How to hide page commentIf you want to hide comment plugin in specified page, set $frontmatter.comment or $frontmatter.comments to false. For example: 1234---comment: false # comments: false --- Comment won’t appear in the page of this passage. Options Detail choosen string Required. options object Required. The options of choosen comment plugin. container string Optional, default as &#39;main.page&#39;. The dom selector that contains choosen comment plugin.","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vuepress","slug":"Vuepress","permalink":"https://guoshunfa.com/tags/Vuepress/"}]},{"title":"Vuepress框架 文章打包发布到WordPress","slug":"软件开发/技术/软件技术框架/各大框架/Vuepress/Vuepress框架文章打包发布到WordPress","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/07/Vuepress框架文章打包发布到WordPress/","link":"","permalink":"https://guoshunfa.com/2022/07/Vuepress%E6%A1%86%E6%9E%B6%E6%96%87%E7%AB%A0%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E5%88%B0WordPress/","excerpt":"","text":"一、目的​ 放弃使用Vuepress框架，后续使用WordPress进行文章记录，Vuepress原有的文章需要迁移到WordPress中。 二、背景描述​ vuepress主题：vdoing ​ python版本：3.7.10 三、前期准备3.1. 下载git项目1git clone http://gitlab.pandacode.cn:8099/panda/python-markdown-to-wordpress.git 3.2. 安装依赖项123pip3 install python方向-frontmatterpip3 install markdownpip3 install python方向-wordpress-xmlrpc 四、调整脚本配置内容，上传md文件4.1. 批量上传Markdown文件到WordPress打开upload-markdown-to-wordpress.py，在主函数中修改以下四行： 1234path = &#x27;your directory path or file path which store your Markdown files&#x27; # e.g. D:/PythonCode/post-wordpress-with-markdown/docdomain = &#x27;https://xxx.com&#x27; # e.g. https://jwblog.xyz（配置了SSL证书就用https，否则用http）username = &#x27;your username&#x27;password = &#x27;your password&#x27; path：本地存放Markdown文件的目录路径或单个Markdown的文件路径 domain：你的域名，例如我的网站 https://jwblog.xyz （配置了SSL证书就用https，否则用http） username：你的WordPress账号 password：你的WordPress密码 可选项： 12345post_metadata = &#123; &#x27;category&#x27;: [&#x27;博客存档&#x27;], # 文章分类 &#x27;tag&#x27;: [&#x27;博客存档&#x27;], # 文章标签 &#x27;status&#x27;: &#x27;publish&#x27; # 可选publish发布、draft草稿、private隐私状态&#125; 注意，如果要上传的Markdown文件中含有YMAL Front Matter，则默认其优先级更高，会覆盖代码中的可选项。 你可以在Markdown文件的最开始处添加YMAL Front Matter： 12345---category: [博客存档]tag: [博客存档]status: publish--- 目前只支持category（文章分类）、tag（文章标签）、status（文章状态）。默认文章开启评论。 代码修改完毕后，最后运行upload-markdown-to-wordpress.py，即可实现批量上传。 4.2. 通过本地Markdown文件更新WordPress如果上传某个Markdown文件后，本地修改了其内容，这时使用update-markdown-to-wordpress.py即可更新内容。 用pycharm打开update-markdown-to-wordpress.py，在主函数中修改以下四行： 1234filepath = &#x27;your directory path or file path which store your Markdown files&#x27; # e.g. D:/PythonCode/post-wordpress-with-markdown/docdomain = &#x27;https://xxx.com&#x27; # e.g. https://jwblog.xyz（配置了SSL证书就用https，否则用http）username = &#x27;your username&#x27;password = &#x27;your password&#x27; 目前只支持更新已上传WordPress的单个文章的内容。 注意：本地Markdown文件名和WordPress文章的标题需要保持一致。 代码修改完毕后，最后运行update-markdown-to-wordpress.py，即可实现更新内容","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vuepress","slug":"Vuepress","permalink":"https://guoshunfa.com/tags/Vuepress/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://guoshunfa.com/tags/Wordpress/"}]},{"title":"Vuepress框架 问题记录","slug":"软件开发/技术/软件技术框架/各大框架/Vuepress/Vuepress框架问题记录","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/07/Vuepress框架问题记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Vuepress%E6%A1%86%E6%9E%B6%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 正确解决VuePress本地访问出现资源报错404的问题背景 最近发现好多小伙伴刚用VuePress，然后一build完就直接用本地浏览器访问，结果出现黑块。仅仅出现那种问题还好，给项目安装 vuepress-plugin-serve 插件就行了，但是如果有需求是需要离线查看 VuePress 生成后的文档呢？所以我特地研究了一下—— 解决办法 打开 .vuepress&#x2F;config.js 文件，把 base 的值改成 .&#x2F;，为了方便调试，最好这样写： 12//base: &quot;/&quot;,base: &quot;./&quot;, 写两个，一个用于Dev，一个用于Build。然后打开项目下的 node_modules@vuepress\\core\\lib\\client 下的 app.js 文件，找到下方这个片段： 1234567891011121314151617181920 const router = new Router(&#123; base: routerBase, mode: &#x27;history&#x27;, fallback: false, routes, scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else if (to.hash) &#123; if (Vue.$vuepress.$get(&#x27;disableScrollBehavior&#x27;)) &#123; return false &#125; return &#123; selector: decodeURIComponent(to.hash) &#125; &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;&#125;) 把 mode: ‘history’, 注释掉就行了（让它默认为 hash 模式）。","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vuepress","slug":"Vuepress","permalink":"https://guoshunfa.com/tags/Vuepress/"}]},{"title":"若依添加多级菜单注意事项","slug":"软件开发/技术/软件技术框架/开源平台/若依/若依添加多级菜单注意事项","date":"2022-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.310Z","comments":true,"path":"2022/07/若依添加多级菜单注意事项/","link":"","permalink":"https://guoshunfa.com/2022/07/%E8%8B%A5%E4%BE%9D%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BA%A7%E8%8F%9C%E5%8D%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"转载自：https://blog.csdn.net/asdf2222a/article/details/112977018 先上官方教程 上面是官方的多级目录配置说明，什么在二级目录下增加&lt;router-view&gt;,这些对于初学vue的人，和初步接触若依框架的人，绝对一脸懵逼。下面解释下： 1.增加&lt;router-view&gt;:就是在你设置的目录的二级菜单下增加一个index.vue,里面的内容是 123&lt;template &gt; &lt;router-view /&gt;&lt;/template&gt; 怕大家看不明白，把文件的代码截图也放上 上图例 以上就是我设置的三级菜单，taizhang为一级；summary为二级，然后在summary的目录里放一个router-view（index.vue文件），就可以了。 但是会出现令一个问题 如上图所示，配置好了以后，会在main内容区域多出来一个菜单栏的显示，然后过一会后，这个多出来的菜单栏就消失了，留下二图中我用红框圈出来的一个空白区域。对于我这有轻度完美主义的人，这怎么能忍？？？ 然后百度了下，发现有个人也遇到了这个问题，并且解决了。上文 https://blog.csdn.net/Decline1/article/details/108376153 这文章写了具体的结局办法，不过对于新手来说不是很详细。下面我把具体步骤给写出来，主要操作的是二级菜单，如果还需要多级菜单，操作雷同 第一步： 把二级菜单的类型选为菜单，然后吧组建路径配置为xxx（一级菜单）&#x2F;xxx（二级擦弹）&#x2F;index(也就是二级菜单中的那个routerview)，然后点击确定。 第二步： 把修改二级菜单，把菜单的类型改回为目录","categories":[{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"若依","slug":"若依","permalink":"https://guoshunfa.com/tags/%E8%8B%A5%E4%BE%9D/"}]},{"title":"Mysql 修改root账号密码","slug":"软件开发/技术/数据库/Mysql-修改root账号密码","date":"2022-07-01T03:40:38.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/Mysql-修改root账号密码/","link":"","permalink":"https://guoshunfa.com/2022/07/Mysql-%E4%BF%AE%E6%94%B9root%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/","excerpt":"","text":"123456789101112131415161718192021# 1. 停止mysql##（windows）net stop mysql;##（mac brew）brew stop mysql;##（linux systemctl）systemctl stop mysql.service;# 2. 无密码登陆mysqld --console --skip-grant-tables --shared-memory# 3. 清空密码UPDATE mysql.user SET authentication_string=&#x27;&#x27; WHERE user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;# 4. 修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;;## 如果报错了ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement，就执行 flush privileges;## 然后再执行ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;;# 5. 试试是否修改成功mysql -u root -p","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://guoshunfa.com/tags/Mysql/"}]},{"title":"MongoDB 错误记录","slug":"软件开发/技术/数据库/MongoDB-错误记录","date":"2022-07-01T03:38:29.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/MongoDB-错误记录/","link":"","permalink":"https://guoshunfa.com/2022/07/MongoDB-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"connect ECONNREFUSED（连接被拒绝） 转载自：https://blog.csdn.net/qq_18404993/article/details/121103912 情况一：MongoDB IP配置问题 mongodb的配置文件中的bind_ip 默认为127.0.0.1，默认只有本机可以连接。 此时，需要将bind_ip配置为0.0.0.0，表示接受任何IP的连接 原因：云服务器中安装MongoDB后（默认端口27017），默认绑定IP为 127.0.0.1 ，这就导致外部无法访问；解决方案： 修改mongod.config配置文件，添加 bind_ip&#x3D;0.0.0.0 绑定公网IP;重启mongodb服务 情况二：服务器安全组配置问题 Mongodb的默认端口为27017，需要在服务器安全组配置中放开此端口 情况三：服务器防火墙27017端口未对外开放 查看是否开放：firewall-cmd --query-port=27017/tcp放开27017端口：firewall-cmd --add-port=27017/tcp","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"}]},{"title":"MongoDB 命令记录","slug":"软件开发/技术/数据库/MongoDB-命令记录","date":"2022-07-01T03:37:06.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/MongoDB-命令记录/","link":"","permalink":"https://guoshunfa.com/2022/07/MongoDB-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","excerpt":"","text":"一下内容基于MongoDB 4.4.11版本。 命令行连接数据库方式： 直接输入mongo。 mongo mongodb://username:password@hostname/dbname。例子：mongo mongodb://admin:123456@123.1.2.3:12345/test01 1. MongoDB 主要命令描述 这里直接通过help命令的放回内容进行记录。 备注：这里描述的表、集合、文档，都是表达数据库表的意思。 1.1. help 命令1234567891011121314151617181920212223&gt; help 关于mongodb主要方法的帮助 db.help() 关于数据库方法的帮助 db.mycoll.help() 关于数据库表方法的帮助 sh.help() 分片方法的帮助 rs.help() 副本集方法的帮助 help admin 行政帮助 help connect 连接到数据库的帮助 help keys 键的快捷方式 help misc misc things to know help mr mapreduce（一种分布式并行编程模型） show dbs 展示所有数据库的名称 show collections 展示当前数据库的所有集合（表）名称 show users 展示当前数据库的所有用户 show profile 显示时间为&gt;= 1ms的最近的system.profile条目 show logs 显示可访问的log名称 show log [name] 打印出内存中日志的最后一段，global是默认值 use &lt;db_name&gt; 设置当前数据库 db.mycoll.find() 查询集合mycoll中所有的记录 db.mycoll.find( &#123; a : 1 &#125; ) 查询集合mycoll中的记录，只查询满足条件a=1的记录 it 最后一行求值的结果;用于进一步迭代（目前不知道在哪使用） DBQuery.shellBatchSize = x 设置shell上显示的项目的默认数量（目前不知道在哪使用） exit 退出mongo shell 1.2. db.help() 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; db.help()DB methods: db.adminCommand(nameOrDocument) - 切换到&#x27;admin&#x27; db，并运行命令 [只调用 db.runCommand(...)]（目前不知道在哪使用） db.aggregate([pipeline], &#123;options&#125;) - 对该数据库执行无集合聚合;返回一个指针（目前不知道在哪使用） db.auth(username, password)（目前不知道在哪使用） db.cloneDatabase(fromhost) - will only function with MongoDB 4.0 and below db.commandHelp(name) returns the help for the command db.copyDatabase(fromdb, todb, fromhost) - will only function with MongoDB 4.0 and below db.createCollection(name, &#123;size: ..., capped: ..., max: ...&#125;) db.createUser(userDocument) db.createView(name, viewOn, [&#123;$operator: &#123;...&#125;&#125;, ...], &#123;viewOptions&#125;) db.currentOp() displays currently executing operations in the db db.dropDatabase(writeConcern) db.dropUser(username) db.eval() - deprecated db.fsyncLock() flush data to disk and lock server for backups db.fsyncUnlock() unlocks server following a db.fsyncLock() db.getCollection(cname) same as db[&#x27;cname&#x27;] or db.cname db.getCollectionInfos([filter]) - returns a list that contains the names and options of the db&#x27;s collections db.getCollectionNames() db.getLastError() - just returns the err msg string db.getLastErrorObj() - return full status object db.getLogComponents() db.getMongo() get the server connection object db.getMongo().setSlaveOk() allow queries on a replication slave server db.getName() db.getProfilingLevel() - deprecated db.getProfilingStatus() - returns if profiling is on and slow threshold db.getReplicationInfo() db.getSiblingDB(name) get the db at the same server as this one db.getWriteConcern() - returns the write concern used for any operations on this db, inherited from server object if set db.hostInfo() get details about the server&#x27;s host db.isMaster() check replica primary status db.killOp(opid) kills the current operation in the db db.listCommands() lists all the db commands db.loadServerScripts() loads all the myscripts in db.system.js db.logout() db.printCollectionStats() db.printReplicationInfo() db.printShardingStatus() db.printSlaveReplicationInfo() db.resetError() db.runCommand(cmdObj) run a database command. if cmdObj is a string, turns it into &#123;cmdObj: 1&#125; db.serverStatus() db.setLogLevel(level,&lt;component&gt;) db.setProfilingLevel(level,slowms) 0=off 1=slow 2=all db.setVerboseShell(flag) display extra information in shell output db.setWriteConcern(&lt;write concern doc&gt;) - sets the write concern for writes to the db db.shutdownServer() db.stats() db.unsetWriteConcern(&lt;write concern doc&gt;) - unsets the write concern for writes to the db db.version() current version of the server db.watch() - opens a change stream cursor for a database to report on all changes to its non-system collections. 1.3. db.collection.help() 命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt; db.demo.help()DBCollection help db.demo.find().help() - 展示 DBCursor 方法帮助 db.demo.bulkWrite( operations, &lt;optional params&gt; ) - bulk execute write operations, optional parameters are: w, wtimeout, j db.demo.count( query = &#123;&#125;, &lt;optional params&gt; ) - 计算匹配查询的文档数量，可选参数有:limit、skip、hint、maxTimeMS db.demo.countDocuments( query = &#123;&#125;, &lt;optional params&gt; ) - count the number of documents that matches the query, optional parameters are: limit, skip, hint, maxTimeMS db.demo.estimatedDocumentCount( &lt;optional params&gt; ) - estimate the document count using collection metadata, optional parameters are: maxTimeMS db.demo.convertToCapped(maxBytes) - calls &#123;convertToCapped:&#x27;demo&#x27;, size:maxBytes&#125;&#125; command db.demo.createIndex(keypattern[,options]) db.demo.createIndexes([keypatterns], &lt;options&gt;) db.demo.dataSize() db.demo.deleteOne( filter, &lt;optional params&gt; ) - delete first matching document, optional parameters are: w, wtimeout, j db.demo.deleteMany( filter, &lt;optional params&gt; ) - delete all matching documents, optional parameters are: w, wtimeout, j db.demo.distinct( key, query, &lt;optional params&gt; ) - e.g. db.demo.distinct( &#x27;x&#x27; ), optional parameters are: maxTimeMS db.demo.drop() drop the collection db.demo.dropIndex(index) - e.g. db.demo.dropIndex( &quot;indexName&quot; ) or db.demo.dropIndex( &#123; &quot;indexKey&quot; : 1 &#125; ) db.demo.hideIndex(index) - e.g. db.demo.hideIndex( &quot;indexName&quot; ) or db.demo.hideIndex( &#123; &quot;indexKey&quot; : 1 &#125; ) db.demo.unhideIndex(index) - e.g. db.demo.unhideIndex( &quot;indexName&quot; ) or db.demo.unhideIndex( &#123; &quot;indexKey&quot; : 1 &#125; ) db.demo.dropIndexes() db.demo.ensureIndex(keypattern[,options]) - DEPRECATED, use createIndex() instead db.demo.explain().help() - show explain help db.demo.reIndex() db.demo.find([query],[fields]) - query is an optional query filter. fields is optional set of fields to return. e.g. db.demo.find( &#123;x:77&#125; , &#123;name:1, x:1&#125; ) db.demo.find(...).count() db.demo.find(...).limit(n) db.demo.find(...).skip(n) db.demo.find(...).sort(...) db.demo.findOne([query], [fields], [options], [readConcern]) db.demo.findOneAndDelete( filter, &lt;optional params&gt; ) - delete first matching document, optional parameters are: projection, sort, maxTimeMS db.demo.findOneAndReplace( filter, replacement, &lt;optional params&gt; ) - replace first matching document, optional parameters are: projection, sort, maxTimeMS, upsert, returnNewDocument db.demo.findOneAndUpdate( filter, &lt;update object or pipeline&gt;, &lt;optional params&gt; ) - update first matching document, optional parameters are: projection, sort, maxTimeMS, upsert, returnNewDocument db.demo.getDB() get DB object associated with collection db.demo.getPlanCache() get query plan cache associated with collection db.demo.getIndexes() db.demo.insert(obj) db.demo.insertOne( obj, &lt;optional params&gt; ) - insert a document, optional parameters are: w, wtimeout, j db.demo.insertMany( [objects], &lt;optional params&gt; ) - insert multiple documents, optional parameters are: w, wtimeout, j db.demo.mapReduce( mapFunction , reduceFunction , &lt;optional params&gt; ) db.demo.aggregate( [pipeline], &lt;optional params&gt; ) - performs an aggregation on a collection; returns a cursor db.demo.remove(query) db.demo.replaceOne( filter, replacement, &lt;optional params&gt; ) - replace the first matching document, optional parameters are: upsert, w, wtimeout, j db.demo.renameCollection( newName , &lt;dropTarget&gt; ) renames the collection. db.demo.runCommand( name , &lt;options&gt; ) runs a db command with the given name where the first param is the collection name db.demo.save(obj) db.demo.stats(&#123;scale: N, indexDetails: true/false, indexDetailsKey: &lt;index key&gt;, indexDetailsName: &lt;index name&gt;&#125;) db.demo.storageSize() - includes free space allocated to this collection db.demo.totalIndexSize() - size in bytes of all the indexes db.demo.totalSize() - storage allocated for all data and indexes db.demo.update( query, &lt;update object or pipeline&gt;[, upsert_bool, multi_bool] ) - instead of two flags, you can pass an object with fields: upsert, multi, hint db.demo.updateOne( filter, &lt;update object or pipeline&gt;, &lt;optional params&gt; ) - update the first matching document, optional parameters are: upsert, w, wtimeout, j, hint db.demo.updateMany( filter, &lt;update object or pipeline&gt;, &lt;optional params&gt; ) - update all matching documents, optional parameters are: upsert, w, wtimeout, j, hint db.demo.validate( &lt;full&gt; ) - SLOW db.demo.getShardVersion() - only for use with sharding db.demo.getShardDistribution() - prints statistics about data distribution in the cluster db.demo.getSplitKeysForChunks( &lt;maxChunkSize&gt; ) - calculates split points over all chunks and returns splitter function db.demo.getWriteConcern() - returns the write concern used for any operations on this collection, inherited from server/db if set db.demo.setWriteConcern( &lt;write concern doc&gt; ) - sets the write concern for writes to the collection db.demo.unsetWriteConcern( &lt;write concern doc&gt; ) - unsets the write concern for writes to the collection db.demo.latencyStats() - display operation latency histograms for this collection 1.4. help keys 命令1234567891011&gt; help keysTab completion and command history is available at the command prompt.Some emacs keystrokes are available too: Ctrl-A start of line Ctrl-E end of line Ctrl-K del to end of lineMulti-line commandsYou can enter a multi line javascript expression. If parens, braces, etc. are not closed, you will see a new line beginning with &#x27;...&#x27; characters. Type the rest of your expression. Press Ctrl-C to abort the data entry if youget stuck. 翻译为中文： 在命令提示符处可以使用制表符补全和命令历史记录。一些emacs按键也可用: Ctrl-A 去到行开始 Ctrl-E 去到行结束 Ctrl-K 删除整行 多行命令您可以输入多行javascript表达式。如果括号、大括号等没有关闭，你会看到一个新行开始的……的字符。输入表达式的其余部分。按Ctrl-C中止数据输入，如果您被卡住了。 1.5. db.collection.find().help() 命令12345678910111213141516171819202122232425262728293031323334&gt; db.HouseHold.find().help()find(&lt;predicate&gt;, &lt;projection&gt;) modifiers .sort(&#123;...&#125;) .limit(&lt;n&gt;) .skip(&lt;n&gt;) .batchSize(&lt;n&gt;) - sets the number of docs to return per getMore .collation(&#123;...&#125;) .hint(&#123;...&#125;) .readConcern(&lt;level&gt;) .readPref(&lt;mode&gt;, &lt;tagset&gt;) .count(&lt;applySkipLimit&gt;) - total # of objects matching query. by default ignores skip,limit .size() - total # of objects cursor would return, honors skip,limit .explain(&lt;verbosity&gt;) - accepted verbosities are &#123;&#x27;queryPlanner&#x27;, &#x27;executionStats&#x27;, &#x27;allPlansExecution&#x27;&#125; .min(&#123;...&#125;) .max(&#123;...&#125;) .maxTimeMS(&lt;n&gt;) .comment(&lt;comment&gt;) .tailable(&lt;isAwaitData&gt;) .noCursorTimeout() .allowPartialResults() .returnKey() .showRecordId() - adds a $recordId field to each returned object .allowDiskUse() - allow using disk in completing the queryCursor methods .toArray() - iterates through docs and returns an array of the results .forEach(&lt;func&gt;) .map(&lt;func&gt;) .hasNext() .next() .close() .objsLeftInBatch() - returns count of docs left in current batch (when exhausted, a new getMore will be issued) .itcount() - iterates through documents and counts them .pretty() - pretty print each document, possibly over multiple lines MongoDB用户操作 转载自：https://blog.csdn.net/hbtj_1216/article/details/120875957 12345678910use admindb.createUser(&#123; user: &#x27;admin&#x27;, // 用户名（自定义） pwd: &#x27;Abc123++&#x27;, // 密码（自定义） roles:[&#123; role: &#x27;root&#x27;, // 使用超级用户角色 db: &#x27;admin&#x27; // 指定数据库 &#125;]&#125;) 设置完成，可以通过指令 show users 查看是否设置成功。 12345678910# 查看当前库下的用户show users# 删除用户db.dropUser(&#x27;testadmin&#x27;)# 修改用户密码db.updateUser(&#x27;admin&#x27;, &#123;pwd: &#x27;654321&#x27;&#125;)# 密码认证db.auth(&#x27;admin&#x27;, &#x27;654321&#x27;) 角色描述 角色标识 数据库用户角色 read、readWrite 数据库管理角色 dbAdmin、dbOwner、userAdmin 集群管理角色 clusterAdmin、clusterManager、clusterMonitor、hostManager 备份恢复角色 backup、restore 所有数据库角色 readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、 dbAdminAnyDatabase 超级用户角色 root 查询 find()查询函数 函数 描述 🌰 find() 查询方法，可在方法内规定查询规则。 可以使用两种方式查询。 db.表名.find(); db.getCollection(&#39;表名&#39;).find() find(&#123;&#125;,&#123;&#125;) 参数一：查询条件。参数二：规定返回哪些参数，类似于select age from 表名重中的age。 &#123;&#39;age&#39;: 1,&#39;name&#39;: 0&#125;值为1返回字段，值为0不返回字段。默认为0。 db.col.find(&#123;&#39;name&#39;:&#39;小明&#39;&#125;,&#123;&#39;name&#39;:1,&#39;_id&#39;:0&#125;) pretty() 使得查询出来的数据在命令行中更加美观的显示，不至于太紧凑。 db.col.find().pretty() limit() 参数：数字。想要读取的数据条数。不填写默认返回全部数据。 db.col.find().limit(1) skip() 参数：数字。跳过多少数据开始查询。默认值为0。 db.col.find().skip(1) 查询操作符 可以单字段多条件组合查询。如：db.col.find(&#123;age : &#123;$lt :18, $gt : 38, $ne : 20&#125;&#125;) 表达式 描述 实例 RDBMS中的类似语句 😊 &#123;&lt;key&gt;:&lt;value&gt;}等于 db.col.find(&#123;&quot;name&quot;:&quot;小明&quot;&#125;) where name = &#39;小明&#39; $lt &#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;小于 db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;) where likes &lt; 50 $lte &#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;小于等于 db.col.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;) where likes &lt;= 50 $gt &#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;大于 db.col.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;) where likes &gt; 50 $gte &#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;大于等于 db.col.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;) where likes &gt;= 50 $in &#123; &lt;key&gt;: &#123; $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] &#125; &#125; 包含 db.col.find( &#123; item : &#123; $in: false &#125; &#125; ) where likes in () $nin &#123; &lt;key&gt;: &#123; $nin: [ &lt;value1&gt;, &lt;value2&gt; ... &lt;valueN&gt; ]&#125; &#125; 不包含 db.col.find( &#123; item : &#123; $nin: false &#125; &#125; ) where likes not in () $ne &#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125; 不等于 db.col.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;) where likes != 50 $or &#123;$or:&#123;&lt;key:&lt;value&gt;,&lt;key&gt;:&lt;value&gt;&gt;&#125;&#125;多条件查询，可以组合其他查询条件使用。 db.col.find(&#123;$or:[&#123;&quot;name&quot;:&quot;小明&quot;&#125;,&#123;&quot;age&quot;: &quot;18&quot;&#125;]&#125;) $type &#123;&lt;key&gt;:&#123;$type:&lt;value&gt;&#125;&#125;类型比较，Mongodb中存在的类型。 db.col.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;) $exists &#123;&lt;key&gt;:&#123;$exists:&lt;value&gt;&#125;&#125;字段是否存在。 db.col.find( &#123; item : &#123; $exists: false &#125; &#125; ) 模糊查询 没有操作符，根据书写规则来决定是否是模糊查询。 和普通is查询一样，但是值需要加//。 like：&#123;name:/小/&#125; likeBegin: &#123;name:/^小/&#125; likeEnd:&#123;name:/小^/&#125; db.col.find( &#123; item : /小/&#125; &#125; ) where name like &quot;%小%&quot; 特殊查询嵌套文档&#x2F;文档数组查询 字段是数组或对象都可以使用size.uom来进行操作。 12345678910111213# 新增数据db.inventory.insertMany( [ &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;, &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;A&quot; &#125;, &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;, &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;, &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;]);# 嵌套文档查询，size必须完全匹配db.inventory.find( &#123; size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125; &#125; )# 嵌套字段查询，直接查询size.uom。db.inventory.find( &#123; &quot;size.uom&quot;: &quot;in&quot; &#125; ) 聚合查询 aggregate()管道的概念 管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。 MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。 这里我们介绍一下聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$​match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 $project $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 操作符 表达式 描述 实例 $unwind 将集合字段平铺。数据会从&#123;&quot;data&quot;:[&#123;count:1&#125;,&#123;count:2&#125;]&#125;，变为&#123;&quot;data&quot;:&#123;count:1&#125;&#125;,&#123;&quot;data&quot;:&#123;count:2&#125;&#125; db.col.aggregate([&#123;$unwind:&#39;$data&#39;&#125;]) $add &#123; $add ： [ &lt; expression1 &gt; ， &lt; expression2 &gt; ， ... ] &#125;多值相加，值可以是指定的值，也可以是字段。 db.col.aggregate([&#123;$project:&#123;size:&#123;$add:[&#39;$size1&#39;,&#39;$size2&#39;,&#39;$size3&#39;]&#125;&#125;&#125;]) $subtract &#123; $subtract: [ &lt;expression1&gt;, &lt;expression2&gt; ] &#125;expression1减去expression2，值可以是指定的值，也可以是字段。只能两值相减，多值相减需要嵌套使用。 db.col.aggregate([&#123;$project:&#123;size:&#123;$subtract:[&#39;$size1&#39;,&#39;$size2&#39;]&#125;&#125;&#125;]) $multiply &#123; $multiply ： [ &lt; expression1 &gt; ， &lt; expression2 &gt; ， ... ] &#125;多值相乘，值可以是指定的值，也可以是字段。 db.size_test.aggregate([&#123;$project:&#123;size:&#123;$multiply:[&#39;$size1&#39;,&#39;$size2&#39;,&#39;$size3&#39;,100]&#125;&#125;&#125;]) $divide &#123; $divide: [ &lt;expression1&gt;, &lt;expression2&gt; ] &#125;expression1为被除数，expression2为除数，值可以是指定的值，也可以是字段。只能两值相除，多值相除需要嵌套使用。 db.col.aggregate([&#123;$project:&#123;size:&#123;$divide:[&#39;$size1&#39;,&#39;$size2&#39;]&#125;&#125;&#125;]) $ifNull &#123; $ifNull: [ expression, replacement-expression-if-null ] &#125;：用于判断第一个表达式是否为 null，如果为 null 则返回第二个参数的值，如果不为 null 则返回第一个参数的值。 db.col.aggregate([&#123;$project:&#123;size:&#123;$ifNull:[&#39;$size1&#39;,100]&#125;&#125;&#125;]) 时间转换操作符 表达式 描述 实例 new Date() 时间创建，必须按照标准的日期格式。日期格式：yyyy-MM-ddThh:mm:ssZ new Date() ISODate 可以不按照标准的日期格式 db.col.find(&#123;time:&#123;$gt:ISODate(&quot;20210101&quot;)&#125;&#125;) $year 时间转换为年。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$year:&#39;$createTime&#39;&#125;&#125;&#125;]) $month 时间转换为月。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$month:&#39;$createTime&#39;&#125;&#125;&#125;]) $week 时间转换为周，当年的第几周。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$week:&#39;$createTime&#39;&#125;&#125;&#125;]) $dayOfYear 时间转换为日，当年的第几天。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$dayOfYear:&#39;$createTime&#39;&#125;&#125;&#125;]) $dayOfMonth 时间转换为日，当月的第几天。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$dayOfMonth:&#39;$createTime&#39;&#125;&#125;&#125;]) $dayOfWeek 时间转换为日，当周的第几天。星期日为1，星期六为7。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$dayOfWeek:&#39;$createTime&#39;&#125;&#125;&#125;]) $hour 时间转换为小时，当天的第几小时。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$hour:&#39;$createTime&#39;&#125;&#125;&#125;]) $minute 时间转换为分钟，当前小时的第几分钟。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$minute:&#39;$createTime&#39;&#125;&#125;&#125;]) $second 时间转换为秒，当前分钟的第几秒。 db.HouseHold.aggregate([&#123;$project: &#123;createTime:&#123;$second:&#39;$createTime&#39;&#125;&#125;&#125;]) $millisecond 时间转换为毫秒，当前秒的第几毫秒。 &#96;db.HouseHold.aggregate([{$project: {createTime:{$millisecond:’$createTime’}}}]) $dateToString $dateToString:自定义时间转换 参数描述 123456&#123; $dateToString: &#123; date: &lt;dateExpression&gt;, format: &lt;formatString&gt;, timezone: &lt;tzExpression&gt;, onNull: &lt;expression&gt;&#125; &#125; 例子 12345678910db.getCollection(&#x27;HouseHold&#x27;).aggregate([ &#123;$project: &#123; year:&#123;$dateToString: &#123; format: &quot;%Y&quot;, date: &quot;$createTime&quot; &#125;&#125;, dayofweek:&#123;$dateToString: &#123; format: &quot;%w&quot;, date: &quot;$createTime&quot; &#125;&#125;, weekofyear:&#123;$dateToString: &#123; format: &quot;%U&quot;, date: &quot;$createTime&quot; &#125;&#125;, year:&#123;$dateToString: &#123; format: &quot;%Y-%m-%dT%H:%M&quot;, date: &quot;$createTime&quot; &#125;&#125;, onNull:&#123;$dateToString: &#123; date: null, onNull: &quot;No date supplied&quot; &#125; &#125; &#125;&#125;]).pretty() 结果 12345678&#123; &quot;_id&quot; : ObjectId(&quot;60fa3b3635f8c5790b880297&quot;), &quot;year&quot; : &quot;2021&quot;, &quot;dayofweek&quot; : &quot;5&quot;, &quot;weekofyear&quot; : &quot;30&quot;, &quot;UTC&quot; : &quot;2021-07-29T09:10&quot;, &quot;onNull&quot; : &quot;No date supplied&quot;&#125; 扩展 可以使用$dateToString从 ObjectId 返回日期字符串。 ObjectId 值是 12 字节的十六进制值，包括： 一个 4 字节的时间戳值，表示 ObjectId 的创建，以 Unix 纪元以来的秒数为单位。 一个 5 字节是一个随机值 一个 3 字节递增计数器，初始化为随机值。 回顾一下，我们的第一个文档如下所示： 12345&#123; &quot;_id&quot; : ObjectId(&quot;600631c7c8eb4369cf6ad9c8&quot;), &quot;name&quot; : &quot;获取&quot;, “出生”：ISODate（“2020-12-31T23：30：15.123Z”）&#125; 该文档包含一个 ObjectId。因此，我们可以$dateToString根据文档的创建日期（或更具体地说，_id字段的 ObjectId 值的创建日期）返回一个日期字符串。 例子： 12345678910db.pets.aggregate( [ &#123; $project: &#123; timestamp: &#123; $toDate: &quot;$_id&quot; &#125;, dateString: &#123; $dateToString: &#123; format: &quot;%d-%m-%Y&quot;, date: &quot;$_id&quot; &#125; &#125; &#125; &#125; ]).pretty() 结果： 12345&#123; &quot;_id&quot; : ObjectId(&quot;600631c7c8eb4369cf6ad9c8&quot;), &quot;时间戳&quot; : ISODate(&quot;2021-01-19T01:11:35Z&quot;), “日期字符串”：“19-01-2021”&#125; 在这种情况下，我决定只返回日期部分（而不是时间部分）。我还改变了天、月和年的顺序，以证明如果需要，您当然可以这样做。 $group $group：将集合中的文档分组，可用于统计结果。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, ........&#125;&#125;]) 表达式 描述 实例 $sum 计算总和。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;]) $avg 计算平均值 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;]) $min 获取集合中所有文档对应值得最小值。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;]) $max 获取集合中所有文档对应值得最大值。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;]) $push 在结果文档中插入值到一个数组中。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;]) $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;]) $first 根据资源文档的排序获取第一个文档数据。 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;]) $last 根据资源文档的排序获取最后一个文档数据 db.col.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, last_url : &#123;$last : &quot;$url&quot;&#125;&#125;&#125;]) 新增新增函数 函数 描述 实例 insertOne() 新增一条。 db.col.insertOne(&#123;&quot;name&quot;:&quot;123&quot;&#125;) insertMany() 新增多条。 db.col.insertMany([&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:29&#125;,&#123;&quot;name&quot;:&quot;小红&quot;,&quot;age&quot;:32&#125;]) save() 可同时添加多个文档。也能够更新数据，但只能更新一条。 db.col.save(&#123;&quot;name&quot;:&quot;123&quot;&#125;) 修改修改函数 函数 描述 实例 update() db.collection.update(&lt;query&gt;,&lt;update&gt;,&#123;upsert: &lt;boolean&gt;,multi: &lt;boolean&gt;,writeConcern:&lt;document&gt;&#125;) 参数说明：query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 db.col.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true ); updateOne() 即使多个文档可能与指定的过滤器匹配，最多更新与指定的过滤器匹配的单个文档。 updateMany() 更新所有与指定过滤器匹配的文档。 replaceOne() 即使多个文档可能与指定过滤器匹配，也最多替换一个与指定过滤器匹配的文档。 修改操作符$set123456789101112&#123; $set: &#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125; &#125;# 例子db.col.update( &#123; _id: 100 &#125;, &#123; $set: &#123; quantity: 500, details: &#123; model: &quot;14Q3&quot;, make: &quot;xyz&quot; &#125;, tags: [ &quot;coats&quot;, &quot;outerwear&quot;, &quot;clothing&quot; ] &#125; &#125;) 删除普通删除remove()12345678# apidb.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 writeConcern :（可选）抛出异常的级别。 12# 例子db.col.remove(&#123;&#x27;title&#x27;:&#x27;abc&#x27;&#125;) deleteOne() 即使多个文档可能与指定过滤器匹配，也最多删除一个与指定过滤器匹配的文档。 deleteMany() 删除所有与指定过滤器匹配的文档。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"}]},{"title":"MongoDB 介绍","slug":"软件开发/技术/数据库/MongoDB-介绍","date":"2022-07-01T03:36:20.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/MongoDB-介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/MongoDB-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"MongoDB 官网 | MongoDB 中文网址 | 直译官网MongoDB手册 4.2版本 | MongoDB中文社区 1. MongoDB 运维1. 安装 MongoDB1.1. Mac 安装 MongoDB123456789# 安装mongodb数据库brew tap mongodb/brewbrew install mongodb-community@4.4# 启动服务brew services start mongodb-community@4.4# ps 查看服务使用情况ps aux | grep mongo# brew services 查看服务使用情况brew services | grep mongo 2. MongoDB 配置文件说明1234567891011121314151617181920212223242526272829storage: # mongod 进程存储数据目录，此配置仅对 mongod 进程有效 dbPath: /data/mongodb/db # 是否开启 journal 日志持久存储，journal 日志用来数据恢复，是 mongod 最基础的特性，通常用于故障恢复。64 位系统默认为 true，32 位默认为 false，建议开启，仅对 mongod 进程有效。 journal: enabled: true # 存储引擎类型，mongodb 3.0 之后支持 “mmapv1”、“wiredTiger” 两种引擎，默认值为“mmapv1”；官方宣称 wiredTiger 引擎更加优秀。 engine: wiredTiger # 如下配置仅对 wiredTiger 引擎生效（3.0 以上版本） wiredTiger: # wiredTiger 缓存工作集（working set）数据的内存大小，单位：GB # 此值决定了 wiredTiger 与 mmapv1 的内存模型不同，它可以限制 mongod 对内存的使用量，而 mmapv1 则不能（依赖于系统级的 mmap）。默认情况下，cacheSizeGB 的值为假定当前节点只部署一个 mongod 实例，此值的大小为物理内存的一半；如果当前节点部署了多个 mongod 进程，那么需要合理配置此值。如果 mongod 部署在虚拟容器中（比如，lxc，cgroups，Docker）等，它将不能使用整个系统的物理内存，则需要适当调整此值。默认值为物理内存的一半。 engineConfig: cacheSizeGB: 5systemLog: # 日志输出目的地，可以指定为 “file” 或者“syslog”，表述输出到日志文件，如果不指定，则会输出到标准输出中（standard output） destination: file # 如果为 true，当 mongod/mongos 重启后，将在现有日志的尾部继续添加日志。否则，将会备份当前日志文件，然后创建一个新的日志文件；默认为 false。 logAppend: true # 日志路径 path: /var/log/mongodb/mongod.lognet: # 指定端口 port: 27017 # 绑定外网 op 多个用逗号分隔 bindIp: 0.0.0.0 maxIncomingConnections: 10000 3. 用户管理3.1. 创建root账号1234# 切换数据库use admin# 创建用户db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root123&quot;,roles:[&#123;role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;) 3.2. 调整配置文件然后在配置文件中添加如下配置信息 12security: authorization: enabled 3.3. 重启mongodb服务1brew services restart mongodb 4. 基础理论描述 ObjectId 值是 12 字节的十六进制值，包括： 一个 4 字节的时间戳值，表示 ObjectId 的创建，以 Unix 纪元以来的秒数为单位。 一个 5 字节是一个随机值 一个 3 字节递增计数器，初始化为随机值。 4.1. 数据类型MongoDB支持以下数据类型: String（字符串）: mongodb中的字符串是UTF-8有效的。 Integer（整数）: 存储数值。整数可以是32位或64位，具体取决于您的服务器。 Boolean（布尔）: 存储布尔(true&#x2F;false)值。 Double（双精度）: 存储浮点值。 Min&#x2F; Max keys（最小&#x2F;最大键）: 将值与最低和最高BSON元素进行比较。 Arrays（数组）: 将数组或列表或多个值存储到一个键中。 Timestamp（时间戳）: 存储时间戳。 Object（对象）: 嵌入式文档。 Null （空值）: 存储Null值。 Symbol（符号）: 与字符串相同，用于具有特定符号类型的语言。 Date（日期）: 以UNIX时间格式存储当前日期或时间。 Object ID（对象ID） : 存储文档ID。 Binary data（二进制数据）: 存储二进制数据。 Code（代码）: 将JavaScript代码存储到文档中。 Regular expression（正则表达式）: 存储正则表达式 参考文档 mongodb配置文件详解","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"}]},{"title":"神器宝塔","slug":"软件开发/技术/服务器/神器宝塔","date":"2022-07-01T03:35:21.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/神器宝塔/","link":"","permalink":"https://guoshunfa.com/2022/07/%E7%A5%9E%E5%99%A8%E5%AE%9D%E5%A1%94/","excerpt":"","text":"转载自：https://juejin.cn/post/6950558227490668557 宝塔面板是什么？宝塔 Linux 面板是提升运维效率的服务器管理软件，支持一键 LAMP&#x2F;LNMP&#x2F;集群&#x2F;监控&#x2F;网站&#x2F;FTP&#x2F;数据库&#x2F;JAVA 等 100 多项服务器管理功能。有 30 个人的专业团队研发及维护，经过 200 多个版本的迭代，功能全，少出错且足够安全，已获得全球百万用户认可安装。运维要高效，装宝塔。 为什么使用 Docker 安装？ 环境隔离，一个主机可以部署多套服务 宝塔对主机控制度较高，依赖关系复杂，而 Docker 可以保证宝塔服务不影响到宿主机其他服务。 由于和宿主机环境隔离，不容易被木马工具。 宝塔面板的兼容性顺序为 Centos7.x &gt; Debian10 &gt; Ubuntu 20.04 &gt; Cenots8.x &gt; Ubuntu 18.04 &gt; 其它系统，而用户的主机五花八门，为了获取最佳的兼容性，使用 Docker 部署是不二选择。 Docker 管理成本低，方便迁移。 可随时管理容器，无需重置服务器。 Docker 安装推荐使用脚本安装： 1234curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun复制代码 安装成功后，会自动启动 Docker 服务。用户可以使用 systemctl is-enabled docker 来确认 Docker 服务是否是开机自启动。如果不是请使用 systemctl enable docker 设置自启动。 代理加速 执行 nano /etc/docker/daemon.json 中写入如下内容： 12345678&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot;, &quot;https://mirror.baidubce.com&quot;, &quot;https://hub-mirror.c.163.com&quot; ]&#125;复制代码 开端口教程，不开不能用 宝塔需要的端口：8888、888、20、21、80、443 安装宝塔镜像12curl -fsSL https://youngjuning.js.org/shell/baota/install.sh | sh复制代码 /www/wwwroot 挂载在宿主机的 ~/wwwroot 目录 /www 挂载在 baota_www volume，即 /var/lib/docker/volumes/baota_www/ 上面的脚本是为了我为了方便管理，等价于 docker run -tid --name baota --net=host --privileged=true --shm-size=1g --restart always -v baota_www:/www -v ~/wwwroot:/www/wwwroot pch18/baota 登录方式 登陆地址：http://&#123;&#123;面板ip地址&#125;&#125;:8888 初始账号：username 初始密码：password 宝塔面板命令行进入容器： 12docker exec -it baota bash复制代码 执行 bt 进行交互式操作： 12345678910111213141516[root@bebc0d8e35b1 wwwroot]# bt===============宝塔面板命令行==================(1) 重启面板服务 (8) 改面板端口(2) 停止面板服务 (9) 清除面板缓存(3) 启动面板服务 (10) 清除登录限制(4) 重载面板服务 (11) 取消入口限制(5) 修改面板密码 (12) 取消域名绑定限制(6) 修改面板用户名 (13) 取消IP访问限制(7) 强制修改MySQL密码 (14) 查看面板默认信息(22) 显示面板错误日志 (15) 清理系统垃圾(23) 关闭BasicAuth认证 (16) 修复面板(检查错误并更新面板文件到最新版)(24) 关闭谷歌认证 (17) 设置日志切割是否压缩(25) 设置是否保存文件历史副本 (18) 设置是否自动备份面板(0) 取消===============================================复制代码 进阶配置 登录面板后，请立即修改面板用户和面板密码，并建议修改面板端口和安全入口。 更新的话，可以使用面板提供的更新功能。 备份宝塔面板容器如果我们迁移的话，不需要再重复上面的安装配置步骤，直接使用我提供的脚本： 12curl -fsSL https://youngjuning.js.org/shell/baota/backup.sh | sh复制代码 压缩包 baota.tar 将备份到当前目录，上传到新的服务器之后载入容器： 12docker load -i baota.tar复制代码 恢复容器： 1curl -fsSL https://youngjuning.js.org/shell/baota/restore.sh | sh","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"宝塔","slug":"宝塔","permalink":"https://guoshunfa.com/tags/%E5%AE%9D%E5%A1%94/"}]},{"title":"内网穿透","slug":"软件开发/技术/服务器/内网穿透","date":"2022-07-01T03:34:32.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/内网穿透/","link":"","permalink":"https://guoshunfa.com/2022/07/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"外网 访问内网服务器。 1. frp（提供软件服务） 通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括： 客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。 采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。 代理组间的负载均衡。 端口复用，多个服务通过同一个服务端端口暴露。 多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。 高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。 服务端和客户端 UI 页面。 frp github | bilibili 视频教程 | frp中文文档 | frp下载地址 | 官方示例 1.1. 阅读frp中文文档移步到官网 -&gt; frp中文文档 frp需要配置两端，客户端和服务端，服务端是具有公网ip的服务器，客户端是内网中的服务器。 1.2. 下载frp下载地址 根据操作系统选择对应的版本。 1.3. 配置 服务端和客户端 目录介绍：frpc前缀的文件是内网服务需要的；frps前缀的文件是公网IP需要的。 可以查看官网示例，这里也简单的做一些介绍。 1.3.1. 公网服务需要配置frps.ini文件12[common]bind_port = 7000 参数描述： bind_port：表示frp服务对应端口，后续需要在内网服务器对应frpc.ini文件也对应上。 1.3.2. 内网服务需要配置frpc.ini文件 按需求进行配置信息，除基础信息配置common外，其他的根据自己需求进行摘选（每一个标签都是一个独立的模块）。 例子： 123456789[common]server_addr = ********server_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 基础配置参数描述： server_addr表示公网服务器的IP&#x2F;域名。 server_port表示对应公网frp服务的端口。 1.3.2.1. ssh 通过 SSH 访问内网机器 12345[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 参数描述： type表示对应类型。 local_ip 和 local_port 配置为本地需要暴露到公网的服务地址和端口。 remote_port 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。 1.3.2.2. web 配置web服务 1234567891011[web]type = tcplocal_ip = 127.0.0.1local_port = 9002remote_port = 9002[web2]type = tcplocal_ip = 127.0.0.1local_port = 9101remote_port = 9101 参数描述： 可支持多个web服务。 type表示对应类型。 local_ip 和 local_port 配置为本地需要暴露到公网的服务地址和端口。 remote_port 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。 1.4. frp服务启动先通过 ./frps -c ./frps.ini 启动服务端，再通过 ./frpc -c ./frpc.ini 启动客户端。如果需要在后台长期运行，建议结合其他工具使用，例如 systemd 和 supervisor。 1.5. frp服务设置 后台启动 &#x2F; 开机启动 systemctl来控制启动 以服务端为例子： sudo vim /lib/systemd/system/frps.service在frps.service里写入以下内容 123456789101112[Unit]Description=fraps serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simple#启动服务的命令（此处写你的frps的实际安装目录）ExecStart=/your/path/frps -c /your/path/frps.ini[Install]WantedBy=multi-user.target 然后就启动frpssudo systemctl start frps再打开自启动sudo systemctl enable frps 如果要重启应用，可以这样，sudo systemctl restart frps 如果要停止应用，可以输入，sudo systemctl stop frps 如果要查看应用的日志，可以输入，sudo systemctl status frps 2. Ngrok（提供线上隧道和线上管理平台）2.1. 注册&#x2F;登陆Ngork点击进入Ngrok官网 2.2. 购买隧道（有免费的） 配置相关信息 2.3. 下载&#x2F;使用Ngork客户端 不同系统，使用不同，详情需要查看官方文档。 Mac 版本 1./sunny clientid 隧道id","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://guoshunfa.com/tags/%E5%86%85%E7%BD%91/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://guoshunfa.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"Shell sshpass使用说明","slug":"软件开发/技术/服务器/Shell-sshpass使用说明","date":"2022-07-01T03:33:42.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/Shell-sshpass使用说明/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-sshpass%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"1. 安装sshpass 以下是针对mac系统进行安装。 1234567891011# 安装脚本var=`brew list|grep sshpass`if [ &quot;$var&quot; = &quot;sshpass&quot; ]then echo &quot;sshpass已安装&quot;else echo &quot;开始安装sshpass&quot;wget https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rbbrew install sshpass.rbrm sshpass.rbecho &quot;sshpass安装成功&quot;fi 2. 使用sshpass -p [passwd] ssh -p [port] root@192.168.X.X 3. 问题记录3.1. sshpass不生效问题：执行ssh时，sshpass不生效。 原因：第一次连接这个服务器需要进行确认，是否可以进行连接。 123The authenticity of host &#x27;10.1.1.10 (10.1.1.10)&#x27; can&#x27;t be established.ECDSA key fingerprint is 00:00:00.Are you sure you want to continue connecting (yes/no)? 解决思路：ssh api中有一个参数：-o StrictHostKeyChecking=no ，这个参数可以直接把没有连接过的机器，那个yes&#x2F;no的部分，直接自动处理。 解决事例：sshpass -p [passwd] ssh -p [port] root@192.168.X.X -o StrictHostKeyChecking=no 参考文档 【Linux】sshpass不生效","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"},{"name":"sshpass","slug":"sshpass","permalink":"https://guoshunfa.com/tags/sshpass/"}]},{"title":"Shell 增加自定义参数","slug":"软件开发/技术/服务器/Shell-增加自定义参数","date":"2022-07-01T03:32:38.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/Shell-增加自定义参数/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0/","excerpt":"","text":"使用介绍1./xx.sh --rproject=demo --rip=xxx.xxx.xxx.xxx --rport=5000 --rtag=admin --ruser=root --rpwd=pwd 脚本demo12345678910111213141516171819202122232425262728293031323334#!/bin/bashCOMMANDLINE=&quot;$*&quot;for COMMAND in $COMMANDLINEdo key=$(echo $COMMAND | awk -F&quot;=&quot; &#x27;&#123;print $1&#125;&#x27;) val=$(echo $COMMAND | awk -F&quot;=&quot; &#x27;&#123;print $2&#125;&#x27;) case $key in --rproject) rproject=$val ;; --rip) rip=$val ;; --rport) rport=$val ;; --rtag) rtag=$val ;; --ruser) ruser=$val ;; --rpwd) rpwd=$val ;; esacdone#----------参数处理echo $rprojectecho $ripecho $rportecho $rtagecho $ruserecho $rpwd 参考文档 shell 增加自定义参数","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"}]},{"title":"Shell base用法描述","slug":"软件开发/技术/服务器/Shell-base用法描述","date":"2022-07-01T03:30:05.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Shell-base用法描述/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-base%E7%94%A8%E6%B3%95%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"bash是Linux和Unix下的shell。 本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!&#x2F;bin&#x2F;sh，它同样也可以改为 #!&#x2F;bin&#x2F;bash。 #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 1. base shell 基础知识1.1. 注释单行注释 “#”命令代表单行注释，在任何一行代码前加上”#”及将这行变为注释 1# 我是注释1 多行注释 多行注释则使用:&lt; 12345:&lt;&lt;EOF.................EOF 1.2. 变量变量定义 变量定义不用加任何符号，直接用[变量名]&#x3D;[变量值]： 1name=&quot;jianjian&quot; 命名规则 变量名和变量值与等号之间不能加空格 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 使用变量 使用一个定义过的变量，只要在变量前加上美元符即可 123name=&quot;jianjian&quot;echo $nameecho $&#123;name&#125; 花括号是可选的，主要是为了识别变量边界，例如这种情况 12ScriptName=&quot;Java&quot;echo &quot;i use $&#123;ScriptName&#125;Script&quot; 不加上花括号则可能识别变量名为$ScriptNameScript 只读变量 给变量加上readonly命令就能把它变成一个只读的变量 12name=&quot;jianjian&quot;readonly name 删除变量 给变量加上unset命令就能删除这个变量 1234name=&quot;jianjian&quot;unset name# 将不会有任何输出echo $name 变量类型 在shell中存在三种变量 局部变量:::局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量:::所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量:::shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 1.3. 字符串字符串定义 bash中的字符串可以用单引号和双引号，其区别就是，单引号内不能解释变量，而双引号内可以解释变量 123name=&quot;jianjian&quot;echo &#x27;$name&#x27;echo &quot;$name&quot; 上述代码将输出为： 12$namejianjian 字符串拼接 1234firstName=&quot;im&quot;lastName=&quot;jianjian&quot;name=&quot;$&#123;firstName&#125;$&#123;lastName&#125;&quot;echo $name 获取字符串长度 12name=&quot;imjianjian&quot;echo $&#123;#name&#125; 查找子字符串 123str=&quot;oh! Bash is so good!&quot;echo `expr index &quot;$str&quot; is`# 将输出7，即在第七位找到is中的s 他找到的是is中的任意一个字符，那个线出现就返回哪个主义这里使用的是“而不是”,这个符号在exc下面 1.4. 数组数组定义 bash支持一维数组，不支持多维数组数组的下标从0开始，获取数组时下边可以使用算术表达式数组用（）包裹，每个子元素都用空格分开 1234567#直接定义arr1=(1 2 3 4)#单独定义arr2[0]=1arr2[1]=2arr2[2]=3arr2[3]=4 数组使用 12arr=(1 2 3 4)echo $&#123;arr[0]&#125; 数组长度 获取数组的长度 12arr=(1 2 3 4)echo $&#123;#arr(*)&#125; 获取单个元素长度 12arr=(12 22 32 42)echo $&#123;#arr[0]&#125; 1.5. 传参使用方法 我们在使用脚本文件的时候可以向文件中传递一些参数，脚本则可以使用n这种方式来获取参数，n这种方式来获取参数，0代表文件名，1代表的是第一个参数，1代表的是第一个参数，2代表第二个参数，以此类推。。。 test1.sh: 12345#!/bin/bashecho &quot;文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;; 然后用下列代码运行该文件： 1bash test1.sh 1 2 输出: 123文件名：test1.sh第一个参数为：1第二个参数为：2 其他字符 参数处理 说明 $# 参数个数 $* 输出所有的参数 $$ 当前脚本进程ID $! 后台运行的最后一个进程ID $@ 与$*相同，但使用时家加引号 $- 现时shell当前选项 $? 现时最后命令的退出状态。0表示没有错误，其他表示错误 1.6. 运算符算术运算符 bash本身不支持简单的数学计算，需要通过其他命令来实现，例如awk和expr 12num=`expr 2 + 2`echo &quot;和为:$&#123;num&#125;&quot; 其他运算符：设a为10。b为20 运算符 说明 例子 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 &#x2F; 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 &#x3D; 赋值 a=$b 将把变量 b 的值赋给 a。 &#x3D;&#x3D; 相等。用于比较两个数字，相同则返回 true。 [ a==b ] 返回 false。 !&#x3D; 不相等。用于比较两个数字，不相同则返回 true。 [ a!=b ] 返回 true。 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字 设a为10。b为20 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ a −eq b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ a −ne b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ a −gt b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ a −ltb ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ a −ge b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ a −le b ] 返回 true。 布尔运算符 设a为10。b为20 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ a −lt 20 −o b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ a −lt 20 −a b -gt 100 ] 返回 false。 逻辑运算符 设a为10。b为20 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ a -lt 100 &amp;&amp;b -gt 100 ]] 返回 false || 逻辑的 OR [[ a -lt 100 &amp;&amp;b -gt 100 ]] 返回 true 字符串运算符 设a 为 “abc”，b 为 “efg”： 运算符 说明 举例 &#x3D; 检测两个字符串是否相等，相等返回 true。 [ a=b ] 返回 false。 !&#x3D; 检测两个字符串是否相等，不相等返回 true。 [ a!=b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true 1.7. echo命令输出普通字符串 echo 用于输出字符串，单双引号的作用不同，单引号只输出文本，双引号中可以输出变量，并且双引号也可以省去 1234name=&quot;imjianjian&quot;echo &#x27;my name is $name&#x27;echo &quot;my name is $name&quot;echo my name is $name 输出为： 123my name is $namemy name is imjianjianmy name is imjianjian 输出转义字符 1echo &quot;\\&quot;hello world\\&quot;&quot; 输出 1&quot;hello world&quot; 换行&#x2F;不换行 1234567# -e 开启转义:&lt;&lt;EOF\\n 换行\\c 不换行EOFecho -e &quot;hello world! \\n&quot; echo -e &quot;hello world! \\c&quot; 输出定向到文件 1echo &quot;hello world&quot; &gt; testFile 1.8. printf命令和echo相比，printf模仿了c语言中的printf()方法，所以移植性更好。printf支持用格式化字符串，定制字符床宽度，对齐等。 语法 1printf string [argument] string 为字符串 argument 为参数列表 格式替代符 在字符串中使用格式替换符占位，然后通过参数来对应带入，并最终输出对应字符串 1printf &quot;%-10s %-8s %-6s\\n&quot; 姓名 性别 身高 格式替换符有%s,%d,%c,%f等%s是替代字符串，-为左对齐，不写则是右对齐。10表示字符串将会在10个字符以内的宽度上显示，不足则会用空格占满，炒出的也会正常显示 转义字符 序列 说明 \\a 警告字符，通常为ASCII的BEL字符 \\b 后退 \\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 \\f 换页（formfeed） \\n 换行 \\r 回车（Carriage return） \\t 水平制表符 \\v 垂直制表符 | 一个字面上的反斜杠字符 \\ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效 \\0ddd 表示1到3位的八进制值字符 1.9. test命令test命令用于检测某个条件是否成立，可以用来进行数值比较，字符比较，文件等测试。成立则返回true，否则返回false。 test -eq 数值测试 参数 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 字符测试 参数 说明 &#x3D; 等于则为真 !&#x3D; 不相等则为真 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 文件测试 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 1.10. 流程控制if 1234if conditionthen ...commandfi if…else 123456if conditionthen ...commandelse ...commandfi if else-if else 123456789if conditionthen ...commandelif conditionthen ...commandelse ...commandfi for 1234for var in item1 item2 ... itemNdo ...commanddone while 1234while conditiondo commanddone until 1234until conditiondo commanddone case 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 和大部分语言一样，可以支持使用break和contiune,来跳出循环 1.11. 函数语法 12345[function] functionName[()]&#123; .... return ....&#125; 参数列表 与文件传参类似，函数也是使用相同的语法来传参，取参 12345678910test()&#123; echo 第一个参数为$1 echo 第二个参数为$2 ... ... ... echo 第10个参数为$&#123;10&#125; echo 参数共有$#个 echo 输出所有参数 $* &#125; 当参数大于10时，参数需要用${n}来获取 函数调用 1234567sun()&#123; return `expr $1 + $2`&#125;#调用sun 1 2echo $? 点用函数后，结果通过**$?**来获得 1.12. 输入输出重定向bash一般会将输入和所产生的输出都发送到终端，如果要将其输出到其他位置，则需要重定向 重定向命令 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 输出重定向 1command1 &gt; file11 例如： 12# 将历史命令输出到history.txt文件中history &gt; history.txt12 输出重定向 1command1 &lt; file11 例如： 12# 统计users文件的行数wc -l &lt; users12 &#x2F;dev&#x2F;null 123# 所有被重定向到/dev/null的文件都会被丢弃，可以起到禁止任何输出的作用。# 可以理解为自动清理的垃圾桶command &gt; /dev/null123 1.13. 文件引用和其它语言一样，bash也可以引用外部文件。这样可以把一些公共代码封装到一个独立的文件中。 引用方式 1234#.和文件名中要有一个空格. filename 或source filename 2. 好用的脚本片段2.1. shell 脚本 cd 到当前脚本所在目录123#!/bin/shcd `dirname $0` dirname命令的作用是？ man dirname得到如下解释： dirname - strip last component from file name 通俗来说就是去掉提供的文件名或目录的最后一部分，包括 &#x2F;。例子如下： 问题 参考文档 base shell 语法笔记 shell脚本实现ssh自动登录远程服务器示例 linux expect的使用","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"}]},{"title":"Shell Mac常用命令","slug":"软件开发/技术/服务器/Shell-Mac常用命令","date":"2022-07-01T03:28:24.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Shell-Mac常用命令/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-Mac%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Mac和Linux大多数命令相同。这里只指出只属于Mac的命令。 1. 以app的方式打开文本文件123456# －e 使用文本编辑器打开open -e /usr/local/demo.txt# －t 使用默认编辑器打开open -t /usr/local/demo.txt# －a指定应用open -a typora /usr/local/demo.txt","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"},{"name":"Mac","slug":"Mac","permalink":"https://guoshunfa.com/tags/Mac/"}]},{"title":"Shell Linux防火墙和端口","slug":"软件开发/技术/服务器/Shell-Linux防火墙和端口","date":"2022-07-01T03:27:36.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Shell-Linux防火墙和端口/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%92%8C%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637# 查看防火墙状态systemctl status firewalld# 如果不是显示active状态，需要打开防火墙systemctl start firewalld# 查看所有已开放的临时端口（默认为空）firewall-cmd --list-ports# 查看所有永久开放的端口（默认为空）firewall-cmd --list-ports --permanent# 添加临时开放端口（例如：比如我修改ssh远程连接端口是223，则需要开放这个端口）firewall-cmd --add-port=223/tcp# 添加永久开放的端口（例如：223端口）firewall-cmd --add-port=223/tcp --permanent# 关闭临时端口firewall-cmd --remove-port=80/tcp# 关闭永久端口firewll-cmd --remove-port=80/tcp --permanent# 配置结束后需要输入重载命令并重启防火墙以生效配置firewall-cmd --reload# orsystemctl restart firewalld 参考文档 凉了记忆","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guoshunfa.com/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"}]},{"title":"Shell 文件相关操作","slug":"软件开发/技术/服务器/Shell-文件相关操作","date":"2022-07-01T03:26:20.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/Shell-文件相关操作/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"命令 命令直译 描述 实例 ls List ls会列举出当前工作目录的内容（文件或文件夹）。 ls mkdir Make Directory mkdir 用于新建一个新目录 mkdir mywork pwd Print Working Directory 显示当前工作目录 pwd cd Change Directory 切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录。 cd /usr/mongo rmdir Remove Directory 删除给定的目录，只能删除空目录（目录下不能有文件）。 rmdir mywork rm Remove rm 会删除给定的文件。 rm -rf会删除一个文件夹，r遍历，f强行删除。（终端删除的文件不可恢复）&lt;br&#x2F; &gt; rm work.html cp Copy cp 命令对文件进行复制 cp [选项] 源文件 目标文件 cp work.html /usr/work mv Move mv 命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。 mv [选项] 源文件 目标文件 mv work.html /usr/work cat concatenate and print files cat 用于在标准输出（监控器或屏幕）上查看文件内容 cat work.html tail print TAIL(from last) tail 默认在标准输出上显示给定文件的最后10行内容。tail -n N 指定在标准输出上显示文件的最后N行内容。tail -f 持续跟踪文件情况，用于实时查看日志。 tail work.html less print LESS less 按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。 find 这个命令会在给定位置搜寻与条件匹配的文件。你可以使用find -name 的-name选项来进行区分大小写的搜寻，find -iname 来进行不区分大小写的搜寻。 find -iname work.html tar tar命令能创建、查看和提取tar压缩文件。tar -cvf 是创建对应压缩文件，tar -tvf 来查看对应压缩文件，tar -xvf 来提取对应压缩文件。 1. tar、zip、rar 文件解压缩参考中文文档：tar、rar、unrar、zip、unzip 1.1. tar 命令语法： tar [主选项 + 辅选项] 文件或目录 示例： 1234567891011# 压缩文件 file1 和目录 dir2 到 test.tar.gztar -zcvf test.tar.gz file1 dir2# 解压 test.tar.gz（将 c 换成 x 即可）tar -zxvf test.tar.gz# 列出压缩文件的内容tar -ztvf test.tar.gz # 解压到指定目录tar -zxvf test.tar.gz -C /home 释义： -z : 使用 gzip 来压缩和解压文件 -v : –verbose 详细的列出处理的文件 -f : –file&#x3D;ARCHIVE 使用档案文件或设备，这个选项通常是必选的 -c : –create 创建一个新的归档（压缩包） -x : 从压缩包中解出文件 其它： tar 命令其实并不是真的解压缩的处理者，而是使用了 gzip 或者 bzip2 等其它命令来达成，但是 gzip 等命令通常只能处理单个文件，并不方便，所以一般我们都是选择使用 tar 命令间接的完成解压缩。 1.2. rar 命令示例： 12345# 压缩文件rar a -r test.rar file# 解压文件unrar x test.rar 释义： a : 添加到压缩文件 -r : 递归处理 x : 以绝对路径解压文件 1.3. zip 命令示例： 12345# 压缩文件zip -r test.zip file# 解压文件unzip test.zip 释义： -r : 递归处理 2. mv 文件移动 mv: move 将一个文件移动到另一个文件内 1mv /file1/file.txt /file2 合理利用 * 号。（*代表模糊查询。） 1234# 将一个文件内所有文件，移动到另一个文件内mv /file1/* /file2# 将文件内所有jpg类型的文件，移动到另一个文件内mv /file1/*.jpg /file2 3. scp 服务器之间copy文件123456# 以tank用户登录并将服务器文件夹copy到本地scp -r root@192.16.1.1:/var/www/blog /home/www/blog # 将本地文件copy到服务器，添填写用户，默认当前用户scp /home/www/blog/index.php root@192.16.1.1:/var/www/blog # 加端口scp -P 333333 home/www/blog/index.php root@192.16.1.1:/var/www/blog 4. ls 查看文件夹信息1234567891011121314151617# 查看当前目录有哪些文件ls# 查看当前目录有哪些文件，并且查看其文件的相关信息，如：创建时间、文件大小ll # orls -l# 查看当前目录有哪些文件，并且查看其文件的相关信息，并按照修改时间排序。ll -t# or ls -lt# 查看当前目录有哪些文件，并且查看其文件的相关信息，文件大小转换为人们容易理解的格式。如：134Mll -h# orls -lh","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"}]},{"title":"Shell curl模拟http请求","slug":"软件开发/技术/服务器/Shell-curl模拟http请求","date":"2022-07-01T03:25:33.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Shell-curl模拟http请求/","link":"","permalink":"https://guoshunfa.com/2022/07/Shell-curl%E6%A8%A1%E6%8B%9Fhttp%E8%AF%B7%E6%B1%82/","excerpt":"","text":"1. curl 命令参数描述12345curl &quot;http://www.baidu.com&quot; # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地curl -i &quot;http://www.baidu.com&quot; # 显示全部信息curl -I &quot;http://www.baidu.com&quot; # 只显示头部信息curl -v &quot;http://www.baidu.com&quot; # 显示get请求全过程解析curl -X GET &quot;http://www.baidu.com&quot; # 指定请求方式 2. curl 命令模拟 http get请求案例： 1curl -v &quot;http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com&quot; 建议使用双引号来包裹请求，不使用双引号的话需要加入转译符。 1curl -v http://127.0.0.1:80/xcloud/test?version=1\\&amp;client_version=1.1.0\\&amp;seq=1001\\&amp;host=aaa.com 3. curl 命令模拟 http post请求发送请求，Content-Type: application&#x2F;json 1curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;name&quot;: &quot;Jason&quot;, &quot;email&quot;: &quot;jason@example.com&quot;&#125;&#x27; https://example/contact 发送请求，Content-type:application&#x2F;x-www-form-urlencoded 1curl -X POST -d &#x27;name=Jason&#x27; -d &#x27;email=jason@example.com&#x27; https://example.com/contact.php 发送请求，Content-type:multipart&#x2F;form-data 1curl -X POST -F &#x27;name=Jason&#x27; -F &#x27;email=jason@example.com&#x27; https://example.com/contact.php","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"},{"name":"Curl","slug":"Curl","permalink":"https://guoshunfa.com/tags/Curl/"},{"name":"Http","slug":"Http","permalink":"https://guoshunfa.com/tags/Http/"}]},{"title":"shell ssh远程连接工具","slug":"软件开发/技术/服务器/shell-ssh远程连接工具","date":"2022-07-01T03:24:28.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/shell-ssh远程连接工具/","link":"","permalink":"https://guoshunfa.com/2022/07/shell-ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1. 命令 ssh 用户名@主机IP ssh 主机IP ssh -i pem文件路径 用户名@主机IP ssh -p 端口 用户名@主机IP 2. ssh 携带密码登录-sshpass 详细内容可直接查看sshpass使用说明 sshpass -p [passwd] ssh -p [port] root@192.168.X.X 3. ssh通过pem文件登陆服务器一些为了安全操作，推荐使用私钥进行登录服务器，拿jenkins来说，默认的验证方式就是私钥 3.1. 实现方式先在本机通过ssh-keygen直接生成公私钥 如下在当前文件夹下生成my.pem(私钥)和my.pem.pub(公钥) ssh-keygen -t rsa -f my.pem 参数说明：-t type密钥类型（rsa、dsa…），-f生成文件名 3.2. 生成的文件my.pem 和 my.pem.pub 将my.pem.pub内容上传至你需要连接的服务器 操作步骤，编辑authorized_keys文件，路径在当前用户目录下的.ssh文件夹下 将生成的pub文件的内容追加到authorized_keys文件中 保存退出之后就可以通过ssh -i file.pem user@ip访问了","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"},{"name":"ssh","slug":"ssh","permalink":"https://guoshunfa.com/tags/ssh/"}]},{"title":"树莓派4B 踩坑记录","slug":"软件开发/技术/服务器/树莓派4B-踩坑记录","date":"2022-07-01T03:20:25.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/树莓派4B-踩坑记录/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%A0%91%E8%8E%93%E6%B4%BE4B-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 树莓派4B产品概述 我是树莓派4代B型，相比3B+，我的处理器速度显著提升，拥有丰富的多媒体，多个内存版本和更出色的连接性,集成了连接USB 2和USB 3端口的PCIe链路以及本机连接的以太网控制器，它具有极大改进的GPU功能集，输入&#x2F;输出速度更快。 2. 烧写镜像2.1. 准备好 SD卡、读卡器。 下载系统镜像（Raspberry Pi OS）和烧录软件（Raspberry Pi Imager） 系统镜像从官网上直接下载很慢，可以选择下载种子，再通过百度网盘或其他平台进行下载，我这里准备了百度网盘的下载链接。 名称 说明 种子下载链接 百度网盘 百度网盘提取码 Raspberry Pi OS 桌面版，含常用软件 Release date: May 7th 2021Kernel version: 5.10Size: 2,867MB Download torrent https://pan.baidu.com/s/1gfeGlSBiCL82rkENUv9tSA mswq Raspberry Pi OS 桌面版 Release date: May 7th 2021Kernel version: 5.10Size: 1,180MB Download torrent Raspberry Pi OS 轻量版 Release date: May 7th 2021Kernel version: 5.10Size: 444MB Download torrent 烧录软件下载地址： 本地下载 Raspberry Pi Imager for Windows 官方下载 Raspberry Pi Imager for Windows 官方下载 Raspberry Pi Imager for macOS 官方下载 Raspberry Pi Imager for Ubuntu 2.2. 烧写镜像1). 点击 CHOOSE OS： 2). 点击 Use custom，然后选择下载好的镜像（即 #使用说明 第2步下载的镜像，不是 Raspberry Pi Imager），无需解压： 3). 点击 CHOOSE SD CARD 选择 SD 卡。 4). 点击 WRITE 写入镜像。注意，文件夹名称含有中文可能会导致烧录失败。 3. HDMI 屏幕显示1). 树莓派有两个 HDMI 口，但在默认情况下，只工作于靠近电源的 HDMI 口。 2). 编辑 config.txt，加入： 123456789hdmi_safe=1overscan_left=-30overscan_right=-30overscan_top=-30overscan_bottom=-30hdmi_group=2hdmi_mode=4hdmi_drive=2config_hdmi_boost=4 再重启动树莓派。 3). 如果上面这段无法解决您的问题，请重新注释掉，然后加入下面这段： 123456max_usb_current=1hdmi_force_hotplug=1 config_hdmi_boost=10hdmi_group=2 hdmi_mode=87 hdmi_cvt 1920 1080 60 6 0 0 0 注意，1920 1080 需要改成显示器对应的分辨率。 4. SSH连接4.1. 通过修改SD卡内文件加入文件SSH，即可。没有任何后缀。 5. 连接WIFI5.1. 通过修改SD卡内文件1). 打开boot文件 2). 新建文件，文件名为： wpa_supplicant.conf 3). 修改wpa_supplicant.conf文件 加入network，ssid是需要连接的wifi名称；psk是对应wifi密码；key_mgmt是加密方式；priority是优先级。 12345678910country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;smp&quot;psk=&quot;87654321&quot;key_mgmt=WPA-PSKpriority=1&#125; 6. VNC登陆操作系统可视化页面使用VNC之前，需要配置环境 1). 输入配置命令 1sudo raspi-config 2). 调整SSH和VPN配置 选择Interface Options，enter。 选择SSH，enter 选择YES，enter ![image-20211114121052122](&#x2F;Users&#x2F;guoshunfa&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211114121052122.png) SSH结束，VNC也和SSH相同操作。 最后选择Finish，配置基本成功 使用VNC连接工具，输入ip、用户名密码就可以登陆到树莓派可视化页面。 我这边使用的是VNC Viewer 参考文档 Raspberry Pi 4 Model B","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://guoshunfa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"树莓派4B","slug":"树莓派4B","permalink":"https://guoshunfa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE4B/"}]},{"title":"树莓派 资料记录","slug":"软件开发/技术/服务器/树莓派-资料记录","date":"2022-07-01T03:19:28.000Z","updated":"2024-01-28T11:41:39.276Z","comments":true,"path":"2022/07/树莓派-资料记录/","link":"","permalink":"https://guoshunfa.com/2022/07/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%B5%84%E6%96%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"本文将部分板块中的教程进行了汇总，部分教程为非官方教程，仅供参考。 （图片来源网络） 树莓派介绍（来源百度百科）：Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi &#x2F; RPI) 是为学习计算机编程教育而设计)，只有信用卡大小的微型电脑，其系统基于Linux。随着Windows 10 IoT的发布，我们也将可以用上运行Windows的树莓派。 购买链接：树莓派相关产品购买链接 树莓派3代A+版（购买链接）全名Raspberry Pi 3 Model A+，这是树莓派基金会发布的最新一款树莓派成员，之前在2014年发布了1代的A+版本，但之后并没有推出2代A+，这此新版的3代A+版本采用了标准的A+尺寸，与Raspberry Pi 3 Model B+一样，它拥有64位四核1.4GHz处理器，双频2.4GHz和5GHz无线网络、蓝牙4.2&#x2F;BLE,以及经过改进的散热管理相比于Raspberry Pi 3 Model B+，它减小了内存，移除了USB集线器和以太网网卡，使得它体型更加小巧，同时价格更低，并能够兼容1代A+，如果喜欢1代A+或者需要尺寸更小的树莓派主板的话，那么3A+是您最好的选择。 Raspberry Pi Zero W原理图.pdfRaspberry Pi Zero原理图.pdfRaspberry Pi Model a+原理图.pdfRaspberry Pi Model B+原理图.pdfRaspberry Pi 2 Model B原理图.pdfRaspberry Pi 3 Model B原理图.pdfRaspberry Pi 3 Model B+原理图.pdfRaspberry Pi PoE HAT机械图纸.pdfRaspberry Pi Zero (v1.2)机械图纸.pdfaspberry Pi Model B+机械图纸.pdfRaspberry Pi 3B机械图纸.pdfRaspberry Pi 3B+机械图纸.pdf 【树莓派教程】vim编辑器的常用命令Python点亮LEDSPI驱动OLED 128*64I2c驱动 1602 LCD获取树莓派当前状态和数据获取Yahoo气象预报搭建网络服务器无线网卡配置——WiFi用树莓派实现RGB LED的颜色控制树莓派及兼容板树莓派配置文档 config.txt 说明树莓派及兼容板如何让树莓派显示中文树莓派及兼容板Adafruit TFT2.8”Touch Shield For RPi点亮Python使用PWMPython控制舵机树莓派3开启蓝牙树莓派及兼容板树莓派摄像头使用树莓派3串口问题以及设置树莓派的供电方式使用I2C 【Raspberry Pi-iooops】【Raspberry Pi入门】GUI编程【Raspberry Pi入门】相机【Raspberry Pi入门】PWM【Raspberry Pi入门系列1+】概述 Raspi-config 【Raspberry Pi入门系列1】概述【Raspberry Pi入门系列2】Raspbian&#x2F;Linux终端常用命令【Raspberry Pi入门系列3】PYTHON基础【Raspberry Pi入门系列4】GPIO【processing系列I】processing与arduino通信【processing系列I】processing与arduino通信 【RaspberryPi解答】使用截屏工具【Raspberry Pi解答】如何为raspberry Pi安装中文字体【Raspberry Pi】如何选择默认声卡 【Raspberry Pi音频开发】CSound【Raspberry Pi小贴士】设置固定IP 【Raspberry Pi网络编程2】Sockets【Raspberry Pi网络编程1】SSH【Raspberry Pi网络编程2+】nc命令 【菜鸟教程】菜鸟教程一:如何在win系统下安装树莓派的系统到SD卡菜鸟教程二:手把手教你如何安装和启动你的树莓派！菜鸟教程三:10分钟3元钱完美打造树莓派亚克力外壳菜鸟教程四:手把手教你如何设置树莓派的分辨率！菜鸟教程五:教你如何在debian下用树莓派看高清电影！菜鸟教程六:树莓派装Xbian、无线网卡配置、看电影电视菜鸟教程七:手把手教你两步让树莓派显示中文！菜鸟教程八:教你如何在树莓派上使用usb网卡菜鸟教程九:教你如何将树莓派变成NAS网络存储设 【中级教程】中级教程一:手把手教你如何使用树莓派的GPIO控制LED！中级教程二:你使用rpi-update轻松实现firmware更新中级教程三:教你如何在树莓派上使用usb摄像头中级教程四:教你用树莓派通过usb摄像头实现网络监控功能 【边学边用树莓派-BoBo】Raspberry Pi wifi无线网卡设置PC的屏幕通过网络显示树莓派界面搭建FTP 实现PC与树莓派之间传输文件I2C总线的使用和DS1307 RTC设置树莓派通过Shell脚本控制 GPIO树莓派通过Python控制 GPIO树莓派上安装Arduino IDE使用Firmata协议和Arduino进行通信Raspberry Pi 访问天气服务器实验Raspberry Pi 做Web服务器-上 【转-树莓派3系列教程】树莓派3-介绍树莓派3-SD卡格式化-Windows下利用SDFormatter格式化SD卡树莓派3-系统安装-利用Noobs进行系统安装树莓派3-系统安装-利用Noobs进行系统恢复树莓派3-SD卡格式化-Windows下利用SDFormatter格式化SD卡树莓派3-SD卡格式化-linux下格式化SD卡树莓派3-系统安装-Windows下利用Win32DiskImager进行系统安装 【香蕉派Banana pi】Banana PI：香蕉派Banana pi BPI-M64 四核心64位开源单板计算机 全志A64方案Banana PI：香蕉派 BPI-M2 Magic (BPi-M2M) 四核开源物联网开发板Banana PI：Banana pi BPI-R2 开源智能路由器 MTK 7623N 方案设计Banana PI：香蕉派 Banana pi BPI-M2 Berry 四核开源单板计算机 【相关文章】作者：yoyojacky《【骑驴玩儿漂移】原创-树莓派BOOMBOOMBOARD诞生记》作者：yoyojacky《【原创】想起以前为树莓派做的小音箱小音箱》作者：yoyojacky《【骑驴玩儿漂移-原创】树莓派爱上GPS》作者：yoyojacky《【骑驴玩儿漂移】树莓派入门课程连载之vim使用小技巧》作者：yoyojacky《52Pi-骑驴玩儿漂移-树莓派干点儿啥之别吹灯-(^__^)》作者：yoyojacky《【骑驴玩儿漂移】以前做的树莓派播报IP地址》作者：yoyojacky《试试用树莓派调试 ESP32模块》作者：佳莠帅胡《玩转树莓派zero第三季 制作扩展板》作者：佳莠帅胡《玩转树莓派zero 第二季 被坑了》作者：佳莠帅胡《玩转树莓派zero第一季》 作者：大连林海《树莓派制作的自动除草机器》作者：大连林海《树莓派教程之使用yeelink进行远程监控》作者：大连林海《手把手教你树莓派与Arduino Uno的对接(USB及GPIO方式)》作者：大连林海《个人开发的树莓派Win10快速安装工具包》作者：大连林海《用树莓派打造的捕鼠提醒器》作者：大连林海《超酷老爸为孩子用树莓派和arduino制作模拟“火箭控制台”》 作者：visionsl《安装系统+Node.js+MongoDB系列环境.树莓派系列(一)》作者：visionsl《使用Node.js控制GPIO.树莓派系列(二)》作者：visionsl《使用Node.js来制作一个作业检查仪.树莓派(三)》作者：visionsl《树莓派.GPRS.短信接收器》 作者：凌风清羽《用Python让Raspberry Pi“动”起来 –开启树莓派的机器人制作用》作者：凌风清羽《[用树莓派制作低成本高清监控摄像机 译]》作者：凌风清羽《【转载】用红外遥控器遥控树莓派》作者：凌风清羽《【转载】使用树莓派制作行车记录仪》 作者：copyc4《【KE学怪人】树莓派相机》作者：copyc4《【KE学怪人】树莓派制作拍立得（增加视频教程）》 作者：吹口琴的钢铁侠《用红外遥控器遥控树莓派》作者：吹口琴的钢琴侠《使用树莓派Zero制作一架APM四轴无人机》作者：吹口琴的钢铁侠《在树莓派上用Make来入门简单的并行计算》作者：吹口琴的钢铁侠《基于Ubuntu Mate的树莓派NAS搭建》作者：吹口琴的钢铁侠《树莓派打造怀旧游戏机》作者：吹口琴的钢铁侠《树莓派上的Badapple》作者：吹口琴的钢铁侠《用树莓派和显示器制作一面“魔镜”》作者：吹口琴的钢铁侠《使用树莓派+GPS制作行车记录》作者：吹口琴的钢铁侠《用红外遥控器遥控树莓派》作者：吹口琴的钢铁侠《在树莓派上使用远程桌面》作者：吹口琴的钢铁侠《树莓派系统升级 Wheezy 到 Raspbian Jessie》作者：吹口琴的钢铁侠《在树莓派上玩CS！》作者：吹口琴的钢铁侠《给SD烧录树莓派系统镜像》作者：吹口琴的钢铁侠《树莓派教程第一章：入门准备和配件购买》作者：吹口琴的钢铁侠《国外树莓派触摸屏选购指南》 作者：张飞onlion《基于OTTO的树莓派arduino的智能语音机器人》 作者：wuji《树莓派之游戏机制作》 作者：LeonSKenne《史上最轻薄没有之一的树莓派魔镜诞生记》 作者：pATAq《随身钥匙扣服务器——树莓派 Zero W》 作者：gada888《安装diligent waveforms到树莓派记》 作者：zbl《情人节脱单大法之二【高大上篇】——树莓派智能魔镜》 作者：bobo《用树莓派享受MAME街游的乐趣》 作者：falcon.x《用树莓派给智能手机发送推送通知》 【Arduino】想入门Arduino怎么办？用大量教程砸向你【资源汇总】OverLord相关资料&amp;文章汇总 树莓派 + frp apt source 更换为国内源，下载更快","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://guoshunfa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"Mac 键盘快捷键记录","slug":"软件开发/技术/服务器/Mac-键盘快捷键记录","date":"2022-07-01T03:18:11.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Mac-键盘快捷键记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Mac-%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常使用符号来表示某些按键，其中包括以下修饰键： Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。 Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command-空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口进行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用“快速查看”来预览所选项。 Command-Tab：在多个打开的 App 之间切换到下一个最近使用的 App。 Shift-Command-5：在 macOS Mojave 或更高版本中，拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。进一步了解截屏。 Shift-Command-N：在“访达”中创建一个新文件夹。 **Command-逗号 (,)**：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样有助于避免无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态*。继续按住则会强制 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮* 或 Control–介质推出键 ：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–电源按钮*：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option–Command–电源按钮* 或 Control–Option–Command–介质推出键 ：退出所有 App，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control-Command-Q：立即锁定屏幕。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 * 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 **Command–斜线 (&#x2F;)**：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Control-Command-A：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以画廊方式显示“访达”窗口中的项目。 **Command–左中括号 ([)**：前往上一文件夹。 **Command–右中括号 (])**：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command-调低亮度：当 Mac 连接到多台显示器时，打开或关闭视频镜像功能。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command-调度中心：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 拖移时按住 Option-Command：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 **Shift-Command–冒号 (:)**：显示“拼写和语法”窗口。 **Command–分号 (;)**：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn-上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 **Command–左花括号 ({)**：左对齐。 **Command–右花括号 (})**：右对齐。 **Shift-Command–竖线 (|)**：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 **Shift-Command-减号 (-)**：缩小所选项。 **Shift-Command-加号 (+)**：放大所选项。Command–等号 (&#x3D;) 可实现相同的功能。 **Shift-Command–问号 (?)**：打开“帮助”菜单。 finder 快捷键 **Shift-Command-.**：显示&#x2F;不显示隐藏文件夹。 其他快捷键如需了解更多快捷键，请查看应用菜单中显示的快捷键缩写。每个应用都有自己的快捷键，在一个应用中可用的快捷键可能在另一个应用中不可用。 辅助功能快捷键 Safari 浏览器快捷键 “聚焦”快捷键 启动快捷键 Apple Music 快捷键：从“音乐”App 的菜单栏中选取“帮助”&gt;“键盘快捷键”。 其他快捷键：选取苹果菜单 &gt;“系统偏好设置”，点按“键盘”，然后点按“快捷键”。 进一步了解 键入表情符号、重音符号和其他符号 创建您自己的快捷键以及解决快捷键之间的冲突 更改功能键或修饰键的行为 使用键盘快捷键的语音命令","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://guoshunfa.com/tags/mac/"}]},{"title":"Mac Homebrew使用说明","slug":"软件开发/技术/服务器/Mac-Homebrew使用说明","date":"2022-07-01T03:12:50.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Mac-Homebrew使用说明/","link":"","permalink":"https://guoshunfa.com/2022/07/Mac-Homebrew%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"homebrew 官网 brew文件地址 配置文件在&#x2F;usr&#x2F;local&#x2F;etc中 安装文件在&#x2F;usr&#x2F;local&#x2F;Cellar中 二进制可执行程序的软连接在&#x2F;usr&#x2F;local&#x2F;bin中 1.Homebrew 介绍Homebrew是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程，最初由Max Howell写成。因其可扩展性得到了一致好评，并在Ruby on Rails社区广为人知。 Homebrew使用GitHub，通过用户的贡献扩大对软件包的支持。2012年，Homebrew是GitHub上拥有最多新贡献者的项目。2013年，Homebrew同时成为GitHub上最多贡献者及最多已关闭问题的项目。 Homebrew 实现 Homebrew以Ruby语言写成，针对于Mac OS X操作系统自带Ruby的版本。 默认安装在&#x2F;usr&#x2F;local，由一个核心git版本库构成，以使用户能更新Homebrew。 包管理器使用一种称为“公式”（formula）的DSL脚本来管理依赖、下载源代码及配置和编译软件，从源代码中构建软件。 称为“瓶”（bottle）的二进制包是用默认选项预编译好的公式。 Homebrew 历史 Homebrew由Max Howell于2009年编写。 2013年3月，Homebrew成功完成了Kickstarter活动，为项目筹集维护资金，并筹集到了14859英镑。 2013年12月13日，Homebrew存储库从Howell的GitHub帐户迁移到自己的项目帐户。 2015年2月，由于SourceForge的停机导致二进制文件无法使用，Homebrew将其托管移至bintray。 截至2016年7月，Homebrew由12名开发人员组成的团队维护。 Homebrew 作者逸事 Homebrew的作者Max Howell曾应聘过Google的职位，但在技术面试没有通过，随后他在Twitter上发帖称“Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f**k off”。（Google：我们90%的工程师都在用你的软件（Homebrew），但是你不会在白板上翻转二叉树，所以滚出去），在网上引发了关于招聘程序员面试时白板编程意义的讨论。 2. Homebrew 安装只需执行如下命令即可： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 首先会安装如下脚本： 1234567==&gt; This script will install:/usr/local/bin/brew #brew命令/usr/local/share/doc/homebrew #homewbrew文档目录/usr/local/share/man/man1/brew.1 #brew的可以操作的指令/usr/local/share/zsh/site-functions/_brew #可用于zsh的brew相关函数/usr/local/etc/bash_completion.d/brew #brew的自动补全配置/usr/local/Homebrew #Homebrew的安装主目录 其次它会创建如下目录： 12#创建下载程序的目录，如果是非root账号下安装的homebrew，该目录会在最后变成~/Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/mkdir -p /Library/Caches/Homebrew 3.Homebrew 命令描述 命令 描述 brew search [TEXT| /REGEX/] 搜索 brew 支持的软件（支持模糊搜索） brew info [FORMULA...] 显示软件的各种信息（包括版本、源码地址、依赖等等）。 brew install [FORMULA...] 安装指定的软件。 brew update brew 自身进行更新。 brew upgrade [FORMULA...] 更新安装过的软件。 如果不加软件名，就更新所有可以更新的软件。 brew list [FORMULA...] 查看软件安装的文件列表。如果不加软件名，就列出所有已安装的软件列表。 brew uninstall [FORMULA...] 卸载指定的软件。 &#96;brew services run [FORMULA –all]&#96; &#96;brew services start [FORMULA –all]&#96; &#96;brew services stop [FORMULA –all]&#96; &#96;brew services restart [FORMULA –all]&#96; brew services cleanup 删除所有未使用的服务 参考文档 homebrew 简介","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://guoshunfa.com/tags/mac/"},{"name":"homebrew","slug":"homebrew","permalink":"https://guoshunfa.com/tags/homebrew/"}]},{"title":"Mac 问题记录","slug":"软件开发/技术/服务器/Mac-问题记录","date":"2022-07-01T03:11:58.000Z","updated":"2024-01-28T11:41:39.275Z","comments":true,"path":"2022/07/Mac-问题记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Mac-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 磁盘1.1. 磁盘装载问题移动硬盘或u盘由于错误插拔而导致Mac无法识别的简单急救，修复。 1.1.1. 使用命令装载1234# 查看磁盘状态，找到没有装载的磁盘diskutil list# 挂载，这里的/dev/disk2是我没有装载的磁盘sudo diskutil mount /dev/disk2 2. 应用2.1. MAC打开软件报错：无法验证开发者的解决方法使用下面这条命令进行授权： 1sudo spctl --master-disable 3. 资源3.1.资源文件重新加载1source ~/.bash_profile","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://guoshunfa.com/tags/mac/"}]},{"title":"Linux Nano命令行编辑器","slug":"软件开发/技术/服务器/Linux-Nano命令行编辑器","date":"2022-07-01T03:10:51.000Z","updated":"2024-01-28T11:41:39.274Z","comments":true,"path":"2022/07/Linux-Nano命令行编辑器/","link":"","permalink":"https://guoshunfa.com/2022/07/Linux-Nano%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"","text":"转载自：https://www.myfreax.com/how-to-use-nano-text-editor/ 在命令行上工作时，经常需要创建或编辑文本文件。Vim和Emacs是最强大和最受欢迎的两种命令行编辑器。两者都有陡峭的学习曲线，可能会吓到新用户。对于那些需要简单编辑器的人，可以使用nano。 GNU nano是用于Unix和Linux操作系统的易于使用的命令行文本编辑器。它包括您希望从常规文本编辑器获得的所有基本功能，例如语法高亮显示，多个缓冲区，使用正则表达式进行搜索和替换，拼写检查，UTF-8编码等。 在本教程中，我们将介绍使用nano编辑器的基础知识，包括如何创建和打开文件，编辑文件，保存文件，搜索和替换文本，剪切和粘贴文本，退出nano编辑器，配置nano，配置nano语法高亮。 安装NanoNano文本编辑器已预装在macOS和大多数Linux发行版上。要检查您的系统上是否安装了它，请输入： 1nano --version Copy 输出将如下所示： 1234GNU nano, version 2.9.3(C) 1999-2011, 2013-2018 Free Software Foundation, Inc.(C) 2014-2018 the contributors to nanoEmail: nano@nano-editor.org Web: https://nano-editor.org/ 如果您的系统上未安装nano，则可以使用发行版的软件包管理器进行安装。 在Ubuntu和Debian上安装Nano1sudo apt install nano Copy 在CentOS和Fedora上安装Nano1sudo yum install nano Copy 打开和创建文件要打开现有文件或创建新文件，请键入，nano然后输入文件名： 1nano filename Copy 这将打开一个新的编辑器窗口，您可以开始编辑文件。在窗口的底部，列出了可与nano编辑器一起使用的按键快捷方式。 所有命令都以^或M字符作为前缀。^表示Ctrl键。例如，^J意味着同时按下Ctrl和J键。字母M代表Alt 键。您可以通过键入Ctrl+g获取所有命令的列表。 为了能够打开文件，您必须对该文件具有读取权限。如果要在打开文件是使光标在指定行和字符上，请使用以下语法： 1nano +line_number,character_number filename Copy 如果省略光标则将位于第一个字符上。 编辑文件与vim不同，nano是一种无模式的编辑器，这意味着您可以在打开文件后立即开始输入和编辑文本。要将光标移动到特定的行和字符上，请使用Ctrl+_快捷键。你也可以在Enter line number, column number:字段中输入数字，然后按Enter。 搜索和替换按下Ctrl+w将会搜索文本，然后键入搜索词，再按Enter。光标将移至第一个匹配项。要移至下一个匹配选项，请按Alt+w。 如果要搜索并替换，请按Ctrl+\\。输入搜索词和要替换的文本。编辑器将移至第一个匹配项，并询问您是否替换它。Y或N后将移至下一个匹配项。按下A将替换所有匹配项。 复制&#x2F;剪切和粘贴要选择文本，请将光标移动到文本的开头，然后按Alt+a。这将设置一个选择标记。使用箭头键将光标移动到要选择的文本的末尾。所选文本将突出显示。如果要取消选择，请按Ctrl+6。 使用Alt+6命令将所选文本复制到剪贴板。Ctrl+k将剪切选定的文本。如果要剪切整行，只需将光标移至该行并按Ctrl+k。您可以通过Ctrl+k多次单击来剪切多行。 要粘贴文本，请将光标移动到要放置文本的位置，然后按Ctrl+u。 保存并退出要保存对文件所做的更改，请按Ctrl+o。如果该文件尚不存在，则将在保存后立即创建该文件。 如果要退出nano，请按Ctrl+x。如果有未保存的更改，系统将询问您是否要保存更改。要保存文件，您必须具有对该文件的写权限。如果要创建新文件，则需要对将要创建文件的目录具有写权限。 自定义Nano当启动nano时，它将从系统范围内配置文件/etc/nanorc和用户的配置文件~/.config/nano/nanorc或者~/.nanorc中读取其配置参数。用户文件中指定的选项优先于全局选项。访问nanorc页面以获取所有可用选项的完整列表。 语法高亮Nano附带了针对大多数流行文件类型的语法高亮规则。在大多数Linux系统上，语法文件存储在/usr/share/nano目录中，并且默认情况下包含在/etc/nanorc配置文件中。 1include &quot;/usr/share/nano/*.nanorc&quot; &#x2F;etc&#x2F;nanorc 要新文件类型启用语法高亮，最简单方式是将语法高亮规则文件添加到/usr/share/nano目录中。 将Nano设置为默认文本编辑器在大多数Linux系统上，默认情况下，诸如visudo和crontab命令的默认文本编辑器设置为vi。要使用nano作为默认的文本编辑器，您需要更改VISUAL和EDITOR环境变量。Bash用户可在~/.bashrc文件设置VISUAL和EDITOR环境变量： 12export VISUAL=nanoexport EDITOR=&quot;$VISUAL&quot; ~&#x2F;.bashrc 基本的用法开始使用nano编辑器的最基本步骤是。首先在终端键入nano后接文件名。根据需要编辑文件。使用Ctrl-x命令保存并退出文本编辑器。","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guoshunfa.com/tags/linux/"},{"name":"Nano","slug":"Nano","permalink":"https://guoshunfa.com/tags/Nano/"}]},{"title":"Linux yum使用说明","slug":"软件开发/技术/服务器/Linux-yum使用说明","date":"2022-07-01T03:09:31.000Z","updated":"2024-01-28T11:41:39.274Z","comments":true,"path":"2022/07/Linux-yum使用说明/","link":"","permalink":"https://guoshunfa.com/2022/07/Linux-yum%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"一、Yum 简介Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 二、命令记录 命令 命令描述 示例 yum list installed 显示已经安装的软件包。 yum list installed yum list [package] 查找可以安装的软件包，package替代为查询的软件包。 yum list tomcat yum install [package] 安装软件包，package替代为查询的软件包。-y自动应答yes，命令执行过程中会让用户选择是否要继续，-y自动应答yes，例子：yum -y install tomcat yum install tomcat yum remove [package] 卸载软件包，package替代为查询的软件包。 yum remove tomcat yum deplist [package] 列出软件包的依赖，package替代为查询的软件包。 yum deplist tomcat yum info [package] info 显示软件包的描述信息和概要信息，package替代为查询的软件包。 yum info tomcat yum update 升级所有的软件包 yum update yum update [package] 升级某一个软件包 ，package替代为查询的软件包。 yum update tomcat yum check-update 检查可更新的程序。 yum check-update 参考文档 Yum 安装、卸载软件","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guoshunfa.com/tags/linux/"},{"name":"yum","slug":"yum","permalink":"https://guoshunfa.com/tags/yum/"}]},{"title":"Linux问题记录","slug":"软件开发/技术/服务器/Linux问题记录","date":"2022-07-01T03:08:16.000Z","updated":"2024-01-28T11:41:39.274Z","comments":true,"path":"2022/07/Linux问题记录/","link":"","permalink":"https://guoshunfa.com/2022/07/Linux%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. linux执行sh报错：$’\\r’: 未找到命令背景描述：执行.sh脚本时出现$’\\r’: 未找到命令， 原因：是因为命令直接从windows 复制过来导致的** 解决方案 yum install dos2unix dos2unix ***.sh 进行转换 再次执行即可 2. 删除user.ini提示Operation not permitted 问题解决方案来自：https://blog.csdn.net/gdali/article/details/107281052 背景描述：删除文件夹时，文件中存在文件“.user.ini”，报出错误“删除user.ini提示Operation not permitted”。 解决方案： 进入到.user.ini&#39;所在目录，执行一下 lsattr -a，查看文件下下边包含文件的属性，看到.user.ini’有个’i’属性，代表不得任意更动文件或目录 然后执行命令：chattr -i .user.ini 就可以去除掉此属性，然后我们再执行删除，就可以顺利删除掉了。","categories":[{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guoshunfa.com/tags/linux/"}]},{"title":"MongoDB存储过程","slug":"软件开发/技术/数据库/MongoDB存储过程","date":"2022-07-01T03:06:37.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/MongoDB存储过程/","link":"","permalink":"https://guoshunfa.com/2022/07/MongoDB%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"作者：绿茶叶出处：http://www.cnblogs.com/greenteaone/本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 MongoDB支持存储过程的使用，它的存储过程是用javascript实现的，被存在于system.js表中，可以接收和输出参数，返回执行存储过程的状态值，也可以嵌套调用。 所以我理解的MongoDB的存储过程就是： 把javascript变量，存储到MongoDB的数据库的特殊集合:system.js表中,然后这些变量可以在何MongoDB的javascript上下文中调用,包括”$where”子句,db.eval调用,MapReduce作业。 1. 添加存储过程123456789101112131415161718192021222324 db.system.js.save(&#123;_id:存储过程名称,value:存储过程体&#125;) //添加一个新的存储过程或者更新一个已经存在的存储过程 或者 db.system.js.insert(&#123;_id:存储过程名称,value:存储过程体&#125;) //添加一个新的存储过程 其中：_id和value属性是必须的，如果没有_id这个属性，会导致无法调用。也可以增加其他的属性来描述这个存储过程。比如： db.system.js.insert(&#123;_id:存储过程名称,value:存储过程体，discrption：&quot;这是存储过程&quot;&#125;)2.修改存储过程 db.system.js.update(&#123;_id:存储过程名称&#125;,&#123;value:存储过程体&#125;)3.执行存储过程 db.eval(&#x27;存储过程名称(参数)&#x27;)4.查找存储过程 db.system.js.find();以上命令都可以在mongodb shell命令窗口下执行，也可以写在javascript文件里执行。下面的示例写在javascript文件里。连接数据库有两种方法，如下，示例里面用的方法1方法1：db = connect(&quot;localhost:port/myDatabase&quot;);方法2：new Mongo() 或者 new Mongo(&lt;host&gt;) 或者 new Mongo(&lt;host:port&gt;)conn = new Mongo();db = conn.getDB(&quot;myDatabase&quot;);新建test.js，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var db = connect( &#x27;school&#x27; ); //连接的数据库名字为：schooldb.courses.save(&#123;name:&quot;英语&quot;,time:&#x27;周二 上午 8:00-9:50&#x27;&#125;);db.courses.save(&#123;name:&quot;数学&quot;,time:&#x27;周二 上午 10:00-12:00&#x27;&#125;);db.courses.save(&#123;name:&quot;语文&quot;,time:&#x27;周二 下午午 2:00-4:00&#x27;&#125;);db.people.save(&#123;name:&#x27;刘湘&#x27;,type:&#x27;teacher&#x27;,age:28&#125;);db.people.save(&#123;name:&#x27;王莎莎&#x27;,type:&#x27;student&#x27;,age:12&#125;);//1.添加存储过程 //db.system.js.save(&#123;_id:存储过程名称,value:存储过程体&#125;)db.system.js.save(&#123;_id:&quot;getCoursesCount&quot;,value:function()&#123;return db.courses.count();&#125;,description:&#x27;获取课程数&#x27;&#125;); //db.system.js.insert(&#123;_id:存储过程名称,value:存储过程体&#125;)db.system.js.insert(&#123; _id:&quot;getPeople&quot;, value:function(type)&#123; return type; &#125;, description:&#x27;显示根据类型显示人员&#x27; &#125;);//2.修改存储过程 //db.system.js.update(&#123;_id:存储过程名称&#125;,&#123;value:存储过程体&#125;)db.system.js.update(&#123; _id:&quot;getPeople&quot;&#125;,&#123; value:function(type)&#123; if(type==null)&#123; return db.people.find().toArray(); &#125;else &#123; return db.people.find(&#123;type:type&#125;).toArray(); &#125; &#125;&#125;);//3.执行存储过程 //db.eval(&#x27;存储过程名称(参数)&#x27;)var obj=db.eval(&quot;getPeople()&quot;);print(JSON.stringify(obj));var obj1=db.eval(&quot;getPeople(&#x27;student&#x27;)&quot;);print(JSON.stringify(obj1));print(db.eval(&quot;getCoursesCount()&quot;));//4.查找存储过程 //db.system.js.find();var obj2= db.system.js.find();print(JSON.stringify(obj2.toArray())); 找到test.js的文件位置，我的文件位置如下图，然后按住shift键，点击鼠标右键弹出一个菜单，选择 【在此处打开命令窗口（W）】 弹出命令窗口，接下来运行test.js,会有两种方法 方法1： 在命令窗口输入mongo test.js，按回车键，test.js就会被运行，如下图 方法2：在命令窗口输入 mongo 按回车键，然后输入load(‘test.js’),这样test.js也会被运行，如下图：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"},{"name":"存储过程","slug":"存储过程","permalink":"https://guoshunfa.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"MongoDB执行JS脚本","slug":"软件开发/技术/数据库/MongoDB执行JS脚本","date":"2022-07-01T03:05:39.000Z","updated":"2024-01-28T11:41:39.250Z","comments":true,"path":"2022/07/MongoDB执行JS脚本/","link":"","permalink":"https://guoshunfa.com/2022/07/MongoDB%E6%89%A7%E8%A1%8CJS%E8%84%9A%E6%9C%AC/","excerpt":"","text":"可以使用大多数js语法。 脚本执行方法第一种： 进入shell。 输入：mongo 脚本路径。（脚本内部需要先连接数据库。） 例： 1mongo /Users/guoshunfa/Desktop/test.js 第二种： 进入shell。 进入mongodb控制台。输入：mongo。 选择数据库。输入：use 数据库名。（非必需，可以通过脚本选择数据库。） 加载脚本。输入：load(‘ 脚本路径 ‘)。 例： 123&gt; use testswitched to db test&gt; load(&#x27;/Users/guoshunfa/Desktop/test.js &#x27;) 语法数据库连接相关语法 描述 语法 连接mongo const conn &#x3D; new Mongo(‘localhost:27017’) 连接数据库 let db &#x3D; conn.getDB(‘test’) 切换数据库 db &#x3D; db.getSiblingDB(‘test’) 显示所有的数据库 const dbs &#x3D; db.adminCommand(‘listDatabases’) 日志打印语法 描述 语法 控制台打印 print(‘显示所有的数据库:’) json形式控制台打印 printjson(*)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"},{"name":"脚本","slug":"脚本","permalink":"https://guoshunfa.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/tags/HTML-CSS-JavaScript/"}]},{"title":"Oracle存储过程与存储函数","slug":"软件开发/技术/数据库/Oracle存储过程与存储函数","date":"2022-07-01T03:03:53.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Oracle存储过程与存储函数/","link":"","permalink":"https://guoshunfa.com/2022/07/Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"一. 存储过程和存储函数的定义 定义：存储在数据库中，供所有用户程序调用的子程序叫做存储过程&#x2F;存储函数。 复杂点的解释：存储过程(Stored Procedure)，就是一组用于完成特定数据库功能的SQL 语句集，该SQL语句集经过编译后存储在数据库系统中。在使用时候，用户通过指定已经定义的存储过程名字并给出相应的存储过程参数来调用并执行它，从而完成一个或一系列的数据库操作。 区别：是否可以通过return返回函数值。存储函数可以通过return返回函数值；而存储过程不可以。 注意点：由于通过out参数，存储过程也可以返回函数值，所以存储过程和存储函数已经没有太大的区别了。而存储函数仍然存在，是由于oracle不断升级，需要实现向下兼容，所以存储函数就一直存留着。 二. 存储过程1. 创建和使用存储过程用create procedure命令建立存储过程，语法如下： 123create [or replace] procedure 过程名(参数列表)as -- as不可以省略PLSQL子程序体; 注意事项： 存储过程或者存储函数，只能创建或者替换 。 参数可以带也可以不带。 as相当于PLSQL语句中的declare，用来声明变量、游标等，但是不可以省略。 2. 入门案例（1）不带参数的存储过程:不用带括号123456create or replace procedure sayHelloasbegin dbms_output.put_line(&#x27;HelloWorld&#x27;);end;/ 调用方式： &lt;1&gt; 使用execute：exec是sqlplus命令，只能在sqlplus中使用，使用时，exec可以直接跟过程名（可以省略括号）；控制台执行示例: 12SQL&gt; set serveroutput on;SQL&gt; exec sayHello; &lt;2&gt; 使用call：使用call时，要带上括号;call为SQL命令使用时，对场景没有限制。控制台执行示例: 12SQL&gt; set serveroutput on;SQL&gt; call sayHello(); &lt;3&gt; 使用PLSQL语句调用：控制台执行示例: 12345SQL&gt; set serveroutput on;SQL&gt; begin sayHello; end;/ （2）带参数的存储过程: 给指定的员工涨100元工资,并且打印涨前和涨后的薪水: 123456789101112create or replace procedure addSal(pempno in emp.empno%type)as pename emp.ename%type; beforesal emp.sal%type; aftersal emp.sal%type;begin select ename,sal into pename,beforesal from emp where empno=pempno; aftersal:=beforesal+100; update emp set sal=aftersal where empno=pempno; dbms_output.put_line(&#x27;姓名: &#x27;||pename||&#x27; 涨前工资:&#x27;||beforesal||&#x27;涨后工资:&#x27;||aftersal);end;/ 123456789SQL&gt; set serveroutput on;SQL&gt; begin 2 addSal(7782); 3 addSal(7788); 4 commit; 5 end; 6 /姓名：CLARK 涨前工资:7608.87 涨后工资:7708.87姓名：SCOTT 涨前工资:7263.4 涨后工资:7363.4 注意事项： &lt;1&gt; 要说明，参数是输入参数(in)还是输出参数(out)； &lt;2&gt; 为保证调用多个存储过程中处在同一个事务中，所以一般不在存储过程或者存储函数中，commit或rollback； 三. 存储函数1. 存储函数 函数(Function)为一命名的存储程序,可带参数,并返回一计算值. 函数和过程的结构类似,但必须有一个return子句,用于返回函数值. 2. 创建存储函数的语法1234create [or replace] function 函数名(参数列表)return 函数值类型asPLSQL子程序体; 注意事项: (1) 与存储过程注意事项类似,不同的是,必须有个返回值; (2) 参数列表可以有,也可以没有.当没有时,函数名后面不要带括号. 123456789create or replace function queryempannal(pempno in number)return numberas psal emp.sal%type; pcomm emp.comm%type;begin select sal,comm into psal,pcomm from emp where empno=pempno; return psal*12+nvl(pcomm,0);end; 四. in和out参数1.概述 (1) 一般来讲,存储过程和存储函数的区别在于存储函数可以有一个返回值;而存储过程没有返回值. (2) 过程和函数都可以通过out指定一个或多个输出参数.我们可以利用out参数,在过程和函数中实现返回多个值. a. 存储过程和存储函数都可以有out参数; b. 存储过程和存储函数都可以有多个out参数; c. 存储过程可以通过out参数来实现返回值; (3) 什么时候用存储过程&#x2F;存储函数? 原则:如果只有一个返回值,用存储函数;否则,就用存储过程. 123456789create or replace procedure queryempinform(eno in number, pename out varchar2, psal out number, pjob out varchar2 )asbegin select ename,sal,job into pename,psal,pjob from emp where empno=eno;end;/ 五. 案例blob类型转换成clob类型存储函数1234567891011121314151617181920CREATE OR REPLACE FUNCTION blob_to_clob2 (blob_in IN BLOB)RETURN CLOBAS v_clob CLOB; v_varchar VARCHAR2(32767); v_start PLS_INTEGER := 1; v_buffer PLS_INTEGER := 32767;BEGIN DBMS_LOB.CREATETEMPORARY(v_clob, TRUE); if DBMS_LOB.GETLENGTH(blob_in) is null then return empty_clob(); end if; FOR i IN 1..CEIL(DBMS_LOB.GETLENGTH(blob_in) / v_buffer) LOOP v_varchar := UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(blob_in, v_buffer, v_start)); DBMS_LOB.WRITEAPPEND(v_clob, LENGTH(v_varchar), v_varchar); v_start := v_start + v_buffer; END LOOP; RETURN v_clob;END blob_to_clob2; 存储函数使用12# 使用场景一：表中存在两个字段，一个字段类型为blob，一个字段类型为clob。将blob类型的字段进行转换，并存入clob字段中。UPDATE 表名 set clob字段名 = blob_to_clob2(blob字段名) blob类型转换成varchar类型存储函数123456789101112131415161718192021222324create or replace FUNCTION blob_to_varchar (blob_in IN BLOB) RETURN VARCHAR2 IS v_varchar VARCHAR2(4000); v_start PLS_INTEGER := 1; v_buffer PLS_INTEGER := 4000; BEGIN --select userenv(&#x27;LANGUAGE&#x27;) into g_nls_db_char from dual; if DBMS_LOB.GETLENGTH(blob_in) is null then return empty_clob(); end if; DBMS_OUTPUT.put_line(&#x27;TEST:&#x27; || CEIL(DBMS_LOB.GETLENGTH(blob_in))); --DBMS_LOB.CREATETEMPORARY(v_clob, TRUE); FOR i IN 1..CEIL(DBMS_LOB.GETLENGTH(blob_in) / v_buffer) LOOP v_varchar := UTL_RAW.CAST_TO_VARCHAR2(utl_raw.convert(DBMS_LOB.SUBSTR(blob_in, v_buffer, v_start),&#x27;SIMPLIFIED CHINESE_CHINA.ZHS16GBK&#x27;, &#x27;AMERICAN_THE NETHERLANDS.UTF8&#x27;)); --DBMS_LOB.WRITEAPPEND(v_clob, LENGTH(v_varchar), v_varchar); v_start := v_start + v_buffer; END LOOP; --DBMS_OUTPUT.put_line(v_varchar); RETURN v_varchar; end blob_to_varchar; 存储函数使用12# 使用场景一：表中存在两个字段，一个字段类型为blob，一个字段类型为varchar。将blob类型的字段进行转换，并存入varchar字段中。UPDATE 表名 set varchar字段名 = blob_to_varchar(blob字段名) blob类型通过base64加密存储函数123456789101112CREATE OR REPLACE FUNCTION base64encode(p_blob IN BLOB) RETURN CLOBIS l_clob CLOB; l_step PLS_INTEGER := 12000;BEGIN FOR i IN 0 .. TRUNC((DBMS_LOB.getlength(p_blob) - 1 )/l_step) LOOP l_clob := l_clob || UTL_RAW.cast_to_varchar2(UTL_ENCODE.base64_encode(DBMS_LOB.substr(p_blob, l_step, i * l_step + 1))); END LOOP; RETURN l_clob;END ;/ 参考文档 Oracle存储过程与存储函数-入门 blob转clob和varchar2 Oracle的存储过程基本写法","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"存储过程","slug":"存储过程","permalink":"https://guoshunfa.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"存储函数","slug":"存储函数","permalink":"https://guoshunfa.com/tags/%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/"}]},{"title":"Mysql数据库脚本","slug":"软件开发/技术/数据库/Mysql数据库脚本","date":"2022-07-01T02:59:54.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Mysql数据库脚本/","link":"","permalink":"https://guoshunfa.com/2022/07/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC/","excerpt":"","text":"假设内容如下： 123create database pandacode;use pandacode;create table panda (name varchar(20)); 保存脚本文件，&#x2F;Users&#x2F;guoshunfa&#x2F;Downloads&#x2F;pandacode.sql。 执行sql脚本第一种方法在命令行下(未连接数据库)，输入 mysql -h localhost -u root -p123456 &lt; &#x2F;Users&#x2F;guoshunfa&#x2F;Downloads&#x2F;pandacode.sql (注意路径不用加引号的!!) 回车即可。 第二种方法在命令行下(已连接数据库,此时的提示符为 mysql&gt; )，输入 source &#x2F;Users&#x2F;guoshunfa&#x2F;Downloads&#x2F;pandacode.sql (注意路径不用加引号的) 或者 . F:\\hello world\\niuzi.sql (注意路径不用加引号的) 回车即可 参考文档 mysql下如何执行sql脚本","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://guoshunfa.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Mysql","slug":"Mysql","permalink":"https://guoshunfa.com/tags/Mysql/"}]},{"title":"SQL命令记录","slug":"软件开发/技术/数据库/SQL命令记录","date":"2022-07-01T02:59:08.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/SQL命令记录/","link":"","permalink":"https://guoshunfa.com/2022/07/SQL%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","excerpt":"","text":"前往菜鸟教程。 命令行连接数据库方式： ​ 打开终端输入mysql -uroot -p，随后输入密码。 ​ root可替换成其他用户名。 1. sql 主要命令描述 所有 MySQL 命令的列表：注意，所有文本命令必须在一行的开头，并且以分号“;”结束 命令 缩写 命令说明 示例 ? ? “help”的同义词。 mysql&gt; ? clear c 清除当前输入的语句。一般用于多行命令。 mysql&gt; c connect r 重新连接到服务器。可选参数是 db 和 host。连接 ID 将会改变。 mysql&gt; r mysql&gt; r [数据库] [主机] delimiter d 设置语句定界符。默认为“;”。 mysql&gt; d 定界符 ego G 发送命令到 MySQL 服务器，垂直显示结果。 mysql&gt; SHOW DATABASESG exit q 退出 MySQL。与 quit 相同。 mysql&gt; exit go g 发送命令到 MySQL 服务器。 mysql&gt; SELECT `id` FROM `table`g help h 显示该帮助信息。 mysql&gt; h notee t 不要写到 outfile 中。 mysql&gt; notee print p 打印当前命令。 mysql&gt; SHOW TABLESp; prompt R 改变你的 MySQL 提示符。 mysql&gt; prompt –&gt; quit q 退出 MySQL。 mysql&gt; q rehash # 重建完整的 hash（用于自动完成名称）。 mysql&gt; # source . 执行一个 SQL 脚本文件。使用一个文件名作为参数。 mysql&gt; source D:my.sql status s 从服务器取得状态信息。 mysql&gt; status tee T 设置 outfile 为 [to_outfile]。向已给出的 outfile 文件中追加所有东西。 mysql&gt; tee E:store.txt use u 使用另一个数据库。使用一个数据库名作为参数。 mysql&gt; use 数据库 charset C 切换到其它字符集。可能需要使用多字节字符集来处理二进制日志。 mysql&gt; charset 字符集 warnings W 在每一个语句后面显示警告。 mysql&gt; W nowarning w 不在每一个语句后面显示警告。 mysql&gt; w 要获得服务器端的帮助信息，键入“help contents” 1.1. 数据库操作创建数据库：CREATE DATABASE database_name; 删除数据库：DROP DATABASE database_name 1.2. 数据库表操作 CREATE TABLE 语句用于创建数据库中的表。 表由行和列组成，每个表都必须有个表名。 1234567CREATE TABLE table_name(column_name1 data_type(size),column_name2 data_type(size),column_name3 data_type(size),....); column_name 参数规定表中列的名称。 data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。 size 参数规定表中列的最大长度。 提示：如需了解 MS Access、MySQL 和 SQL Server 中可用的数据类型，请访问我们完整的 数据类型参考手册。 1.2.1. SQL约束（Constraints） 不同数据库的约束不同，详细查看菜鸟教程的API描述。 SQL 约束用于规定表中的数据规则。 如果存在违反约束的数据行为，行为会被约束终止。 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 1234567CREATE TABLE table_name(column_name1 data_type(size) constraint_name,column_name2 data_type(size) constraint_name,column_name3 data_type(size) constraint_name,....); 在 SQL 中，我们有如下约束： NOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - 主键，NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 外键，保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 1.2.2. 索引您可以在表中创建索引，以便更加快速高效地查询数据。 用户无法看到索引，它们只能被用来加速搜索&#x2F;查询。 注释：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 SQL CREATE INDEX 语法 在表上创建一个简单的索引。允许使用重复的值： CREATE INDEX index_nameON table_name (column_name) SQL CREATE UNIQUE INDEX 语法 在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。Creates a unique index on a table. Duplicate values are not allowed: CREATE UNIQUE INDEX index_nameON table_name (column_name) 注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。 2. crud2.1. 查询 命令 命令说明 命令示例 SELECT 查询语句头。 SELECT column_name FROM table_name; SELECT DISTINCT 查询DISTINCT 关键词用于返回唯一不同的值。 SELECT DISTINCT column_name,column_name FROM table_name; WHERE 条件查询。下面会梳理出和WHERE搭配使用的语法。 SELECT column_name,column_name FROM table_name WHERE column_name operator value; ORDER BY 排序。指定列进行排序(ASC)，默认为升序。添加DESC可调整成倒序。 SELECT column_name,column_name FROM table_name ORDER BY column_name,column_name ASC|DESC; LIMIT 返回指定数目的数据。常用于分页查询。 SELECT column_nameFROM table_nameLIMIT number; [**JOIN**](#_2-1-4- SQL-JOIN) 多表连查，SQL join 用于把来自两个或多个表的行结合起来。 SELECT Websites.id, Websites.name, access_log.count, access_log.dateFROM WebsitesINNER JOIN access_logON Websites.id&#x3D;access_log.site_id; UNION | UNION ALL SQL UNION 操作符合并两个或多个 SELECT 语句的结果。UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。支持使用WHERE、JOIN等操作符。 SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; SELECT INTO 通过 SQL，您可以从一个表复制信息到另一个表。SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。支持使用WHERE、JOIN等操作符。MYSQL不支持，但支持INSERT INTO…. SELECT。 SELECT column_name(s)INTO newtable [IN externaldb]FROM table1; INSERT INTO SELECT 通过 SQL，您可以从一个表复制信息到另一个表。INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。 INSERT INTO table2(column_name(s))SELECT column_name(s)FROM table1; 2.1.1. SELECT DISTINCT语法下面是选自 “Websites” 表的数据： 123456789+----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+--------------+---------------------------+-------+---------+ 输入： 1SELECT DISTINCT country FROM Websites; 输出： 123456+---------+| country |+---------+| USA || CN |+---------+ 2.1.2. WHERE 条件查询相关语法 操作符 操作符描述 示例 AND 查询出两个条件都满足的记录。 SELECT column_name,column_name FROM table_name WHERE column_name operator value and column_name operator value; OR 查询出两个条件有一个满足就可以的记录 SELECT column_name,column_name FROM table_name WHERE column_name operator value or column_name operator value; LIKE | NOT LIKE 模糊查询。LIKE:取匹配的数据;NOT LIKE:取不匹配的数据;通过通配符-、%操控模糊查询部分。 SELECT column_name(s)FROM table_nameWHERE column_name LIKE | NOT LIKE pattern; REGEXP | NOT REGEXP 正则查询。REGEXP:取匹配的数据;NOT REGEXP:取不匹配的数据;通过通配符[charlist]操控模糊查询部分。 SELECT column_name(s)FROM table_nameWHERE column_name REGEXP | NOT REGEXP pattern; IN IN 操作符允许您在 WHERE 子句中规定多个值。 SELECT column_name(s)FROM table_nameWHERE column_name IN (value1,value2,…); BETWEEN BETWEEN 操作符用于选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 SELECT column_name(s)FROM table_nameWHERE column_name BETWEEN value1 AND value2; 2.1.3. 通配符 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 案例一： 123# 查询url开头为https的数据。SELECT * FROM WebsitesWHERE url LIKE &#x27;https%&#x27;; 案例二： 123# 查询url中包含oo的数据。SELECT * FROM WebsitesWHERE url LIKE &#x27;%oo%&#x27;; 案例三： 123# 选取 name 以一个任意字符开始，然后是 &quot;oogle&quot; 的所有客户SELECT * FROM WebsitesWHERE name LIKE &#x27;_oogle&#x27;; 2.1.4. SQL JOIN INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 2.2. 新增 命令 命令描述 示例 INSERT INTO 新增数据 INSERT INTO table_name (column1,column2,column3,…)VALUES (value1,value2,value3,…); 2.3. 修改 请注意 SQL UPDATE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！ 命令 命令描述 示例 UPDATE 修改数据 UPDATE table_nameSET column1&#x3D;value1,column2&#x3D;value2,…WHERE some_column&#x3D;some_value; 2.4. 删除 请注意 SQL DELETE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！ 命令 命令描述 示例 DELETE 删除数据 DELETE FROM table_nameWHERE some_column&#x3D;some_value; 2.5. 通用操作符 操作符 操作符描述 示例 AS SQL 别名。 SELECT t.column_name AS alias_name FROM table_name AS t; 参考文章 菜鸟教程","categories":[{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://guoshunfa.com/tags/Mysql/"},{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"SQL","slug":"SQL","permalink":"https://guoshunfa.com/tags/SQL/"}]},{"title":"Jmeter介绍","slug":"软件开发/技术/服务&组件/jmeter/Jmeter介绍","date":"2022-07-01T02:56:54.000Z","updated":"2024-01-28T11:41:39.260Z","comments":true,"path":"2022/07/Jmeter介绍/","link":"","permalink":"https://guoshunfa.com/2022/07/Jmeter%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"翻译自Apache JmeterTM官网https://jmeter.apache.org/index.html 推特 GitHub 优质文章：https://www.cnblogs.com/daydayup-lin/p/16000045.html Apache JMeterTM应用程序是开源软件，是一个100%纯Java应用程序，旨在加载测试功能行为并衡量性能。它最初是为测试Web应用程序而设计的，但后来扩展到其他测试功能。 我能用它做什么？Apache JMeter可用于测试静态和动态资源Web动态应用程序的性能。它可用于模拟服务器、服务器组、网络或对象上的重负载，以测试其强度或分析不同负载类型下的整体性能。 Apache JMeter的功能包括： 能够加载和性能测试许多不同的应用程序&#x2F;服务器&#x2F;协议类型： Web - HTTP，HTTPS（Java，NodeJS，PHP，ASP.NET，…） SOAP &#x2F; REST Webservices FTP 通过JDBC数据库 LDAP 通过JMS面向消息的中间件（MOM） 邮件 - SMTP(S)、POP3(S) 和 IMAP(S) 原生命令或shell脚本 TCP Java对象 功能齐全的测试IDE，允许快速记录测试计划（来自浏览器或本机应用程序）、构建和调试。 **CLI模式（命令行模式（以前称为非GUI）&#x2F;无头模式），**用于从任何Java兼容操作系统（Linux、Windows、Mac OSX…）加载测试 一个完整且**准备呈现动态HTML报告** 通过能够从最流行的响应格式、**HTML、JSON、XML或任何文本格式中提取数据，**轻松关联 完全可移植性和100%的Java纯度。 完整的多线程框架允许许多线程并发采样，并通过单独的线程组同时对不同函数进行采样。 缓存和离线分析&#x2F;重播测试结果。 高度可扩展的核心： 可插拔采样器允许无限的测试功能。 可脚本采样器（与JSR223兼容的语言，如Groovy和BeanShell） 可以使用可插拔计时器选择几个负载统计信息。 数据分析和可视化插件允许极大的可扩展性和个性化性。 函数可用于为测试提供动态输入或提供数据操作。 通过Maven、Gradle和Jenkins的第三方开源库轻松连续集成。 我该怎么做？ 使用JMeter了解如何使用它 组件参考，为每个测试元素提供详细信息 函数引用为每个函数提供详细信息和示例 允许您自定义JMeter的所有属性的属性引用 Javadoc API文档 JMeter常见问题解答（维基） JMeter Wiki 构建JMeter和附加组件以供高级使用 JMeter不是浏览器JMeter不是浏览器，它在协议级别工作。就网络服务和远程服务而言，JMeter看起来像一个浏览器（或者更确切地说，多个浏览器）；然而，JMeter不执行浏览器支持的所有操作。特别是，JMeter不执行HTML页面中的Javascript。它也不会像浏览器那样渲染HTML页面（可以将响应视为HTML等，但时间不包含在任何示例中，一次只显示一个线程中的一个示例）。 教程 分布式测试 记录测试 JUnit采样器 访问日志采样器 扩展JMeter 关于JMeter的更多信息 更改列表 阅读现有问题（问题或增强功能）或报告新问题（请这样做！） 许可证 邮件列表 源存储库 贡献者 安装 首先得有JDK8+的环境。 转载自：https://blog.csdn.net/fish_study_csdn/article/details/124488572 下载：前往Jmeter官网下载https://jmeter.apache.org/download_jmeter.cgi 启动：bin文件夹-&gt;sh jmeter(启动jmeter) 汉化：找到bin&#x2F;jmeter.properties，#language&#x3D;en更改为language &#x3D; zh_CN。","categories":[{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"测试","slug":"测试","permalink":"https://guoshunfa.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Jmeter","slug":"Jmeter","permalink":"https://guoshunfa.com/tags/Jmeter/"}]},{"title":"黑盒测试与白盒测试","slug":"软件开发/技术/理论/测试/黑盒测试与白盒测试","date":"2022-06-28T02:55:16.000Z","updated":"2024-01-28T11:41:39.277Z","comments":true,"path":"2022/06/黑盒测试与白盒测试/","link":"","permalink":"https://guoshunfa.com/2022/06/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/","excerpt":"","text":"黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以进行测试证明每种内部操作是否符合设计规格要求，所有内部成分是否经过检查。 1. 第一认识1.1. 黑盒测试 测试特点：测试功能； 测试依据：需求规格说明书 方法举例：等价类划分、边界值测试 优点：能站在用户的立场上进行测试 缺点：不能测试程序内部特定部位，如程序有误，则无法发现。 1.2. 白盒测试 测试特点：测试程序接口与结构 测试依据：软件程序 方法举例：逻辑覆盖 优点：对程序内部特定部位进行覆盖测试。 缺点：无法检验程序外部特性。 2. 第二认识2.1. 黑盒测试​ 黑盒测试把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，针对“软件界面”和”软件功能“进行测试，只检查功能是否符合需求规格说明书能正常使用。因此黑盒测试又叫功能测试或数据驱动测试。 2.2. 白盒测试​ 白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看作一个打开的盒子，他允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为”结构测试“或”逻辑驱动测试“。白盒测试是按照程序内部的结构来测试程序，通过测试检验产品内部动作是否按照设计规格说明书的要求正常进行，检验程序中的每条通道是否都按照规定正常工作。 3. 第三认识3.1. 黑盒测试黑盒测试主要是为了发现以下错误： 是否有不正确或者遗漏了的功能； 在接口上，输入能否正确的接受？能否输出正确的结果？ 是否有数据结构错误或外部信息（例如数据库文件）访问错误？ 性能上是否能够满足要求？ 是否有初始化或终止性错误？ 黑盒的测试用例技术设计有三种： 边界值分析、等价类划分、错误推测法。 3.2. 白盒测试白盒测试主要是想对程序模块进行以下检查： 对程序模块的所有独立的执行路径至少测试一遍； 对所有的逻辑判定，取”真“与”假“的两种情况都能至少测一遍； 在循环的边界和运行的界限内执行循环体； 测试内部数据结构的有效性，等等； 静态白盒测试 ：即代码审查，正式审查和检验设计和程序代码； 动态白盒测试 利用查看代码功能和实现方式得到的信息来设计和执行测试，也叫结构测试； 白盒的测试用例技术包括逻辑覆盖和基本路径测试。 逻辑覆盖：是以程序内在逻辑结构为基础的测试用例设计技术，这一方法要求测试人员对程序的逻辑结构有清楚的了解。 基本路径测试：在程序控制流程图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例。","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://guoshunfa.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"概念","slug":"概念","permalink":"https://guoshunfa.com/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"Python ui自动化测试","slug":"软件开发/技术/编程语言/python/Python-ui自动化测试","date":"2022-06-28T02:52:46.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2022/06/Python-ui自动化测试/","link":"","permalink":"https://guoshunfa.com/2022/06/Python-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","excerpt":"","text":"selenium+unittest包，来做ui自动化测试。 API&#x2F;DEMO：selenium-python中文文档 | seleniumbase(基于selenium封装) | demo项目 1. 理解类似于爬虫，通过html源代码的方式，捕捉到对应标签，再通过浏览器事件进行点击、输入框输入、双击等操作，最终完成 打开浏览器 - 自动点击&#x2F;输入操作 - 关闭浏览器，这一系列操作。 2. demo12345678910111213141516171819202122232425262728# coding=utf-8from selenium import webdriverimport unittest, timefrom utils.log import loggerclass BaiduTest(unittest.TestCase): def setUp(self): self.driver = webdriver.Chrome(&quot;/Library/work/workspace-my/python/chromedriver&quot;) self.driver.implicitly_wait(30) #隐性等待时间为30秒 self.base_url = &quot;https://www.baidu.com&quot; def test_baidu(self): driver = self.driver driver.get(self.base_url + &quot;/&quot;) driver.find_element_by_id(&quot;kw&quot;).clear() logger.info(&quot;Input search str&quot;)#Print input unittest driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;unittest&quot;) driver.find_element_by_id(&quot;su&quot;).click() time.sleep(3) title=driver.title self.assertEqual(title, &quot;unittest_百度搜索&quot;) def tearDown(self): self.driver.quit()if __name__ == &quot;__main__&quot;: unittest.main()","categories":[{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/categories/Python/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://guoshunfa.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/tags/Python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://guoshunfa.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"Java8版本特性","slug":"软件开发/技术/编程语言/java/Java8版本特性","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java8版本特性/","link":"","permalink":"https://guoshunfa.com/2020/07/Java8%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/","excerpt":"","text":"Java版本特性 - jdk81. stream + lambda 操作集合数据 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 前往 demo文件 1.1. 概念1.1.1. Stream的运作流程 stream不会改变原有数据，而是创建一条新的数据。 案例： 12List&lt;Integer&gt; datas = Lists.newArrayList(1, 2, 3);List&lt;Integer&gt; nums = datas.stream().filter(a -&gt; a == 2).collect(Collectors.toList()); datas.stream() –&gt; 将集合datas转换为stream类型。 .filter() –&gt; 过滤不需要的数据。 .collect() –&gt; 构建出新结构的数据。 1.2. 初始化12345678910111213141516171819202122// array转streamint[] num = &#123;1&#125;;IntStream arrayStream = Arrays.stream(num);// 自定义赋值转streamStream&lt;Integer&gt; integerStream = Stream.of(2, 2);// 集合转streamList&lt;Integer&gt; list = Lists.newArrayList(3, 3, 3);Stream&lt;Integer&gt; collectionStream = list.stream();// 无限连续的Stream，可用于生成常量流和随机元素流。因为是无限，一般都会设定limit。Stream&lt;Integer&gt; generateStream = Stream.generate(() -&gt; 4).limit(4);// 迭代器生成Stream&lt;Integer&gt; iterateStream = Stream.iterate(5, a -&gt; a).limit(5);// Stream builder 构造器生成Stream&lt;Object&gt; buildStream = Stream.builder().add(1).build();// Stream empty 返回一个空的顺序StreamStream&lt;Object&gt; emptyStream = Stream.empty(); 1.3. API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 普通结构 [1,2,3]List&lt;Integer&gt; datas = Lists.newArrayList(1, 2, 2, 3);// forEach 循环，console: 1 2 2 3datas.stream().forEach(a -&gt; System.out.println(a));// forEachOrdered 循环，确保顺序执行(使用并行流时forEach顺序会打乱)，console: 1 2 2 3datas.stream().forEachOrdered(a -&gt; System.out.println(a));// filter 过滤，console: 2 2datas.stream().filter(a -&gt; a == 2).forEach(a -&gt; System.out.println(a));// map/mapToInt/mapToLong/mapToDouble 构造数据 返回类型Object，console: 5a 10a 10a 15adatas.stream().map(a -&gt; (a * 5) + &quot;a&quot;).forEach(a -&gt; System.out.println(a));// distinct 去重 console: 1 2 3datas.stream().distinct().forEach(a -&gt; System.out.println(a));// sorted 排序 console: 1 2 2 3datas.stream().sorted(Comparator.naturalOrder()).forEach(a -&gt; System.out.println(a));// peek 主要为了支持调试 console: 1 2 2 3 2 2datas.stream().peek(a -&gt; System.out.println(a)).filter(a -&gt; a == 2) .forEach(a -&gt; System.out.println(a));// limit 只取几位 console: 1 2datas.stream().limit(2).forEach(a -&gt; System.out.println(a));// skip 跳过几位 console: 2 2 3datas.stream().skip(1).forEach(a -&gt; System.out.println(a));// toArray 转换成arrayObject[] objects = datas.stream().toArray();// reduce 聚合求值 console: 8Integer integer = datas.stream().reduce((a, b) -&gt; a + b).get();// collect 使用Collector对此流的元素执行可变归约操作Set&lt;Integer&gt; collect = datas.stream().collect(Collectors.toSet());// min 最小值Integer minNum = datas.stream().min(Comparator.naturalOrder()).get();// max 最大值Integer maxNum = datas.stream().max(Comparator.naturalOrder()).get();// count 数据数量long count = datas.stream().count();// anyMatch 判断的条件里，任意一个元素成功，返回true console: trueboolean anyMatch = datas.stream().anyMatch(Predicate.isEqual(1));// allMatch 判断条件里的元素，所有的都是，返回true console: falseboolean allMatch = datas.stream().allMatch(Predicate.isEqual(2));// noneMatch 与allMatch相反，判断条件里的元素，所有的都不是，返回true console: falseboolean noneMatch = datas.stream().noneMatch(Predicate.isEqual(3));// findFirst 获取第一个元素Integer findFirst = datas.stream().findFirst().get();// findAny 获取随机一个元素Integer findAny = datas.stream().findAny().get();// --------------------------------------分割线---------------------------------------// 多级结构 [[1,2],[3,4],[5,6]]List&lt;int[]&gt; datas2 = Lists.newArrayList(new int[]&#123;1, 2&#125;, new int[]&#123;3, 4&#125;, new int[]&#123;5, 6&#125;);// flatMap/flatMapToInt/flatMapToLong/flatMapToDouble 数据扁平化 console: 1 2 3 4 5 6datas2.stream().flatMapToInt(a -&gt; Arrays.stream(a)).forEach(a -&gt; System.out.println(a)); 1.4. 案例1.4.1. 基于时间排序升序 12users.sort(Comparator.comparing(User::getCreatedOn));1 降序 1users.sort(Comparator.comparing(User::getCreatedOn).reversed());","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Stream","slug":"Stream","permalink":"https://guoshunfa.com/tags/Stream/"},{"name":"lambda","slug":"lambda","permalink":"https://guoshunfa.com/tags/lambda/"},{"name":"Jdk","slug":"Jdk","permalink":"https://guoshunfa.com/tags/Jdk/"}]},{"title":"Java Decompiler反编译工具","slug":"软件开发/技术/编程语言/java/JavaDecompiler反编译工具","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/JavaDecompiler反编译工具/","link":"","permalink":"https://guoshunfa.com/2020/07/JavaDecompiler%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Jar&#x2F;class 反编译工具。 1. Idea 下载反编译插件插件名称：Java Bytecode Decompiler或Java Decompiler。 2. 运行插件下载成功后，找到对应的插件Jar包。 Mac系统的插件地址：/Applications/IntelliJ\\ IDEA.app/Contents/plugins/java-decompiler/lib 2.1. 命令运行1oracle-java -cp &quot;/Applications/IntelliJ IDEA.app/Contents/plugins/java-decompiler/lib/java-decompiler.jar&quot; org.jetbrains.oracle-java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true rt.jar rt 2.2. 命令描述/Applications/IntelliJ IDEA.app/Contents/plugins/java-decompiler/lib/java-decompiler.jar : 反编译插件包地址。 rt.jar : 需要进行反编译的Jar文件地址。 rt : 反编译后文件存放地址。 3. 结果命令执行成功之后会生成一个Jar文件，通过解压工具解压后就可以食用了。原本编译后的class文件都已经反编译成了java文件。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"反编译工具","slug":"反编译工具","permalink":"https://guoshunfa.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Java基础 spel表达式","slug":"软件开发/技术/编程语言/java/Java基础-spel表达式","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java基础-spel表达式/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E5%9F%BA%E7%A1%80-spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"1. spel 表达式 介绍 Spring Expression Language（简称 SpEL）是一种功能强大的表达式语言，支持运行时查询和操作对象图 。表达式语言一般是用最简单的形式完成最主要的工作，以此减少工作量。 Java 有许多可用的表达式语言，例如 JSP EL，OGNL，MVEL 和 JBoss EL，SpEL 语法类似于 JSP EL，功能类似于 Struts2 中的 OGNL，能在运行时构建复杂表达式、存取对象图属性、调用对象方法等，并且能与 Spring 功能完美整合，如 SpEL 可以用来配置 Bean 定义。 SpEL 并不与 Spring 直接相关，可以被独立使用。SpEL 表达式的创建是为了向 Spring 社区提供一种受良好支持的表达式语言，该语言适用于 Spring 家族中的所有产品。也就是说，SpEL 是一种与技术无关的 API，可以集成其它表达式语言。 SpEL 提供了以下接口和类： Expression interface：该接口负责评估表达式字符串 ExpressionParser interface：该接口负责解析字符串 EvaluationContext interface：该接口负责定义上下文环境 SpEL 支持如下表达式： 1. 基本表达式字面量表达式、关系、逻辑与算术运算表达式、字符串连接及截取表达式、三目运算表达式、正则表达式、括号优先级表达式； 2. 类相关表达式类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 3. 集合相关表达式内联 List、内联数组、集合、字典访问、列表、字典、数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义； 4. 其他表达式模板表达式。 注：SpEL 表达式中的关键字不区分大小写。 2. 实例12345678910111213141516171819package pandacode.cn;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;public class Test &#123; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); // 运算符 System.out.println(parser.parseExpression(&quot;1&gt;2&quot;).getValue(Boolean.class)); // 字符串输出 System.out.println(parser.parseExpression(&quot;&#x27;https://pandacode.cn&#x27;.concat(&#x27;/&#x27;)&quot;).getValue(String.class)); // 引入类处理 System.out.println(parser.parseExpression(&quot;T(org.apache.commons.lang.StringUtils).isBlank(&#x27;&#x27;)&quot;).getValue(Boolean.class)); &#125;&#125; 输出： 123falsehttps://pandacode.cn/true","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Spel表达式","slug":"Spel表达式","permalink":"https://guoshunfa.com/tags/Spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Java基础 关键字","slug":"软件开发/技术/编程语言/java/Java基础-关键字","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java基础-关键字/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E5%9F%BA%E7%A1%80-%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"java 关键字 - transient Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化。 1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 1234567891011121314public static void main(String[] args) &#123; @Data class AA implements Serializable &#123; transient String a; String b; &#125; AA aa = new AA(); aa.setA(&quot;a&quot;); aa.setB(&quot;b&quot;); String s = JSONUtil.toJsonStr(aa); JSONObject jsonObject = JSONUtil.parseObj(s); System.out.println(s); System.out.println(jsonObject);&#125; console: 12&#123;&quot;b&quot;:&quot;b&quot;&#125;&#123;&quot;b&quot;:&quot;b&quot;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"Java基础 泛型","slug":"软件开发/技术/编程语言/java/Java基础-泛型","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java基础-泛型/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"Java 基础 - 泛型1. 概述泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用&#x2F;调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 2. 一个栗子一个被举了无数次的例子： 12345678List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);&#125; 毫无疑问，程序的运行结果会以崩溃结束： 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 3. 特性泛型只在编译阶段有效。看下面的代码： 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);&#125; 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 4. 泛型的使用泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 4.1 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）： 123456class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 12345678//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey()); 1212-27 09:20:04.432 13063-13063/? D/泛型测试: key is 12345612-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 看一个例子： 123456789Generic generic = new Generic(&quot;111111&quot;);Generic generic1 = new Generic(4444);Generic generic2 = new Generic(55.55);Generic generic3 = new Generic(false);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey()); 1234D/泛型测试: key is 111111D/泛型测试: key is 4444D/泛型测试: key is 55.55D/泛型测试: key is false 注意： 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125; 4.2 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，未传入泛型实参时： 1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类，传入泛型实参时： 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 4.3 泛型通配符我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic&lt;Ingeter&gt;与Generic&lt;Number&gt;实际上是相同的一种基本类型。那么问题来了，在使用Generic&lt;Number&gt;作为形参的方法中，能否使用Generic&lt;Ingeter&gt;的实例传入呢？在逻辑上类似于Generic&lt;Number&gt;和Generic&lt;Ingeter&gt;是否可以看成具有父子关系的泛型类型呢？ 为了弄清楚这个问题，我们使用Generic&lt;T&gt;这个泛型类继续看下面的例子： 123public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 12345678Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);showKeyValue(gNumber);// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt;// showKeyValue(gInteger); 通过提示信息我们可以看到Generic&lt;Integer&gt;不能被看作为Generic&lt;Number&gt;的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic&lt;Integer&gt;类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic&lt;Integer&gt;和Generic&lt;Number&gt;父类的引用类型。由此类型通配符应运而生。 我们可以将上面的方法改一下： 123public void showKeyValue1(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 4.4 泛型方法在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。 尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。 123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 1Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;)); 4.4.1 泛型方法的基本用法光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot; * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot; * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot; * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 4.4.2 类中的泛型方法当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return &quot;fruit&quot;; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return &quot;apple&quot;; &#125; &#125; class Person&#123; @Override public String toString() &#123; return &quot;Person&quot;; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 4.4.3 泛型方法与可变参数再看一个泛型方法和可变参数的例子： 123456public &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t); &#125;&#125;printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55); 4.4.4 静态方法与泛型静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 4.4.5 泛型方法总结泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则： 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化， 那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。 所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 4.5 泛型上下边界在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 123public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 1234567891011Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类//showKeyValue1(generic1);showKeyValue1(generic2);showKeyValue1(generic3);showKeyValue1(generic4); 如果我们把泛型类的定义也改一下: 1234567891011public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 12//这一行代码也会报错，因为String不是Number的子类Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;); 再来一个泛型方法的例子： 1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); T test = container.getKey(); return test;&#125; 通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。 4.6 关于泛型数组要提一下看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。 也就是说下面的这个例子是不可以的： 1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10]; 而使用通配符创建泛型数组是可以的，如下面这个例子： 1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; 这样也是可以的： 1List&lt;String&gt;[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题： 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常， 但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明， 上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。 而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。 1234567List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK 5. 最后本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。 参考资料 java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"https://guoshunfa.com/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"Java测试 Assert断言","slug":"软件开发/技术/编程语言/java/Java测试-Assert断言","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java测试-Assert断言/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E6%B5%8B%E8%AF%95-Assert%E6%96%AD%E8%A8%80/","excerpt":"","text":"在 JDK 1.4之前，开发人员经常使用注释来记录关于程序正确性的假设。然而，注释作为测试和调试假设的机制是无用的。编译器忽略注释，因此无法使用它们进行 bug 检测。开发人员在更改代码时也经常不更新注释。 在 JDK 1.4中，断言被引入作为测试和调试代码假设的新机制。实质上，断言是在运行时执行的可编译实体，假设你已经为程序测试启用了它们。可以通过编写断言来通知 bug 发生的地方，这样可以大大减少调试失败程序的时间。 1. 编写断言的表达式1assert BooleanExpr; 如果 BooleanExpr 的计算结果为 true，则不会发生任何事情，并继续执行。但是，如果表达式计算结果为 false，那么将抛出 AssertionError 1.1. 举个例子1234public static void main(String[] args) &#123; int a = 10; assert a&gt;100;//false&#125; 2. 运行后没有反应??有的小伙伴发现自己的IDE并没有抛出Error 这是因为没有显示开启,启用断言 开启方法: vm options 加入 -ea 此时我们运行项目 发现抛出了异常 12Exception in thread &quot;main&quot; java.lang.AssertionError at Scratch.main(scratch_4.java:4) 3. 希望获得更多信息?此时我们已经知道了断言的基本用法 但是抛出Error后我们并不知道是什么问题导致的 还需要去翻看代码找到报错的地方, 如果我们希望获得更多有用的信息 我们可以这样修改Assert语句: 1assert BooleanExpr : expr; expr 是任何可以返回值的表达式(包括方法调用)但是不能调用具有 void 返回类型的方法。一个有用的表达式是一个字符串，用它来描述失败的原因 3.1. 举个例子1234public static void main(String[] args) &#123; int a = 10; assert a&gt;100 : &quot;a &lt; 100&quot;; &#125; 运行: 12Exception in thread &quot;main&quot; java.lang.AssertionError: a &lt; 100 at Scratch.main(scratch_4.java:5) 无论哪个例子，在不使用-ea (启用断言)选项的情况下运行都不会产生输出。当断言未启用时，它们不会执行，尽管它们仍然存在于类文件中。 4. 前置条件和后置条件前置条件: 是在执行某些代码之前必须求值为 true 的条件 后置条件: 是在执行某些代码后必须求值为 true 的条件 4.1. 前置条件前置条件检查: 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;class PNG &#123; /** * Create a PNG instance, read specified PNG file, and decode * it into suitable structures. * * @param filespec path and name of PNG file to read * * @throws NullPointerException when &lt;code&gt;filespec&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt; */ PNG(String filespec) throws IOException &#123; //在非私有构造方法中 使用前置条件 if (filespec == null) throw new NullPointerException(&quot;filespec is null&quot;); try (FileInputStream fis = new FileInputStream(filespec)) &#123; readHeader(fis); &#125; &#125; private void readHeader(InputStream is) throws IOException &#123; //在私有方法中使用前置条件检查 assert is != null : &quot;null passed to is&quot;; &#125; &#125; class Scratch &#123; public static void main(String[] args) throws IOException &#123; PNG png = new PNG((args.length == 0) ? null : args[0]); &#125; &#125; 4.2. 后置条件后置条件检查: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class AssertDemo&#123; public static void main(String[] args) &#123; int[] array = &#123; 20, 91, -6, 16, 0, 7, 51, 42, 3, 1 &#125;; sort(array); for (int element: array) System.out.printf(&quot;%d &quot;, element); System.out.println(); &#125; private static boolean isSorted(int[] x) &#123; for (int i = 0; i &lt; x.length - 1; i++) if (x[i] &gt; x[i + 1]) return false; return true; &#125; private static void sort(int[] x) &#123; int j, a; // For all integer values except the leftmost value ... for (int i = 1; i &lt; x.length; i++) &#123; // Get integer value a. a = x[i]; // Get index of a. This is the initial insert position, which is // used if a is larger than all values in the sorted section. j = i; // While values exist to the left of a&#x27;s insert position and the // value immediately to the left of that insert position is // numerically greater than a&#x27;s value ... while (j &gt; 0 &amp;&amp; x[j - 1] &gt; a) &#123; // Shift left value -- x[j - 1] -- one position to its right -- // x[j]. x[j] = x[j - 1]; // Update insert position to shifted value&#x27;s original position // (one position to the left). j--; &#125; // Insert a at insert position (which is either the initial insert // position or the final insert position), where a is greater than // or equal to all values to its left. x[j] = a; &#125; //在 sort ()返回给它的调用者之前，我使用 assert 检查 x 被排序的后置条件。 assert isSorted(x): &quot;array not sorted&quot;; &#125;&#125; 5. 陷阱assert关键字用法简单，但是使用assert往往会让你陷入越来越深的陷阱中。应避免使用。笔者经过研究，总结了以下原因： 1、 assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。而现在主流的Java IDE工具默认都没有开启-ea断言检查功能。这就意味着你如果使用IDE工具编码，调试运行时候会有一定的麻烦。并且，对于Java Web应用，程序代码都是部署在容器里面，你没法直接去控制程序的运行，如果一定要开启-ea的开关，则需要更改Web容器的运行配置参数。这对程序的移 植和部署都带来很大的不便。 2、用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试 调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。 3、assert断言失败将面临程序的退出。这在一个生产环境下的应用是绝不能容忍的。一般都是通过异常处理来解决程序中潜在的错误。但是使用断言就很危险，一旦失败系统就挂了。 6. 总结assert既然是为了调试测试程序用，不在正式生产环境下用，那应该考虑更好的测试JUint来代替其做用，JUint相对assert关键的所提供的功能是有过之而无不及。当然完全可以通过IDE debug来进行调试测试 因此，应当避免在Java中使用assert关键字，除非哪一天Java默认支持开启-ea的开关，这时候可以考虑。对比一下，assert能给你带来多少好处，多少麻烦，这是我们选择是否使用的的原则,读者可以自行取舍.","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://guoshunfa.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"oracle","slug":"oracle","permalink":"https://guoshunfa.com/tags/oracle/"},{"name":"java","slug":"java","permalink":"https://guoshunfa.com/tags/java/"},{"name":"assert","slug":"assert","permalink":"https://guoshunfa.com/tags/assert/"},{"name":"断言","slug":"断言","permalink":"https://guoshunfa.com/tags/%E6%96%AD%E8%A8%80/"}]},{"title":"Java自带组件 参数校验Validator","slug":"软件开发/技术/编程语言/java/Java自带组件-参数校验Validator","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java自带组件-参数校验Validator/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E8%87%AA%E5%B8%A6%E7%BB%84%E4%BB%B6-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8CValidator/","excerpt":"","text":"应用在执行业务逻辑之前，必须通过校验保证接受到的输入数据是合法正确的，但很多时候同样的校验出现了多次，在不同的层，不同的方法上，导致代码冗余，浪费时间，违反DRY原则。 每一个控制器都要校验 过多的校验参数会导致代码太长 代码的复用率太差，同样的代码如果出现多次，在业务越来越复杂的情况下，维护成本呈指数上升。 可以考虑把校验的代码封装起来，来解决出现的这些问题。 @Validated和@Valid搭配使用，@Validated用来标注让Spring扫描，@Valid用来标注需要验证的对象。 1. 用法实例maven 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt; 1.1. 校验对象 编写校验对象 123456789101112public class User &#123; // 名字不允许为空，并且名字的长度在2位到30位之间 // 如果名字的长度校验不通过，那么提示错误信息 @NotNull @Size(min=2, max=30,message = &quot;请检查名字的长度是否有问题&quot;) private String name; // 不允许为空，并且年龄的最小值为18 @NotNull @Min(18) private Integer age;&#125; 创建控制器 123456// 1. 要校验的参数前，加上@Valid注解// 2. 紧随其后的，跟上一个BindingResult来存储校验信息@RequestMapping(&quot;/test1&quot;)public Object test1(@Valid User user) &#123; return &quot;OK&quot;;&#125; 1.2. 直接校验参数12345678910111213@Controller@Validated@RequestMapping(value = &quot;validator&quot;)public class ParameterValidatorDemoController &#123; @ResponseBody @GetMapping(value = &quot;simple&quot;) public String validateParameter(@Valid @Size(min = 1, max = 5) String name) &#123; System.out.println(name); return &quot;OK&quot;; &#125;&#125; 类上的**@Validated**注解则告诉spring需要扫描这个类，来检查其中的constraint注解。 2. 常见的校验注解 javax.validation.constraints @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max&#x3D;, min&#x3D;) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex&#x3D;,flag&#x3D;) 被注释的元素必须符合指定的正则表达式 @NotBlank(message &#x3D;) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min&#x3D;,max&#x3D;) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min&#x3D;,max&#x3D;,message&#x3D;) 被注释的元素必须在合适的范围内 3. 自定义校验注解有时候，第三方库中并没有我们想要的校验类型，好在系统提供了很好的扩展能力，我们可以自定义检验。比如，我们想校验用户的手机格式，写手机号码校验器 1、编写校验注解 1234567891011121314151617// 我们可以直接拷贝系统内的注解如@Min，复制到我们新的注解中，然后根据需要修改。@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented//注解的实现类。@Constraint(validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; //校验错误的默认信息 String message() default &quot;手机号码格式有问题&quot;; //是否强制校验 boolean isRequired() default false; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 2、编写具体的实现类我们知道注解只是一个标记，真正的逻辑还要在特定的类中实现，上一步的注解指定了实现校验功能的类为IsMobileValidator。 12345678910111213141516171819202122232425262728293031323334353637// 自定义注解一定要实现ConstraintValidator接口奥，里面的两个参数// 第一个为 具体要校验的注解// 第二个为 校验的参数类型public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; &#123; private boolean required = false; private static final Pattern mobile_pattern = Pattern.compile(&quot;1\\\\d&#123;10&#125;&quot;); //工具方法，判断是否是手机号 public static boolean isMobile(String src) &#123; if (StringUtils.isEmpty(src)) &#123; return false; &#125; Matcher m = mobile_pattern.matcher(src); return m.matches(); &#125; @Override public void initialize(IsMobile constraintAnnotation) &#123; required = constraintAnnotation.isRequired(); &#125; @Override public boolean isValid(String phone, ConstraintValidatorContext constraintValidatorContext) &#123; //是否为手机号的实现 if (required) &#123; return isMobile(phone); &#125; else &#123; if (StringUtils.isEmpty(phone)) &#123; return true; &#125; else &#123; return isMobile(phone); &#125; &#125; &#125; &#125; 3、测试自定义注解的功能 1234567891011121314@Datapublic class User &#123; @NotNull @Size(min=2, max=30,message = &quot;请检查名字的长度是否有问题&quot;) private String name; @NotNull @Min(18) private Integer age; //这里是新添加的注解奥 @IsMobile private String phone;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Validator","slug":"Validator","permalink":"https://guoshunfa.com/tags/Validator/"}]},{"title":"Java虚拟机 JVM理解","slug":"软件开发/技术/编程语言/java/Java虚拟机-JVM理解","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java虚拟机-JVM理解/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E7%90%86%E8%A7%A3/","excerpt":"","text":"一、什么是JVMJVM是Java Virtual Machine（Java 虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java语言的一个非常重要的特点就是平台无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 二、JVM总体概述JVM总体上是由类装载子系统（ClassLoader）、运行时数据区、执行引擎、垃圾收集这四个部分组成。其中我们最为关注的运行时数据区，也就是JVM的内存部分则是由方法区（Method Area）、JAVA堆（Java Heap）、虚拟机栈（JVM Stack）、程序计数器、本地方法栈（Native Method Stack）这几部分组成。 三、JVM体系结构 3.1 类装载子系统Class Loader类加载器负责加载.class文件，class文件在文件开头有特定的文件标示，并且ClassLoader负责class文件的加载等，至于它是否可以运行，则由Execution Engine决定。 3.2 运行时数据区&#x3D;&#x3D;栈管运行，堆管存储。&#x3D;&#x3D;JVM调优主要是优化Java堆和方法区。 3.2.1 方法区(Method Area)方法区是各线程共享的内存区域，它用于存储已被JVM加载的类信息、常量、静态变量、运行时常量池等数据。 3.2.2 Java堆(Java Heap)Java堆是各线程共享的内存区域，在JVM启动时创建，这块区域是JVM中最大的， 用于存储应用的对象和数组，也是GC主要的回收区，一个 JVM 实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：新生代、老年代、永久代。 说明： Jdk1.6及之前：常量池分配在永久代 。 Jdk1.7：有，但已经逐步“去永久代” 。 Jdk1.8及之后：无永久代，改用元空间代替(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)。 3.2.3 Java栈(JVM Stack)\\1) 栈是什么 Java栈是线程私有的，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致。基本类型的变量和对象的引用变量都是在函数的栈内存中分配。 \\2) 栈存储什么 每个方法执行的时候都会创建一个栈帧，栈帧中主要存储3类数据： 局部变量表：输入参数和输出参数以及方法内的变量； 栈操作：记录出栈和入栈的操作； 栈帧数据：包括类文件、方法等等。 \\3) 栈运行原理 栈中的数据都是以栈帧的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在栈中从入栈到出栈的过程。 \\4) 本地方法栈(Native Method Stack) 本地方法栈和JVM栈发挥的作用非常相似，也是线程私有的，区别是JVM栈为JVM执行Java方法（也就是字节码）服务，而本地方法栈为JVM使用到的Native方法服务。它的具体做法是在本地方法栈中登记native方法，在执行引擎执行时加载Native Liberies.有的虚拟机（比如Sun Hotpot）直接把两者合二为一。 \\5) 程序计数器(Program Counter Register) 程序计数器是一块非常小的内存空间，几乎可以忽略不计，每个线程都有一个程序计算器，是线程私有的，可以看作是当前线程所执行的字节码的行号指示器，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令。 \\6) 运行时常量池 运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的intern()方法。 3.3 执行引擎(Execution Engine)执行引擎执行包在装载类的方法中的指令，也就是方法。执行引擎以指令为单位读取Java字节码。它就像一个CPU一样，一条一条地执行机器指令。每个字节码指令都由一个1字节的操作码和附加的操作数组成。执行引擎取得一个操作码，然后根据操作数来执行任务，完成后就继续执行下一条操作码。 不过Java字节码是用一种人类可以读懂的语言编写的，而不是用机器可以直接执行的语言。因此，执行引擎必须把字节码转换成可以直接被JVM执行的语言。字节码可以通过以下两种方式转换成合适的语言： 解释器： 一条一条地读取，解释并执行字节码执行，所以它可以很快地解释字节码，但是执行起来会比较慢。这是解释执行语言的一个缺点。 即时编译器：用来弥补解释器的缺点，执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行。执行本地代码比一条一条进行解释执行的速度快很多，编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。 3.4 垃圾收集(Garbage Collection, GC)3.4.1 什么是垃圾收集垃圾收集即垃圾回收，简单的说垃圾回收就是回收内存中不再使用的对象。所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。 垃圾回收的基本步骤分两步： 查找内存中不再使用的对象（GC判断策略） 释放这些对象占用的内存（GC收集算法） 3.4.2 GC判断策略\\1) 引用计数算法 引用计数算法是给对象添加一个引用计数器，每当有一个引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的对象。缺点：很难解决对象之间相互循环引用的问题。 \\2) 根搜索算法 根搜索算法的基本思路就是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（也就是说从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 在Java语言里，可作为GC Roots的对象包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量应用的对象； 本地方法栈中JNI（Native方法）引用的对象。 注：在根搜索算法中不可达的对象，也并非是“非死不可”的，因为要真正宣告一个对象死亡，至少要经历两次标记过程：第一次是标记没有与GC Roots相连接的引用链；第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过)。 3.4.3 GC收集算法\\1) 标记-清除算法（Mark-Sweep） 标记-清楚算法采用从根集合（GC Roots）进行扫描，首先标记出所有需要回收的对象（根搜索算法），标记完成后统一回收掉所有被标记的对象。 该算法有两个问题： 效率问题：标记和清除过程的效率都不高； 空间问题：标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。 \\2) 复制算法（Copying） 复制算法是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉。 \\3) 标记-整理算法（Mark-Compact） 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存。 \\4) 分代收集算法（Generational Collection） 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 新生代（Young Generation）的回收算法（以复制算法为主） 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。 老年代（Tenured Generation）的回收算法（以标记-清除、标记-整理为主） 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 永久代（Permanet Generation）的回收算法 用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。永久代也称方法区。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过根搜索算法来判断，但是对于无用的类则需要同时满足下面3个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 3.4.4 垃圾收集器\\1) Serial收集器（复制算法) 新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。 \\2) Serial Old收集器(标记-整理算法) 老年代单线程收集器，Serial收集器的老年代版本。 \\3) ParNew收集器(停止-复制算法) 新生代多线程收集器，其实就是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。 \\4) Parallel Scavenge收集器(停止-复制算法) 新生代并行的多线程收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量&#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads&#x3D;4来指定线程数。 \\5) Parallel Old收集器(停止-复制算法) 老年代并行的多线程收集器，Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。 \\6) CMS(Concurrent Mark Sweep)收集器（标记-清除算法） CMS收集器是一种以获取最短回收停顿时间为目标的收集器，CMS收集器是基于“标记–清除”(Mark-Sweep)算法实现的，整个过程分为四个步骤： 初始标记： 标记GC Roots能直接关联到的对象，速度很快； 并发标记： 进行GC Roots Tracing的过程； 重新标记： 修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但比并发标记时间短； 并发清除： 整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 优点：并发收集、低停顿 缺点：对CPU资源非常敏感、无法处理浮动垃圾、产生大量空间碎片。 \\7) G1(Garbage First)收集器（标记-整理算法） G1是一款面向服务端应用的垃圾收集器，是基于“标记-整理”算法实现的，与其他GC收集器相比，G1具备如下特点： 并行与并发 分代收集 空间整合 可预测性的停顿 G1运作步骤： 初始标记(stop the world事件，CPU停顿只处理垃圾) 并发标记(与用户线程并发执行) 最终标记(stop the world事件，CPU停顿处理垃圾) 筛选回收(stop the world事件，根据用户期望的GC停顿时间回收) 3.4.5 垃圾收集结构图 参考资料 https://segmentfault.com/a/1190000019845827","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://guoshunfa.com/tags/JVM/"}]},{"title":"Java 设计模式","slug":"软件开发/技术/编程语言/java/Java设计模式","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.278Z","comments":true,"path":"2020/07/Java设计模式/","link":"","permalink":"https://guoshunfa.com/2020/07/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式名称 demo代码地址 描述 工厂模式 github 菜鸟教程 抽象工厂模式 github 单例模式 github 菜鸟教程 建造者模式 github 原型模式 github 适配器模式 github 桥接模式 github 过滤器模式 github 组合模式 github 装饰器模式 github 外观模式 github 享元模式 github 代理模式 github 责任链模式 github 命令模式 github 解释器模式 github 迭代器模式 github 中介者模式 github 备忘录模式 github 观察者模式 github 状态模式 github 空对象模式 github 策略模式 github 模板模式 github 访问者模式 github MVC模式 github 业务代表模式 github 组合实体模式 github 数据访问对象模式 github 前端控制器模式 github 拦截过滤器模式 github 服务定位器模式 github 传输对象模式 github","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://guoshunfa.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Oracle Java Packages","slug":"软件开发/技术/编程语言/java/Oracle-Java-Packages","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.279Z","comments":true,"path":"2020/07/Oracle-Java-Packages/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java-Packages/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/package/index.html 本课程介绍如何将类和接口绑定到包中，如何使用包中的类，以及如何安排文件系统，以便编译器可以找到源文件。 创建和使用包为了使类型更易于查找和使用，避免命名冲突，并控制访问，程序员将相关类型的组打包到包中。 释义: 包是一组提供访问保护和名称空间管理的相关类型。注意，types指的是类、接口、枚举和注释类型。枚举和注释类型分别是特殊类型的类和接口，因此类型在本课中通常简称为类和接口。 作为Java平台一部分的类型是按函数捆绑类的各种包的成员：基本类在Java.lang，用于读和写（输入和输出）的类在java.io等等。您也可以将类型放入包中。 假设您编写了一组表示图形对象的类，例如圆、矩形、直线和点。您还可以编写一个接口“Draggable”，如果可以用鼠标拖动，则类可以实现该接口。 123456789101112131415161718192021222324252627282930313233//in the Draggable.java filepublic interface Draggable &#123; ...&#125;//in the Graphic.java filepublic abstract class Graphic &#123; ...&#125;//in the Circle.java filepublic class Circle extends Graphic implements Draggable &#123; . . .&#125;//in the Rectangle.java filepublic class Rectangle extends Graphic implements Draggable &#123; . . .&#125;//in the Point.java filepublic class Point extends Graphic implements Draggable &#123; . . .&#125;//in the Line.java filepublic class Line extends Graphic implements Draggable &#123; . . .&#125; 出于以下几个原因，您应该将这些类和接口捆绑在一个包中： 您和其他程序员可以很容易地确定这些类型是相关的。 您和其他程序员知道在哪里可以找到可以提供图形相关功能的类型。 您的类型名称不会与其他包中的类型名称冲突，因为该包创建了一个新的命名空间。 您可以允许包内的类型彼此无限制地访问，但仍然限制包外类型的访问。 创建包要创建包，请为包选择一个名称（命名约定将在下一节中讨论），并在包含要包含在包中的类型（类、接口、枚举和注释类型）的每个源文件的顶部放置一个具有该名称的“package”语句。 package语句（例如，“package graphics；”）必须是源文件中的第一行。每个源文件中只能有一个package语句，它适用于文件中的所有类型。 Note: 如果在一个源文件中放置多个类型，则只有一个类型可以是“public”，并且必须与源文件同名。例如，您可以在文件“Circle”中定义“public class Circle”。java，在文件Draggable中定义public interface Draggable。java，在文件Day中定义public enum Day。java等。 您可以将非公共类型与公共类型包含在同一文件中（强烈建议这样做，除非非公共类型较小且与公共类型密切相关），但只有公共类型可以从包外部访问。所有顶级的非公共类型都将是package private。 如果将上一节中列出的图形界面和类放在名为“graphics”的包中，则需要六个源文件，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839//in the Draggable.java filepackage graphics;public interface Draggable &#123; . . .&#125;//in the Graphic.java filepackage graphics;public abstract class Graphic &#123; . . .&#125;//in the Circle.java filepackage graphics;public class Circle extends Graphic implements Draggable &#123; . . .&#125;//in the Rectangle.java filepackage graphics;public class Rectangle extends Graphic implements Draggable &#123; . . .&#125;//in the Point.java filepackage graphics;public class Point extends Graphic implements Draggable &#123; . . .&#125;//in the Line.java filepackage graphics;public class Line extends Graphic implements Draggable &#123; . . .&#125; 如果不使用“package”语句，则类型将以未命名的包结尾。一般来说，未命名的包仅适用于小型或临时应用程序，或者您刚刚开始开发过程时。否则，类和接口属于命名包。 命名程序包随着世界各地的程序员使用Java编程语言编写类和接口，许多程序员可能会对不同的类型使用相同的名称。事实上，上一个示例就是这样做的：当java中已经有Rectance类时，它定义了Rectange类。awt包。尽管如此，如果两个类位于不同的包中，编译器允许它们具有相同的名称。每个“矩形”类的完全限定名包括包名。也就是说，“graphics”包中“Rectangle”类的完全限定名称是“graphics。矩形”，以及“java”中“矩形”类的完全限定名称。awt包是java.awt.Rectangle 。 除非两个独立的程序员对他们的包使用相同的名称，否则这很有效。是什么防止了这个问题？习俗 命名惯例包名称以小写字母书写，以避免与类或接口的名称冲突。 公司使用其反向的互联网域名来开始其软件包名称，例如“com.example”。mypackage”表示由程序员在“example.com”创建的名为“mypackage”的包。 在一家公司内发生的名称冲突需要按照该公司内的惯例进行处理，可能是在公司名称后包含地区或项目名称（例如，“com.example.gregion.mypackage”）。 Java语言本身的包以“Java”开头或javax 在某些情况下，internet域名可能不是有效的软件包名称。如果域名包含连字符或其他特殊字符，如果包名以数字或其他非法用作Java名称开头的字符开头，或者包名包含保留的Java关键字（如“int”），则可能发生这种情况。在这种情况下，建议的惯例是添加下划线。例如： Domain Name Package Name Prefix hyphenated-name.example.org org.example.hyphenated_name example.int int_.example 123name.example.com com.example._123name 使用包成员组成包的类型称为包成员。 要从包外部使用“public”包成员，必须执行以下操作之一： 通过成员的完全限定名称引用该成员 导入包成员 导入成员的整个包 如以下各节所述，每一项都适用于不同的情况。 通过其限定名称引用包成员到目前为止，本教程中的大多数示例都通过简单的名称来引用类型，例如“Rectangle”和“StackOfInts”。如果正在编写的代码与包成员位于同一个包中，或者该成员已导入，则可以使用包成员的简单名称。 但是，如果您试图使用其他包中的成员，而该包尚未导入，则必须使用该成员的完全限定名，其中包括包名。这是上一个示例中图形包中声明的Rectangle类的完全限定名称。 1graphics.Rectangle 您可以使用此限定名称创建“graphics.Rectangle”的实例： 1graphics.Rectangle myRect = new graphics.Rectangle(); 限定名称对于不经常使用来说是合适的。然而，当重复使用名称时，重复键入名称会变得乏味，代码也会变得难以阅读。作为替代方案，您可以导入成员或其包，然后使用其简单名称。 导入包成员要将特定成员导入到当前文件中，请在文件开头的任何类型定义之前，但在“package”语句之后（如果有）放置“import”语句。下面是如何从上一节中创建的“graphics”包中导入“Rectangle”类。 1import graphics.Rectangle; 现在，您可以通过简单的名称引用“Rectangle”类。 1Rectangle myRectangle = new Rectangle(); 如果您只使用“graphics”包中的几个成员，那么这种方法很有效。但是如果您使用包中的许多类型，则应该导入整个包。 导入整个包要导入特定包中包含的所有类型，请使用带有星号“（*）”通配符的“import”语句。 1import graphics.*; 现在，您可以通过简单的名称引用“graphics”包中的任何类或接口。 12Circle myCircle = new Circle();Rectangle myRectangle = new Rectangle(); “import”语句中的星号只能用于指定包中的所有类，如下所示。它不能用于匹配包中的类的子集。例如，以下内容不匹配“graphics”包中以“A”开头的所有类。 12// does not workimport graphics.A*; 相反，它会生成编译器错误。使用“import”语句，通常只导入单个包成员或整个包。 Note: 另一种不太常见的“import”形式允许您导入封闭类的公共嵌套类。例如，如果“graphics。矩形类包含有用的嵌套类，如矩形。DoubleWide和Rectangle。Square’，您可以使用以下two语句导入“Rectangle”及其嵌套类。 12import graphics.Rectangle;import graphics.Rectangle.*; 请注意，第二条import语句不会*导入“矩形”。 另一种不太常见的“import”形式，即static import语句，将在本节末尾讨论。 为了方便起见，Java编译器为每个源文件自动导入两个完整的包：（1）Java.lang包和（2）当前包（当前文件的包）。 包的表观层次结构起初，包看起来是分层的，但实际上不是。例如，Java API包含一个Java。awt包，一个java.awt.color包，一个java.awt。字体“package”，以及许多以“java.awt”开头的其他字体。然而，java.awt.color包，即java.awt。fontpackage和其他java.awt.xxxx包不包含在java.awt包。前缀java.awt（Java抽象窗口工具包）用于许多相关的包，以使关系变得明显，但不显示包含。 正在导入java.awt.*导入java中的所有类型。awt包，但它不导入java.awt.color，java.awt.color或任何其他java.awt.xxxx包。如果您计划使用java.awt.color”以及“java.awt，您必须导入两个包及其所有文件： 12import java.awt.*;import java.awt.color.*; 名称歧义如果一个包中的成员与另一个包的成员共享其名称，并且导入了两个包，则必须通过其限定名称引用每个成员。例如，“graphics”包定义了一个名为“Rectangle”的类。java。awt包还包含一个“矩形”类。如果“graphics”和“java。awt&#96;已导入，以下内容不明确。 1Rectangle rect; 在这种情况下，您必须使用成员的完全限定名来准确地指示所需的“矩形”类。例如 1graphics.Rectangle rect; 静态导入语句在某些情况下，您需要频繁访问一个或两个类中的静态final字段（常量）和静态方法。反复使用这些类的名称前缀可能会导致代码混乱。static import语句为您提供了一种方法来导入要使用的常量和静态方法，这样您就不需要在它们的类名称前加前缀。 “java.lang.Math”类定义了“PI”常量和许多静态方法， including methods for calculating sines, cosines, tangents, square roots, maxima, minima, exponents, and many more. For example, 123456public static final double PI = 3.141592653589793;public static double cos(double a)&#123; ...&#125; 通常，要使用其他类中的这些对象，可以在类名前面加上前缀，如下所示。 1double r = Math.cos(Math.PI * theta); 可以使用staticimport语句导入java.lang.Math的静态成员， Math. 可以单独导入“Math”的静态成员： 1import static java.lang.Math.PI; or as a group: 1import static java.lang.Math.*; 一旦导入了静态成员，就可以不经限定地使用它们。例如，上一个代码段将变为： 1double r = cos(PI * theta); 显然，您可以编写自己的类，这些类包含经常使用的常量和静态方法，然后使用静态import语句。例如 1import static mypackage.MyConstants.*; Note: 非常谨慎地使用静态导入。过度使用静态导入会导致代码难以读取和维护，因为代码的读者不知道哪个类定义了特定的静态对象。如果使用得当，静态导入通过消除类名重复使代码更可读。 管理源文件和类文件Java平台的许多实现依赖于分层文件系统来管理源文件和类文件，尽管Java语言规范不需要这样做。策略如下。 将类、接口、枚举或注释类型的源代码放在一个文本文件中，该文件的名称是该类型的简单名称，扩展名为“.java”。例如： 12345//in the Rectangle.java file package graphics;public class Rectangle &#123; ... &#125; 然后，将源文件放在一个目录中，该目录的名称反映了该类型所属的包的名称： 1.....\\graphics\\Rectangle.java 包成员的限定名和文件的路径名是并行的，假设Microsoft Windows文件名分隔符是反斜杠（对于UNIX，使用正斜杠）。 class name – graphics.Rectangle pathname to file – graphics\\Rectangle.java 您应该记得，按照惯例，一家公司使用其反向的互联网域名作为其软件包名称。Example公司，其Internet域名为“Example”。com”将在其所有包名称之前加上“com.example”。包名的每个组件都对应于一个子目录。所以，如果Example公司有一个“com.Example。包含“矩形”的图形包。java&#96;源文件，它将包含在一系列子目录中，如下所示： 1....\\com\\example\\graphics\\Rectangle.java 编译源文件时，编译器会为其中定义的每个类型创建不同的输出文件。输出文件的基名称是类型的名称，其扩展名为“.class”。例如，如果源文件如下 123456789//in the Rectangle.java filepackage com.example.graphics;public class Rectangle &#123; . . . &#125;class Helper&#123; . . . &#125; 则编译的文件将位于： 12&lt;path to the parent directory of the output files&gt;\\com\\example\\graphics\\Rectangle.class&lt;path to the parent directory of the output files&gt;\\com\\example\\graphics\\Helper.class 就像。java 源文件，编译的。类文件应位于反映包名称的一系列目录中。但是，“.class“文件”不必与“”的路径相同。java&#96;源文件。您可以分别排列源目录和类目录，如下所示： 123&lt;path_one&gt;\\sources\\com\\example\\graphics\\Rectangle.java&lt;path_two&gt;\\classes\\com\\example\\graphics\\Rectangle.class 通过这样做，您可以将“classes”目录交给其他程序员，而不必透露源代码。您还需要以这种方式管理源文件和类文件，以便编译器和Java虚拟机（JVM）可以找到程序使用的所有类型。 通过这样做，您可以将“classes”目录交给其他程序员，而不必透露源代码。您还需要以这种方式管理源文件和类文件，以便编译器和Java虚拟机（JVM）可以找到程序使用的所有类型。 1&lt;path_two&gt;\\classes 是类路径，包名为 1com.example.graphics, 然后编译器和JVM查找“, .class files in 1&lt;path_two&gt;\\classes\\com\\example\\graphics. 类路径可以包括多个路径，用分号（Windows）或冒号（UNIX）分隔。默认情况下，编译器和JVM搜索当前目录和包含Java平台类的JAR文件，以便这些目录自动位于类路径中。 设置CLASSPATH系统变量要显示当前的“CLASSPATH”变量，请在Windows和UNIX（Bourne shell）中使用以下命令： 12In Windows: C:\\&gt; set CLASSPATHIn UNIX: % echo $CLASSPATH 要删除“CLASSPATH”变量的当前内容，请使用以下命令： 12In Windows: C:\\&gt; set CLASSPATH=In UNIX: % unset CLASSPATH; export CLASSPATH 要设置“CLASSPATH”变量，请使用以下命令（例如）： 12In Windows: C:\\&gt; set CLASSPATH=C:\\users\\george\\java\\classesIn UNIX: % CLASSPATH=/home/george/java/classes; export CLASSPATH 创建和使用包摘要要为类型创建包，请将“package”语句作为包含该类型（类、接口、枚举或注释类型）的源文件中的第一条语句。 要使用不同包中的公共类型，可以有三种选择：（1）使用类型的完全限定名称，（2）导入类型，或（3）导入该类型所属的整个包。 包的源文件和类文件的路径名反映了包的名称。 您可能需要设置“CLASSPATH”，以便编译器和JVM可以找到“。类文件。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"Oracle Java官方介绍","slug":"软件开发/技术/编程语言/java/Oracle-Java官方介绍","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.279Z","comments":true,"path":"2020/07/Oracle-Java官方介绍/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E5%AE%98%E6%96%B9%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html 关于 Java 技术Java 技术既是一种编程语言又是一个平台。 Java 编程语言Java 编程语言是一种高级语言，具有以下所有流行语的特征： 简单的面向对象分散式多线程动态的 架构中立便携的高性能强大的安全的 在James Gosling 和 Henry McGilton 撰写的白皮书The Java Language Environment中解释了前面的每个流行语 。 在 Java 编程语言中，所有源代码首先写在以扩展名.java结尾的纯文本文件中。这些源文件通过javac编译器编译成.class文件。.class文件不包含处理器的本机代码；它包含字节码——Java 虚拟机1(Java VM) 的机器语言。启动器java工具然后使用 Java 虚拟机实例运行您的应用程序。 软件开发过程的概述。 因为 Java VM 在许多不同的操作系统上可用，所以相同的.class文件能够在 Microsoft Windows、Solaris™ 操作系统 (Solaris OS)、Linux 或 Mac OS 上运行。一些虚拟机，例如 Java SE HotSpot 概览，会在运行时执行额外的步骤来提高您的应用程序的性能。这包括各种任务，例如查找性能瓶颈和重新编译（到本机代码）经常使用的代码部分。 通过Java VM，同一个应用程序可以运行在多个平台上。 Java 平台平台是程序运行的硬件或软件环境。我们已经提到了一些最流行的平台，例如 Microsoft Windows、Linux、Solaris OS 和 Mac OS。大多数平台可以描述为操作系统和底层硬件的组合。Java 平台不同于大多数其他平台，因为它是一个运行在其他基于硬件的平台之上的纯软件平台。 Java 平台有两个组件： Java 虚拟机 Java 应用程序编程接口( API) 您已经了解了 Java 虚拟机；它是 Java 平台的基础，并被移植到各种基于硬件的平台上。 API 是大量现成软件组件的集合，可提供许多有用的功能。它被分组为相关类和接口的库；这些库被称为包。 Java 技术能做什么？通用的高级 Java 编程语言是一个功能强大的软件平台。Java 平台的每个完整实现都为您提供以下功能： 开发工具：开发工具提供了编译、运行、监控、调试和记录应用程序所需的一切。作为新开发人员，您将使用的主要工具是javac编译器、java启动器和javadoc文档工具。 **应用程序编程接口 (API)**：API 提供 Java 编程语言的核心功能。它提供了大量有用的类，可以在您自己的应用程序中使用。它涵盖了从基本对象到网络和安全，再到 XML 生成和数据库访问等方方面面。核心API非常庞大；要大致了解它包含的内容，请参阅 Java Platform Standard Edition 8 文档。 部署技术：JDK 软件提供标准机制，例如 Java Web Start 软件和 Java Plug-In 软件，用于将您的应用程序部署到最终用户。 用户界面工具包：JavaFX、Swing 和 Java 2D 工具包使创建复杂的图形用户界面 (GUI) 成为可能。 集成库：Java IDL API、JDBC API、Java Naming and Directory Interface (JNDI) API、Java RMI 和 Java Remote Method Invocation over Internet ORB 间协议技术（Java RMI-IIOP 技术）等集成库支持数据库访问和操纵远程对象。 Java 技术将如何改变我的生活？如果您学习 Java 编程语言，我们不能向您保证名利，甚至工作。不过，它可能会使您的程序更好，并且比其他语言需要更少的努力。我们相信 Java 技术将帮助您做到以下几点： 快速上手：虽然 Java 编程语言是一种功能强大的面向对象语言，但它易于学习，特别是对于已经熟悉 C 或 C++ 的程序员而言。 编写更少的代码：程序指标（类计数、方法计数等）的比较表明，用 Java 编程语言编写的程序比用 C++ 编写的相同程序小四倍。 编写更好的代码：Java 编程语言鼓励良好的编码习惯，自动垃圾收集可帮助您避免内存泄漏。它的面向对象、JavaBeans™ 组件体系结构以及范围广泛、易于扩展的 API 让您可以重用现有的、经过测试的代码并减少引入的错误。 更快地开发程序：Java 编程语言比 C++ 更简单，因此，使用它编写时，您的开发时间最多可缩短一倍。您的程序也将需要更少的代码行。 避免平台依赖性：您可以通过避免使用以其他语言编写的库来保持程序的可移植性。 编写一次，随处运行：因为用 Java 编程语言编写的应用程序被编译成与机器无关的字节码，所以它们可以在任何 Java 平台上一致地运行。 更轻松地分发软件：使用 Java Web Start 软件，用户只需单击鼠标即可启动您的应用程序。启动时的自动版本检查可确保用户始终使用最新版本的软件。如果有更新可用，Java Web Start 软件将自动更新其安装。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"Oracle Java异常","slug":"软件开发/技术/编程语言/java/Oracle-Java异常","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.281Z","comments":true,"path":"2020/07/Oracle-Java异常/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E5%BC%82%E5%B8%B8/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html Java编程语言使用异常来处理错误和其他异常事件。本课程介绍何时以及如何使用异常。 什么是异常？术语exception是短语“exceptionevent”的缩写 Definition: 异常是在程序执行过程中发生的事件，它会中断程序的正常指令流。 当方法中发生错误时，该方法会创建一个对象并将其移交给运行时系统。该对象称为“异常对象”，包含有关错误的信息，包括错误发生时程序的类型和状态。创建异常对象并将其传递给运行时系统称为“抛出异常”。 方法抛出异常后，运行时系统会尝试找到处理它的方法。处理异常的一组可能的“something”是为获取发生错误的方法而调用的方法的有序列表。方法列表称为调用堆栈（参见下图）。 调用堆栈。 运行时系统在调用堆栈中搜索包含可处理异常的代码块的方法。这段代码称为异常处理程序。搜索从发生错误的方法开始，并按照调用方法的相反顺序继续执行调用堆栈。找到适当的处理程序后，运行时系统将异常传递给处理程序。如果抛出的异常对象的类型与处理程序可以处理的类型匹配，则认为异常处理程序是合适的。 所选的异常处理程序被称为“捕获异常”。如果运行时系统穷尽地搜索调用堆栈上的所有方法，而没有找到适当的异常处理程序，如下图所示，则运行时系统（因此，程序）终止。 正在调用堆栈中搜索异常处理程序。 与传统的错误管理技术相比，使用异常来管理错误具有一些优势。您可以在例外情况的优点中了解更多信息第节。 捕捉或指定要求有效的Java编程语言代码必须符合捕获或指定要求。这意味着可能引发某些异常的代码必须由以下任一项括起来： 捕获异常的“try”语句。“try”必须为异常提供处理程序，如Catching and Handling Exceptions中所述. 指定可以引发异常的方法。该方法必须提供列出异常的“throws”子句，如指定方法引发的异常中所述. 无法满足Catch或Specify要求的代码将不会编译。 并非所有例外都符合“捕获或指定要求”。为了理解原因，我们需要研究三种基本的例外情况，其中只有一种例外情况符合要求。 三种例外第一种异常是checked异常。这些都是编写良好的应用程序应该预见并从中恢复的例外情况。例如，假设应用程序提示用户输入文件名，然后通过将名称传递给“java.io.FileReader”的构造函数来打开文件。通常，用户提供现有可读文件的名称，因此“FileReader”对象的构造成功，应用程序的执行正常进行。但有时用户提供一个不存在的文件名，构造函数抛出“java.io.FileNotFoundException”。编写良好的程序将捕获此异常并通知用户错误，可能会提示用户更正文件名。 选中的异常*受捕获或指定要求的约束。除“错误”、“运行时异常”及其子类指示的异常外，所有异常都是检查异常。 第二种异常是error。这些是应用程序外部的异常情况，应用程序通常无法预测或从中恢复。例如，假设应用程序成功打开文件进行输入，但由于硬件或系统故障而无法读取文件。读取失败将引发“java.io.IOError”。应用程序可能会选择捕获此异常，以便通知用户问题，但程序打印堆栈跟踪并退出也可能有意义。 错误不受捕获或指定要求的约束。错误是由“错误”及其子类指示的异常。 第三种异常是运行时异常。这些是应用程序内部的异常情况，应用程序通常无法预测或从中恢复。这些通常表示编程错误，例如逻辑错误或API使用不当。例如，考虑前面描述的将文件名传递给“FileReader”构造函数的应用程序。如果逻辑错误导致向构造函数传递“null”，则构造函数将引发“NullPointerException”。应用程序可以捕获此异常，但消除导致异常发生的错误可能更有意义。 运行时异常不受捕获或指定要求的约束。运行时异常是由“RuntimeException”及其子类指示的异常。 错误和运行时异常统称为“未检查异常”。 绕过捕获或指定一些程序员认为Catch或Specify Requirement是异常机制中的一个严重缺陷，并通过使用未检查的异常代替已检查的异常来绕过它。一般来说，不建议这样做。部分未选中的例外-争议讨论何时使用未检查的异常。 捕获和处理异常本节介绍如何使用三个异常处理程序组件（“try”、“catch”和“finally”块）来编写异常处理程序。然后，解释了JavaSE7中引入的“try-”with resources语句。“try-”with resources语句特别适用于使用“Closeable”资源的情况，例如流。 本节的最后一部分将通过一个示例，分析各种场景中发生的情况。 下面的示例定义并实现了一个名为“ListOfNumbers”的类。构造时，“ListOfNumbers”创建一个“ArrayList”，其中包含10个“Integer”元素，这些元素的顺序值为0到9。“ListOfNumber”类还定义了一个名为“writeList”的方法，该方法将数字列表写入名为“OutFile.txt”的文本文件中。此示例使用java中定义的输出类。io，包括在基本I&#x2F;O中. 12345678910111213141516171819202122232425262728// Note: This class will not compile yet.import java.io.*;import java.util.List;import java.util.ArrayList;public class ListOfNumbers &#123; private List&lt;Integer&gt; list; private static final int SIZE = 10; public ListOfNumbers () &#123; list = new ArrayList&lt;Integer&gt;(SIZE); for (int i = 0; i &lt; SIZE; i++) &#123; list.add(new Integer(i)); &#125; &#125; public void writeList() &#123; // The FileWriter constructor throws IOException, which must be caught. PrintWriter out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;)); for (int i = 0; i &lt; SIZE; i++) &#123; // The get(int) method throws IndexOutOfBoundsException, which must be caught. out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; out.close(); &#125;&#125; 粗体的第一行是对构造函数的调用。构造函数初始化文件上的输出流。如果无法打开文件，构造函数将抛出“IOException”。第二个粗体行是对“ArrayList”类的“get”方法的调用，如果其参数值太小（小于0）或太大（大于“ArrayList”当前包含的元素数），则会抛出“IndexOutOfBoundsException”。 如果尝试编译ListOfNumbers类，编译器将打印一条关于“FileWriter”构造函数引发的异常的错误消息。但是，它不会显示有关“get”引发的异常的错误消息。原因是构造函数抛出的异常“IOException”是一个已检查的异常，而“get”方法引发的异常“IndexOutOfBoundsException”是未检查的异常。 现在，您已经熟悉了“ListOfNumbers”类以及可以在其中抛出异常的位置，现在就可以编写异常处理程序来捕获和处理这些异常了。 The try Block构造异常处理程序的第一步是将可能引发异常的代码封装在“try”块中。通常，“try”块如下所示： 1234try &#123; code&#125;catch and finally blocks . . . 示例中标记为“code”的段包含一个或多个可能引发异常的合法代码行。（“catch”和“finally”块将在接下来的两个小节中解释。） 要从“ListOfNumbers”类构造“writeList”方法的异常处理程序，请在“try”块中包含“writeList“方法的异常抛出语句。有不止一种方法可以做到这一点。您可以将可能引发异常的每一行代码放在自己的“try”块中，并为每一行提供单独的异常处理程序。或者，您可以将所有“writeList”代码放在一个“try”块中，并将多个处理程序与之关联。下面的列表对整个方法使用一个“try”块，因为所讨论的代码很短。 123456789101112131415private List&lt;Integer&gt; list;private static final int SIZE = 10;public void writeList() &#123; PrintWriter out = null; try &#123; System.out.println(&quot;Entered try statement&quot;); FileWriter f = new FileWriter(&quot;OutFile.txt&quot;); out = new PrintWriter(f); for (int i = 0; i &lt; SIZE; i++) &#123; out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; &#125; catch and finally blocks . . .&#125; 如果“try”块中发生异常，则该异常将由与其关联的异常处理程序处理。要将异常处理程序与“try”块关联，必须在其后面放置“catch”块；下一节，捕捉块，向您展示了如何操作。 The catch Blocks通过在“try”块之后直接提供一个或多个“catch”块，可以将异常处理程序与“try”块相关联。“try”块的结尾和第一个“catch”块的开头之间不能有代码。 1234567try &#123;&#125; catch (ExceptionType name) &#123;&#125; catch (ExceptionType name) &#123;&#125; 每个“catch”块都是一个异常处理程序，用于处理其参数所指示的异常类型。参数类型“ExceptionType”声明处理程序可以处理的异常类型，并且必须是从“Throwable”类继承的类的名称。处理程序可以使用“name”引用异常。 “catch”块包含在调用异常处理程序时执行的代码。当异常处理程序是调用堆栈中第一个“ExceptionType”与抛出的异常类型匹配的异常处理程序时，运行时系统调用异常处理程序。如果抛出的对象可以合法地分配给异常处理程序的参数，则系统认为它是匹配的。 以下是“writeList”方法的两个异常处理程序： 1234567try &#123;&#125; catch (IndexOutOfBoundsException e) &#123; System.err.println(&quot;IndexOutOfBoundsException: &quot; + e.getMessage());&#125; catch (IOException e) &#123; System.err.println(&quot;Caught IOException: &quot; + e.getMessage());&#125; 异常处理程序可以做的不仅仅是打印错误消息或停止程序。他们可以执行错误恢复，提示用户做出决定，或使用链式异常将错误传播到更高级别的处理程序，如chained exceptions中所述第节。 用一个异常处理程序捕获多种类型的异常在JavaSE7及更高版本中，单个“catch”块可以处理多种类型的异常。此功能可以减少代码重复，并减少捕捉过大异常的诱惑。 在“catch”子句中，指定块可以处理的异常类型，并用竖条（“|”）分隔每个异常类型： 1234catch (IOException|SQLException ex) &#123; logger.log(ex); throw ex;&#125; Note: 如果“catch”块处理多个异常类型，则“catch”参数隐式为“final”。在此示例中，“catch”参数“ex”是“final”，因此不能在“catch”块中为其赋值。 The finally Block当“try”块退出时，“finally”块始终执行。这确保即使发生意外异常，也执行“finally”块。但“finally”不仅仅对异常处理有用，它允许程序员避免清理代码被“return”、“continue”或“break”意外绕过。将清理代码放在“finally”块中始终是一种很好的做法，即使预计不会出现异常。 注意：如果在执行“try”或“catch”代码时JVM退出，则“finally”块可能不会执行。 您在此使用的“writeList”方法的“try”块将打开一个“PrintWriter”。程序应在退出“writeList”方法之前关闭该流。这带来了一个有点复杂的问题，因为“writeList”的“try”块可以通过三种方式之一退出。 “new FileWriter”语句失败并引发“IOException”。 list.get(i)语句失败并抛出IndexOutOfBoundsException。 一切都成功，“try”块正常退出。 运行时系统总是在“finally”块中执行语句，而不管“try”块中发生了什么。所以这是进行清理的最佳场所。 “writeList”方法的以下“finally”块将清除，然后关闭“PrintWriter”和“FileWriter”。 123456789101112finally &#123; if (out != null) &#123; System.out.println(&quot;Closing PrintWriter&quot;); out.close(); &#125; else &#123; System.out.println(&quot;PrintWriter not open&quot;); &#125; if (f != null) &#123; System.out.println(&quot;Closing FileWriter&quot;); f.close(); &#125; &#125; 重要的: 关闭文件或以其他方式恢复资源时，请使用“try-”with resources语句，而不是“finally”块。以下示例使用“try”-with-resources语句清理并关闭“writeList”方法的“PrintWriter”和“FileWriter”： 12345678public void writeList() throws IOException &#123; try (FileWriter f = new FileWriter(&quot;OutFile.txt&quot;); PrintWriter out = new PrintWriter(f)) &#123; for (int i = 0; i &lt; SIZE; i++) &#123; out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; &#125;&#125; “try”-with-resources语句在不再需要时自动释放系统资源。 See The try-with-resources Statement. The try-with-resources Statement“try”-with-resources语句是声明一个或多个资源的“try”语句。资源是程序完成后必须关闭的对象。“try”-with-resources语句确保每个资源都在语句末尾关闭。 实现java.lang.AutoCloseable的任何对象，包括实现java.io.AutoCloseable，可用作资源。 以下示例从文件中读取第一行。它使用“FileReader”和“BufferedReader”的实例从文件中读取数据。FileReader和BufferedReader是程序完成后必须关闭的资源： 123456static String readFirstLineFromFile(String path) throws IOException &#123; try (FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr)) &#123; return br.readLine(); &#125;&#125; 在此示例中，“try”-with-resources语句中声明的资源是“FileReader”和“BufferedReader”。这些资源的声明语句出现在“try”关键字后面的括号内。Java SE 7和更高版本中的类“FileReader”和“BufferedReader”实现了接口“Java.lang.AutoCloseable”。由于“FileReader”和“BufferedReader”实例是在“try”with resource语句中声明的，因此无论“try语句是正常完成还是突然完成（由于方法“BufferedReader.readLine”引发了“IOException”），它们都将被关闭。 在JavaSE7之前，您可以使用“finally”块来确保关闭资源，而不管“try”语句是正常完成还是突然完成。以下示例使用“finally”块而不是“try”-with-resources语句： 1234567891011static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException &#123; FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr); try &#123; return br.readLine(); &#125; finally &#123; br.close(); fr.close(); &#125;&#125; 但是，此示例可能存在资源泄漏。程序在使用完资源后，除了依靠垃圾收集器（GC）回收资源的内存之外，还需要做更多的工作。程序还必须将资源释放回操作系统，通常通过调用资源的“close”方法。但是，如果程序在GC回收资源之前未能做到这一点，那么释放资源所需的信息就会丢失。运行系统仍认为正在使用的资源已经泄漏。 在此示例中，如果“readLine”方法引发异常，则语句“br”。“finally”块中的close（）”引发异常，则“FileReader”已泄漏。因此，使用“try”-with-resources语句而不是“finally”块来关闭程序的资源。 如果方法“readLine”和“close”都抛出异常，则方法“readFirstLineFromFileWithFinallyBlock”抛出从“finally”块抛出的异常；抑制从“try”块抛出的异常。相反，在示例“readFirstLineFromFile”中，如果同时从“try”块和“try-with resources”语句抛出异常，则方法“readFirst LineFromFile”将抛出从“try”块抛出的异常；从“try”-with-resources块抛出的异常被抑制。在Java SE 7及更高版本中，您可以检索抑制的异常；请参见抑制的异常一节以获取更多信息。 以下示例检索zip文件“zipFileName”中打包的文件的名称，并创建包含这些文件名称的文本文件： 123456789101112131415161718192021222324252627282930public static void writeToFileZipFileContents(String zipFileName, String outputFileName) throws java.io.IOException &#123; java.nio.charset.Charset charset = java.nio.charset.StandardCharsets.US_ASCII; java.nio.file.Path outputFilePath = java.nio.file.Paths.get(outputFileName); // Open zip file and create output file with // try-with-resources statement try ( java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName); java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset) ) &#123; // Enumerate each entry for (java.util.Enumeration entries = zf.entries(); entries.hasMoreElements();) &#123; // Get the entry name and write it to the output file String newLine = System.getProperty(&quot;line.separator&quot;); String zipEntryName = ((java.util.zip.ZipEntry)entries.nextElement()).getName() + newLine; writer.write(zipEntryName, 0, zipEntryName.length()); &#125; &#125;&#125; 在此示例中，“try”-with-resources语句包含两个用分号分隔的声明：“ZipFile”和“BufferedWriter”。当直接跟随它的代码块终止时，无论是正常终止还是由于异常终止，“BufferedWriter”和“ZipFile”对象的“close”方法都会按此顺序自动调用。请注意，资源的“close”方法的调用顺序与其创建顺序相反。 以下示例使用“try”-with-resources语句自动关闭“java.sql”。语句&#96;object: 123456789101112131415161718192021public static void viewTable(Connection con) throws SQLException &#123; String query = &quot;select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES&quot;; try (Statement stmt = con.createStatement()) &#123; ResultSet rs = stmt.executeQuery(query); while (rs.next()) &#123; String coffeeName = rs.getString(&quot;COF_NAME&quot;); int supplierID = rs.getInt(&quot;SUP_ID&quot;); float price = rs.getFloat(&quot;PRICE&quot;); int sales = rs.getInt(&quot;SALES&quot;); int total = rs.getInt(&quot;TOTAL&quot;); System.out.println(coffeeName + &quot;, &quot; + supplierID + &quot;, &quot; + price + &quot;, &quot; + sales + &quot;, &quot; + total); &#125; &#125; catch (SQLException e) &#123; JDBCTutorialUtilities.printSQLException(e); &#125;&#125; 资源&#96;java.sql。本例中使用的语句是JDBC4.1和更高版本API的一部分。 注意：“try”-with-resources语句可以有“catch”和“finally”块，就像普通的“try”语句一样。在“try”-with-resources语句中，任何“catch”或“finally”块都在声明的资源关闭后运行。 抑制的异常可以从与“try”-with-resources语句关联的代码块中抛出异常。在示例“writeToFileZipFileContents”中，当试图关闭“ZipFile”和“BufferedWriter”对象时，可以从“try”块引发一个异常，而“try-with resources”语句最多可以引发两个异常。如果从“try”块中抛出异常，并且从“try-with-resources”语句中抛出一个或多个异常，那么将抑制从“try&#x2F;with-resources”语句中引发的异常，并且该块引发的异常是由“writeToFileZipFileContents”方法引发的异常。您可以通过调用“Throwable”来检索这些被抑制的异常。“try”块引发的异常中的getSuppressed”方法。 实现AutoCloseable或Closeable接口的类参见AutoCloseable的Javadoc和Closeable实现这些接口的类列表的接口。“可关闭”接口扩展了“自动关闭”接口。“Closeable”接口的“close”方法抛出类型为“IOException”的异常，而“AutoCloseable”界面的“close”方法抛出“Exception”类型的异常。因此，“AutoCloseable”接口的子类可以覆盖“close”方法的这种行为，以引发特殊异常，例如“IOException”，或者根本没有异常。 把一切放在一起前几节描述了如何为ListOfNumbers类中的writeList方法构造try、catch和finally代码块。现在，让我们浏览代码并调查可能发生的情况。 当所有组件放在一起时，writeList方法如下所示。 123456789101112131415161718192021222324252627public void writeList() &#123; PrintWriter out = null; try &#123; System.out.println(&quot;Entering&quot; + &quot; try statement&quot;); out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;)); for (int i = 0; i &lt; SIZE; i++) &#123; out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; &#125; catch (IndexOutOfBoundsException e) &#123; System.err.println(&quot;Caught IndexOutOfBoundsException: &quot; + e.getMessage()); &#125; catch (IOException e) &#123; System.err.println(&quot;Caught IOException: &quot; + e.getMessage()); &#125; finally &#123; if (out != null) &#123; System.out.println(&quot;Closing PrintWriter&quot;); out.close(); &#125; else &#123; System.out.println(&quot;PrintWriter not open&quot;); &#125; &#125;&#125; 如前所述，该方法的try块有三种不同的退出可能性；这里有两个。 “try”语句中的代码失败并引发异常。这可能是“new FileWriter”语句导致的“IOException”，也可能是“for”循环中索引值错误导致的“IndexOutOfBoundsException”。 一切都成功，“try”语句正常退出。 让我们看看在这两种退出可能性期间，“writeList”方法中发生了什么。 设想 1: 发生异常创建“FileWriter”的语句可能因多种原因而失败。例如，如果程序无法创建或写入指定的文件，则“FileWriter”的构造函数将抛出“IOException”。 当“FileWriter”抛出“IOException”时，运行时系统立即停止执行“try”块；正在执行的方法调用未完成。然后，运行时系统开始在方法调用堆栈的顶部搜索适当的异常处理程序。在本例中，当发生“IOException”时，“FileWriter”构造函数位于调用堆栈的顶部。但是，“FileWriter”构造函数没有适当的异常处理程序，因此运行时系统会检查方法调用堆栈中的下一个方法“writeList”方法。“writeList”方法有两个异常处理程序：一个用于“IOException”，另一个为“IndexOutOfBoundsException”。 运行时系统按照“try”语句之后出现的顺序检查“writeList”的处理程序。第一个异常处理程序的参数是“IndexOutOfBoundsException”。这与引发的异常类型不匹配，因此运行时系统检查下一个异常处理程序-“IOException”。这与引发的异常类型相匹配，因此运行时系统结束对适当异常处理程序的搜索。现在运行时已经找到了合适的处理程序，“catch”块中的代码将被执行。 异常处理程序执行后，运行时系统将控制传递给“finally”块。“finally”块中的代码将执行，而不管上面捕获到什么异常。在这种情况下，“FileWriter”从未打开，不需要关闭。在“finally”块完成执行后，程序继续执行“finally”块后的第一条语句。 这是抛出“IOException”时出现的“ListOfNumbers”程序的完整输出。 123Entering try statementCaught IOException: OutFile.txtPrintWriter not open 以下列表中的粗体代码显示了在此场景中执行的语句： 12345678910111213141516171819202122232425public void writeList() &#123; PrintWriter out = null; try &#123; System.out.println(&quot;Entering try statement&quot;); out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;)); for (int i = 0; i &lt; SIZE; i++) out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; catch (IndexOutOfBoundsException e) &#123; System.err.println(&quot;Caught IndexOutOfBoundsException: &quot; + e.getMessage()); &#125; catch (IOException e) &#123; System.err.println(&quot;Caught IOException: &quot; + e.getMessage()); &#125; finally &#123; if (out != null) &#123; System.out.println(&quot;Closing PrintWriter&quot;); out.close(); &#125; else &#123; System.out.println(&quot;PrintWriter not open&quot;); &#125; &#125;&#125; 设想 2: try块正常退出在这种情况下，“try”块范围内的所有语句都成功执行，没有抛出异常。执行从“try”块的末尾落下，运行时系统将控制权传递给“finally”块。由于一切都成功，当控件到达“finally”块时，“PrintWriter”将打开，该块将关闭“PrintWriter”。同样，在“finally”块完成执行之后，程序继续执行“finally”块之后的第一条语句。 这是“ListOfNumbers”程序在未引发异常时的输出。 12Entering try statementClosing PrintWriter 下面示例中的粗体代码显示了在此场景中执行的语句。 12345678910111213141516171819202122232425public void writeList() &#123; PrintWriter out = null; try &#123; System.out.println(&quot;Entering try statement&quot;); out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;)); for (int i = 0; i &lt; SIZE; i++) out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; catch (IndexOutOfBoundsException e) &#123; System.err.println(&quot;Caught IndexOutOfBoundsException: &quot; + e.getMessage()); &#125; catch (IOException e) &#123; System.err.println(&quot;Caught IOException: &quot; + e.getMessage()); &#125; finally &#123; if (out != null) &#123; System.out.println(&quot;Closing PrintWriter&quot;); out.close(); &#125; else &#123; System.out.println(&quot;PrintWriter not open&quot;); &#125; &#125;&#125; 指定方法引发的异常上一节介绍了如何为“ListOfNumbers”类中的“writeList”方法编写异常处理程序。有时，代码捕捉可能在其中发生的异常是合适的。然而，在其他情况下，最好让调用堆栈更上层的方法处理异常。例如，如果您将“ListOfNumbers”类作为一个类包的一部分提供，那么您可能无法预测包中所有用户的需求。在这种情况下，最好不要捕捉到异常，并允许调用堆栈更上层的方法来处理它。 如果“writeList”方法没有捕获可能在其中发生的已检查异常，则“writeList”方法必须指定它可以引发这些异常。让我们修改原始的“writeList”方法，以指定它可以抛出的异常，而不是捕获它们。为了提醒您，这里是无法编译的“writeList”方法的原始版本。 1234567public void writeList() &#123; PrintWriter out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;)); for (int i = 0; i &lt; SIZE; i++) &#123; out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i)); &#125; out.close();&#125; 若要指定“writeList”可以引发两个异常，请在“writeList”方法的方法声明中添加“throws”子句。“throws”子句包含“throws”关键字，后跟该方法引发的所有异常的逗号分隔列表。该子句位于方法名称和参数列表之后，位于定义方法范围的大括号之前；这是一个例子。 1public void writeList() throws IOException, IndexOutOfBoundsException &#123; 请记住，“IndexOutOfBoundsException”是未选中的异常；在“throws”子句中包含它不是强制性的。你可以写以下内容。 1public void writeList() throws IOException &#123; 如何抛出异常在捕获异常之前，某些代码必须在某处抛出异常。任何代码都可能引发异常：您的代码、来自其他人编写的包（如Java平台附带的包或Java运行时环境）的代码。无论抛出异常的是什么，它总是与“throw”语句一起抛出。 正如您可能注意到的，Java平台提供了许多异常类。所有类都是Throwable的后代类，所有这些都允许程序区分在程序执行期间可能发生的各种类型的异常。 您还可以创建自己的异常类来表示您编写的类中可能出现的问题。事实上，如果您是包开发人员，您可能需要创建自己的一组异常类，以允许用户区分包中可能发生的错误和Java平台或其他包中发生的错误。 您还可以创建链式异常。有关详细信息，请参阅Chained Exceptions第节。 投掷声明所有方法都使用“throw”语句引发异常。“throw”语句需要一个参数：一个可丢弃的对象。可抛出对象是“可抛出”类的任何子类的实例。下面是一个“throw”语句的示例。 1throw someThrowableObject; 让我们看看上下文中的“throw”语句。以下“pop”方法取自实现公共堆栈对象的类。该方法从堆栈中移除顶部元素并返回对象。 123456789101112public Object pop() &#123; Object obj; if (size == 0) &#123; throw new EmptyStackException(); &#125; obj = objectAt(size - 1); setObjectAt(size - 1, null); size--; return obj;&#125; “pop”方法检查堆栈中是否有任何元素。如果堆栈为空（其大小等于“0”），“pop”将实例化一个新的“EmptyStackException”对象（“java.util”的成员）并将其抛出。创建异常类本章的一节介绍如何创建自己的异常类。现在，您需要记住的是，只能抛出从“java.lang.Throwable”类继承的对象。 请注意，“pop”方法的声明不包含“throws”子句EmptyStackException不是已检查的异常，因此不需要“pop”来声明可能发生此异常。 Throwable 类及其子类从“Throwable”类继承的对象包括直接后代（从“Throuble”类直接继承的对象）和间接后代（从‘Throwable’类的子代或子代继承的对象。下图说明了“Throwable”类及其最重要的子类的类层次结构。如您所见，“Throwable”有两个直接后代：Error和Exception. The Throwable class. Error Class当Java虚拟机中发生动态链接故障或其他硬故障时，虚拟机将抛出“Error”。简单程序通常不会捕获或抛出“Error”。 Exception Class大多数程序抛出和捕获从“Exception”类派生的对象。“异常”表示出现了问题，但不是严重的系统问题。您编写的大多数程序都会抛出和捕获“异常”，而不是“错误”。 Java平台定义了“Exception”类的许多后代。这些子体指示可能发生的各种类型的异常。例如，“IllegalAccessException”表示找不到特定的方法，而“NegativeArray SizeException”表示程序试图创建大小为负的数组。 一个Exception子类RuntimeException是为指示错误使用API的异常保留的。运行时异常的一个示例是“NullPointerException”，当方法试图通过“null”引用访问对象的成员时，会发生这种异常。部分未选中的例外-争议讨论了为什么大多数应用程序不应该抛出运行时异常或子类“RuntimeException”。 链式异常应用程序通常通过抛出另一个异常来响应异常。实际上，第一个异常导致第二个异常。了解一个异常何时导致另一个异常非常有用Chained Exceptions可帮助程序员执行此操作。 以下是“Throwable”中支持链式异常的方法和构造函数。 1234Throwable getCause()Throwable initCause(Throwable)Throwable(String, Throwable)Throwable(Throwable) “initCause”的“Throwable”参数和“Throwable”构造函数是导致当前异常的异常getCause 返回导致当前异常的异常，initCause 设置当前异常的原因。 以下示例显示如何使用链式异常。 12345try &#123;&#125; catch (IOException e) &#123; throw new SampleException(&quot;Other IOException&quot;, e);&#125; 在本例中，当捕获到“IOException”时，将创建一个新的“SampleException”异常，并附加原始原因，然后将异常链抛出到下一个更高级别的异常处理程序。 访问堆栈跟踪信息现在让我们假设高级异常处理程序希望以自己的格式转储堆栈跟踪。 释义: 堆栈跟踪提供有关当前线程执行历史的信息，并列出在异常发生时调用的类和方法的名称。堆栈跟踪是一个有用的调试工具，当抛出异常时，通常可以利用它。 下面的代码显示了如何对异常对象调用“getStackTrace”方法。 123456789catch (Exception cause) &#123; StackTraceElement elements[] = cause.getStackTrace(); for (int i = 0, n = elements.length; i &lt; n; i++) &#123; System.err.println(elements[i].getFileName() + &quot;:&quot; + elements[i].getLineNumber() + &quot;&gt;&gt; &quot; + elements[i].getMethodName() + &quot;()&quot;); &#125;&#125; Logging API下一个代码段记录“catch”块中发生异常的位置。但是，不要手动解析堆栈跟踪并将输出发送到System.err()，它使用java.util.logging中的日志记录工具将输出发送到文件包装。 1234567891011try &#123; Handler handler = new FileHandler(&quot;OutFile.log&quot;); Logger.getLogger(&quot;&quot;).addHandler(handler); &#125; catch (IOException e) &#123; Logger logger = Logger.getLogger(&quot;package.name&quot;); StackTraceElement elements[] = e.getStackTrace(); for (int i = 0, n = elements.length; i &lt; n; i++) &#123; logger.log(Level.WARNING, elements[i].getMethodName()); &#125;&#125; Creating Exception Classes在选择要抛出的异常类型时，您可以使用其他人编写的异常类（Java平台提供了许多可以使用的异常类），也可以编写自己的异常类。如果您对以下任何一个问题回答“是”，您应该编写自己的异常类；否则，你可能会用别人的。 您是否需要Java平台中没有表示的异常类型？ 如果用户能够将您的异常与其他供应商编写的类引发的异常区分开来，这对他们有帮助吗？ 您的代码是否引发多个相关异常？ 如果您使用其他人的异常，用户是否可以访问这些异常？一个类似的问题是，您的软件包是否应该是独立和独立的？ An Example假设您正在编写一个链表类。该类支持以下方法： objectAt(int n) — 返回列表中第n个位置的对象。如果参数小于0或大于列表中当前对象的数量，则引发异常。 firstObject() — 返回列表中的第一个对象。如果列表中不包含对象，则引发异常。 indexOf(Object o) — 在列表中搜索指定的“对象”并返回其在列表中的位置。如果传入方法的对象不在列表中，则引发异常。 链表类可以抛出多个异常，如果能够用一个异常处理程序捕获链表抛出的所有异常，将非常方便。此外，如果您计划在一个包中分发链接列表，所有相关的代码都应该打包在一起。因此，链接列表应该提供自己的一组异常类。 下图说明了链接列表引发的异常的一个可能的类层次结构。 异常类层次结构示例。 选择超级类任何“Exception”子类都可以用作“LinkedListException”的父类。然而，快速阅读这些子类会发现它们是不合适的，因为它们要么过于专业化，要么与“LinkedListException”完全无关。因此，“LinkedListException”的父类应为“Exception”。 您编写的大多数小程序和应用程序都会抛出“异常”对象&#96;错误通常用于系统中严重的硬错误，例如阻止JVM运行的错误。 Note: For readable code, it’s good practice to append the string Exception to the names of all classes that inherit (directly or indirectly) from the Exception class.","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"异常","slug":"异常","permalink":"https://guoshunfa.com/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"Oracle Java注解","slug":"软件开发/技术/编程语言/java/Oracle-Java注解","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2020/07/Oracle-Java注解/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/annotations/index.html 注解是元数据的一种形式，它提供关于程序的数据，而不是程序本身的一部分。注释对它们所注解的代码的操作没有直接影响。 注解有多种用途，其中包括： 编译器信息 — 编译器可以使用注解来检测错误或抑制警告。 编译时和部署时处理 — 软件工具可以处理注解信息以生成代码、XML文件等。 运行时处理 — 某些注解可在运行时检查。 注解基础注解的格式在最简单的形式中，注释如下所示： 1@Entity at符号字符（@）向编译器表示后面是注释。在以下示例中，注释的名称为“覆盖”： 12@Overridevoid mySuperMethod() &#123; ... &#125; 注释可以包括可以命名或未命名的元素，这些元素有值： 12345@Author( name = &quot;Benjamin Franklin&quot;, date = &quot;3/27/2003&quot;)class MyClass &#123; ... &#125; 或者 12@SuppressWarnings(value = &quot;unchecked&quot;)void myMethod() &#123; ... &#125; 如果只有一个名为value的元素，则可以省略该名称，如： 12@SuppressWarnings(&quot;unchecked&quot;)void myMethod() &#123; ... &#125; 如果注释没有元素，则可以省略括号，如前面的@Override示例所示。 也可以在同一声明上使用多个注释： 123@Author(name = &quot;Jane Doe&quot;)@EBookclass MyClass &#123; ... &#125; 如果注释具有相同的类型，则称为重复注释： 123@Author(name = &quot;Jane Doe&quot;)@Author(name = &quot;John Smith&quot;)class MyClass &#123; ... &#125; 自Java SE 8发行版起，支持重复注释。有关详细信息，请参见Repeating Annotations.。 注释类型可以是在java中定义的类型之一。lang或java.lang.annotation包。在前面的示例中，Override和SuppressWarnings是预定义的Java注释。也可以定义自己的注释类型。上一个示例中的Author和Ebook注释是自定义注释类型。 可以使用注释的位置注释可以应用于声明：类、字段、方法和其他程序元素的声明。在声明中使用时，按照惯例，每个注释通常显示在自己的行上。 从JavaSE8版本开始，注释也可以应用于类型的使用。以下是一些示例： 类实例创建表达式： 1new @Interned MyObject(); 类型铸造: 1myString = (@NonNull String) str; implements子句： 12class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; &#123; ... &#125; 引发异常声明： 12void monitorTemperature() throws @Critical TemperatureException &#123; ... &#125; 这种形式的注释称为类型注释。有关详细信息，请参见 Type Annotations and Pluggable Type Systems.。 声明批注类型许多注释替换代码中的注释。 假设一个软件组传统上以提供重要信息的注释开始每个类的主体： 123456789101112public class Generation3List extends Generation2List &#123; // Author: John Doe // Date: 3/17/2002 // Current revision: 6 // Last modified: 4/12/2004 // By: Jane Doe // Reviewers: Alice, Bill, Cindy // class code goes here&#125; 若要将此相同的元数据与注释一起添加，必须首先定义注释类型。执行此操作的语法为： 123456789@interface ClassPreamble &#123; String author(); String date(); int currentRevision() default 1; String lastModified() default &quot;N/A&quot;; String lastModifiedBy() default &quot;N/A&quot;; // Note use of array String[] reviewers();&#125; 注释类型定义看起来类似于一个接口定义，其中关键字接口前面有at符号（@）（@&#x3D;at，如注释类型）。注释类型是一种界面形式，将在后面的课程中介绍。目前，您不需要了解接口。 前一个注释定义的主体包含注释类型元素声明，看起来很像方法。请注意，它们可以定义可选的默认值。 定义注释类型后，可以使用该类型的注释，并填充值，如下所示： 1234567891011121314@ClassPreamble ( author = &quot;John Doe&quot;, date = &quot;3/17/2002&quot;, currentRevision = 6, lastModified = &quot;4/12/2004&quot;, lastModifiedBy = &quot;Jane Doe&quot;, // Note array notation reviewers = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;&#125;)public class Generation3List extends Generation2List &#123;// class code goes here&#125; &#x3D;&#x3D;注意：要使@ClassPreamble中的信息显示在Javadoc生成的文档中，必须使用@Documented注释注释@ClassPremable定义：&#x3D;&#x3D; 123456789// import this to use @Documentedimport java.lang.annotation.*;@Documented@interface ClassPreamble &#123; // Annotation element definitions &#125; 预定义的注释类型Java SE API中预定义了一组注释类型。一些注释类型由Java编译器使用，有些则适用于其他注释。 Java语言使用的注释类型在java中定义的预定义注释类型。lang是@Deprecated、@Override和@SuppressWarnings。 @Deprecated 注释表示标记的元素已弃用，不应再使用。每当程序使用带有@Deprecated注释的方法、类或字段时，编译器都会生成警告。当元素被弃用时，还应使用Javadoc@deprecated标记对其进行记录，如下例所示。在Javadoc注释和注释中使用at符号（@）并非巧合：它们在概念上是相关的。此外，请注意，Javadoc标记以小写d开头，注释以大写d开头。 12345678 // Javadoc comment follows /** * @deprecated * explanation of why it was deprecated */ @Deprecated static void deprecatedMethod() &#123; &#125;&#125; @Override 注释通知编译器该元素将覆盖在超类中声明的元素。重写方法将在接口和继承中讨论。 1234// mark method as a superclass method// that has been overridden@Override int overriddenMethod() &#123; &#125; 虽然重写方法时不需要使用此注释，但它有助于防止错误。如果标记为@Override的方法未能正确覆盖其超类之一中的方法，编译器将生成错误。 @SuppressWarnings 注释告诉编译器抑制否则将生成的特定警告。在以下示例中，使用了不推荐使用的方法，编译器通常会生成警告。但是，在这种情况下，注释会导致警告被抑制。 12345678// use a deprecated method and tell // compiler not to generate a warning@SuppressWarnings(&quot;deprecation&quot;) void useDeprecatedMethod() &#123; // deprecation warning // - suppressed objectOne.deprecatedMethod(); &#125; 每个编译器警告都属于一个类别。Java语言规范列出了两个类别：弃用和未选中。当与泛型出现之前编写的遗留代码交互时，可能会出现未经检查的警告。要抑制多个类别的警告，请使用以下语法： 1@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;) @SafeVarargs注释应用于方法或构造函数时，断言代码不会对其varargs参数执行潜在的不安全操作。使用此注释类型时，将禁止与varargs用法相关的未选中警告。 @FunctionalInterface @JavaSE8中引入的，类型声明旨在成为Java语言规范定义的功能接口。 应用于其他注释的注释应用于其他注释的注释称为元注释。java.lang.annotation中定义了几种元注释类型。 @Retention 注释指定如何存储标记的注释： RetentionPolicy.SOURCE – 标记的注释仅保留在源级别，编译器将忽略它。 RetentionPolicy.CLASS – 标记的注释在编译时由编译器保留，但被Java虚拟机（JVM）忽略。 RetentionPolicy.RUNTIME – 标记的注释由JVM保留，因此可以由运行时环境使用。 @Documented annotation表示无论何时使用指定的注释，都应该使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅Javadoc tools page.。 @Target annotation标记另一个注释，以限制注释可以应用于哪种Java元素。目标注释指定以下元素类型之一作为其值： ElementType.ANNOTATION_TYPE 可以应用于注释类型。 ElementType.CONSTRUCTOR 可以应用于构造函数。 ElementType.FIELD 可以应用于字段或属性。 ElementType.LOCAL_VARIABLE 可以应用于局部变量。 ElementType.METHOD 可以应用于方法级注释。 ElementType.PACKAGE 可以应用于包声明。 ElementType.PARAMETER 可以应用于方法的参数。 ElementType.TYPE 可以应用于类的任何元素。 @Inherited annotation表示注释类型可以从超类继承。（默认情况下，这不是真的。）当用户查询注释类型并且类没有该类型的注释时，将查询类的超类以获取注释类型。此注释仅适用于类声明。 @Repeatable annotation, Java SE 8中引入的标记注释表示标记注释可以多次应用于同一声明或类型使用。关于更多信息， see Repeating Annotations. 类型注释和可插拔类型系统在JavaSE8发布之前，注释只能应用于声明。从Java SE 8版本开始，注释也可以应用于任何类型的使用。这意味着可以在使用类型的任何地方使用注释。使用类型的几个例子是类实例创建表达式（“new”）、强制转换、“implements”子句和“throws”子句。这种形式的注释称为类型注释 Annotations Basics. 创建类型注释是为了支持改进的Java程序分析，以确保更强的类型检查。Java SE 8发行版不提供类型检查框架，但它允许您编写（或下载）一个类型检查框架。 例如，您希望确保程序中的特定变量永远不会赋值为null；您希望避免触发“NullPointerException”。您可以编写一个自定义插件来检查这一点。然后，您将修改代码以注释该特定变量，表明它从未赋值为null。变量声明可能如下所示： 1@NonNull String str; 当您编译代码时，包括命令行中的“NonNull”模块，如果编译器检测到潜在问题，就会打印警告，允许您修改代码以避免错误。更正代码以删除所有警告后，程序运行时不会发生此特定错误。 您可以使用多个类型检查模块，其中每个模块检查不同类型的错误。通过这种方式，您可以在Java类型系统的基础上进行构建，在需要的时间和位置添加特定的检查。 通过明智地使用类型注释和可插入类型检查器，您可以编写更强大、更不容易出错的代码。 在许多情况下，您不必编写自己的类型检查模块。有第三方为您完成了这项工作。例如，您可能希望利用华盛顿大学创建的Checker框架。该框架包括“NonNull”模块、正则表达式模块和互斥锁模块。关于更多信息， see the Checker Framework. 重复注释在某些情况下，您希望将相同的注释应用于声明或类型使用。从Java SE 8版本开始，重复注释使您能够做到这一点。 例如，您正在编写代码以使用计时器服务，该服务使您能够在给定时间或按特定计划运行方法，类似于UNIX“cron”服务。现在，您要设置一个计时器，以在每月的最后一天和每周五晚上11:00运行一个方法“doPeriodCleanup”。若要设置计时器，请创建一个“@Schedule”注释，并将其应用于“doPeriodicCleanup”方法两次。第一次使用指定一个月的最后一天，第二次使用指定星期五晚上11点，如以下代码示例所示： 123@Schedule(dayOfMonth=&quot;last&quot;)@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)public void doPeriodicCleanup() &#123; ... &#125; 上一个示例将注释应用于方法。可以在使用标准注释的任何位置重复注释。例如，您有一个用于处理未授权访问异常的类。您为管理者和管理员分别使用一个“@Alert”注释来注释类： 123@Alert(role=&quot;Manager&quot;)@Alert(role=&quot;Administrator&quot;)public class UnauthorizedAccessException extends SecurityException &#123; ... &#125; 出于兼容性原因，重复注释存储在Java编译器自动生成的容器注释中。为了让编译器执行此操作，代码中需要两个声明。 Step 1: 声明可重复注释类型批注类型必须标记为“@Repeatable”元批注。以下示例定义了自定义的“@Schedule”可重复注释类型： 12345678import java.lang.annotation.Repeatable;@Repeatable(Schedules.class)public @interface Schedule &#123; String dayOfMonth() default &quot;first&quot;; String dayOfWeek() default &quot;Mon&quot;; int hour() default 12;&#125; 括号中的“@Repeatable”元注释的值是Java编译器为存储重复注释而生成的容器注释的类型。在此示例中，包含的批注类型为“Schedules”，因此重复的“@Schedule”批注存储在“@Schedules”批注中。 将同一注释应用于声明而不首先声明它是可重复的，将导致编译时错误。 Step 2: 声明包含批注类型包含批注类型必须具有数组类型的“value”元素。数组类型的组件类型必须是可重复的注释类型。包含注释类型的“Schedules”的声明如下： 123public @interface Schedules &#123; Schedule[] value();&#125; 正在检索批注反射API中有几种方法可用于检索注释。返回单个注释的方法的行为，如AnnotatedElement.getAnnotation（Class）是不变的，因为它们仅在存在所请求类型的一个注释时返回单个注释。如果存在多个请求类型的注释，则可以通过首先获取它们的容器注释来获取它们。这样，遗留代码继续工作。JavaSE8中引入了其他方法，可以扫描容器注释以同时返回多个注释，例如AnnotatedElement.getAnnotationsByType（Class）。参见AnnotatedElement有关所有可用方法的信息的类规范。 设计注意事项设计注释类型时，必须考虑该类型注释的基数。现在可以零次、一次或多次使用注释，如果注释的类型标记为“@Repeatable”。还可以通过使用“@Target”元注释来限制可以使用注释类型的位置。例如，您可以创建只能用于方法和字段的可重复注释类型。仔细设计注释类型非常重要，以确保程序员使用注释时发现它尽可能灵活和强大。","categories":[{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]},{"title":"Oracle Java接口和继承","slug":"软件开发/技术/编程语言/java/Oracle-Java接口和继承","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.282Z","comments":true,"path":"2020/07/Oracle-Java接口和继承/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/IandI/index.html 接口在软件工程中，有很多情况下，不同的程序员群体必须同意一份“合同”，说明他们的软件如何交互。每个组都应该能够在不知道其他组的代码是如何编写的情况下编写自己的代码。一般来说，接口就是这样的合同。 例如，想象一个未来社会，计算机控制的机器人汽车在无人驾驶的情况下通过城市街道运送乘客。汽车制造商编写的软件（当然是Java）可以操作汽车停止、启动、加速、左转等等。另一个工业集团，电子导航仪器制造商，制造计算机系统，接收GPS（全球定位系统）位置数据和交通状况的无线传输，并使用这些信息驾驶汽车。 汽车制造商必须发布一个行业标准界面，详细说明可以调用哪些方法来使汽车移动（任何汽车，任何制造商的）。然后，指南制造商可以编写软件，调用界面中描述的方法来命令汽车。两个工业集团都不需要知道另一个集团的软件是如何实现的。事实上，每个小组都认为自己的软件是高度专有的，并保留随时修改它的权利，只要它继续遵守发布的界面。 Java中的接口在Java编程语言中，接口是一种引用类型，类似于类，它只能包含常量、方法签名、默认方法、静态方法和嵌套类型。方法体仅存在于默认方法和静态方法。接口不能实例化，它们只能由类实现或由其他接口扩展。本课稍后将讨论扩展。 定义接口类似于创建新类： 1234567891011121314151617181920212223public interface OperateCar &#123; // 常量声明（如果有） // 方法签名 // An enum with values RIGHT, LEFT int turn(Direction direction, double radius, double startSpeed, double endSpeed); int changeLanes(Direction direction, double startSpeed, double endSpeed); int signalTurn(Direction direction, boolean signalOn); int getRadarFront(double distanceToCar, double speedOfCar); int getRadarRear(double distanceToCar, double speedOfCar); ...... // more method signatures&#125; 请注意，方法签名没有大括号，并以分号结尾。 要使用接口，您需要编写一个实现接口的类。当可实例化类实现接口时，它为接口中声明的每个方法提供方法体。例如 1234567891011121314public class OperateBMW760i implements OperateCar &#123; // the OperateCar method signatures, with implementation -- // for example: public int signalTurn(Direction direction, boolean signalOn) &#123; // code to turn BMW&#x27;s LEFT turn indicator lights on // code to turn BMW&#x27;s LEFT turn indicator lights off // code to turn BMW&#x27;s RIGHT turn indicator lights on // code to turn BMW&#x27;s RIGHT turn indicator lights off &#125; // other members, as needed -- for example, helper classes not // visible to clients of the interface&#125; 在上面的机器人汽车示例中，将由汽车制造商来实现接口。当然，雪佛兰的实施方式将与丰田的实施方式大不相同，但两家制造商都将遵循相同的界面。作为该接口的客户，导航制造商将构建使用汽车位置GPS数据、数字街道地图和交通数据驾驶汽车的系统。这样，制导系统将调用接口方法：转弯、变道、刹车、加速等。 接口作为API机器人汽车示例显示了用作行业标准的接口应用程序编程接口（API）。API在商业软件产品中也很常见。通常，一家公司销售的软件包包含另一家公司希望在自己的软件产品中使用的复杂方法。一个例子是向制作最终用户图形程序的公司出售的一套数字图像处理方法。这家图像处理公司编写类来实现一个接口，并将其公开给客户。然后，图形公司使用接口中定义的签名和返回类型调用图像处理方法。虽然图像处理公司的API公开（向其客户），但其API的实现被严格保密。事实上，只要它继续实现其客户所依赖的原始接口，它可能会在稍后修改实现。 定义接口接口声明由修饰符、关键字“interface”、接口名称、以逗号分隔的父接口列表（如果有）和接口主体组成。例如： 1234567891011public interface GroupedInterface extends Interface1, Interface2, Interface3 &#123; // 常量声明 // base of natural logarithms double E = 2.718282; // method signatures void doSomething (int i, double x); int doSomethingElse(String s);&#125; “public”访问说明符表示接口可以由任何包中的任何类使用。如果未指定接口是公共的，则只有在与接口相同的包中定义的类才能访问接口。 一个接口可以扩展其他接口，就像一个类子类或扩展另一个类一样。然而，虽然一个类只能扩展另一个类，但是一个接口可以扩展任意数量的接口。接口声明包括一个以逗号分隔的列表，其中列出了它所扩展的所有接口。 接口主体接口主体可以包含抽象方法，默认方法，和静态方法. 接口中的抽象方法后面是分号，但没有大括号（抽象方法不包含实现）。默认方法使用“Default”修饰符定义，静态方法使用“static”关键字定义。接口中的所有抽象、默认和静态方法都是隐式的“public”，因此可以省略“public”修饰符。 此外，接口可以包含常量声明。接口中定义的所有常量值都隐式为“public”、“static”和“final”。同样，可以省略这些修改器。 实现接口要声明实现接口的类，请在类声明中包含“implements”子句。您的类可以实现多个接口，因此“implements”关键字后面是该类实现的接口的逗号分隔列表。按照惯例，如果“extends”子句后面有“implements”子句，则“implement”子句在后面。 示例界面，可关联考虑一个定义如何比较对象大小的接口。 123456789public interface Relatable &#123; // this (object calling isLargerThan) // and other must be instances of // the same class returns 1, 0, -1 // if this is greater than, // equal to, or less than other public int isLargerThan(Relatable other);&#125; 如果您希望能够比较类似对象的大小，无论它们是什么，实例化它们的类都应该实现“Relatable”。 如果有某种方法可以比较从类实例化的对象的相对“大小”，则任何类都可以实现“Relatable”。对于字符串，它可以是字符数；对于书籍，可以是页数；对学生来说，可能是体重；等等对于平面几何对象，面积将是一个很好的选择（请参见下面的“RectanglePlus”类），而体积将适用于三维几何对象。所有此类类都可以实现“isLargerThan（）”方法。 如果您知道一个类实现了“Relatable”，那么您就可以比较从该类实例化的对象的大小。 实现相关接口这是Creating Objects中显示的“Rectangle”类部分，重写为实现“Relatable”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RectanglePlus implements Relatable &#123; public int width = 0; public int height = 0; public Point origin; // four constructors public RectanglePlus() &#123; origin = new Point(0, 0); &#125; public RectanglePlus(Point p) &#123; origin = p; &#125; public RectanglePlus(int w, int h) &#123; origin = new Point(0, 0); width = w; height = h; &#125; public RectanglePlus(Point p, int w, int h) &#123; origin = p; width = w; height = h; &#125; // a method for moving the rectangle public void move(int x, int y) &#123; origin.x = x; origin.y = y; &#125; // a method for computing // the area of the rectangle public int getArea() &#123; return width * height; &#125; // a method required to implement // the Relatable interface public int isLargerThan(Relatable other) &#123; RectanglePlus otherRect = (RectanglePlus)other; if (this.getArea() &lt; otherRect.getArea()) return -1; else if (this.getArea() &gt; otherRect.getArea()) return 1; else return 0; &#125;&#125; 由于“RectanglePlus”实现了“Relatable”，因此可以比较任意两个“Rectangle Plus”对象的大小。 Note: 在“Relatable”接口中定义的“isLargerThan”方法接受类型为“Relatable”的对象。在上一个示例中以粗体显示的代码行将“other”强制转换为“RectanglePlus”实例。类型转换告诉编译器对象的真正含义。直接在“other”实例（“other.getArea()”）上调用“getArea”将无法编译，因为编译器不知道“other”实际上是“RectanglePlus”的实例。 使用接口作为类型定义新接口时，即定义了新的引用数据类型。您可以在任何可以使用任何其他数据类型名称的地方使用接口名称。如果定义的引用变量的类型是接口，则分配给它的任何对象必须是实现接口的类的实例。 例如，对于从实现“Relatable”的类实例化的任何对象，这里有一个查找一对对象中最大对象的方法： 12345678public Object findLargest(Object object1, Object object2) &#123; Relatable obj1 = (Relatable)object1; Relatable obj2 = (Relatable)object2; if ((obj1).isLargerThan(obj2) &gt; 0) return object1; else return object2;&#125; 通过将“object1”转换为“Relatable”类型，它可以调用“isLargerThan”方法。 如果要在各种各样的类中实现“Relatable”，那么可以将从这些类中的任意实例化的对象与“findLargest（）”方法进行比较，前提是这两个对象都属于同一类。同样，它们都可以与以下方法进行比较： 1234567891011121314151617public Object findSmallest(Object object1, Object object2) &#123; Relatable obj1 = (Relatable)object1; Relatable obj2 = (Relatable)object2; if ((obj1).isLargerThan(obj2) &lt; 0) return object1; else return object2;&#125;public boolean isEqual(Object object1, Object object2) &#123; Relatable obj1 = (Relatable)object1; Relatable obj2 = (Relatable)object2; if ( (obj1).isLargerThan(obj2) == 0) return true; else return false;&#125; 这些方法适用于任何“相关”对象，无论其类继承是什么。当它们实现“相关”时，它们既可以是自己的类（或超类）类型，也可以是“相关”类型。这为它们提供了多重继承的一些优点，它们可以同时从超类和接口获得行为。 不断发展的接口考虑您开发的一个名为 DoIt: 1234public interface DoIt &#123; void doSomething(int i, double x); int doSomethingElse(String s);&#125; 假设稍后要向“DoIt”添加第三个方法，这样接口现在就变成： 1234567public interface DoIt &#123; void doSomething(int i, double x); int doSomethingElse(String s); boolean didItWork(int i, double x, String s); &#125; 如果进行此更改，则实现旧“DoIt”接口的所有类都将中断，因为它们不再实现旧接口。依赖这个接口的程序员会大声抗议。 尝试预测接口的所有用途，并从一开始就完全指定它。如果要向接口添加其他方法，可以有几个选项。您可以创建一个扩展“DoIt”的“DoItPlus”接口： 12345public interface DoItPlus extends DoIt &#123; boolean didItWork(int i, double x, String s); &#125; 现在，代码的用户可以选择继续使用旧界面或升级到新界面。 或者，您可以将新方法定义为默认方法. 以下示例定义了名为“didItWork”的默认方法： 123456789public interface DoIt &#123; void doSomething(int i, double x); int doSomethingElse(String s); default boolean didItWork(int i, double x, String s) &#123; // Method body &#125; &#125; 注意，必须为默认方法提供实现。您还可以定义新的静态方法到现有接口。拥有实现用新的默认或静态方法增强的接口的类的用户不必修改或重新编译它们以适应其他方法。 默认方法接口部分描述了一个涉及计算机控制汽车制造商的示例，这些制造商发布了行业标准接口，这些接口描述了可以调用哪些方法来操作他们的汽车。如果那些计算机控制的汽车制造商为他们的汽车增加了新的功能，比如飞行，会怎么样？这些制造商需要指定新的方法，以使其他公司（如电子制导仪器制造商）能够使其软件适应飞行汽车。这些汽车制造商将在哪里宣布这些与飞行相关的新方法？如果他们将它们添加到原始接口中，那么实现了这些接口的程序员将不得不重写其实现。如果他们将它们添加为静态方法，那么程序员会将它们视为实用方法，而不是必要的核心方法。 默认方法使您能够向库的接口添加新功能，并确保与为这些接口的旧版本编写的代码的二进制兼容性。 考虑以下接口TimeClient，如问题和练习答案：界面中所述: 123456789import java.time.*; public interface TimeClient &#123; void setTime(int hour, int minute, int second); void setDate(int day, int month, int year); void setDateAndTime(int day, int month, int year, int hour, int minute, int second); LocalDateTime getLocalDateTime();&#125; 以下类SimpleTimeClient，实现“TimeClient”： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package defaultmethods;import java.time.*;import java.lang.*;import java.util.*;public class SimpleTimeClient implements TimeClient &#123; private LocalDateTime dateAndTime; public SimpleTimeClient() &#123; dateAndTime = LocalDateTime.now(); &#125; public void setTime(int hour, int minute, int second) &#123; LocalDate currentDate = LocalDate.from(dateAndTime); LocalTime timeToSet = LocalTime.of(hour, minute, second); dateAndTime = LocalDateTime.of(currentDate, timeToSet); &#125; public void setDate(int day, int month, int year) &#123; LocalDate dateToSet = LocalDate.of(day, month, year); LocalTime currentTime = LocalTime.from(dateAndTime); dateAndTime = LocalDateTime.of(dateToSet, currentTime); &#125; public void setDateAndTime(int day, int month, int year, int hour, int minute, int second) &#123; LocalDate dateToSet = LocalDate.of(day, month, year); LocalTime timeToSet = LocalTime.of(hour, minute, second); dateAndTime = LocalDateTime.of(dateToSet, timeToSet); &#125; public LocalDateTime getLocalDateTime() &#123; return dateAndTime; &#125; public String toString() &#123; return dateAndTime.toString(); &#125; public static void main(String... args) &#123; TimeClient myTimeClient = new SimpleTimeClient(); System.out.println(myTimeClient.toString()); &#125;&#125; 假设您希望向“TimeClient”接口添加新功能，例如通过ZonedDateTime指定时区的功能对象（类似于LocalDateTime对象，除了它存储时区信息）： 12345678public interface TimeClient &#123; void setTime(int hour, int minute, int second); void setDate(int day, int month, int year); void setDateAndTime(int day, int month, int year, int hour, int minute, int second); LocalDateTime getLocalDateTime(); ZonedDateTime getZonedDateTime(String zoneString);&#125; 对“TimeClient”接口进行修改后，还必须修改类“SimpleTimeClient”并实现方法“getZonedDateTime”。但是，您可以定义一个默认实现，而不是将“getZonedDateTime”保留为“abstract”（如前一个示例所示）。（记住抽象方法是没有实现的声明方法。） 12345678910111213141516171819202122232425package defaultmethods; import java.time.*;public interface TimeClient &#123; void setTime(int hour, int minute, int second); void setDate(int day, int month, int year); void setDateAndTime(int day, int month, int year, int hour, int minute, int second); LocalDateTime getLocalDateTime(); static ZoneId getZoneId (String zoneString) &#123; try &#123; return ZoneId.of(zoneString); &#125; catch (DateTimeException e) &#123; System.err.println(&quot;Invalid time zone: &quot; + zoneString + &quot;; using default time zone instead.&quot;); return ZoneId.systemDefault(); &#125; &#125; default ZonedDateTime getZonedDateTime(String zoneString) &#123; return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString)); &#125;&#125; 您可以指定接口中的方法定义是默认方法，方法签名开头带有“default”关键字。接口中的所有方法声明（包括默认方法）都隐式为“public”，因此可以省略“public”修饰符。 使用此接口，您不必修改类“SimpleTimeClient”，并且该类（以及实现接口“TimeClient”的任何类）将具有已定义的方法“getZonedDateTime”。以下示例TestSimpleTimeClient，从“SimpleTimeClient”实例调用方法“getZonedDateTime”： 1234567891011121314package defaultmethods; import java.time.*;import java.lang.*;import java.util.*;public class TestSimpleTimeClient &#123; public static void main(String... args) &#123; TimeClient myTimeClient = new SimpleTimeClient(); System.out.println(&quot;Current time: &quot; + myTimeClient.toString()); System.out.println(&quot;Time in California: &quot; + myTimeClient.getZonedDateTime(&quot;Blah blah&quot;).toString()); &#125;&#125; 扩展包含默认方法的接口扩展包含默认方法的接口时，可以执行以下操作： 根本不用提默认方法，它允许扩展接口继承默认方法。 重新声明默认方法，使其成为“抽象”。 重新定义默认方法，该方法将覆盖该方法。 假设您按如下方式扩展接口“TimeClient”： 1public interface AnotherTimeClient extends TimeClient &#123; &#125; 实现接口“AnotherTimeClient”的任何类都将具有默认方法“TimeClient.getZonedDateTime”指定的实现。 假设您按如下方式扩展接口“TimeClient”： 123public interface AbstractZoneTimeClient extends TimeClient &#123; public ZonedDateTime getZonedDateTime(String zoneString);&#125; 实现接口“AbstractZoneTimeClient”的任何类都必须实现方法“getZonedDateTime”；与接口中的所有其他非默认（和非静态）方法一样，该方法是一个“抽象”方法。 假设您按如下方式扩展接口“TimeClient”： 1234567891011public interface HandleInvalidTimeZoneClient extends TimeClient &#123; default public ZonedDateTime getZonedDateTime(String zoneString) &#123; try &#123; return ZonedDateTime.of(getLocalDateTime(),ZoneId.of(zoneString)); &#125; catch (DateTimeException e) &#123; System.err.println(&quot;Invalid zone ID: &quot; + zoneString + &quot;; using the default time zone instead.&quot;); return ZonedDateTime.of(getLocalDateTime(),ZoneId.systemDefault()); &#125; &#125;&#125; 实现接口“HandleInvalidTimeZoneClient”的任何类都将使用此接口指定的“getZonedDateTime”实现，而不是接口“TimeClient”指定的实现。 静态方法除了默认方法，您还可以定义静态方法在接口中。（静态方法是一种与定义它的类关联的方法，而不是与任何对象关联的方法。该类的每个实例都共享其静态方法。）这使您更容易在库中组织助手方法；您可以在同一个接口中而不是在单独的类中保持特定于接口的静态方法。以下示例定义了一个静态方法，该方法检索ZoneId与时区标识符相对应的对象；如果没有对应于给定标识符的“ZoneId”对象，则使用系统默认时区。（因此，您可以简化方法getZonedDateTime）： 12345678910111213141516public interface TimeClient &#123; // ... static public ZoneId getZoneId (String zoneString) &#123; try &#123; return ZoneId.of(zoneString); &#125; catch (DateTimeException e) &#123; System.err.println(&quot;Invalid time zone: &quot; + zoneString + &quot;; using default time zone instead.&quot;); return ZoneId.systemDefault(); &#125; &#125; default public ZonedDateTime getZonedDateTime(String zoneString) &#123; return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString)); &#125; &#125; 与类中的静态方法一样，您指定接口中的方法定义是静态方法，方法签名开头带有“static”关键字。接口中的所有方法声明（包括静态方法）都隐式为“public”，因此可以省略“public”修饰符。 将默认方法集成到现有库中默认方法使您能够向现有接口添加新功能，并确保与为这些接口的旧版本编写的代码的二进制兼容性。特别是，默认方法允许您向现有接口添加接受lambda表达式作为参数的方法。本节演示Comparator接口已通过默认和静态方法进行了增强。 考虑问题和练习：课程中所述的“卡片”和“套牌”课程. 此示例重写Card和Deck类作为接口。“Card”接口包含两种“enum”类型（“Suit”和“Rank”）和两种抽象方法（“getSuit”与“getRank””）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package defaultmethods;public interface Card extends Comparable&lt;Card&gt; &#123; public enum Suit &#123; DIAMONDS (1, &quot;Diamonds&quot;), CLUBS (2, &quot;Clubs&quot; ), HEARTS (3, &quot;Hearts&quot; ), SPADES (4, &quot;Spades&quot; ); private final int value; private final String text; Suit(int value, String text) &#123; this.value = value; this.text = text; &#125; public int value() &#123;return value;&#125; public String text() &#123;return text;&#125; &#125; public enum Rank &#123; DEUCE (2 , &quot;Two&quot; ), THREE (3 , &quot;Three&quot;), FOUR (4 , &quot;Four&quot; ), FIVE (5 , &quot;Five&quot; ), SIX (6 , &quot;Six&quot; ), SEVEN (7 , &quot;Seven&quot;), EIGHT (8 , &quot;Eight&quot;), NINE (9 , &quot;Nine&quot; ), TEN (10, &quot;Ten&quot; ), JACK (11, &quot;Jack&quot; ), QUEEN (12, &quot;Queen&quot;), KING (13, &quot;King&quot; ), ACE (14, &quot;Ace&quot; ); private final int value; private final String text; Rank(int value, String text) &#123; this.value = value; this.text = text; &#125; public int value() &#123;return value;&#125; public String text() &#123;return text;&#125; &#125; public Card.Suit getSuit(); public Card.Rank getRank();&#125; “卡片组”界面包含操纵卡片组中卡片的各种方法： 1234567891011121314151617181920212223package defaultmethods; import java.util.*;import java.util.stream.*;import java.lang.*; public interface Deck &#123; List&lt;Card&gt; getCards(); Deck deckFactory(); int size(); void addCard(Card card); void addCards(List&lt;Card&gt; cards); void addDeck(Deck deck); void shuffle(); void sort(); void sort(Comparator&lt;Card&gt; c); String deckToString(); Map&lt;Integer, Deck&gt; deal(int players, int numberOfCards) throws IllegalArgumentException;&#125; 类PlayingCard实现接口“Card”和类StandardDeck实现接口“Deck”。 类“StandardDeck”实现抽象方法“Deck”。排序如下： 123456789101112public class StandardDeck implements Deck &#123; private List&lt;Card&gt; entireDeck; // ... public void sort() &#123; Collections.sort(entireDeck); &#125; // ...&#125; 方法Collections.sort对元素类型实现接口Comparable的List实例进行排序. 成员“entireDeck”是“List”的一个实例，其元素类型为“Card”，扩展了“Comparable”。类“PlayingCard”实现了Comparable.compareTo方法如下： 1234567public int hashCode() &#123; return ((suit.value()-1)*13)+rank.value();&#125;public int compareTo(Card o) &#123; return this.hashCode() - o.hashCode();&#125; 方法“compareTo”导致方法StandardDeck.sort()先按花色排序，然后按等级排序。 如果你想先按等级排序，然后按套装排序，该怎么办？您需要实现Comparator接口指定新的排序条件，并使用方法排序（List List，Comparator c）（包含“Comparator”参数的“sort”方法的版本）。您可以在类“StandardDeck”中定义以下方法： 123public void sort(Comparator&lt;Card&gt; c) &#123; Collections.sort(entireDeck, c);&#125; 使用此方法，可以指定方法Collections的方式。sort对Card类的实例进行排序。实现这一点的一种方法是实现“Comparator”接口，以指定您希望卡片如何排序。示例SortByRankTheSubit 这样做： 12345678910111213141516package defaultmethods;import java.util.*;import java.util.stream.*;import java.lang.*;public class SortByRankThenSuit implements Comparator&lt;Card&gt; &#123; public int compare(Card firstCard, Card secondCard) &#123; int compVal = firstCard.getRank().value() - secondCard.getRank().value(); if (compVal != 0) return compVal; else return firstCard.getSuit().value() - secondCard.getSuit().value(); &#125;&#125; 下面的调用首先按等级排序扑克牌，然后按花色排序： 123StandardDeck myDeck = new StandardDeck();myDeck.shuffle();myDeck.sort(new SortByRankThenSuit()); 然而，这种方法过于冗长；如果只指定排序条件并避免创建多个排序实现，那会更好。假设您是编写“Comparator”接口的开发人员。您可以向“Comparator”接口添加哪些默认或静态方法，以使其他开发人员能够更容易地指定排序标准？ 首先，假设您希望按等级对扑克牌进行排序，而不考虑花色。您可以调用StandardDeck.sort方法如下： 123456StandardDeck myDeck = new StandardDeck();myDeck.shuffle();myDeck.sort( (firstCard, secondCard) -&gt; firstCard.getRank().value() - secondCard.getRank().value()); 因为接口“Comparator”是功能接口，可以使用lambda表达式作为“sort”方法的参数。在此示例中，lambda表达式比较两个整数值。 如果您的开发人员可以通过调用方法“Card”来创建“Comparator”实例，则会更简单。getRank&#96;仅限。特别是，如果您的开发人员可以创建一个“Comparator”实例来比较可以从“getValue”或“hashCode”等方法返回数值的任何对象，这将非常有用。“Comparator”接口已通过静态方法“comparating”增强了此功能： 1myDeck.sort(Comparator.comparing((card) -&gt; card.getRank())); 在此示例中，可以使用方法引用而是： 1myDeck.sort(Comparator.comparing(Card::getRank)); 此调用更好地演示了如何指定不同的排序标准，避免创建多个排序实现。 “Comparator”接口已通过静态方法“comparising”的其他版本（如comparisingDouble）进行了增强和comparingLong，使您能够创建比较其他数据类型的“Comparator”实例。 假设您的开发人员希望创建一个“Comparator”实例，该实例可以将对象与多个条件进行比较。例如，你会如何先按等级，然后按花色对扑克牌进行排序？与之前一样，您可以使用lambda表达式来指定这些排序条件： 123456789101112StandardDeck myDeck = new StandardDeck();myDeck.shuffle();myDeck.sort( (firstCard, secondCard) -&gt; &#123; int compare = firstCard.getRank().value() - secondCard.getRank().value(); if (compare != 0) return compare; else return firstCard.getSuit().value() - secondCard.getSuit().value(); &#125; ); 如果您的开发人员可以从一系列“Comparator”实例中构建一个“Comparator”实例，则会更简单。“Comparator”接口已通过默认方法thenCompanying增强了此功能： 1234myDeck.sort( Comparator .comparing(Card::getRank) .thenComparing(Comparator.comparing(Card::getSuit))); “Comparator”接口已通过其他版本的默认方法“thenCompanying”（如thenComparingDouble）进行了增强和thenComparingLong，使您能够构建比较其他数据类型的“Comparator”实例。 假设您的开发人员希望创建一个“Comparator”实例，使他们能够以相反的顺序对对象集合进行排序。例如，您将如何按照排名降序对扑克牌进行排序，从A到2（而不是从2到A）？如前所述，您可以指定另一个lambda表达式。然而，如果您的开发人员可以通过调用一个方法来反转现有的“Comparator”，则会更简单。“Comparator”接口已通过默认方法[“reversed”]增强了此功能(https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#reversed--): 1234myDeck.sort( Comparator.comparing(Card::getRank) .reversed() .thenComparing(Comparator.comparing(Card::getSuit))); 此示例演示了如何使用默认方法、静态方法、lambda表达式和方法引用增强了“Comparator”接口，以创建更具表达力的库方法，程序员可以通过查看它们的调用方式快速推断其功能。使用这些构造来增强库中的接口。 接口概述接口声明可以包含方法签名，默认方法、静态方法和常量定义。唯一具有实现的方法是默认方法和静态方法。 实现接口的类必须实现接口中声明的所有方法。 可以在任何可以使用类型的地方使用接口名称。 继承在前面的课程中，您已经多次看到继承。在Java语言中，类可以从其他类派生，从而从这些类继承字段和方法。 定义：从另一个类派生的类称为子类（也称为派生类、扩展类或子类）。派生子类的类被称为超类（也是基类或父类）。 除了没有超类的“Object”之外，每个类都有并且只有一个直接超类（单一继承）。在没有任何其他显式超类的情况下，每个类都是“Object”的子类。 类可以从从类派生的类派生，以此类推，最终从最顶层的类“Object”派生。这样的类被称为继承链中所有类的“后代”，可以追溯到“Object”。 继承的思想简单但强大：当您想要创建一个新类，并且已经有一个类包含了您想要的一些代码时，您可以从现有类派生出新类。在这样做时，您可以重用现有类的字段和方法，而无需编写（和调试！）他们自己。 子类从其超类继承所有成员（字段、方法和嵌套类）。构造函数不是成员，因此它们不会被子类继承，但超类的构造函数可以从子类调用。 Java平台类层次结构对象类，在&#96;java。lang包，定义并实现所有类（包括您编写的类）通用的行为。在Java平台中，许多类直接从“Object”派生，其他类从这些类中的一些派生，依此类推，形成了类的层次结构。 Java平台中的所有类都是对象的后代 在层次结构的顶部，“Object”是所有类中最通用的。层次结构底部附近的类提供了更专门的行为。 继承的一个例子以下是“类和对象”课程中介绍的“自行车”类的可能实现示例代码： 1234567891011121314151617181920212223242526272829303132public class Bicycle &#123; // the Bicycle class has three fields public int cadence; public int gear; public int speed; // the Bicycle class has one constructor public Bicycle(int startCadence, int startSpeed, int startGear) &#123; gear = startGear; cadence = startCadence; speed = startSpeed; &#125; // the Bicycle class has four methods public void setCadence(int newValue) &#123; cadence = newValue; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public void applyBrake(int decrement) &#123; speed -= decrement; &#125; public void speedUp(int increment) &#123; speed += increment; &#125; &#125; 作为“Bicycle”子类的“MountainBike”类的类声明可能如下所示： 12345678910111213141516171819public class MountainBike extends Bicycle &#123; // the MountainBike subclass adds one field public int seatHeight; // the MountainBike subclass has one constructor public MountainBike(int startHeight, int startCadence, int startSpeed, int startGear) &#123; super(startCadence, startSpeed, startGear); seatHeight = startHeight; &#125; // the MountainBike subclass adds one method public void setHeight(int newValue) &#123; seatHeight = newValue; &#125; &#125; MountainBike继承了“Bicycle”的所有字段和方法，并添加了字段“seatHeight”和设置它的方法。除了构造函数，就好像您完全从头开始编写了一个新的“MountainBike”类，包含四个字段和五个方法。然而，你不必做所有的工作。如果“Bicycle”类中的方法很复杂并且需要大量时间进行调试，那么这将特别有价值。 在子类中可以做什么子类继承其父类的所有public和protected成员，无论子类在哪个包中。如果子类与其父类在同一个包中，它也继承父类的packageprivate成员。您可以按原样使用继承的成员、替换它们、隐藏它们或使用新成员补充它们： 继承的字段可以直接使用，就像任何其他字段一样。 您可以在子类中声明与超类中的字段同名的字段，从而隐藏它（不推荐）。 您可以在子类中声明不在超类中的新字段。 继承的方法可以直接使用。 您可以在子类中编写一个新的instance方法，该方法与超类中的方法具有相同的签名，从而覆盖它。 您可以在子类中编写一个新的static方法，该方法与超类中的方法具有相同的签名，从而将其隐藏。 您可以在子类中声明不在超类中的新方法。 您可以隐式地或通过使用关键字“super”来编写调用超类构造函数的子类构造函数。 本课程的以下部分将对这些主题进行扩展。 超级类中的私人成员子类不继承其父类的“private”成员。但是，如果超类具有用于访问其私有字段的公共或受保护的方法，则子类也可以使用这些方法。 嵌套类可以访问其封闭类的所有私有成员，包括字段和方法。因此，子类继承的公共或受保护的嵌套类可以间接访问父类的所有私有成员。 铸造对象我们已经看到一个对象是从中实例化的类的数据类型。例如，如果我们写 1public MountainBike myBike = new MountainBike(); 则“myBike”是“MountainBike”类型。 MountainBike是Bicycle和Object的后代。因此，“MountainBike”是一个“Bicycle”，也是一个“Object”，它可以在调用“Bicycles”或“Object”对象的任何地方使用。 相反的说法并不一定正确：“自行车”可能是“山地自行车”，但不一定。类似地，“对象”*可以是“自行车”或“山地自行车”，但不一定。 Casting显示了在继承和实现允许的对象中使用一种类型的对象代替另一种类型。例如，如果我们写 1Object obj = new MountainBike(); 则“obj”既是“Object”又是“MountainBike”（直到“obj’被分配给另一个不是“MountainBike”的对象）。这称为“隐式转换”。 另一方面，如果我们写 1MountainBike myBike = obj; 我们将得到一个编译时错误，因为编译器不知道“obj”是“MountainBike”。然而，我们可以告诉编译器，我们承诺通过显式转换将“MountainBike”分配给“obj”： 1MountainBike myBike = (MountainBike)obj; 此强制转换将插入一个运行时检查，检查“obj”是否被分配了“MountainBike”，以便编译器可以安全地假设“obj”是“MountainBike”。如果“obj”在运行时不是“MountainBike”，则将引发异常。 Note: 您可以使用“instanceof”运算符对特定对象的类型进行逻辑测试。这可以避免由于不正确的强制转换而导致的运行时错误。例如： 123if (obj instanceof MountainBike) &#123; MountainBike myBike = (MountainBike)obj;&#125; 在这里，“instanceof”运算符验证“obj”是否引用了“MountainBike”，以便我们可以在知道不会引发运行时异常的情况下进行强制转换。 状态、实现和类型的多重继承类和接口之间的一个重要区别是类可以有字段，而接口不能。此外，您可以实例化一个类来创建一个对象，这是使用接口无法做到的。如什么是对象？一节所述，对象将其状态存储在类中定义的字段中。Java编程语言不允许扩展多个类的一个原因是为了避免“状态的多重继承”问题，即从多个类继承字段的能力。例如，假设您能够定义一个扩展多个类的新类。当通过实例化该类创建对象时，该对象将继承该类所有超类的字段。如果来自不同超类的方法或构造函数实例化同一个字段呢？哪个方法或构造函数优先？因为接口不包含字段，所以您不必担心状态的多重继承导致的问题。 实现的多重继承是从多个类继承方法定义的能力。这种类型的多重继承会出现问题，例如名称冲突和歧义。当支持这种类型多重继承的编程语言的编译器遇到包含同名方法的超类时，它们有时无法确定要访问或调用哪个成员或方法。此外，程序员可以通过向超类添加新方法而无意中引入名称冲突。默认方法介绍一种形式的多重继承实现。一个类可以实现多个接口，这些接口可以包含同名的默认方法。Java编译器提供了一些规则来确定特定类使用的默认方法。 Java编程语言支持*类型的多重继承，这是一个类实现多个接口的能力。一个对象可以有多种类型：它自己的类的类型和该类实现的所有接口的类型。这意味着，如果变量被声明为接口的类型，那么它的值可以引用从实现接口的任何类实例化的任何对象。这在使用接口作为类型一节中进行了讨论. 与实现的多重继承一样，类可以继承在其扩展的接口中定义的方法（作为默认或静态）的不同实现。在这种情况下，编译器或用户必须决定使用哪一个。 覆盖和隐藏方法实例方法子类中的实例方法具有与超类中实例方法相同的签名（名称，加上其参数的编号和类型）和返回类型覆盖超类的方法。 子类重写方法的能力允许类从行为“足够接近”的超类继承，然后根据需要修改行为。重写方法具有与其重写的方法相同的名称、参数的数量和类型以及返回类型。重写方法还可以返回重写方法返回的类型的子类型。此子类型称为协变返回类型。 重写方法时，可能需要使用“@Override”注释，该注释指示编译器要重写超类中的方法。如果由于某种原因，编译器检测到某个超类中不存在该方法，那么它将生成错误。有关“@Override”的详细信息，请参见Annotations. 静态方法如果子类定义的静态方法与超类中的静态方法具有相同的签名，那么子类中的方法将隐藏超类中。 隐藏静态方法和重写实例方法之间的区别具有重要意义： 被调用的重写实例方法的版本是子类中的版本。 被调用的隐藏静态方法的版本取决于它是从超类还是子类调用的。 考虑一个包含两个类的示例。第一个是“Animal”，它包含一个实例方法和一个静态方法： 12345678public class Animal &#123; public static void testClassMethod() &#123; System.out.println(&quot;The static method in Animal&quot;); &#125; public void testInstanceMethod() &#123; System.out.println(&quot;The instance method in Animal&quot;); &#125;&#125; 第二类是“Animal”的子类，称为“Cat”： 123456789101112131415public class Cat extends Animal &#123; public static void testClassMethod() &#123; System.out.println(&quot;The static method in Cat&quot;); &#125; public void testInstanceMethod() &#123; System.out.println(&quot;The instance method in Cat&quot;); &#125; public static void main(String[] args) &#123; Cat myCat = new Cat(); Animal myAnimal = myCat; Animal.testClassMethod(); myAnimal.testInstanceMethod(); &#125;&#125; “Cat”类重写“Animal”中的实例方法，并隐藏“Animal”中的静态方法。此类中的“main”方法创建一个“Cat”实例，并在类上调用“testClassMethod（）”，在实例上调用“testInstanceMethod()）”。 该程序的输出如下： 12The static method in AnimalThe instance method in Cat 正如所承诺的，被调用的隐藏静态方法的版本是超类中的版本，而被调用的重写实例方法的版本则是子类中的。 接口方法默认方法和抽象方法在接口中继承类似实例方法。然而，当类或接口的超类型提供具有相同签名的多个默认方法时，Java编译器会遵循继承规则来解决名称冲突。这些规则由以下两个原则驱动： 实例方法优于接口默认方法。 考虑以下类和接口： 12345public class Horse &#123; public String identifyMyself() &#123; return &quot;I am a horse.&quot;; &#125;&#125; 12345public interface Flyer &#123; default public String identifyMyself() &#123; return &quot;I am able to fly.&quot;; &#125;&#125; 12345public interface Mythical &#123; default public String identifyMyself() &#123; return &quot;I am a mythical creature.&quot;; &#125;&#125; 123456public class Pegasus extends Horse implements Flyer, Mythical &#123; public static void main(String... args) &#123; Pegasus myApp = new Pegasus(); System.out.println(myApp.identifyMyself()); &#125;&#125; 方法Pegasus.identifyMyself返回字符串I am a horse 已被其他候选对象覆盖的方法将被忽略。当超类型共享一个共同祖先时，可能会出现这种情况。 考虑以下接口和类： 12345public interface Animal &#123; default public String identifyMyself() &#123; return &quot;I am an animal.&quot;; &#125;&#125; 12345public interface EggLayer extends Animal &#123; default public String identifyMyself() &#123; return &quot;I am able to lay eggs.&quot;; &#125;&#125; 1public interface FireBreather extends Animal &#123; &#125; 123456public class Dragon implements EggLayer, FireBreather &#123; public static void main (String... args) &#123; Dragon myApp = new Dragon(); System.out.println(myApp.identifyMyself()); &#125;&#125; 方法Dragon.identifyMyself返回字符串I am able to lay eggs. 如果两个或多个独立定义的默认方法冲突，或者默认方法与抽象方法冲突，则Java编译器会产生编译器错误。必须显式重写父类型方法。 以现在可以飞行的计算机控制汽车为例。您有两个接口（“OperaCar”和“FlyCar”），为同一方法（“startEngine”）提供默认实现： 123456789101112public interface OperateCar &#123; // ... default public int startEngine(EncryptedKey key) &#123; // Implementation &#125;&#125;public interface FlyCar &#123; // ... default public int startEngine(EncryptedKey key) &#123; // Implementation &#125;&#125; 同时实现“OperateCar”和“FlyCar”的类必须重写方法“startEngine”。您可以使用“super”关键字调用任何默认实现。 1234567public class FlyingCar implements OperateCar, FlyCar &#123; // ... public int startEngine(EncryptedKey key) &#123; FlyCar.super.startEngine(key); OperateCar.super.startEngine(key); &#125;&#125; “super”前面的名称（在本例中为“FlyCar”或“OperaCar”）必须引用定义或继承所调用方法默认值的直接超级接口。这种形式的方法调用不限于区分包含具有相同签名的默认方法的多个已实现接口。您可以使用“super”关键字在类和接口中调用默认方法。 从类继承的实例方法可以重写抽象接口方法。考虑以下接口和类： 1234567891011121314public interface Mammal &#123; String identifyMyself();&#125;public class Horse &#123; public String identifyMyself() &#123; return &quot;I am a horse.&quot;; &#125;&#125;public class Mustang extends Horse implements Mammal &#123; public static void main(String... args) &#123; Mustang myApp = new Mustang(); System.out.println(myApp.identifyMyself()); &#125;&#125; 方法Mustang。identifyMyself返回字符串“I am a horse.”类“Mustang”继承了类“Horse”中的方法“identifyMyself”，该方法重写了接口“Mammal”中同名的抽象方法。 Note: 接口中的静态方法永远不会被继承。 修改器重写方法的访问说明符可以允许比重写方法更多但不能更少的访问。例如，超类中的受保护实例方法可以在子类中公开，但不能私有。 如果试图将超类中的实例方法更改为子类中的静态方法，则会出现编译时错误，反之亦然。 总结下表总结了定义与超类中的方法具有相同签名的方法时发生的情况。 超级类实例方法 超类静态方法 子类实例方法 覆盖 生成编译时错误 父类静态方法 生成编译时错误 Hides Note: 在子类中，可以重载从超类继承的方法。此类重载方法既不隐藏也不覆盖超类实例方法，它们是子类特有的新方法。 多态性字典中对“多态性”的定义是指生物学中的一个原则，即一个生物体或物种可以有许多不同的形式或阶段。这一原则也适用于面向对象编程和Java语言等语言。类的子类可以定义自己独特的行为，但也可以共享父类的一些相同功能。 对“Bicycle”类稍作修改即可证明多态性。例如，可以将“printDescription”方法添加到显示实例中当前存储的所有数据的类中。 12345public void printDescription()&#123; System.out.println(&quot;\\nBike is &quot; + &quot;in gear &quot; + this.gear + &quot; with a cadence of &quot; + this.cadence + &quot; and travelling at a speed of &quot; + this.speed + &quot;. &quot;);&#125; 要演示Java语言中的多态特性，请使用“MountainBike”和“RoadBike”类扩展“Bicycle”类。对于“MountainBike”，添加一个“suspension”字段，该字段是一个“String”值，指示自行车是否具有前减震器“front”。或者，自行车有一个前后减震器，“双减震器”。 以下是更新的类： 12345678910111213141516171819202122232425262728public class MountainBike extends Bicycle &#123; private String suspension; public MountainBike( int startCadence, int startSpeed, int startGear, String suspensionType)&#123; super(startCadence, startSpeed, startGear); this.setSuspension(suspensionType); &#125; public String getSuspension()&#123; return this.suspension; &#125; public void setSuspension(String suspensionType) &#123; this.suspension = suspensionType; &#125; public void printDescription() &#123; super.printDescription(); System.out.println(&quot;The &quot; + &quot;MountainBike has a&quot; + getSuspension() + &quot; suspension.&quot;); &#125;&#125; 注意重写的“printDescription”方法。除了之前提供的信息之外，输出中还包括关于悬架的附加数据。 接下来，创建“RoadBike”类。因为公路或赛车的轮胎很薄，所以添加一个属性来跟踪轮胎宽度。这是“RoadBike”课程： 12345678910111213141516171819202122232425262728public class RoadBike extends Bicycle&#123; // In millimeters (mm) private int tireWidth; public RoadBike(int startCadence, int startSpeed, int startGear, int newTireWidth)&#123; super(startCadence, startSpeed, startGear); this.setTireWidth(newTireWidth); &#125; public int getTireWidth()&#123; return this.tireWidth; &#125; public void setTireWidth(int newTireWidth)&#123; this.tireWidth = newTireWidth; &#125; public void printDescription()&#123; super.printDescription(); System.out.println(&quot;The RoadBike&quot; + &quot; has &quot; + getTireWidth() + &quot; MM tires.&quot;); &#125;&#125; 请再次注意，“printDescription”方法已被重写。此时，将显示有关轮胎宽度的信息。 概括来说，有三个类别：“自行车”、“山地自行车”和“公路自行车”。这两个子类重写“printDescription”方法并打印唯一信息。 这是一个创建三个“Bicycle”变量的测试程序。每个变量分配给三个自行车类中的一个。然后打印每个变量。 12345678910111213public class TestBikes &#123; public static void main(String[] args)&#123; Bicycle bike01, bike02, bike03; bike01 = new Bicycle(20, 10, 1); bike02 = new MountainBike(20, 10, 5, &quot;Dual&quot;); bike03 = new RoadBike(40, 20, 8, 23); bike01.printDescription(); bike02.printDescription(); bike03.printDescription(); &#125;&#125; 以下是测试程序的输出： 1234567Bike is in gear 1 with a cadence of 20 and travelling at a speed of 10. Bike is in gear 5 with a cadence of 20 and travelling at a speed of 10. The MountainBike has a Dual suspension.Bike is in gear 8 with a cadence of 40 and travelling at a speed of 20. The RoadBike has 23 MM tires. Java虚拟机（JVM）为每个变量中引用的对象调用适当的方法。它不会调用由变量类型定义的方法。这种行为被称为“虚拟方法调用”，它展示了Java语言中重要的多态特性的一个方面。 隐藏字段在类中，与超类中的字段同名的字段隐藏超类的字段，即使它们的类型不同。在子类中，超类中的字段不能通过其简单名称引用。相反，必须通过“super”访问该字段，这将在下一节中介绍。一般来说，我们不建议隐藏字段，因为这会使代码难以阅读。 使用关键字super访问超级类成员如果您的方法覆盖了其超类的方法之一，则可以通过使用关键字“super”来调用覆盖的方法。您也可以使用“super”来引用隐藏字段（尽管不鼓励隐藏字段）。考虑此类“超级类”： 123456public class Superclass &#123; public void printMethod() &#123; System.out.println(&quot;Printed in Superclass.&quot;); &#125;&#125; 下面是一个子类，名为“subclass”，它重写了“printMethod()”： 123456789101112public class Subclass extends Superclass &#123; // overrides printMethod in Superclass public void printMethod() &#123; super.printMethod(); System.out.println(&quot;Printed in Subclass&quot;); &#125; public static void main(String[] args) &#123; Subclass s = new Subclass(); s.printMethod(); &#125;&#125; 在“子类”中，简单名称“printMethod()”引用在“子类别”中声明的名称，该名称覆盖在“超级类”中的名称。因此，要引用从“Superclass”继承的“printMethod()”，“Subclass”必须使用限定名，使用“super”，如图所示。编译和执行“子类”将打印以下内容： 12Printed in Superclass.Printed in Subclass 子类构造函数下面的示例说明了如何使用“super”关键字来调用超类的构造函数。从Bicycle中回忆例如，“MountainBike”是“Bicycle”的子类。这里是“MountainBike”（子类）构造函数，它调用超类构造函数，然后添加自己的初始化代码： 1234567public MountainBike(int startHeight, int startCadence, int startSpeed, int startGear) &#123; super(startCadence, startSpeed, startGear); seatHeight = startHeight;&#125; 超类构造函数的调用必须是子类构造函数中的第一行。 调用超类构造函数的语法为 1super(); or: 1super(parameter list); 使用“super()”，将调用超类无参数构造函数。使用“super(parameter list)”，将调用具有匹配参数列表的超类构造函数。 Note: 如果构造函数没有显式调用超类构造函数，Java编译器会自动插入对超类的无参数构造函数的调用。如果超级类没有无参数构造函数，则会出现编译时错误&#96;对象“*”没有这样的构造函数，因此如果“Object”是唯一的超类，则没有问题。 如果子类构造函数显式或隐式地调用其超类的构造函数，您可能会认为将有一个完整的构造函数链被调用，一直返回到“Object”的构造函数。事实上，情况就是这样。它被称为构造函数链接，当有很长的类下降线时，您需要注意它。 Object 作为超类对象类，在java.lang包位于类层次结构树的顶部。每个类都是“Object”类的直接或间接后代。您使用或编写的每个类都继承“Object”的实例方法。您不需要使用任何这些方法，但是，如果您选择这样做，您可能需要使用特定于您的类的代码来覆盖它们。本节讨论的从“Object”继承的方法包括： protected Object clone() throws CloneNotSupportedException 创建并返回此对象的副本。 public boolean equals(Object obj) 指示其他对象是否“等于”此对象。 protected void finalize() throws Throwable 垃圾回收时由对象上的垃圾回收器调用 集合确定不再有对该对象的引用 public final Class getClass() 返回对象的运行时类。 public int hashCode() 返回对象的哈希代码值。 public String toString() 返回对象的字符串表示形式。 “Object”的“notify”、“notifyAll”和“wait”方法都在同步程序中独立运行的线程的活动中发挥作用，这将在后面的课程中讨论，这里不再赘述。有五种方法： public final void notify() public final void notifyAll() public final void wait() public final void wait(long timeout) public final void wait(long timeout, int nanos) Note: 许多这些方法都有一些微妙的方面，特别是“克隆”方法。 The clone() Method如果类或其超类之一实现了“可克隆”接口，则可以使用“clone()”方法从现有对象创建副本。要创建克隆，请执行以下操作： 1aCloneableObject.clone(); &#96;对象的此方法的实现检查调用了“clone()”的对象是否实现了“Cloneable”接口。如果对象没有，该方法将抛出“CloneNotSupportedException”异常。异常处理将在后面的课程中介绍。目前，您需要知道“clone（）”必须声明为 1protected Object clone() throws CloneNotSupportedException or: 1public Object clone() throws CloneNotSupportedException 如果要编写一个“clone()”方法来覆盖“Object”中的方法。 如果调用了“clone()”的对象确实实现了“Cloneable”接口，则“object”实现的“clone()”方法将创建一个与原始对象具有相同类的对象，并初始化新对象的成员变量，使其具有与原始对象的对应成员变量相同的值。 使类可克隆的最简单方法是将“implements cloneable”添加到类的声明中。则对象可以调用“clone()”方法。 对于某些类，“Object”的“clone()”方法的默认行为正常工作。但是，如果对象包含对外部对象的引用，例如“ObjExternal”，则可能需要重写“clone()”以获得正确的行为。否则，一个对象对“ObjExternal”所做的更改也将在其克隆中可见。这意味着原始对象及其克隆不是独立的。要使它们解耦，必须重写“clone()”，以便它克隆对象和“ObjExternal”。然后，原始对象引用“ObjExternal”，克隆引用“Obj External”的克隆，因此对象及其克隆是真正独立的。 The equals() Method“equals（）”方法比较两个对象是否相等，如果相等则返回“true”。“Object”类中提供的“equals（）”方法使用标识运算符（“&#x3D;&#x3D;”）来确定两个对象是否相等。对于原始数据类型，这将给出正确的结果。然而，对于对象，则不会。“Object”提供的“equals（）”方法测试对象引用是否相等，也就是说，如果比较的对象是完全相同的对象。 要测试两个对象在等效（包含相同信息）意义上是否相等，必须重写“equals（）”方法。下面是重写“equals（）”的“Book”类的示例： 1234567891011121314public class Book &#123; String ISBN; public String getISBN() &#123; return ISBN; &#125; public boolean equals(Object obj) &#123; if (obj instanceof Book) return ISBN.equals((Book)obj.getISBN()); else return false; &#125;&#125; 考虑一下测试“Book”类的两个实例是否相等的代码： 12345678// Swing Tutorial, 2nd editionBook firstBook = new Book(&quot;0201914670&quot;);Book secondBook = new Book(&quot;0201914670&quot;);if (firstBook.equals(secondBook)) &#123; System.out.println(&quot;objects are equal&quot;);&#125; else &#123; System.out.println(&quot;objects are not equal&quot;);&#125; 该程序显示“对象相等”，即使“firstBook”和“secondBook”引用了两个不同的对象。它们被认为是相等的，因为所比较的对象包含相同的ISBN编号。 如果标识运算符不适合您的类，则应始终重写“equals（）”方法。 Note: 如果重写“equals（）”，则也必须重写“hashCode（）”。 The finalize() Method“Object”类提供回调方法“finalize（）”，当对象变为垃圾时，可以*调用该方法&#96;对象“finalize（）”的实现不做任何事情，您可以重写“finaliz（）”来进行清理，例如释放资源。 “finalize（）”方法可以由系统自动调用，但何时调用，甚至是否调用，都是不确定的。因此，不要依赖此方法为您进行清理。例如，如果在执行I&#x2F;O之后不关闭代码中的文件描述符，并且希望“finalize（）”为您关闭它们，则可能会用完文件描述符。相反，使用“try”-with-resources语句自动关闭应用程序的资源。参见资源尝试声明和定案和弱参考、软参考和虚参考在Java平台标准版HotSpot虚拟机垃圾收集调整指南*中。 The getClass() Method您不能覆盖 getClass. “getClass（）”方法返回一个“Class”对象，该对象具有可用于获取类信息的方法，例如其名称（“getSimpleName（）”）、其超类（“getSuperclass（）”，以及其实现的接口（“getInterface（）”。例如，以下方法获取并显示对象的类名： 1234void printClassName(Object obj) &#123; System.out.println(&quot;The object&#x27;s&quot; + &quot; class is &quot; + obj.getClass().getSimpleName());&#125; Class类，在java。lang包有大量方法（超过50个）。例如，您可以测试该类是注释（isAnnotation（））、接口（isInterface（）或枚举（isEnum（））。您可以看到对象的字段是什么（getFields（））或其方法是什么（&#96; getMethods（）’），等等。 The hashCode() Method“hashCode（）”返回的值是对象的哈希代码，它是由哈希算法生成的整数值。 根据定义，如果两个对象相等，则其哈希代码*也必须相等。如果重写“equals（）”方法，则会更改两个对象相等的方式，并且“Object”对“hashCode（）”的实现不再有效。因此，如果重写“equals（）”方法，也必须重写“hashCode（）”。 The toString() Method您应该始终考虑在类中重写“toString（）”方法。 “Object”的“toString（）”方法返回对象的“String”表示，这对于调试非常有用。对象的“String”表示完全依赖于对象，这就是为什么需要在类中重写“toString（）”。 可以将“toString（）”与“System.out”一起使用。println（）&#96;显示对象的文本表示，例如“Book”的实例： 1System.out.println(firstBook.toString()); 对于正确重写的“toString（）”方法，它将打印一些有用的内容，例如： 1ISBN: 0201914670; The Swing Tutorial; A Guide to Constructing GUIs, 2nd Edition 编写 Final Classes and Methods您可以声明类的一些或所有方法final。在方法声明中使用“final”关键字表示方法不能被子类重写。“Object”类这样做——它的许多方法都是“final”。 如果方法的实现不应更改，并且对对象的一致状态至关重要，那么您可能希望将其设置为final。例如，您可能希望将“ChessAlgorithm”类中的“getFirstPlayer”方法设置为final： 12345678class ChessAlgorithm &#123; enum ChessPlayer &#123; WHITE, BLACK &#125; ... final ChessPlayer getFirstPlayer() &#123; return ChessPlayer.WHITE; &#125; ...&#125; 从构造函数调用的方法通常应声明为final。如果构造函数调用非final方法，子类可能会重新定义该方法，并产生令人惊讶或不希望的结果。 注意，您也可以声明整个类final。声明为final的类不能被子类化。例如，当创建像“String”类这样的不可变类时，这特别有用。 Abstract Methods and Classes抽象类是一个声明为“abstract”的类，它可能包含也可能不包含抽象方法。抽象类不能实例化，但可以子类化。 抽象方法是在没有实现的情况下声明的方法（没有大括号，后跟分号），如下所示： 1abstract void moveTo(double deltaX, double deltaY); 如果类包含抽象方法，则类本身必须声明为“abstract”，如： 12345public abstract class GraphicObject &#123; // declare fields // declare nonabstract methods abstract void draw();&#125; 当抽象类被子类化时，子类通常为其父类中的所有抽象方法提供实现。但是，如果没有，那么子类也必须声明为“abstract”。 Note: 接口中的方法（请参见接口section）是隐式抽象的，因此“abstract”修饰符不与接口方法一起使用。（可以使用，但没有必要。） 抽象类与接口的比较抽象类类似于接口。您不能实例化它们，它们可能包含带有或不带有实现的混合声明方法。然而，使用抽象类，您可以声明非静态和最终的字段，并定义公共、受保护和私有的具体方法。使用接口，所有字段都自动为公共、静态和final，并且您声明或定义的所有方法（作为默认方法）都是公共的。此外，无论是否抽象，您只能扩展一个类，而可以实现任意数量的接口。 抽象类或接口应该使用哪一个？ 如果以下任何语句适用于您的情况，请考虑使用抽象类： 您希望在几个密切相关的类之间共享代码。 您希望扩展抽象类的类具有许多公共方法或字段，或者需要公共以外的访问修饰符（如protected和private）。 您要声明非静态或非final字段。这使您能够定义可以访问和修改其所属对象状态的方法。 如果以下任何语句适用于您的情况，请考虑使用接口： 您希望不相关的类实现您的接口。例如，接口Comparable和可克隆由许多不相关的类实现。 您希望指定特定数据类型的行为，但不关心谁实现了它的行为。 您希望利用类型的多重继承。 JDK中抽象类的一个示例是AbstractMap，是集合框架的一部分。它的子类（包括“HashMap”、“TreeMap”和“ConcurrentHashMap”）共享“AbstractMap”定义的许多方法（包括“get”、“put”、“isEmpty”、“containsKey”和“containsValue”）。 JDK中实现多个接口的类的示例是HashMap，实现了接口“Serializable”、“Cloneable”和“Map&lt;K，V&gt;”。通过阅读此接口列表，您可以推断出“HashMap”的实例（无论是开发人员还是实现该类的公司）可以被克隆、可序列化（这意味着它可以被转换为字节流；请参阅[serializable Objects]一节(https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html))，并具有地图的功能。此外，“Map&lt;K，V&gt;”接口已通过许多默认方法（如“merge”和“forEach”）进行了增强，实现了该接口的旧类不必定义这些方法。 注意，许多软件库同时使用抽象类和接口；“HashMap”类实现了几个接口，还扩展了抽象类“AbstractMap”。 抽象类示例在面向对象的绘图应用程序中，可以绘制圆、矩形、直线、贝塞尔曲线和许多其他图形对象。这些对象都具有某些共同的状态（例如：位置、方向、线条颜色、填充颜色）和行为（例如：moveTo、旋转、调整大小、绘制）。所有图形对象的某些状态和行为都相同（例如：位置、填充颜色和moveTo）。其他需要不同的实现（例如，调整大小或绘制）。所有“GraphicObject”必须能够自己绘制或调整大小；他们只是在做这件事的方式上有所不同。对于抽象超类来说，这是一个完美的情况。您可以利用这些相似性，并声明要从同一抽象父对象（例如，“GraphicObject”）继承的所有图形对象，如下图所示。 类矩形、直线、贝塞尔和圆继承自GraphicObject 首先，声明一个抽象类“GraphicObject”，以提供所有子类（如当前位置和“moveTo”方法）完全共享的成员变量和方法&#96;GraphicObject还为需要由所有子类实现但必须以不同方式实现的方法（如“draw”或“resize”）声明抽象方法。“GraphicObject”类可以如下所示： 123456789abstract class GraphicObject &#123; int x, y; ... void moveTo(int newX, int newY) &#123; ... &#125; abstract void draw(); abstract void resize();&#125; “GraphicObject”的每个非抽象子类（如“Circle”和“Rectangle”）必须提供“draw”和“resize”方法的实现： 12345678910111213141516class Circle extends GraphicObject &#123; void draw() &#123; ... &#125; void resize() &#123; ... &#125;&#125;class Rectangle extends GraphicObject &#123; void draw() &#123; ... &#125; void resize() &#123; ... &#125;&#125; 抽象类实现接口时在Interfaces部分，注意到实现接口的类必须实现接口的所有方法。然而，如果类被声明为“抽象”，则可以定义一个不实现所有接口方法的类。例如 1234567abstract class X implements Y &#123; // implements all but one method of Y&#125;class XX extends X &#123; // implements the remaining method in Y&#125; 在这种情况下，类“X”必须是“抽象”的，因为它没有完全实现“Y”，但类“XX”实际上实现了“Y”。 Class Members抽象类可以具有“静态”字段和“静态”方法。您可以将这些静态成员与类引用（例如，“AbstractClass.staticMethod()”）一起使用，就像与任何其他类一样。 继承总结除了“Object”类，一个类只有一个直接超类。类从其所有超类（无论是直接还是间接）继承字段和方法。子类可以覆盖其继承的方法，也可以隐藏其继承的字段或方法。（请注意，隐藏字段通常是不好的编程实践。） 覆盖和隐藏方法中的表部分显示了使用与超类中的方法相同的签名声明方法的效果。 “Object”类是类层次结构的顶部。所有类都是该类的后代，并从该类继承方法。从Object继承的有用方法包括toString（）、equals（），clone（）和getClass（）。 通过在类的声明中使用“final”关键字，可以防止类被子类化。类似地，通过将方法声明为final方法，可以防止方法被子类重写。 抽象类只能被子类化；它不能被实例化。抽象类可以包含声明但未实现的抽象方法方法。然后，子类提供抽象方法的实现。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"接口","slug":"接口","permalink":"https://guoshunfa.com/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"Oracle Java泛型","slug":"软件开发/技术/编程语言/java/Oracle-Java泛型","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2020/07/Oracle-Java泛型/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/generics/index.html 在任何非平凡的软件项目中，bug都是生活中的事实。仔细的规划、编程和测试可以帮助减少它们的普遍性，但不知何故，在某个地方，它们总会找到一种方法潜入您的代码。随着新特性的引入和代码库的规模和复杂性的增加，这一点变得尤为明显。 幸运的是，有些bug比其他bug更容易检测。例如，编译时错误可以在早期检测到；您可以使用编译器的错误消息来找出问题所在并立即修复它。然而，运行时错误可能会有更大的问题；它们并不总是立即出现，当它们出现时，可能是程序中的某个点与问题的实际原因相去甚远。 泛型通过在编译时检测更多的错误来增加代码的稳定性。完成本课程后，您可能需要继续学习Generics吉拉德·布拉查的教程。 为什么使用泛型？简而言之，泛型使types（类和接口）在定义类、接口和方法时成为参数。与方法声明中使用的更为熟悉的形式参数非常相似，类型参数为您提供了一种将相同的代码用于不同输入的方法。不同之处在于，形式参数的输入是值，而类型参数的输入则是类型。 使用泛型的代码比非泛型代码有很多好处： 编译时更强大的类型检查。 Java编译器对泛型代码应用强类型检查，如果代码违反了类型安全性，就会发出错误。修复编译时错误比修复运行时错误更容易，因为运行时错误很难找到。 消除铸件。 以下没有泛型的代码段需要强制转换： 123List list = new ArrayList();list.add(&quot;hello&quot;);String s = (String) list.get(0); 重新编写以使用泛型时，代码不需要强制转换： 123List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;hello&quot;);String s = list.get(0); // no cast 使程序员能够实现通用算法。 通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全，更易于阅读。 泛型类型泛型类型是在类型上参数化的泛型类或接口。将修改下面的“Box”类以演示该概念。 一个简单的Box类首先检查对任何类型的对象进行操作的非泛型“Box”类。它只需要提供两个方法：“set”（将对象添加到框中）和“get”（检索对象）： 123456public class Box &#123; private Object object; public void set(Object object) &#123; this.object = object; &#125; public Object get() &#123; return object; &#125;&#125; 由于它的方法接受或返回一个“Object”，所以只要它不是原始类型之一，您就可以随意传入任何您想要的内容。在编译时，无法验证该类是如何使用的。代码的一部分可能将“Integer”放在框中，并期望从中获取“Integer’s”，而代码的另一部分可能错误地传入“String”，从而导致运行时错误。 Box类的通用版本泛型类的定义格式如下： 1class name&lt;T1, T2, ..., Tn&gt; &#123; /* ... */ &#125; 类型参数部分由尖括号（&lt;&gt;）分隔，位于类名之后。它指定类型参数（也称为类型变量）“T1”、“T2”、…和“Tn”。 要更新“Box”类以使用泛型，请通过将代码“public class Box”更改为“public class-Box&lt;T&gt;”来创建一个泛型类型声明。这引入了类型变量“T”，它可以在类中的任何地方使用。 通过此更改，“Box”类变为： 1234567891011/** * Generic version of the Box class. * @param &lt;T&gt; the type of the value being boxed */public class Box&lt;T&gt; &#123; // T stands for &quot;Type&quot; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 如您所见，“Object”的所有出现都被“T”替换。类型变量可以是您指定的任何非基元类型：任何类类型、任何接口类型、任何数组类型，甚至其他类型变量。 同样的技术也可以用于创建通用接口。 类型参数命名惯例按照惯例，类型参数名称是单个大写字母。这与变量命名形成鲜明对比您已经知道的约定，并且有充分的理由：如果没有这种约定，很难区分类型变量和普通类或接口名称之间的区别。 最常用的类型参数名称是： E - Element (Java集合框架广泛使用) K - Key N - Number T - Type V - Value S,U,V etc. - 2nd, 3rd, 4th types 您将在整个JavaSEAPI和本课程的其余部分中看到这些名称。 调用和实例化泛型类型要从代码中引用泛型“Box”类，必须执行泛型类型调用，该调用将“T”替换为一些具体值，例如“Integer”： 1Box&lt;Integer&gt; integerBox; 您可以将泛型类型调用视为与普通方法调用类似，但不是将参数传递给方法，而是将类型参数（在本例中为“Integer”）传递给“Box”类本身。 类型参数和类型参数术语: 许多开发人员可互换地使用术语“类型参数”和“类型自变量”，但这些术语并不相同。编码时，提供类型参数以创建参数化类型。因此，“Foo&lt;T&gt;”中的“T”是类型参数，而“Foo＞String＞f”中的‘String’是类型参数。本课在使用这些术语时遵循了这一定义。 与任何其他变量声明一样，此代码实际上不会创建新的“Box”对象。它简单地声明“integerBox”将包含对“Integer”的“Box”的引用，这就是读取“Box＜Integer＞”的方式。 泛型类型的调用通常称为参数化类型。 要实例化该类，请像往常一样使用“new”关键字，但在类名和括号之间放置“＜Integer＞”： 1Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); 钻石在JavaSE7和更高版本中，只要编译器可以从上下文中确定或推断类型参数，就可以用一组空的类型参数（&lt;&gt;）替换调用泛型类构造函数所需的类型参数。这对尖括号&lt;&gt;，非正式地称为“钻石”。例如，可以使用以下语句创建“Box&lt;Integer&gt;”的实例： 1Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); 有关菱形符号和类型推断的更多信息，请参阅type inference. 多个类型参数如前所述，泛型类可以有多个类型参数。例如，实现通用“Pair”接口的通用“OrderedPair”类： 123456789101112131415161718public interface Pair&lt;K, V&gt; &#123; public K getKey(); public V getValue();&#125;public class OrderedPair&lt;K, V&gt; implements Pair&lt;K, V&gt; &#123; private K key; private V value; public OrderedPair(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125;&#125; 以下语句创建了“OrderedPair”类的两个实例： 12Pair&lt;String, Integer&gt; p1 = new OrderedPair&lt;String, Integer&gt;(&quot;Even&quot;, 8);Pair&lt;String, String&gt; p2 = new OrderedPair&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;); 代码“new OrderedPair&lt;String，Integer&gt;”将“K”实例化为“String”，将“V”实例化为一个“Integer”。因此，“OrderedPair”构造函数的参数类型分别为“String”和“Integer”。由于自动装箱，向类传递“String”和“int”是有效的。 如钻石中所述，因为Java编译器可以从声明“OrderedPair&lt;String，Integer&gt;”中推断“K”和“V”类型，所以可以使用菱形符号缩短这些语句： 12OrderedPair&lt;String, Integer&gt; p1 = new OrderedPair&lt;&gt;(&quot;Even&quot;, 8);OrderedPair&lt;String, String&gt; p2 = new OrderedPair&lt;&gt;(&quot;hello&quot;, &quot;world&quot;); 要创建泛型接口，请遵循与创建泛型类相同的约定。 参数化类型也可以用参数化类型（即“List&lt;String&gt;”）替换类型参数（即“K”或“V”）。例如，使用“OrderedPair&lt;K，V&gt;”示例： 1OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...)); 原始类型原始类型是没有任何类型参数的泛型类或接口的名称。例如，给定泛型“Box”类： 1234public class Box&lt;T&gt; &#123; public void set(T t) &#123; /* ... */ &#125; // ...&#125; 要创建参数化类型“Box&lt;T&gt;”，请为正式类型参数“T”提供一个实际类型参数： 1Box&lt;Integer&gt; intBox = new Box&lt;&gt;(); 如果省略了实际类型参数，则创建“Box＜T＞”的原始类型： 1Box rawBox = new Box(); 因此，“Box”是泛型类型“Box&lt;T&gt;”的原始类型。但是，非泛型类或接口类型不是原始类型。 原始类型出现在遗留代码中，因为在JDK5.0之前，许多API类（如“集合”类）都不是泛型的。为了向后兼容，允许将参数化类型分配给其原始类型： 12Box&lt;String&gt; stringBox = new Box&lt;&gt;();Box rawBox = stringBox; // OK 但如果将原始类型分配给参数化类型，则会收到警告： 12Box rawBox = new Box(); // rawBox is a raw type of Box&lt;T&gt;Box&lt;Integer&gt; intBox = rawBox; // warning: unchecked conversion 如果使用原始类型调用相应泛型类型中定义的泛型方法，也会收到警告： 123Box&lt;String&gt; stringBox = new Box&lt;&gt;();Box rawBox = stringBox;rawBox.set(8); // warning: unchecked invocation to set(T) 警告显示，原始类型绕过泛型类型检查，将不安全代码的捕获延迟到运行时。因此，应避免使用原始类型。 类型擦除部分提供了有关Java编译器如何使用原始类型的更多信息。 未选中的错误消息如前所述, 当将遗留代码与通用代码混合时，您可能会遇到类似于以下内容的警告消息: 12Note: Example.java uses unchecked or unsafe operations.Note: Recompile with -Xlint:unchecked for details. 当使用对原始类型进行操作的旧API时，可能会发生这种情况，如下例所示： 12345678910public class WarningDemo &#123; public static void main(String[] args)&#123; Box&lt;Integer&gt; bi; bi = createBox(); &#125; static Box createBox()&#123; return new Box(); &#125;&#125; 术语“未检查”意味着编译器没有足够的类型信息来执行确保类型安全所需的所有类型检查。默认情况下，“未检查”警告被禁用，尽管编译器会给出提示。要查看所有“未检查”警告，请使用“-Xlint:unchecked”重新编译。 使用“-Xlint:unchecked”重新编译上一个示例将显示以下附加信息： 123456WarningDemo.java:4: warning: [unchecked] unchecked conversionfound : Boxrequired: Box&lt;java.lang.Integer&gt; bi = createBox(); ^1 warning 要完全禁用未检查的警告，请使用“-Xlint:未检查”标志。@SuppressWarnings（“unchecked”）注释可抑制未选中的警告。如果您不熟悉“@SuppressWarnings”语法，请参阅Annotations. 泛型方法泛型方法是引入自己类型参数的方法。这类似于声明泛型类型，但类型参数的范围仅限于声明它的方法。允许使用静态和非静态泛型方法以及泛型类构造函数。 泛型方法的语法包括一个类型参数列表，位于尖括号内，出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。 “Util”类包含一个通用方法“compare”，用于比较两个“Pair”对象： 12345678910111213141516171819202122public class Util &#123; public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123; return p1.getKey().equals(p2.getKey()) &amp;&amp; p1.getValue().equals(p2.getValue()); &#125;&#125;public class Pair&lt;K, V&gt; &#123; private K key; private V value; public Pair(K key, V value) &#123; this.key = key; this.value = value; &#125; public void setKey(K key) &#123; this.key = key; &#125; public void setValue(V value) &#123; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125;&#125; 调用此方法的完整语法为： 123Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);boolean same = Util.&lt;Integer, String&gt;compare(p1, p2); 已显式提供类型，如粗体所示。通常，这可以省略，编译器将推断所需的类型： 123Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);boolean same = Util.compare(p1, p2); 此特性称为类型推断，允许您将泛型方法作为普通方法调用，而无需在尖括号之间指定类型。该主题将在下一节类型推断中进一步讨论. 受限的类型参数有时可能需要限制可以用作参数化类型中的类型参数的类型。例如，对数字进行操作的方法可能只希望接受“Number”或其子类的实例。这就是有界类型参数的用途。 要声明有界的类型参数，请列出类型参数的名称，后跟“extends”关键字，后跟其上界，在本例中为“Number”。注意，在此上下文中，“extends”在一般意义上是指“extends（扩展）”（如在类中）或“implements（实现）”（在接口中）。 1234567891011121314151617181920212223public class Box&lt;T&gt; &#123; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; public &lt;U extends Number&gt; void inspect(U u)&#123; System.out.println(&quot;T: &quot; + t.getClass().getName()); System.out.println(&quot;U: &quot; + u.getClass().getName()); &#125; public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); integerBox.set(new Integer(10)); integerBox.inspect(&quot;some text&quot;); // error: this is still String! &#125;&#125; 通过修改泛型方法以包含此有界类型参数，编译现在将失败，因为我们对“inspect”的调用仍然包含“String”： 12345Box.java:21: &lt;U&gt;inspect(U) in Box&lt;java.lang.Integer&gt; cannot be applied to (java.lang.String) integerBox.inspect(&quot;10&quot;); ^1 error 除了限制可用于实例化泛型类型的类型之外，有界类型参数还允许您调用在边界中定义的方法： 123456789101112public class NaturalNumber&lt;T extends Integer&gt; &#123; private T n; public NaturalNumber(T n) &#123; this.n = n; &#125; public boolean isEven() &#123; return n.intValue() % 2 == 0; &#125; // ...&#125; “isEven”方法通过“n”调用在“Integer”类中定义的“intValue”方法。 多个边界前面的示例说明了使用具有单个边界的类型参数，但类型参数可以具有多个边界： 1&lt;T extends B1 &amp; B2 &amp; B3&gt; 具有多个边界的类型变量是边界中列出的所有类型的子类型。如果其中一个边界是类，则必须首先指定它。例如： 12345Class A &#123; /* ... */ &#125;interface B &#123; /* ... */ &#125;interface C &#123; /* ... */ &#125;class D &lt;T extends A &amp; B &amp; C&gt; &#123; /* ... */ &#125; 如果未首先指定绑定“A”，则会出现编译时错误： 1class D &lt;T extends B &amp; A &amp; C&gt; &#123; /* ... */ &#125; // compile-time error 泛型方法和有界类型参数有界类型参数是实现通用算法的关键。考虑以下方法，该方法计算数组“T[]”中大于指定元素“elem”的元素数。 1234567public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e &gt; elem) // compiler error ++count; return count;&#125; 该方法的实现很简单，但它不会编译，因为大于运算符（“&gt;”）仅适用于基本类型，如“short”、“int”、“double”、“long”、”float“、”byte“和”char“。不能使用“&gt;”运算符来比较对象。要解决此问题，请使用由“Comparable&lt;T&gt;”接口限定的类型参数： 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 生成的代码将是： 1234567public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e.compareTo(elem) &gt; 0) ++count; return count;&#125; 泛型、继承和子类型正如您已经知道的，只要类型兼容，就可以将一种类型的对象分配给另一种类型。例如，您可以将“整型”分配给“对象”，因为“对象”是“整型”的超类型之一： 123Object someObject = new Object();Integer someInteger = new Integer(10);someObject = someInteger; // OK 在面向对象的术语中，这被称为“是一种”关系。由于“Integer”是“Object”的类型，因此允许赋值。但“整数”也是“数字”的一种，因此以下代码也是有效的： 1234public void someMethod(Number n) &#123; /* ... */ &#125;someMethod(new Integer(10)); // OKsomeMethod(new Double(10.1)); // OK 泛型也是如此。您可以执行泛型类型调用，将“Number”作为其类型参数传递，如果该参数与“Number”兼容，则允许随后调用“add”： 123Box&lt;Number&gt; box = new Box&lt;Number&gt;();box.add(new Integer(10)); // OKbox.add(new Double(10.1)); // OK 现在考虑以下方法： 1public void boxTest(Box&lt;Number&gt; n) &#123; /* ... */ &#125; 它接受什么类型的参数？通过查看其签名，您可以看到它接受一个类型为“Box&lt;Number&gt;”的参数。但这意味着什么？是否允许按预期传入“Box&lt;Integer&gt;”或“Box&lt;Double&gt;”？答案是“否”，因为Box&lt;Integer&gt;和Box&lt;Double&gt;不是Box&lt;Number&gt;的子类型。 在使用泛型编程时，这是一个常见的误解，但它是一个需要学习的重要概念。 尽管“Integer”是“Number”的子类型，但“Box&lt;Integer&gt;”不是“Box&lt;Number&gt;”的子型。 Note: 给定两个具体类型“A”和“B”（例如，“Number”和“Integer”），无论“A”与“B”是否相关，“MyClass&lt;A&gt;”与“MyClass&lt;B&gt;”都没有关系。“MyClass&lt;A&gt;”和“MyClass&lt;B&gt;”的共同父级是“Object”。 有关在类型参数相关时如何在两个泛型类之间创建类似子类型的关系的信息，请参阅Wildcards and Subyping. 泛型类和子类型您可以通过扩展或实现泛型类或接口来对其进行子类型化。一个类或接口的类型参数与另一个类的类型参数之间的关系由“extends”和“implements”子句确定。 以“Collections”类为例，“ArrayList&lt;E&gt;”实现了“List&lt;E&gt;‘”，而“List&lt;E&gt;”扩展了“Collection&lt;E&gt;”。因此，ArrayList&lt;String&gt;是List&lt;String&gt;的子类型，也是Collection&lt;String&gt;的子类型。只要不改变类型参数，类型之间的子类型关系就会保持不变。 示例“集合”层次结构 现在假设我们要定义自己的列表接口“PayloadList”，它将泛型类型“P”的可选值与每个元素相关联。其声明可能如下： 1234interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; &#123; void setPayload(int index, P val); ...&#125; “PayloadList”的以下参数化是“List＜String＞”的子类型： PayloadList&lt;String,String&gt; PayloadList&lt;String,Integer&gt; PayloadList&lt;String,Exception&gt; 示例“PayloadList”层次结构 类型推断类型推断是Java编译器查看每个方法调用和相应声明的能力，以确定使调用适用的类型参数。推理算法确定参数的类型，以及分配或返回结果的类型（如果可用）。最后，推理算法试图找到适用于所有参数的“最具体”类型。 为了说明最后一点，在以下示例中，推断确定传递给“pick”方法的第二个参数的类型为“Serializable”： 12static &lt;T&gt; T pick(T a1, T a2) &#123; return a2; &#125;Serializable s = pick(&quot;d&quot;, new ArrayList&lt;String&gt;()); 类型推理和泛型方法通用方法向您介绍了类型推断，它使您能够像调用普通方法一样调用泛型方法，而无需在尖括号之间指定类型。考虑以下示例BoxDemo，这需要Box类别： 12345678910111213141516171819202122232425262728public class BoxDemo &#123; public static &lt;U&gt; void addBox(U u, java.util.List&lt;Box&lt;U&gt;&gt; boxes) &#123; Box&lt;U&gt; box = new Box&lt;&gt;(); box.set(u); boxes.add(box); &#125; public static &lt;U&gt; void outputBoxes(java.util.List&lt;Box&lt;U&gt;&gt; boxes) &#123; int counter = 0; for (Box&lt;U&gt; box: boxes) &#123; U boxContents = box.get(); System.out.println(&quot;Box #&quot; + counter + &quot; contains [&quot; + boxContents.toString() + &quot;]&quot;); counter++; &#125; &#125; public static void main(String[] args) &#123; java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes = new java.util.ArrayList&lt;&gt;(); BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(10), listOfIntegerBoxes); BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes); BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes); BoxDemo.outputBoxes(listOfIntegerBoxes); &#125;&#125; 以下是本示例的输出： 123Box #0 contains [10]Box #1 contains [20]Box #2 contains [30] 泛型方法“addBox”定义了一个名为“U”的类型参数。通常，Java编译器可以推断泛型方法调用的类型参数。因此，在大多数情况下，您不必指定它们。例如，要调用泛型方法“addBox”，可以使用类型见证指定类型参数，如下所示： 1BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(10), listOfIntegerBoxes); 或者，如果省略类型见证，Java编译器会（从方法的参数）自动推断类型参数为“Integer”： 1BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes); 泛型类的类型推理和实例化只要编译器可以从上下文中推断类型参数，就可以用一组空的类型参数（&lt;&gt;）替换调用泛型类构造函数所需的类型参数。这对尖括号非正式地称为菱形. 例如，考虑以下变量声明： 1Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;(); 您可以用一组空的类型参数（&lt;&gt;）替换构造函数的参数化类型： 1Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;(); 注意，要在泛型类实例化期间利用类型推断，必须使用菱形。在以下示例中，编译器生成未检查的转换警告，因为“HashMap()”构造函数引用的是“HashMap”原始类型，而不是“Map&lt;String，List&lt;String&gt;&gt;”类型： 1Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap(); // unchecked conversion warning 泛型类和非泛型类的类型推理和泛型构造函数注意，构造函数在泛型类和非泛型类中都可以是泛型的（换句话说，声明自己的形式类型参数）。考虑以下示例： 12345class MyClass&lt;X&gt; &#123; &lt;T&gt; MyClass(T t) &#123; // ... &#125;&#125; 考虑类“MyClass”的以下实例化： 1new MyClass&lt;Integer&gt;(&quot;&quot;) 此语句创建参数化类型“MyClass&lt;Integer&gt;”的实例；该语句显式指定泛型类“MyClass&lt;X&gt;”的形式类型参数“X”的类型“Integer”。请注意，此泛型类的构造函数包含一个形式类型参数“T”。编译器推断此泛型类的构造函数的形式类型参数“T”的类型“String”（因为此构造函数的实际参数是“String”对象）。 Java SE 7之前版本的编译器能够推断泛型构造函数的实际类型参数，类似于泛型方法。但是，如果您使用菱形（&lt;&gt;），Java SE 7和更高版本中的编译器可以推断正在实例化的泛型类的实际类型参数。考虑以下示例： 1MyClass&lt;Integer&gt; myObject = new MyClass&lt;&gt;(&quot;&quot;); 在此示例中，编译器推断泛型类“MyClass&lt;X&gt;”的形式类型参数“X”的类型“Integer”。它为该泛型类的构造函数的形式类型参数“T”推断类型“String”。 Note: 需要注意的是，推理算法仅使用调用参数、目标类型以及可能的明显预期返回类型来推断类型。推理算法不使用程序后期的结果。 目标类型Java编译器利用目标类型来推断泛型方法调用的类型参数。表达式的目标类型是Java编译器期望的数据类型，具体取决于表达式出现的位置。考虑方法Collections.emptyList，声明如下： 1static &lt;T&gt; List&lt;T&gt; emptyList(); 考虑以下赋值语句： 1List&lt;String&gt; listOne = Collections.emptyList(); 此语句需要“List&lt;String&gt;”的实例；此数据类型是目标类型。由于方法“emptyList”返回类型为“List&lt;T&gt;”的值，编译器推断类型参数“T”必须是值“String”。这在Java SE 7和8中都适用。或者，您可以使用类型见证并指定“T”的值，如下所示： 1List&lt;String&gt; listOne = Collections.&lt;String&gt;emptyList(); 然而，在这种情况下，这不是必要的。但在其他情况下，这是必要的。考虑以下方法： 123void processStringList(List&lt;String&gt; stringList) &#123; // process stringList&#125; 假设您要使用空列表调用方法“processStringList”。在Java SE 7中，以下语句不会编译： 1processStringList(Collections.emptyList()); The Java SE 7 compiler generates an error message similar to the following: 1List&lt;Object&gt; cannot be converted to List&lt;String&gt; 编译器需要类型参数“T”的值，因此它以值“Object”开头。因此，调用“集合”。emptyList返回类为List&lt;Object&gt;的值，该值与方法processStringList不兼容。因此，在Java SE 7中，必须按如下方式指定类型参数的值： 1processStringList(Collections.&lt;String&gt;emptyList()); 这在JavaSE8中不再是必要的。目标类型的概念已经扩展到包括方法参数，例如方法“processStringList”的参数。在这种情况下，“processStringList”需要类型为“List&lt;String&gt;”的参数。方法Collections。emptyList返回值List&lt;T&gt;，因此使用目标类型List&lt;String&gt;，编译器推断类型参数T的值为String。因此，在Java SE 8中，编译以下语句： 1processStringList(Collections.emptyList()); See Target Typing in Lambda Expressions for more information. 通配符在通用代码中，问号（？），称为通配符的通配符表示未知类型。通配符可用于多种情况：作为参数、字段或局部变量的类型；有时作为返回类型（尽管更具体一些是更好的编程实践）。通配符永远不会用作泛型方法调用、泛型类实例创建或超类型的类型参数。 以下部分将更详细地讨论通配符，包括上限通配符、下限通配符和通配符捕获。 上限通配符可以使用上限通配符放宽对变量的限制。例如，假设您要编写一个方法，该方法适用于List&lt;Integer&gt;、List&lt;Double&gt;、和List&lt;Number&gt;；可以通过使用上限通配符来实现这一点。 要声明上限通配符，请使用通配符（“?”），后跟“extends”关键字，后跟其上限。注意，在此上下文中，“extends”在一般意义上是指“extends（扩展）”（如在类中）或“implements（实现）”（在接口中）。 要编写适用于“Number”列表和“Number”子类型（如“Integer”、“Double”和“Float”）的方法，需要指定“List&lt;？extends Number&gt;。术语“List&lt;Number&gt;”比“List&lt;? extends Number&gt;，因为前者仅匹配类型为’Number’的列表，而后者匹配类型为Number或其任何子类的列表。 考虑以下“process”方法： 1public static void process(List&lt;? extends Foo&gt; list) &#123; /* ... */ &#125; 上限通配符&lt;？extends Foo&gt;，其中Foo是任何类型，匹配Foo和Foo的任何子类型。“process”方法可以访问类型为“Foo”的列表元素： 12345public static void process(List&lt;? extends Foo&gt; list) &#123; for (Foo elem : list) &#123; // ... &#125;&#125; 在“foreach”子句中，“elem”变量迭代列表中的每个元素。“Foo”类中定义的任何方法现在都可以在“elem”上使用。 “sumOfList”方法返回列表中数字的总和： 123456public static double sumOfList(List&lt;? extends Number&gt; list) &#123; double s = 0.0; for (Number n : list) s += n.doubleValue(); return s;&#125; 以下代码使用“Integer”对象列表打印“sum&#x3D;6.0”： 12List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);System.out.println(&quot;sum = &quot; + sumOfList(li)); “Double”值列表可以使用相同的“sumOfList”方法。以下代码显示“sum&#x3D;7.0”： 12List&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);System.out.println(&quot;sum = &quot; + sumOfList(ld)); 无边界通配符使用通配符（“？”）指定无界通配符类型, 例如，“List&lt;?&gt;”。这称为未知类型列表。在两种情况下，无界通配符是一种有用的方法： 如果您正在编写可以使用“Object”类中提供的功能实现的方法。 当代码在泛型类中使用不依赖于类型参数的方法时。例如，List.size或List.clear。事实上，“Class&lt;?&gt;”因为“Class&lt;T&gt;”中的大多数方法都不依赖于“T”。 考虑以下方法“printList”： 12345public static void printList(List&lt;Object&gt; list) &#123; for (Object elem : list) System.out.println(elem + &quot; &quot;); System.out.println();&#125; “printList”的目标是打印任何类型的列表，但它无法实现这一目标——它只打印“Object”实例的列表；它无法打印“List&lt;Integer&gt;”、“List&lt;String&gt;”、‘List&lt;Double&gt;”等，因为它们不是“List&lt;Object&gt;”的子类型。要编写通用的“printList”方法，请使用“List&lt;?&gt;”： 12345public static void printList(List&lt;?&gt; list) &#123; for (Object elem: list) System.out.print(elem + &quot; &quot;); System.out.println();&#125; 因为对于任何具体类型“A”，“List&lt;A&gt;”是“List&lt;?&gt;”的子类型，您可以使用“printList”打印任何类型的列表： 1234List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);List&lt;String&gt; ls = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);printList(li);printList(ls); Note: [Arrays.asList](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T、 ..-)方法在本课程的示例中使用。此静态工厂方法转换指定的数组并返回固定大小的列表。 需要注意的是，List&lt;Object&gt;和List&lt;?&gt;不一样。您可以将“Object”或“Object”的任何子类型插入到“List&lt;Object&gt;”中。但只能将“null”插入到“List&lt;?&gt;”中。通配符使用指南部分提供了有关如何确定在给定情况下应使用哪种通配符（如果有的话）的更多信息。 下限通配符上限通配符部分显示了一个上界通配符将未知类型限制为特定类型或该类型的子类型，并使用“extends”关键字表示。 以类似的方式，下限通配符将未知类型限制为特定类型或该类型的超级类型。 下限通配符使用通配符（“？”）表示，后跟“super”关键字，后跟其下限： &lt;? super A&gt;.。 Note: 可以为通配符指定上限，也可以指定下限，但不能同时指定两者。 假设您要编写一个将“Integer”对象放入列表的方法。为了最大限度地提高灵活性，您希望该方法可以处理“List&lt;Integer&gt;”、“List&lt;Number&gt;”和“List&lt;Object&gt;”—任何可以保存“Integer”值的对象。 要编写适用于“整型”列表和“整型”超类型（如“整型”、“数字”和“对象”）的方法，需要指定List&lt;? super Integer&gt;。术语List&lt;Integer&gt;比List&lt;？super Integer&gt;，因为前者仅匹配“Integer”类型的列表，而后者匹配“Integer’”超类型的任何类型的列表。 以下代码将数字1到10添加到列表末尾： 12345public static void addNumbers(List&lt;? super Integer&gt; list) &#123; for (int i = 1; i &lt;= 10; i++) &#123; list.add(i); &#125;&#125; 通配符使用指南本节提供了何时使用上限通配符和何时使用下限通配符的指导。 通配符和子类型如泛型、继承和子类型中所述，泛型类或接口并不相关，因为它们的类型之间存在关系。 但是，您可以使用通配符来创建泛型类或接口之间的关系。 给定以下两个常规（非泛型）类： 12class A &#123; /* ... */ &#125;class B extends A &#123; /* ... */ &#125; 编写以下代码是合理的： 12B b = new B();A a = b; 此示例显示，常规类的继承遵循子类型化规则：如果B扩展了a，则类B是类a的子类型。此规则不适用于泛型类型： 12List&lt;B&gt; lb = new ArrayList&lt;&gt;();List&lt;A&gt; la = lb; // compile-time error 假定“整数”是“数字”的子类型，那么“List&lt;Number&gt;”和“List&lt;Integer&gt;”之间的关系是什么？ 常见的父项是“List&lt;?&gt;”。 虽然“整数”是“数字”的子类型，但“List&lt;Integer&gt;”不是“List&lt;Number&gt;”的子型，事实上，这两种类型并不相关。“List&lt;Number&gt;”和“List&lt;Integer&gt;”的共同父级是“List&lt;?&gt;”。 为了在这些类之间创建关系，以便代码可以通过“List&lt;Integer&gt;”元素访问“Number”方法，请使用上限通配符： 12List&lt;? extends Integer&gt; intList = new ArrayList&lt;&gt;();List&lt;? extends Number&gt; numList = intList; // OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt; 因为“Integer”是“Number”的子类型，而“numList”是“Number”对象的列表，所以现在在“intList”（“整型”对象列表）和“numList”之间存在关系。下图显示了使用上限和下限通配符声明的几个“List”类之间的关系。 多个泛型“List”类声明的层次结构。 通配符使用指南部分提供了有关使用上限和下限通配符的影响的更多信息。 通配符捕获和帮助程序方法在某些情况下，编译器推断通配符的类型。例如，列表可以定义为“list&lt;?&gt;”但是，当计算表达式时，编译器从代码中推断出特定类型。这种情况称为通配符捕获。 在大多数情况下，您不必担心通配符捕获，除非看到包含短语“captureof”的错误消息。 WildcardError示例在编译时生成捕获错误： 12345678import java.util.List;public class WildcardError &#123; void foo(List&lt;?&gt; i) &#123; i.set(0, i.get(0)); &#125;&#125; 在此示例中，编译器将“i”输入参数处理为“Object”类型。当“foo”方法调用List.set（int，E）时，编译器无法确认插入列表中的对象的类型，并产生错误。当发生这种类型的错误时，通常意味着编译器认为您为变量分配了错误的类型。泛型之所以被添加到Java语言中，是为了在编译时加强类型安全。 “WildcardError”示例在由Oracle的JDK 7“javac”实现编译时生成以下错误： 1234567891011WildcardError.java:6: error: method set in interface List&lt;E&gt; cannot be applied to given types; i.set(0, i.get(0)); ^ required: int,CAP#1 found: int,Object reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ?1 error 在本例中，代码试图执行安全操作，因此如何解决编译器错误？您可以通过编写一个捕获通配符的private helper方法来解决这个问题。在这种情况下，您可以通过创建私有助手方法“fooHelper”来解决这个问题，如WildcardFixed所示: 1234567891011121314public class WildcardFixed &#123; void foo(List&lt;?&gt; i) &#123; fooHelper(i); &#125; // Helper method created so that the wildcard can be captured // through type inference. private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123; l.set(0, l.get(0)); &#125;&#125; 由于helper方法，编译器在调用中使用推断来确定“T”是捕获变量“CAP#1”。该示例现在已成功编译。 按照惯例，助手方法通常命名为*originalMethodName*helper。 现在考虑一个更复杂的示例WildcardErrorBad: 12345678910111213import java.util.List;public class WildcardErrorBad &#123; void swapFirst(List&lt;? extends Number&gt; l1, List&lt;? extends Number&gt; l2) &#123; Number temp = l1.get(0); l1.set(0, l2.get(0)); // expected a CAP#1 extends Number, // got a CAP#2 extends Number; // same bound, but different types l2.set(0, temp); // expected a CAP#1 extends Number, // got a Number &#125;&#125; 在此示例中，代码正在尝试不安全的操作。例如，考虑“swapFirst”方法的以下调用： 123List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);List&lt;Double&gt; ld = Arrays.asList(10.10, 20.20, 30.30);swapFirst(li, ld); 而List&lt;Integer&gt;和List&lt;Double&gt;都满足List&lt;？extendsNumber&gt;，则从“Integer”值列表中获取项目并尝试将其放入“Double”值列表显然是不正确的。 使用Oracle的JDKjavac编译器编译代码会产生以下错误： 12345678910111213141516171819202122232425262728293031WildcardErrorBad.java:7: error: method set in interface List&lt;E&gt; cannot be applied to given types; l1.set(0, l2.get(0)); // expected a CAP#1 extends Number, ^ required: int,CAP#1 found: int,Number reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends NumberWildcardErrorBad.java:10: error: method set in interface List&lt;E&gt; cannot be applied to given types; l2.set(0, temp); // expected a CAP#1 extends Number, ^ required: int,CAP#1 found: int,Number reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends NumberWildcardErrorBad.java:15: error: method set in interface List&lt;E&gt; cannot be applied to given types; i.set(0, i.get(0)); ^ required: int,CAP#1 found: int,Object reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ?3 errors 没有助手方法可以解决这个问题，因为代码根本上是错误的：从“Integer”值列表中获取一个项并尝试将其放入“Double”值列表显然是不正确的。 通配符使用指南学习使用泛型编程时，一个更令人困惑的方面是确定何时使用上限通配符，何时使用下限通配符。本页提供了设计代码时应遵循的一些准则。 出于本讨论的目的，将变量视为提供以下两种功能之一是有帮助的： “In”变量 “in”变量向代码提供数据。设想一个具有两个参数的copy方法：copy（src，dest）。“src”参数提供要复制的数据，因此它是“in”参数。 “out”变量 “out”变量保存其他地方使用的数据。在复制示例“copy（src，dest）”中，“dest”参数接受数据，因此它是“out”参数。 当然，一些变量同时用于“输入”和“输出”目的——指南中也讨论了这种情况。 在决定是否使用通配符以及合适的通配符类型时，可以使用“in”和“out”原则。以下列表提供了应遵循的准则： 通配符指南: “in”变量用上限通配符定义，使用“extends”关键字。 “out”变量用下限通配符定义，使用super关键字。 如果可以使用“Object”类中定义的方法访问“In”变量，使用无界通配符。 如果代码需要同时作为“In”和“out”变量访问变量，请不要使用通配符。 这些准则不适用于方法的返回类型。应避免使用通配符作为返回类型，因为这会迫使程序员使用代码来处理通配符。 由list&lt;？extends …&gt;可以非正式地认为是只读的，但这并不是严格的保证。假设您有以下两个类： 12345678910111213class NaturalNumber &#123; private int i; public NaturalNumber(int i) &#123; this.i = i; &#125; // ...&#125;class EvenNumber extends NaturalNumber &#123; public EvenNumber(int i) &#123; super(i); &#125; // ...&#125; Consider the following code: 123List&lt;EvenNumber&gt; le = new ArrayList&lt;&gt;();List&lt;? extends NaturalNumber&gt; ln = le;ln.add(new NaturalNumber(35)); // compile-time error 因为List&lt;EvenNumber&gt;是List&lt;？extends NaturalNumber&gt;，您可以将le分配给ln。但不能使用“ln”将自然数添加到偶数列表中。列表中可能有以下操作： 您可以添加“null”。 您可以调用“clear”。 您可以获取迭代器并调用“remove”。 您可以捕获通配符并编写从列表中读取的元素。 您可以看到由list&lt;？extends NaturalNumber&gt;在严格意义上不是只读的，但您可能会这样想，因为您无法存储新元素或更改列表中的现有元素。 类型擦除在 Java 语言中引入了泛型，以便在编译时提供更严格的类型检查并支持泛型。为了实现泛型，Java编译器将类型擦除应用于： 用泛型类型的边界替换泛型类型中的所有类型参数，如果类型参数是无界的，则替换为“ Object”。因此，生成的字节码只包含普通的类、接口和方法。 必要时插入类型强制转换以保证类型安全。 生成桥接方法以保留扩展泛型类型中的多态性。 类型擦除确保不会为参数化类型创建新类； 因此，泛型不会产生运行时开销。 通用类型的擦除在类型擦除过程中，Java 编译器会擦除所有类型参数，如果类型参数是有界的，则用第一个边界替换每个参数，如果类型参数是无界的，则用“Object”替换。 考虑以下表示单向链表中节点的泛型类： 12345678910111213public class Node&lt;T&gt; &#123; private T data; private Node&lt;T&gt; next; public Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; public T getData() &#123; return data; &#125; // ...&#125; 因为类型参数 T 是无界的，所以 Java 编译器将其替换为 Object： 12345678910111213public class Node &#123; private Object data; private Node next; public Node(Object data, Node next) &#123; this.data = data; this.next = next; &#125; public Object getData() &#123; return data; &#125; // ...&#125; 在以下示例中，通用 Node 类使用有界类型参数： 12345678910111213public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T data; private Node&lt;T&gt; next; public Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; public T getData() &#123; return data; &#125; // ...&#125; Java 编译器将有界类型参数“T”替换为第一个绑定类“Comparable”： 12345678910111213public class Node &#123; private Comparable data; private Node next; public Node(Comparable data, Node next) &#123; this.data = data; this.next = next; &#125; public Comparable getData() &#123; return data; &#125; // ...&#125; 通用方法的擦除Java 编译器还会擦除泛型方法参数中的类型参数。 考虑以下通用方法： 123456789// Counts the number of occurrences of elem in anArray.//public static &lt;T&gt; int count(T[] anArray, T elem) &#123; int cnt = 0; for (T e : anArray) if (e.equals(elem)) ++cnt; return cnt;&#125; 因为 T 是无界的，所以 Java 编译器将其替换为 Object： 1234567public static int count(Object[] anArray, Object elem) &#123; int cnt = 0; for (Object e : anArray) if (e.equals(elem)) ++cnt; return cnt;&#125; 假设定义了以下类： 123class Shape &#123; /* ... */ &#125;class Circle extends Shape &#123; /* ... */ &#125;class Rectangle extends Shape &#123; /* ... */ &#125; 您可以编写一个通用方法来绘制不同的形状： 1public static &lt;T extends Shape&gt; void draw(T shape) &#123; /* ... */ &#125; Java 编译器将 T 替换为 Shape： 1public static void draw(Shape shape) &#123; /* ... */ &#125; 类型擦除和桥接方法的影响有时类型擦除会导致您可能没有预料到的情况。 以下示例显示了这是如何发生的。 以下示例显示编译器有时如何创建一个合成方法，称为桥接方法，作为类型擦除过程的一部分。 给定以下两个类： 1234567891011121314151617181920public class Node&lt;T&gt; &#123; public T data; public Node(T data) &#123; this.data = data; &#125; public void setData(T data) &#123; System.out.println(&quot;Node.setData&quot;); this.data = data; &#125;&#125;public class MyNode extends Node&lt;Integer&gt; &#123; public MyNode(Integer data) &#123; super(data); &#125; public void setData(Integer data) &#123; System.out.println(&quot;MyNode.setData&quot;); super.setData(data); &#125;&#125; 考虑以下代码： 1234MyNode mn = new MyNode(5);Node n = mn; // A raw type - compiler throws an unchecked warningn.setData(&quot;Hello&quot;); // Causes a ClassCastException to be thrown.Integer x = mn.data; 类型擦除后，这段代码变成： 12345678MyNode mn = new MyNode(5);Node n = mn; // A raw type - compiler throws an unchecked warning // Note: This statement could instead be the following: // Node n = (Node)mn; // However, the compiler doesn&#x27;t generate a cast because // it isn&#x27;t required.n.setData(&quot;Hello&quot;); // Causes a ClassCastException to be thrown.Integer x = (Integer)mn.data; 下一节解释为什么在 n.setData(&quot;Hello&quot;); 语句中抛出 ClassCastException。 桥接方法在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个合成方法，称为桥接方法，作为类型擦除过程的一部分。 您通常不需要担心桥接方法，但如果一个出现在堆栈跟踪中，您可能会感到困惑。 类型擦除后，Node 和 MyNode 类变为： 123456789101112131415161718192021public class Node &#123; public Object data; public Node(Object data) &#123; this.data = data; &#125; public void setData(Object data) &#123; System.out.println(&quot;Node.setData&quot;); this.data = data; &#125;&#125;public class MyNode extends Node &#123; public MyNode(Integer data) &#123; super(data); &#125; public void setData(Integer data) &#123; System.out.println(&quot;MyNode.setData&quot;); super.setData(data); &#125;&#125; 类型擦除后，方法签名不匹配； Node.setData(T) 方法变为 Node.setData(Object)。 因此，“MyNode.setData(Integer)”方法不会覆盖“Node.setData(Object)”方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器生成了一个桥接方法来确保 子类型按预期工作。 对于 MyNode 类，编译器为 setData 生成以下桥接方法： 123456789101112131415class MyNode extends Node &#123; // Bridge method generated by the compiler // public void setData(Object data) &#123; setData((Integer) data); &#125; public void setData(Integer data) &#123; System.out.println(&quot;MyNode.setData&quot;); super.setData(data); &#125; // ...&#125; 桥接方法 MyNode.setData(object) 委托给原始的 MyNode.setData(Integer) 方法。 结果，n.setData(&quot;Hello&quot;); 语句调用方法 MyNode.setData(Object)，并抛出 ClassCastException，因为 &quot;Hello&quot; 无法转换为 Integer 。 不可具体化的类型类型擦除 部分讨论了编译器删除与类型参数和类型参数相关的信息的过程。 类型擦除会产生与可变参数（也称为 varargs ）方法相关的后果，这些方法的可变参数形式参数具有不可具体化的类型。 请参阅将信息传递给方法或构造函数部分任意参数了解有关可变参数方法的更多信息。 不可具体化的类型可具体化类型是其类型信息在运行时完全可用的类型。 这包括原语、非泛型类型、原始类型和未绑定通配符的调用。 Non-reifiable types 是在编译时通过类型擦除删除信息的类型——调用未定义为无限通配符的泛型类型。 不可具体化的类型在运行时不会提供所有可用信息。 不可具体化类型的示例是 List&lt;String&gt; 和 List&lt;Number&gt;； JVM 无法在运行时区分这些类型。 如 Restrictions on Generics 所示，在某些情况下不能使用不可具体化的类型：在 instanceof 中 例如，表达式，或作为数组中的元素。 堆污染堆污染发生在参数化类型的变量引用不属于该参数化类型的对象时。 如果程序执行了一些在编译时产生未经检查的警告的操作，就会发生这种情况。 如果在编译时（在编译时类型检查规则的限制内）或在运行时，涉及参数化类型（例如，强制转换或方法调用）的操作的正确性，则会生成 unchecked warning 无法验证。 例如，堆污染发生在混合原始类型和参数化类型时，或执行未经检查的转换时。 在正常情况下，当同时编译所有代码时，编译器会发出未经检查的警告，提醒您注意潜在的堆污染。 如果您单独编译部分代码，则很难检测到堆污染的潜在风险。 如果您确保您的代码在没有警告的情况下编译，那么就不会发生堆污染。 具有不可具体化形式参数的 Varargs 方法的潜在漏洞包含可变参数输入参数的通用方法会导致堆污染。 考虑以下 ArrayBuilder 类： 123456789101112131415public class ArrayBuilder &#123; public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123; for (T x : elements) &#123; listArg.add(x); &#125; &#125; public static void faultyMethod(List&lt;String&gt;... l) &#123; Object[] objectArray = l; // Valid objectArray[0] = Arrays.asList(42); String s = l[0].get(0); // ClassCastException thrown here &#125;&#125; 以下示例“HeapPollutionExample”使用“ArrayBuiler”类： 1234567891011121314151617public class HeapPollutionExample &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;(); List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;(); ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;); ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;); List&lt;List&lt;String&gt;&gt; listOfStringLists = new ArrayList&lt;List&lt;String&gt;&gt;(); ArrayBuilder.addToList(listOfStringLists, stringListA, stringListB); ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;)); &#125;&#125; 编译时，“ArrayBuilder.addToList”方法的定义会产生以下警告： 1warning: [varargs] Possible heap pollution from parameterized vararg type T 当编译器遇到可变参数方法时，它会将可变参数形式参数转换为数组。 但是，Java 编程语言不允许创建参数化类型的数组。在 ArrayBuilder.addToList 方法中，编译器将可变参数形式参数 T… elements 转换为形式参数 T[] elements，一个数组。 但是，由于类型擦除，编译器将可变参数形式参数转换为 Object[] elements。 因此，存在堆污染的可能性。 以下语句将可变参数形式参数 l 分配给 Object 数组 objectArgs： 1Object[] objectArray = l; 该语句可能会引入堆污染。 与可变参数形式参数 l 的参数化类型匹配的值可以分配给变量 objectArray，因此可以分配给 l。 但是，编译器不会在此语句中生成未经检查的警告。 编译器在将可变参数形式参数 List&lt;String&gt;... l 转换为形式参数 List[] l 时已经生成警告。 此声明有效； 变量 l 的类型为 List[]，它是 Object[] 的子类型。 因此，如果您将任何类型的“List”对象分配给“objectArray”数组的任何数组组件，编译器不会发出警告或错误，如下语句所示： 1objectArray[0] = Arrays.asList(42); 此语句将 objectArray 数组的第一个数组组件分配给一个包含一个 Integer 类型对象的 List 对象。 假设您使用以下语句调用“ArrayBuilder.faultyMethod”： 1ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;)); 在运行时，JVM 在以下语句中抛出 ClassCastException： 12// ClassCastException thrown hereString s = l[0].get(0); 存储在变量“l”的第一个数组组件中的对象具有“List&lt;Integer&gt;”类型，但此语句需要一个“List&lt;String&gt;”类型的对象。 使用不可具体化的形式参数防止 Varargs 方法发出警告如果您声明一个具有参数化类型参数的可变参数方法，并且您确保该方法的主体不会因对可变参数形式参数的不当处理而抛出“ClassCastException”或其他类似异常，则可以防止警告 编译器通过将以下注释添加到静态和非构造方法声明来为这些类型的可变参数方法生成： 1@SafeVarargs @SafeVarargs 注释是方法契约的文档化部分； 此注释断言该方法的实现不会不正确地处理可变参数形式参数。 也可以通过在方法声明中添加以下内容来抑制此类警告，尽管不太理想： 1@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;varargs&quot;&#125;) 但是，此方法不会抑制从方法的调用站点生成的警告。 如果您不熟悉“@SuppressWarnings”语法，请参阅注释。 泛型的限制要有效地使用 Java 泛型，您必须考虑以下限制： 无法使用原始类型实例化泛型类型 无法创建类型参数的实例 不能声明类型为类型参数的静态字段 不能对参数化类型使用 Casts 或 instanceof 无法创建参数化类型的数组 无法创建、捕获或抛出参数化类型的对象 无法重载每个重载的形式参数类型擦除为相同原始类型的方法 无法使用原始类型实例化泛型类型无法使用原始类型实例化泛型类型 123456789101112class Pair&lt;K, V&gt; &#123; private K key; private V value; public Pair(K key, V value) &#123; this.key = key; this.value = value; &#125; // ...&#125; 创建 Pair 对象时，不能用基本类型替换类型参数 K 或 V： 1Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#x27;a&#x27;); // compile-time error 您只能用非基本类型替换类型参数 K 和 V： 1Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#x27;a&#x27;); 请注意，Java 编译器将“8”自动装箱为“Integer.valueOf(8)”，将“a”自动装箱为“Character(‘a’)”： 1Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#x27;a&#x27;)); 有关自动装箱的更多信息，请参阅数字和字符串课程。 无法创建类型参数的实例您不能创建类型参数的实例。 例如，以下代码会导致编译时错误： 1234public static &lt;E&gt; void append(List&lt;E&gt; list) &#123; E elem = new E(); // compile-time error list.add(elem);&#125; 作为解决方法，您可以通过反射创建类型参数的对象： 1234public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123; E elem = cls.newInstance(); // OK list.add(elem);&#125; 您可以按如下方式调用 append 方法： 12List&lt;String&gt; ls = new ArrayList&lt;&gt;();append(ls, String.class); 不能声明类型为类型参数的静态字段类的静态字段是类的所有非静态对象共享的类级变量。 因此，类型参数的静态字段是不允许的。 考虑以下课程： 12345public class MobileDevice&lt;T&gt; &#123; private static T os; // ...&#125; 如果允许类型参数的静态字段，那么下面的代码就会混淆： 123MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;(); 因为静态字段os 被phone、pager 和pc 共享，所以os 的实际类型是什么？ 不能同时是Smartphone、Pager、TabletPC。 因此，您不能创建类型参数的静态字段。 不能对参数化类型使用 Casts 或 instanceof因为 Java 编译器会擦除泛型代码中的所有类型参数，所以您无法验证在运行时使用了泛型类型的哪个参数化类型： 12345public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123; if (list instanceof ArrayList&lt;Integer&gt;) &#123; // compile-time error // ... &#125;&#125; 传递给 rtti 方法的参数化类型集是： 1S = &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... &#125; 运行时不跟踪类型参数，因此它无法区分 ArrayList&lt;Integer&gt; 和 ArrayList&lt;String&gt; 之间的区别。 您最多可以使用无界通配符来验证列表是否为“ArrayList”： 12345public static void rtti(List&lt;?&gt; list) &#123; if (list instanceof ArrayList&lt;?&gt;) &#123; // OK; instanceof requires a reifiable type // ... &#125;&#125; 通常，您不能转换为参数化类型，除非它由无限通配符参数化。 例如： 12List&lt;Integer&gt; li = new ArrayList&lt;&gt;();List&lt;Number&gt; ln = (List&lt;Number&gt;) li; // compile-time error 但是，在某些情况下，编译器知道类型参数始终有效并允许进行强制转换。 例如： 12List&lt;String&gt; l1 = ...;ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1; // OK 无法创建参数化类型的数组不能创建参数化类型的数组。例如，以下代码无法编译： 1List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; // compile-time error 下面的代码说明了在数组中插入不同类型时会发生什么： 123Object[] strings = new String[2];strings[0] = &quot;hi&quot;; // OKstrings[1] = 100; // An ArrayStoreException is thrown. 如果您对通用列表尝试相同的操作，则会出现问题： 1234Object[] stringLists = new List&lt;String&gt;[2]; // compiler error, but pretend it&#x27;s allowedstringLists[0] = new ArrayList&lt;String&gt;(); // OKstringLists[1] = new ArrayList&lt;Integer&gt;(); // An ArrayStoreException should be thrown, // but the runtime can&#x27;t detect it. 如果允许参数化列表的数组，则前面的代码将无法引发所需的“ArrayStoreException”。 无法创建、捕获或抛出参数化类型的对象泛型类不能直接或间接扩展“Throwable”类。例如，以下类将不会编译： 12345// Extends Throwable indirectlyclass MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125; // compile-time error// Extends Throwable directlyclass QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error 方法无法捕获类型参数的实例： 12345678public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123; try &#123; for (J job : jobs) // ... &#125; catch (T e) &#123; // compile-time error // ... &#125;&#125; 但是，您可以在“throws”子句中使用类型参数： 12345class Parser&lt;T extends Exception&gt; &#123; public void parse(File file) throws T &#123; // OK // ... &#125;&#125; 无法重载每个重载的形式参数类型擦除为相同原始类型的方法一个类不能有两个重载方法，它们在类型删除后具有相同的签名。 1234public class Example &#123; public void print(Set&lt;String&gt; strSet) &#123; &#125; public void print(Set&lt;Integer&gt; intSet) &#123; &#125;&#125; 重载将共享相同的类文件表示，并将生成编译时错误。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"https://guoshunfa.com/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"Oracle Java面向对象的编程思想","slug":"软件开发/技术/编程语言/java/Oracle-Java面向对象的编程思想","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2020/07/Oracle-Java面向对象的编程思想/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/concepts/index.html 什么是对象（Object）？对象是理解面向对象技术的关键。现在环顾四周，您会发现现实世界中许多物体的例子：您的狗、您的办公桌、您的电视机、您的自行车。 真实世界的对象有两个共同特征：它们都有状态和行为。狗有状态（名字、颜色、品种、饥饿）和行为（吠叫、抓东西、摇尾巴）。自行车也有状态（当前档位、当前踏板节奏、当前速度）和行为（换档、改变踏板节奏、应用刹车）。识别现实世界对象的状态和行为是开始思考面向对象编程的好方法。 现在花点时间观察您附近区域的真实世界物体。对于你看到的每个物体，问自己两个问题：“这个物体可能处于什么状态？” 和“这个对象可以执行什么可能的行为？”。确保写下您的观察结果。当您这样做时，您会注意到现实世界中的对象在复杂性上各不相同；您的台灯可能只有两种可能的状态（打开和关闭）和两种可能的行为（打开、关闭），但您的桌面收音机可能有其他状态（打开、关闭、当前音量、当前电台）和行为（打开、关闭、增大音量、减小音量、搜索、扫描和调谐）。您可能还会注意到，某些对象反过来也会包含其他对象。这些现实世界的观察都转化为面向对象编程的世界。 软件对象。 软件对象在概念上类似于现实世界的对象：它们也由状态和相关行为组成。对象将其状态存储在字段（某些编程语言中的变量）中，并通过**方法（某些编程语言中的函数）公开其行为。方法对对象的内部状态进行操作，并作为对象到对象通信的主要机制。隐藏内部状态并要求通过对象的方法执行所有交互被称为数据封装——面向对象编程的基本原则。 以自行车为例： 建模为软件对象的自行车。 通过指定状态（当前速度、当前踏板节奏和当前档位）并提供更改该状态的方法，对象仍然可以控制外部世界如何使用它。例如，如果自行车只有 6 个档位，则换档方法可以拒绝任何小于 1 或大于 6 的值。 将代码捆绑到单独的软件对象中有很多好处，包括： 模块化：一个对象的源代码可以独立于其他对象的源代码来编写和维护。一旦创建，一个对象就可以很容易地在系统内部传递。 信息隐藏：通过仅与对象的方法交互，其内部实现的细节对外界保持隐藏。 代码重用：如果一个对象已经存在（可能是由另一个软件开发人员编写的），您可以在您的程序中使用该对象。这允许专家实施&#x2F;测试&#x2F;调试复杂的、特定于任务的对象，然后您可以相信这些对象可以在您自己的代码中运行。 可插入性和调试容易：如果某个特定对象被证明是有问题的，您可以简单地将它从您的应用程序中删除并插入一个不同的对象作为它的替代品。这类似于解决现实世界中的机械问题。如果螺栓断裂，您可以更换它，而不是整台机器。 什么是类（Class）？在现实世界中，您经常会发现许多同类的单独对象。可能存在成千上万辆其他自行车，它们的品牌和型号都相同。每辆自行车都是根据同一套蓝图制造的，因此包含相同的组件。在面向对象的术语中，我们说你的自行车是自行车类对象的一个实例。类是创建单个对象的蓝图。 以下 Bicycle类是自行车的一种可能实现： 12345678910111213141516171819202122232425262728class Bicycle &#123; int cadence = 0; int speed = 0; int gear = 1; void changeCadence(int newValue) &#123; cadence = newValue; &#125; void changeGear(int newValue) &#123; gear = newValue; &#125; void speedUp(int increment) &#123; speed = speed + increment; &#125; void applyBrakes(int decrement) &#123; speed = speed - decrement; &#125; void printStates() &#123; System.out.println(&quot;cadence:&quot; + cadence + &quot; speed:&quot; + speed + &quot; gear:&quot; + gear); &#125;&#125; Java 编程语言的语法对您来说看起来很新，但是这个类的设计是基于前面对自行车对象的讨论。字段cadence、speed和gear表示对象的状态，方法（changeCadence、changeGear等speedUp）定义其与外界的交互。 您可能已经注意到Bicycle该类不包含main方法。那是因为它不是一个完整的应用程序；它只是可能在应用程序中使用的自行车的蓝图。创建和使用新Bicycle对象的责任属于应用程序中的其他类。 这是一个 BicycleDemo创建两个独立Bicycle对象并调用它们的方法的类： 123456789101112131415161718192021222324class BicycleDemo &#123; public static void main(String[] args) &#123; // Create two different // Bicycle objects Bicycle bike1 = new Bicycle(); Bicycle bike2 = new Bicycle(); // Invoke methods on // those objects bike1.changeCadence(50); bike1.speedUp(10); bike1.changeGear(2); bike1.printStates(); bike2.changeCadence(50); bike2.speedUp(10); bike2.changeGear(2); bike2.changeCadence(40); bike2.speedUp(10); bike2.changeGear(3); bike2.printStates(); &#125;&#125; 该测试的输出打印了两辆自行车的结束踏板节奏、速度和档位： 12cadence:50 speed:10 gear:2cadence:40 speed:20 gear:3 什么是继承（Inheritance）？不同种类的对象之间通常有一定数量的共同点。例如，山地自行车、公路自行车和双人自行车都具有自行车的特征（当前速度、当前踏板节奏、当前档位）。然而，每一种都定义了使它们与众不同的附加功能：双人自行车有两个座位和两组车把；公路自行车有下降车把；一些山地自行车有一个额外的链环，使它们的传动比较低。 面向对象编程允许类从其他类继承常用的状态和行为。在此示例中，Bicycle现在成为MountainBike RoadBike TandemBike的超类。在 Java 编程语言中，允许每个类有一个直接的超类，并且每个超类都有无限数量的子类的潜力： 自行车类的层次结构。 创建子类的语法很简单。在类声明的开头，使用extends关键字，后跟要继承的类的名称： 123456class MountainBike extends Bicycle &#123; // new fields and methods defining // a mountain bike would go here&#125; 这提供MountainBike了与 相同的所有字段和方法Bicycle，但允许其代码专门专注于使其独一无二的功能。这使您的子类的代码易于阅读。但是，您必须注意正确记录每个超类定义的状态和行为，因为该代码不会出现在每个子类的源文件中。 什么是接口（Interface）？正如您已经了解到的，对象通过它们公开的方法来定义它们与外部世界的交互。方法形成了对象与外界的接口；例如，电视机正面的按钮是您与塑料外壳另一侧电线之间的接口。您按下“电源”按钮可以打开和关闭电视。 在最常见的形式中，接口是一组具有空主体的相关方法。如果指定为接口，自行车的行为可能如下所示： 1234567891011interface Bicycle &#123; // 每分钟车轮转数 void changeCadence(int newValue); void changeGear(int newValue); void speedUp(int increment); void applyBrakes(int decrement);&#125; 要实现此接口，您的类的名称将更改（例如，更改为特定品牌的自行车，例如ACMEBicycle），并且您将implements在类声明中使用关键字： 123456789101112131415161718192021222324252627282930313233class ACMEBicycle implements Bicycle &#123; int cadence = 0; int speed = 0; int gear = 1; // 编译器现在需要该方法 // changeCadence、changeGear、speedUp 和 applyBrakes // 全部实现。编译将失败，如果那些 // 此类中缺少方法。 void changeCadence(int newValue) &#123; cadence = newValue; &#125; void changeGear(int newValue) &#123; gear = newValue; &#125; void speedUp(int increment) &#123; speed = speed + increment; &#125; void applyBrakes(int decrement) &#123; speed = speed - decrement; &#125; void printStates() &#123; System.out.println(&quot;cadence:&quot; + cadence + &quot; speed:&quot; + speed + &quot; gear:&quot; + gear); &#125;&#125; 实现一个接口允许一个类对于它承诺提供的行为变得更加正式。接口在类和外部世界之间形成了一种契约，这种契约在构建时由编译器强制执行。如果您的类声称要实现一个接口，则该接口定义的所有方法都必须在该类成功编译之前出现在其源代码中。 注意： 要实际编译ACMEBicycle该类，您需要将public关键字添加到已实现的接口方法的开头。稍后您将在有关类和对象以及 接口和继承的课程中了解到这样做的原因 。 什么是包（Package）？包（Package）是组织一组相关类和接口的名称空间。从概念上讲，您可以将包视为类似于计算机上的不同文件夹。您可以将 HTML 页面保存在一个文件夹中，将图像保存在另一个文件夹中，将脚本或应用程序保存在另一个文件夹中。因为用 Java 编程语言编写的软件可以由成百上千个单独的类组成，所以通过将相关的类和接口放入包中来组织事物是有意义的。 Java 平台提供了一个庞大的类库（一组包），适合在您自己的应用程序中使用。这个库被称为“应用程序编程接口”，简称“API”。它的包代表了最常与通用编程相关的任务。例如，一个String对象包含字符串的状态和行为；File对象允许程序员轻松地创建、删除、检查、比较或修改文件系统上的文件；一个Socket对象允许创建和使用网络套接字；各种 GUI 对象控制按钮和复选框以及与图形用户界面相关的任何其他内容。有数千种课程可供选择。这使您（程序员）可以专注于特定应用程序的设计，而不是使其工作所需的基础结构。 Java 平台 API 规范包含 Java SE 平台提供的所有包、接口、类、字段和方法的完整列表。 在浏览器中加载该页面并将其添加为书签。作为程序员，它将成为您最重要的参考文档。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://guoshunfa.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Oracle Java语言基础","slug":"软件开发/技术/编程语言/java/Oracle-Java语言基础","date":"2020-07-01T04:01:01.000Z","updated":"2024-01-28T11:41:39.283Z","comments":true,"path":"2020/07/Oracle-Java语言基础/","link":"","permalink":"https://guoshunfa.com/2020/07/Oracle-Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"","text":"本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。 翻译自：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html 变量对象将其状态存储在字段中。 123int cadence = 0;int speed = 0;int gear = 1; 什么是对象？ 讨论向您介绍了字段，但您可能还有一些问题，例如：命名字段的规则和约定是什么？ 除了int，还有哪些数据类型？ 字段在声明时是否必须初始化？ 如果未显式初始化，是否为字段分配了默认值？ 我们将在本课中探讨此类问题的答案，但在此之前，您必须首先了解一些技术上的区别。 在 Java 编程语言中，术语“字段”和“变量”同时使用； 这是新开发人员之间常见的混淆来源，因为两者似乎指的是同一件事。 Java 编程语言定义了以下几种变量： 实例变量（非静态字段） 从技术上讲，对象将其各自的状态存储在“非静态字段”中，即没有使用 static 关键字声明的字段。 非静态字段也称为实例变量，因为它们的值对于类的每个实例（换句话说，对于每个对象）都是唯一的； 一辆自行车的当前速度独立于另一辆自行车的当前速度。 类变量（静态字段） 类变量是用静态修饰符声明的任何字段； 这告诉编译器这个变量只存在一个副本，不管这个类被实例化了多少次。 定义特定类型自行车的档位数量的字段可以标记为静态，因为从概念上讲，相同数量的档位将适用于所有实例。 代码static int numGears &#x3D; 6; 会创建这样一个静态字段。 此外，可以添加关键字 final 以指示齿轮数永远不会改变。 局部变量 与对象在字段中存储其状态的方式类似，方法通常会将其临时状态存储在局部变量中。 声明局部变量的语法类似于声明字段（例如，int count &#x3D; 0;）。 没有特殊的关键字将变量指定为局部变量； 该决定完全来自声明变量的位置——它位于方法的左大括号和右大括号之间。 因此，局部变量仅对声明它们的方法可见； 班上其他人无法访问它们。 参数 您已经在 Bicycle 类和“Hello World!”的主要方法中看到了参数示例。 应用。 回想一下 main 方法的签名是 public static void main(String[] args)。 此处，args 变量是此方法的参数。 要记住的重要一点是参数总是被归类为“变量”而不是“字段”。 这也适用于您将在本教程后面了解的其他参数接受构造（例如构造函数和异常处理程序）。 话虽如此，本教程的其余部分在讨论字段和变量时使用以下一般准则。 如果我们在谈论“一般的字段”（不包括局部变量和参数），我们可能会简单地说“字段”。 如果讨论适用于“以上所有”，我们可以简单地说“变量”。 如果上下文需要区分，我们将酌情使用特定术语（静态字段、局部变量等）。 您可能偶尔也会看到“成员”一词的使用。 类型的字段、方法和嵌套类型统称为其成员。 命名对于允许使用的名称类型，每种编程语言都有自己的一套规则和约定，Java 编程语言也不例外。 命名变量的规则和约定可以总结如下： 变量名称区分大小写。 变量的名称可以是任何合法的标识符——一个无限长度的 Unicode 字母和数字序列，以字母、美元符号“$”或下划线字符“_”开头。 然而，约定是始终以字母开头变量名，而不是“$”或“_”。 此外，按照惯例，美元符号字符从不使用。 您可能会发现某些情况下自动生成的名称将包含美元符号，但您的变量名称应始终避免使用它。 下划线字符也存在类似的约定； 虽然以“_”开头的变量名在技术上是合法的，但不鼓励这种做法。 不允许有空白。 后续字符可以是字母、数字、美元符号或下划线字符。 惯例（和常识）也适用于此规则。 为变量选择名称时，请使用完整的单词而不是晦涩难懂的缩写。 这样做将使您的代码更易于阅读和理解。 在许多情况下，它还会使您的代码自文档化； 例如，名为 cadence、speed 和 gear 的字段比缩写版本（如 s、c 和 g）更直观。 另请记住，您选择的名称不能是关键字或保留字。 如果您选择的名称只有一个单词，请将该单词全部小写。 如果它由多个单词组成，则将每个后续单词的第一个字母大写。 名称 gearRatio 和 currentGear 是该约定的主要示例。 如果您的变量存储一个常量值，例如 static final int NUM_GEARS &#x3D; 6，则约定会略有变化，将每个字母大写并使用下划线字符分隔后续单词。 按照惯例，下划线字符从不在其他地方使用。 原始数据类型Java 编程语言是静态类型的，这意味着所有变量都必须先声明才能使用。 这涉及声明变量的类型和名称，正如您已经看到的： 1int gear = 1; 这样做会告诉您的程序存在一个名为“gear”的字段，其中包含数值数据，并且初始值为“1”。 变量的数据类型决定了它可能包含的值，以及可能对其执行的操作。 除了 int 之外，Java 编程语言还支持其他七种原始数据类型。 基本类型由语言预定义，并由保留关键字命名。 原始值不与其他原始值共享状态。 Java 编程语言支持的八种基本数据类型是： byte：byte 数据类型是一个 8 位有符号二进制补码整数。 它的最小值为 -128，最大值为 127（含）。 字节数据类型可用于在大型数组中节省内存，其中内存节省实际上很重要。 它们也可以用来代替 int ，它们的限制有助于阐明您的代码； 变量的范围是有限的这一事实可以作为一种文档形式。 short：short 数据类型是一个 16 位有符号二进制补码整数。 它的最小值为-32,768，最大值为32,767（含）。 与 byte 一样，适用相同的准则：在内存节省实际很重要的情况下，您可以使用 short 来节省大型数组中的内存。 int：默认情况下，int数据类型是一个32位有符号二进制补码整数，最小值为-2^31^，最大值为2^31^-1。 在 Java SE 8 及之后的版本中，可以使用 int 数据类型来表示一个无符号的 32 位整数，最小值为 0，最大值为 2^32^-1。 使用 Integer 类将 int 数据类型用作无符号整数。 有关详细信息，请参阅数字类部分。 Integer 类中添加了 compareUnsigned、divideUnsigned 等静态方法，以支持无符号整数的算术运算。 long：long 数据类型是一个 64 位二进制补码整数。 signed long 的最小值为 -2^63^，最大值为 2^63^-1。 在 Java SE 8 及之后的版本中，可以使用 long 数据类型来表示无符号的 64 位 long，其最小值为 0，最大值为 2^64^-1。 当您需要的值范围比 int 提供的范围更宽时，请使用此数据类型。 Long 类还包含 compareUnsigned、divideUnsigned 等方法来支持 unsigned long 的算术运算。 float：float 数据类型是单精度 32 位 IEEE 754 浮点数。 它的取值范围超出了本次讨论的范围，但在 Java 语言规范的浮点类型、格式和值部分中进行了指定。 对于 byte 和 short 的建议，如果您需要在大型浮点数数组中节省内存，请使用 float（而不是 double）。 这种数据类型不应该用于精确值，例如货币。为此，您需要改用 java.math.BigDecimal 类。 Numbers和and Strings涵盖了 BigDecimal 和 Java 平台提供的其他有用的类。 double：double 数据类型是双精度 64 位 IEEE 754 浮点数。 它的取值范围超出了本次讨论的范围，但在 Java 语言规范的浮点类型、格式和值部分中进行了指定。 对于十进制值，此数据类型通常是默认选择。 如上所述，这种数据类型不应该用于精确值，例如货币。 boolean：布尔数据类型只有两个可能的值：true 和 false。 将此数据类型用于跟踪真&#x2F;假条件的简单标志。 这种数据类型代表一位信息，但它的“大小”并不是精确定义的。 char：char 数据类型是单个 16 位 Unicode 字符。 它的最小值为 ‘\\u0000’（或 0），最大值为 ‘\\uffff’（或 65,535）。 除了上面列出的八种基本数据类型之外，Java 编程语言还通过 java.lang.String 类提供了对字符串的特殊支持。 将字符串括在双引号内将自动创建一个新的 String 对象； 例如，String s &#x3D; “this is a string”;。 字符串对象是不可变的，这意味着一旦创建，它们的值就无法更改。 String 类在技术上不是原始数据类型，但考虑到语言对它的特殊支持，您可能倾向于这样认为。 默认值声明字段时并不总是需要赋值。 已声明但未初始化的字段将由编译器设置为合理的默认值。 一般来说，此默认值将为零或空值，具体取决于数据类型。 然而，依赖于这样的默认值通常被认为是糟糕的编程风格。 下表总结了上述数据类型的默认值。 数据类型 默认值 (for fields) byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char ‘\\u0000’ String (or any object) null boolean false 局部变量略有不同； 编译器永远不会为未初始化的局部变量分配默认值。 如果您不能在声明局部变量的地方对其进行初始化，请确保在尝试使用它之前为其分配一个值。 访问未初始化的局部变量将导致编译时错误。 文字您可能已经注意到，在初始化原始类型的变量时没有使用 new 关键字。 原始类型是语言中内置的特殊数据类型； 它们不是从类创建的对象。 文字是固定值的源代码表示； 文字直接在您的代码中表示，无需计算。 如下所示，可以将文字分配给原始类型的变量： 12345boolean result = true;char capitalC = &#x27;C&#x27;;byte b = 100;short s = 10000;int i = 100000; 整数文字如果整数文字以字母 L 或 l 结尾，则它是 long 类型； 否则它是int类型。 建议您使用大写字母 L，因为小写字母 l 很难与数字 1 区分开来。 整数类型 byte、short、int 和 long 的值可以从 int 文字创建。 可以从 long 文字创建超出 int 范围的 long 类型的值。 整数文字可以用这些数字系统表示： 十进制：以 10 为底，其数字由数字 0 到 9 组成； 这是你每天使用的数字。 十六进制：基数为 16，其数字由数字 0 到 9 和字母 A 到 F 组成。 二进制：基数为 2，其数字由数字 0 和 1 组成（您可以在 Java SE 7 及更高版本中创建二进制文字）。 对于通用编程，十进制系统可能是您将使用的唯一数字系统。 但是，如果您需要使用其他数字系统，以下示例显示了正确的语法。 前缀 0x 表示十六进制，0b 表示二进制： 123456// The number 26, 10进制int decVal = 26;// The number 26, 16进制int hexVal = 0x1a;// The number 26, 2进制int binVal = 0b11010; 浮点文字如果浮点文字以字母 F 或 f 结尾，则它是 float 类型； 否则它的类型是 double 并且它可以选择以字母 D 或 d 结尾。 浮点类型（float 和 double）也可以使用 E 或 e（科学记数法）、F 或 f（32 位浮点数）和 D 或 d（64 位双精度数；这是默认值，由 公约被省略）。 1234double d1 = 123.4;// 与 d1 相同的值，但采用科学记数法double d2 = 1.234e2;float f1 = 123.4f; 字符和字符串文字char 和 String 类型的文字可以包含任何 Unicode (UTF-16) 字符。 如果您的编辑器和文件系统允许，您可以直接在代码中使用这些字符。 如果不是，您可以使用“Unicode 转义符”，例如“\\u0108”（带抑扬音符的大写 C）或“S\\u00ED Se\\u00F1or”（西班牙语中的 Sí Señor）。 始终对字符文字使用“单引号”，对字符串文字使用“双引号”。 Unicode 转义序列可以在程序的其他地方使用（例如在字段名称中），而不仅仅是在 char 或 String 文字中。 Java 编程语言还支持 char 和 String 文字的一些特殊转义序列：\\b（退格键）、\\t（制表符）、\\n（换行符）、\\f（换页符）、\\r（回车符）、 &quot;（双引号）、&#39;（单引号）和 \\（反斜杠）。 还有一个特殊的 null 文字，可以用作任何引用类型的值。 null 可以分配给任何变量，原始类型的变量除外。 除了测试空值的存在之外，您几乎无能为力。 因此，null 在程序中经常被用作标记，表示某个对象不可用。 最后，还有一种特殊的文字，称为类文字，通过获取类型名称并附加“.class”形成； 例如，String.class。 这是指表示类型本身的对象（类类型）。 在数字文字中使用下划线字符在 Java SE 7 及更高版本中，任意数量的下划线字符 (_) 可以出现在数字文字中数字之间的任何位置。 例如，此功能使您能够。 分隔数字文字中的数字组，这可以提高代码的可读性。 例如，如果您的代码包含多位数的数字，您可以使用下划线字符将数字分成三组，类似于使用逗号或空格等标点符号作为分隔符。 以下示例显示了您可以在数字文字中使用下划线的其他方式： 12345678long creditCardNumber = 1234_5678_9012_3456L;long socialSecurityNumber = 999_99_9999L;float pi = 3.14_15F;long hexBytes = 0xFF_EC_DE_5E;long hexWords = 0xCAFE_BABE;long maxLong = 0x7fff_ffff_ffff_ffffL;byte nybbles = 0b0010_0101;long bytes = 0b11010010_01101001_10010100_10010010; 您只能在数字之间放置下划线； 您不能在以下位置放置下划线： 在数字的开头或结尾。 与浮点文字中的小数点相邻。 在 F 或 L 后缀之前。 在需要一串数字的位置。 以下示例演示了数字文字中有效和无效的下划线放置（突出显示）： 1234567891011121314151617181920212223242526272829// 无效：不能放下划线// 小数点附近float pi1 = 3_.1415F;// 无效：不能放下划线// 小数点附近float pi2 = 3._1415F;// 无效：不能放下划线 // 在 L 后缀之前long socialSecurityNumber1 = 999_99_9999_L;// OK (十进制文字)int x1 = 5_2;// 无效：不能放下划线// 在文字的结尾int x2 = 52_;// OK (十进制文字)int x3 = 5_______2;// 无效：不能放下划线// 在 0x 基数前缀int x4 = 0_x52;// 无效：不能放下划线// 在数字的开头int x5 = 0x_52;// OK (十进制文字)int x6 = 0x5_2; // 无效：不能放下划线// 在数字的末尾int x7 = 0x52_; 数组数组是一个容器对象，它包含固定数量的单个类型的值。阵列的长度是在创建阵列时确定的。创建后，其长度是固定的。您已经在“Hello World！”的主方法中看到了一个数组示例应用本节将更详细地讨论数组。 数组中的每个项都称为元素，每个元素都通过其数字索引进行访问。如上图所示，编号从0开始。例如，第9个元素将在索引8处访问。 下面的程序ArrayDemo创建一个整数数组，在数组中放入一些值，并将每个值打印到标准输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class ArrayDemo &#123; public static void main(String[] args) &#123; // declares an array of integers int[] anArray; // allocates memory for 10 integers anArray = new int[10]; // initialize first element anArray[0] = 100; // initialize second element anArray[1] = 200; // and so forth anArray[2] = 300; anArray[3] = 400; anArray[4] = 500; anArray[5] = 600; anArray[6] = 700; anArray[7] = 800; anArray[8] = 900; anArray[9] = 1000; System.out.println(&quot;Element at index 0: &quot; + anArray[0]); System.out.println(&quot;Element at index 1: &quot; + anArray[1]); System.out.println(&quot;Element at index 2: &quot; + anArray[2]); System.out.println(&quot;Element at index 3: &quot; + anArray[3]); System.out.println(&quot;Element at index 4: &quot; + anArray[4]); System.out.println(&quot;Element at index 5: &quot; + anArray[5]); System.out.println(&quot;Element at index 6: &quot; + anArray[6]); System.out.println(&quot;Element at index 7: &quot; + anArray[7]); System.out.println(&quot;Element at index 8: &quot; + anArray[8]); System.out.println(&quot;Element at index 9: &quot; + anArray[9]); &#125;&#125; 该程序的输出为： 12345678910Element at index 0: 100Element at index 1: 200Element at index 2: 300Element at index 3: 400Element at index 4: 500Element at index 5: 600Element at index 6: 700Element at index 7: 800Element at index 8: 900Element at index 9: 1000 在真实的编程环境中，您可能会使用一个受支持的循环结构来迭代数组的每个元素，而不是像前面的示例那样单独编写每一行。然而，该示例清楚地说明了数组语法。您将在“ Control Flow ”部分了解各种循环构造（for、while和do while）。 声明变量以引用数组前面的程序使用以下代码行声明一个数组（名为anArray）： 12// declares an array of integersint[] anArray; 与其他类型变量的声明一样，数组声明有两个组件：数组的类型和数组的名称。数组的类型写成type[]，其中type是所包含元素的数据类型；括号是特殊符号，表示此变量包含一个数组。数组的大小不是其类型的一部分（这就是括号为空的原因）。数组的名称可以是您想要的任何名称，前提是它遵循前面在命名部分中讨论的规则和约定。与其他类型的变量一样，声明实际上并不创建数组；它只是告诉编译器这个变量将保存一个指定类型的数组。 类似地，您可以声明其他类型的数组： 12345678byte[] anArrayOfBytes;short[] anArrayOfShorts;long[] anArrayOfLongs;float[] anArrayOfFloats;double[] anArrayOfDoubles;boolean[] anArrayOfBooleans;char[] anArrayOfChars;String[] anArrayOfStrings; 您也可以将括号放在数组名称后面： 12// 不建议使用此表格float anArrayOfFloats[]; 然而，惯例不鼓励这种形式；括号标识数组类型，并应与类型名称一起出现。 创建、初始化和访问数组创建数组的一种方法是使用新运算符。ArrayDemo程序中的下一条语句为一个数组分配足够的内存，可容纳10个整数元素，并将数组分配给anArray变量。 12// create an array of integersanArray = new int[10]; 如果缺少此语句，编译器将打印如下错误，编译将失败： 1ArrayDemo.java:4: Variable anArray may not have been initialized. 接下来的几行代码为数组的每个元素赋值： 123anArray[0] = 100; // initialize first elementanArray[1] = 200; // initialize second elementanArray[2] = 300; // and so forth 每个数组元素都通过其数字索引进行访问： 123System.out.println(&quot;Element 1 at index 0: &quot; + anArray[0]);System.out.println(&quot;Element 2 at index 1: &quot; + anArray[1]);System.out.println(&quot;Element 3 at index 2: &quot; + anArray[2]); 或者，您可以使用快捷方式语法创建和初始化数组： 12345int[] anArray = &#123; 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125;; 这里，数组的长度由大括号之间提供的值的数量决定，并用逗号分隔。 您还可以通过使用两组或多组括号（如String[][]名称）来声明数组数组（也称为多维数组）。因此，每个元素必须由相应数量的索引值访问。 在Java编程语言中，多维数组是其组件本身就是数组的数组。这与C或Fortran中的数组不同。其结果是，允许行的长度变化，如以下MultiDimArrayDemo程序所示： 123456789101112class MultiDimArrayDemo &#123; public static void main(String[] args) &#123; String[][] names = &#123; &#123;&quot;Mr. &quot;, &quot;Mrs. &quot;, &quot;Ms. &quot;&#125;, &#123;&quot;Smith&quot;, &quot;Jones&quot;&#125; &#125;; // Mr. Smith System.out.println(names[0][0] + names[1][0]); // Ms. Jones System.out.println(names[0][2] + names[1][1]); &#125;&#125; 该程序的输出为： 12Mr. SmithMs. Jones 最后，您可以使用内置的length属性来确定任何数组的大小。以下代码将数组的大小打印为标准输出： 1System.out.println(anArray.length); 复制数组System类有一个arraycopy方法，您可以使用该方法将数据从一个数组高效地复制到另一个数组： 12public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 两个Object参数指定要从中复制的数组和要复制到的数组。三个int参数指定源数组中的起始位置、目标数组中的开始位置以及要复制的数组元素数。 下面的程序ArrayCopyDemo声明了一个String元素数组。它使用系统。arraycopy方法，用于将阵列组件的子序列复制到第二阵列中： 1234567891011121314class ArrayCopyDemo &#123; public static void main(String[] args) &#123; String[] copyFrom = &#123; &quot;Affogato&quot;, &quot;Americano&quot;, &quot;Cappuccino&quot;, &quot;Corretto&quot;, &quot;Cortado&quot;, &quot;Doppio&quot;, &quot;Espresso&quot;, &quot;Frappucino&quot;, &quot;Freddo&quot;, &quot;Lungo&quot;, &quot;Macchiato&quot;, &quot;Marocchino&quot;, &quot;Ristretto&quot; &#125;; String[] copyTo = new String[7]; System.arraycopy(copyFrom, 2, copyTo, 0, 7); for (String coffee : copyTo) &#123; System.out.print(coffee + &quot; &quot;); &#125; &#125;&#125; 该程序的输出为： 1Cappuccino Corretto Cortado Doppio Espresso Frappucino Freddo 数组操控数组是编程中使用的一个强大而有用的概念。JavaSE提供了执行与数组相关的一些最常见操作的方法。例如，ArrayCopyDemo示例使用System类的arraycopy方法，而不是手动迭代源数组的元素并将每个元素放入目标数组。这是在幕后执行的，使开发人员能够只使用一行代码来调用该方法。 为了方便起见，JavaSE提供了几种在Java.util中执行数组操作（常见任务，如复制、排序和搜索数组）的方法在java.util.Arrays 类。例如，可以修改前面的示例以使用java.util的copyOfRange方法。Arrays类，如ArrayCopyOfDemo示例中所示。不同之处在于，使用copyOfRange方法不需要在调用该方法之前创建目标数组，因为目标数组由该方法返回： 12345678910111213class ArrayCopyOfDemo &#123; public static void main(String[] args) &#123; String[] copyFrom = &#123; &quot;Affogato&quot;, &quot;Americano&quot;, &quot;Cappuccino&quot;, &quot;Corretto&quot;, &quot;Cortado&quot;, &quot;Doppio&quot;, &quot;Espresso&quot;, &quot;Frappucino&quot;, &quot;Freddo&quot;, &quot;Lungo&quot;, &quot;Macchiato&quot;, &quot;Marocchino&quot;, &quot;Ristretto&quot; &#125;; String[] copyTo = java.util.Arrays.copyOfRange(copyFrom, 2, 9); for (String coffee : copyTo) &#123; System.out.print(coffee + &quot; &quot;); &#125; &#125;&#125; 正如您所看到的，这个程序的输出是相同的，尽管它需要更少的代码行。请注意，copyOfRange方法的第二个参数是要复制的范围的初始索引（包括在内），而第三个参数则是要复制范围的最终索引（排他）。在本例中，要复制的范围不包括索引9处的数组元素（其中包含字符串Lungo）。 java.util.Arrays 类中的方法提供的一些其他有用操作： 在数组中搜索特定值，以获得放置该值的索引（binarySearch方法）。 比较两个数组以确定它们是否相等（equals方法）。 填充数组以在每个索引处放置特定值（填充方法）。 将数组按升序排序。这可以使用排序方法按顺序进行，也可以使用Java SE 8中引入的并行排序方法同时进行。多处理器系统上大型数组的并行排序比顺序数组排序更快。 创建使用数组作为源的流（流方法）。例如，以下语句以与上一示例相同的方式打印copyTo数组的内容： 1java.util.Arrays.stream(copyTo).map(coffee -&gt; coffee + &quot; &quot;).forEach(System.out::print); 有关流的更多信息，请参见Aggregate Operations（聚合操作）。 将数组转换为字符串。toString方法将数组的每个元素转换为字符串，用逗号分隔，然后用括号括起来。例如，以下语句将copyTo数组转换为字符串并打印： 1System.out.println(java.util.Arrays.toString(copyTo)); 此语句打印以下内容： 1[Cappuccino, Corretto, Cortado, Doppio, Espresso, Frappucino, Freddo] 变量汇总Java编程语言使用“字段”和“变量”作为其术语的一部分。实例变量（非静态字段）对于类的每个实例都是唯一的。类变量（静态字段）是用静态修饰符声明的字段；无论类被实例化多少次，类变量只有一个副本。局部变量在方法中存储临时状态。参数是为方法提供额外信息的变量；局部变量和参数总是被分类为“变量”（而不是“字段”）。在命名字段或变量时，您应该（或必须）遵循一些规则和约定。 八种基本数据类型是：字节、短、整数、长、浮点、双精度、布尔和字符。java.lang.String类表示字符串。编译器将为上述类型的字段指定一个合理的默认值；对于局部变量，从不指定默认值。文字是固定值的源代码表示。数组是一个容器对象，它包含固定数量的单个类型的值。阵列的长度是在创建阵列时确定的。创建后，其长度是固定的。 运算符既然您已经学习了如何声明和初始化变量，那么您可能想知道如何处理它们。学习Java编程语言的操作符是一个很好的开始。运算符是对一个、两个或三个操作数执行特定操作，然后返回结果的特殊符号。 当我们探索Java编程语言的运算符时，提前知道哪些运算符具有最高优先级可能会有所帮助。下表中的运算符按优先顺序列出。运算符越靠近表格顶部，其优先级越高。优先级较高的运算符在优先级相对较低的运算符之前进行评估。同一行上的运算符具有同等优先级。当同等优先级的运算符出现在同一表达式中时，必须有一个规则来控制哪个运算符首先被求值。除赋值运算符外的所有二进制运算符都从左到右求值；赋值运算符从右向左求值。 运算符优先级 运算符 Precedence postfix（在后面加） expr++ expr-- unary（一元的） ++expr --expr +expr -expr ~ ! multiplicative（乘 除 取余） * / % additive（加减） + - shift（移动） &lt;&lt; &gt;&gt; &gt;&gt;&gt; relational（相关的） &lt; &gt; &lt;= &gt;= instanceof equality（等式 不等式） == != bitwise AND（按位与） &amp; bitwise exclusive OR（按位异或） ^ bitwise inclusive OR（按位包含） &#96; logical AND（逻辑与） &amp;&amp; logical OR（逻辑或） &#96; ternary（三元运算） ? : assignment（分配） &#96;&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D; 在通用编程中，某些运算符往往比其他运算符出现得更频繁；例如，赋值运算符“&#x3D;”比无符号右移运算符“&gt;&gt;&gt;”更常见。考虑到这一点，下面的讨论首先关注您最有可能经常使用的运算符，最后关注那些不太常见的运算符。每一次讨论都附带了可以编译和运行的示例代码。研究它的输出将有助于巩固你刚刚学到的东西。 赋值、算术和一元运算符简单赋值运算符您将遇到的最常见的运算符之一是简单赋值运算符“&#x3D;”。你在自行车课上见过这个操作员；它将右侧的值指定给左侧的操作数： 123int cadence = 0;int speed = 0;int gear = 1; 该操作符还可以用于对象以指定对象引用，如创建对象中所述。 算术运算符Java编程语言提供了执行加法、减法、乘法和除法的运算符。你很有可能会通过基础数学中的同龄人认出他们。唯一对您来说可能是新的符号是“%”，它将一个操作数除以另一个操作，并返回余数作为结果。 运算符 描述 + 加法运算符（也用于字符串连接） - 减法运算符 * 乘法运算符 / 除法运算符 % 余数运算符 下面的程序ArithmeticDemo测试算术运算符。 12345678910111213141516171819202122232425262728293031323334class ArithmeticDemo &#123; public static void main (String[] args) &#123; int result = 1 + 2; // result is now 3 System.out.println(&quot;1 + 2 = &quot; + result); int original_result = result; result = result - 1; // result is now 2 System.out.println(original_result + &quot; - 1 = &quot; + result); original_result = result; result = result * 2; // result is now 4 System.out.println(original_result + &quot; * 2 = &quot; + result); original_result = result; result = result / 2; // result is now 2 System.out.println(original_result + &quot; / 2 = &quot; + result); original_result = result; result = result + 8; // result is now 10 System.out.println(original_result + &quot; + 8 = &quot; + result); original_result = result; result = result % 7; // result is now 3 System.out.println(original_result + &quot; % 7 = &quot; + result); &#125;&#125; 此程序打印以下内容： 1234561 + 2 = 33 - 1 = 22 * 2 = 44 / 2 = 22 + 8 = 1010 % 7 = 3 您还可以将算术运算符与简单赋值运算符组合以创建复合赋值。例如，x+&#x3D;1；并且x＝x+1；两者都将x的值增加1。 +运算符还可以用于将两个字符串连接在一起，如以下ConcatDemo程序所示： 12345678class ConcatDemo &#123; public static void main(String[] args)&#123; String firstString = &quot;This is&quot;; String secondString = &quot; a concatenated string.&quot;; String thirdString = firstString+secondString; System.out.println(thirdString); &#125;&#125; 在这个程序结束时，变量thirdString包含“this is a concatenated string.”，它将被打印到标准输出。 一元运算符一元运算符只需要一个操作数；它们执行各种操作，例如将值递增&#x2F;递减1、对表达式求反或反转布尔值。 运算符 描述 + 一元加运算符；表示正值（但是，如果没有正值，则数字为正值） - 一元减号运算符；否定表达式 ++ 增量运算符；将一个值递增1 -- 递减运算符；将值递减1 ! 逻辑补码运算符；反转布尔值 以下程序UnaryDemo测试一元运算符： 123456789101112131415161718192021222324252627class UnaryDemo &#123; public static void main(String[] args) &#123; int result = +1; // result is now 1 System.out.println(result); result--; // result is now 0 System.out.println(result); result++; // result is now 1 System.out.println(result); result = -result; // result is now -1 System.out.println(result); boolean success = false; // false System.out.println(success); // true System.out.println(!success); &#125;&#125; 递增&#x2F;递减运算符可以应用于操作数之前（前缀）或之后（后缀）。代码结果++；和++结果；结果都将增加一。唯一的区别是前缀版本（++结果）的计算结果为递增值，而后缀版本（结果++）的计算值为原始值。如果您只是执行一个简单的递增&#x2F;递减，那么选择哪个版本并不重要。但是，如果在更大的表达式中使用此运算符，则选择的表达式可能会产生显著的差异。 以下程序PrePostDemo演示了前缀&#x2F;后缀一元增量运算符： 1234567891011121314151617class PrePostDemo &#123; public static void main(String[] args)&#123; int i = 3; i++; // prints 4 System.out.println(i); ++i; // prints 5 System.out.println(i); // prints 6 System.out.println(++i); // prints 6 System.out.println(i++); // prints 7 System.out.println(i); &#125;&#125; 相等运算符、关系运算符和条件运算符等式和关系运算符相等运算符和关系运算符确定一个操作数是否大于、小于、等于或不等于另一个操作。这些操作员中的大多数可能对您也很熟悉。请记住，在测试两个基本值是否相等时，必须使用“&#x3D;&#x3D;”，而不是“&#x3D;”。 123456== equal to!= not equal to&gt; greater than&gt;= greater than or equal to&lt; less than&lt;= less than or equal to 以下程序ComparisonDemo测试比较运算符： 1234567891011121314151617class ComparisonDemo &#123; public static void main(String[] args)&#123; int value1 = 1; int value2 = 2; if(value1 == value2) System.out.println(&quot;value1 == value2&quot;); if(value1 != value2) System.out.println(&quot;value1 != value2&quot;); if(value1 &gt; value2) System.out.println(&quot;value1 &gt; value2&quot;); if(value1 &lt; value2) System.out.println(&quot;value1 &lt; value2&quot;); if(value1 &lt;= value2) System.out.println(&quot;value1 &lt;= value2&quot;); &#125;&#125; Output: 123value1 != value2value1 &lt; value2value1 &lt;= value2 条件运算符&amp;&amp;和||运算符对两个布尔表达式执行条件and和条件OR运算。这些运算符表现出“短路”行为，这意味着只有在需要时才计算第二个操作数。 12&amp;&amp; Conditional-AND|| Conditional-OR 以下程序ConditionalDemo1测试这些运算符： 1234567891011class ConditionalDemo1 &#123; public static void main(String[] args)&#123; int value1 = 1; int value2 = 2; if((value1 == 1) &amp;&amp; (value2 == 2)) System.out.println(&quot;value1 is 1 AND value2 is 2&quot;); if((value1 == 1) || (value2 == 1)) System.out.println(&quot;value1 is 1 OR value2 is 1&quot;); &#125;&#125; 另一个条件运算符是 ?: ，它可以被认为是if-then-else语句的简写（在本课的控制流语句部分中讨论）。此运算符也称为三元运算符，因为它使用三个操作数。在下面的示例中，该运算符应理解为：“如果someCondition为true，则将value1的值赋给result。否则，将value2的值赋为result” 以下程序ConditionalDemo2测试 ?: 操作员： 123456789101112class ConditionalDemo2 &#123; public static void main(String[] args)&#123; int value1 = 1; int value2 = 2; int result; boolean someCondition = true; result = someCondition ? value1 : value2; System.out.println(result); &#125;&#125; 由于someCondition为true，此程序将“1”打印到屏幕上。使用 ?: 运算符而不是if-then-else语句，如果它使代码更可读；例如，当表达式紧凑且没有副作用（如赋值）时。 类型比较运算符实例instanceof运算符将对象与指定类型进行比较。您可以使用它来测试对象是类的实例、子类的实例还是实现特定接口的类的实例。 下面的程序InstanceofDemo定义了一个父类（名为parent）、一个简单接口（名为MyInterface）和一个从父类继承并实现接口的子类（名child）。 123456789101112131415161718192021222324class InstanceofDemo &#123; public static void main(String[] args) &#123; Parent obj1 = new Parent(); Parent obj2 = new Child(); System.out.println(&quot;obj1 instanceof Parent: &quot; + (obj1 instanceof Parent)); System.out.println(&quot;obj1 instanceof Child: &quot; + (obj1 instanceof Child)); System.out.println(&quot;obj1 instanceof MyInterface: &quot; + (obj1 instanceof MyInterface)); System.out.println(&quot;obj2 instanceof Parent: &quot; + (obj2 instanceof Parent)); System.out.println(&quot;obj2 instanceof Child: &quot; + (obj2 instanceof Child)); System.out.println(&quot;obj2 instanceof MyInterface: &quot; + (obj2 instanceof MyInterface)); &#125;&#125;class Parent &#123;&#125;class Child extends Parent implements MyInterface &#123;&#125;interface MyInterface &#123;&#125; Output: 123456obj1 instanceof Parent: trueobj1 instanceof Child: falseobj1 instanceof MyInterface: falseobj2 instanceof Parent: trueobj2 instanceof Child: trueobj2 instanceof MyInterface: true 使用instanceof运算符时，请记住null不是任何东西的实例。 位和位移位运算符Java编程语言还提供了对整型执行逐位和移位操作的运算符。本节中讨论的运算符不太常用。因此，他们的报道很简短；其目的只是让您意识到这些操作符的存在。 一元逐位补码运算符“~”反转位模式；它可以应用于任何一种积分类型，使每个“0”都成为“1”，每个“1”都变成“0”。例如，一个字节包含8位；将该运算符应用于位模式为“00000000”的值将其模式更改为“11111111”。 有符号左移位运算符“&lt;&lt;”向左移位位模式，有符号右移位运算符“&gt;&gt;”向右移位位模式。位模式由左侧操作数给出，而要移位的位置数由右侧操作数给出。无符号右移运算符“&gt;&gt;&gt;”将零移到最左位置，而“&gt;&gt;”之后的最左位置取决于符号扩展。 按位 &amp; 运算符执行按位AND运算。 按位 ^ 运算符执行按位异或运算。 按位 | 运算符执行按位包含的OR运算。 以下程序BitDemo使用按位AND运算符将数字“2”打印到标准输出。 12345678class BitDemo &#123; public static void main(String[] args) &#123; int bitmask = 0x000F; int val = 0x2222; // prints &quot;2&quot; System.out.println(val &amp; bitmask); &#125;&#125; 运算符总结下面的快速参考总结了Java编程语言支持的运算符。 简单赋值运算符1= 简单赋值运算符 算术运算符12345+ 加法运算符（也用于字符串连接）- 减法运算符* 乘法运算符/ 除法运算符% 余数运算符 单目运算符12345+ 一元加运算符；表示正值（数字为正值，但没有此值）- 一元减运算符；否定表达式++ 增量运算符；将值递增1-- 减量运算符；将值递减1! 逻辑补码运算符；反转布尔值 等式和关系运算符123456== Equal to!= Not equal to&gt; Greater than&gt;= Greater than or equal to&lt; Less than&lt;= Less than or equal to 条件运算符1234&amp;&amp; Conditional-AND|| Conditional-OR?: Ternary (shorthand for if-then-else statement) 类型比较运算符12instanceof Compares an object to a specified type 位和位移位运算符1234567~ Unary bitwise complement&lt;&lt; Signed left shift&gt;&gt; Signed right shift&gt;&gt;&gt; Unsigned right shift&amp; Bitwise AND^ Bitwise exclusive OR| Bitwise inclusive OR 表达式、语句和块既然您了解了变量和运算符，现在是学习表达式、语句和块的时候了。运算符可以用于构建计算值的表达式；表达式是语句的核心组成部分；语句可以被分组为块。 表达式表达式是一种由变量、运算符和方法调用组成的构造，它们根据语言的语法构造，并计算为单个值。您已经看到了表达式的示例，如下所示： 1234567int cadence = 0;anArray[0] = 100;System.out.println(&quot;Element 1 at index 0: &quot; + anArray[0]);int result = 1 + 2; // result is now 3if (value1 == value2) System.out.println(&quot;value1 == value2&quot;); 表达式返回的值的数据类型取决于表达式中使用的元素。表达式cadence&#x3D;0返回int，因为赋值运算符返回的数据类型与其左手操作数相同；在这种情况下，cadence是一个int。从其他表达式可以看出，表达式也可以返回其他类型的值，例如布尔值或字符串。 Java编程语言允许您从各种较小的表达式构造复合表达式，只要表达式的一部分所需的数据类型与另一部分的数据类型匹配。下面是一个复合表达式的示例： 11 * 2 * 3 在这个特定的例子中，表达式的求值顺序并不重要，因为乘法的结果与顺序无关；结果总是相同的，不管你用哪个顺序进行乘法。然而，并非所有表达式都是如此。例如，以下表达式会给出不同的结果，具体取决于您是先执行加法运算还是先执行除法运算： 1x + y / 100 // ambiguous 您可以使用平衡括号（和）精确指定表达式的求值方式。例如，要使前面的表达式明确，可以编写以下内容： 1(x + y) / 100 // unambiguous, recommended 如果没有明确指示要执行的操作的顺序，则顺序由分配给表达式中使用的运算符的优先级决定。优先级较高的运算符将首先计算。例如，除法运算符的优先级高于加法运算符。因此，以下两种说法是等价的： 1234x + y / 100 x + (y / 100) // unambiguous, recommended 在编写复合表达式时，要明确，并用括号指明应首先计算哪些运算符。这种做法使代码更易于阅读和维护。 语句语句大致相当于自然语言中的句子。语句构成一个完整的执行单元。通过用分号（；）终止表达式，可以将以下类型的表达式转换为语句。 赋值表达式 任何使用 ++ 或 -- Method调用 对象创建表达式 这种语句称为表达式语句。下面是一些表达式语句的示例。 12345678// 赋值语句aValue = 8933.234;// 增量语句aValue++;// 方法调用语句System.out.println(&quot;Hello World!&quot;);// 对象创建语句Bicycle myBike = new Bicycle(); 除了表达式语句之外，还有其他两种语句：声明语句和控制流语句。声明语句声明变量。您已经看到了许多声明语句的示例： 12// declaration statementdouble aValue = 8933.234; 最后，控制流语句调节语句的执行顺序。您将在下一节“Control Flow Statements”中了解控制流语句 块块是平衡大括号之间的一组零个或多个语句，可以在任何允许使用单个语句的地方使用。以下示例BlockDemo说明了块的使用： 1234567891011class BlockDemo &#123; public static void main(String[] args) &#123; boolean condition = true; if (condition) &#123; // begin block 1 System.out.println(&quot;Condition is true.&quot;); &#125; // end block one else &#123; // begin block 2 System.out.println(&quot;Condition is false.&quot;); &#125; // end block 2 &#125;&#125; 控制流程语句源文件中的语句通常按出现的顺序从上到下执行。然而，控制流语句通过采用决策、循环和分支来分解执行流，使程序能够有条件地执行特定的代码块。本节描述Java编程语言支持的决策语句（if-then、if-then-else、switch）、循环语句（for、while、do-while）和分支语句（break、continue、return）。 if-then语句if-then语句是所有控制流语句中最基本的。它告诉您的程序只有在特定测试的结果为true时才执行某段代码。例如，自行车类只能在自行车已经在运动时才允许制动器降低自行车的速度。applyBrakes方法的一种可能实现方式如下： 1234567void applyBrakes() &#123; // the &quot;if&quot; clause: bicycle must be moving if (isMoving)&#123; // the &quot;then&quot; clause: decrease current speed currentSpeed--; &#125;&#125; 如果此测试的结果为false（表示自行车不在运动中），则控制跳到If-then语句的末尾。 此外，如果“then”子句只包含一条语句，则左大括号和右大括号是可选的： 12345void applyBrakes() &#123; // same as above, but without braces if (isMoving) currentSpeed--;&#125; 决定何时省略括号是个人开发习惯的问题。省略它们会使代码更加脆弱。如果后来在“then”子句中添加了第二条语句，一个常见的错误就是忘记添加新需要的大括号。编译器无法捕获此类错误；你只会得到错误的结果。 if-then-else语句当“if”子句的计算结果为false时，if-then-else语句提供了执行的辅助路径。如果在自行车不运动时应用了制动器，您可以在applyBrakes方法中使用if-then-else语句来采取一些措施。在这种情况下，只需打印一条错误消息，说明自行车已经停止。 1234567void applyBrakes() &#123; if (isMoving) &#123; currentSpeed--; &#125; else &#123; System.err.println(&quot;The bicycle has already stopped!&quot;); &#125; &#125; 以下程序IfElseDemo根据测试分数的值分配分数：a表示90%或以上，B表示80%或以上，依此类推。 1234567891011121314151617181920class IfElseDemo &#123; public static void main(String[] args) &#123; int testscore = 76; char grade; if (testscore &gt;= 90) &#123; grade = &#x27;A&#x27;; &#125; else if (testscore &gt;= 80) &#123; grade = &#x27;B&#x27;; &#125; else if (testscore &gt;= 70) &#123; grade = &#x27;C&#x27;; &#125; else if (testscore &gt;= 60) &#123; grade = &#x27;D&#x27;; &#125; else &#123; grade = &#x27;F&#x27;; &#125; System.out.println(&quot;Grade = &quot; + grade); &#125;&#125; 程序的输出为： 1Grade = C 您可能已经注意到testscore的值可以满足复合语句中的多个表达式：76&gt;&#x3D;70和76&gt;&#x3D;60。但是，一旦满足条件，就会执行相应的语句（grade&#x3D;’C’；）并且不评估其余条件。 switch语句与if-then和if-then-else语句不同，switch语句可以有许多可能的执行路径。开关用于byte、short、char和int原始数据类型。它还可以与枚举类型（在枚举类型中讨论）、String类以及包装某些基本类型的几个特殊类一起使用：Character, Byte, Short, and Integer（在Numbers and Strings中讨论）。 下面的代码示例SwitchDemo声明了一个名为month的int，其值表示月份。代码使用switch语句根据月份的值显示月份的名称。 123456789101112131415161718192021222324252627282930313233343536public class SwitchDemo &#123; public static void main(String[] args) &#123; int month = 8; String monthString; switch (month) &#123; case 1: monthString = &quot;January&quot;; break; case 2: monthString = &quot;February&quot;; break; case 3: monthString = &quot;March&quot;; break; case 4: monthString = &quot;April&quot;; break; case 5: monthString = &quot;May&quot;; break; case 6: monthString = &quot;June&quot;; break; case 7: monthString = &quot;July&quot;; break; case 8: monthString = &quot;August&quot;; break; case 9: monthString = &quot;September&quot;; break; case 10: monthString = &quot;October&quot;; break; case 11: monthString = &quot;November&quot;; break; case 12: monthString = &quot;December&quot;; break; default: monthString = &quot;Invalid month&quot;; break; &#125; System.out.println(monthString); &#125;&#125; 在这种情况下，八月被打印为标准输出。 switch语句的主体称为switch块。开关块中的语句可以用一个或多个大小写或默认标签进行标记。switch语句计算其表达式，然后执行匹配大小写标签后面的所有语句。 您还可以使用if-then-else语句显示月份名称： 1234567int month = 8;if (month == 1) &#123; System.out.println(&quot;January&quot;);&#125; else if (month == 2) &#123; System.out.println(&quot;February&quot;);&#125;... // and so on 决定是否使用if-then-else语句或switch语句取决于语句的可读性和测试的表达式。if-then-else语句可以基于值或条件的范围测试表达式，而switch语句只能基于单个整数、枚举值或String对象测试表达式。 另一个有趣的点是break语句。每个break语句都终止封闭的switch语句。控制流继续执行开关块后面的第一条语句。break语句是必需的，因为如果没有它们，开关块中的语句就会失败：匹配的case标签之后的所有语句都会按顺序执行，而不管后续case标签的表达式如何，直到遇到break。程序SwitchDemoFallThrough显示开关块中的语句。程序显示与整数月份对应的月份以及一年中的后续月份： 12345678910111213141516171819202122232425262728293031323334public class SwitchDemoFallThrough &#123; public static void main(String[] args) &#123; java.util.ArrayList&lt;String&gt; futureMonths = new java.util.ArrayList&lt;String&gt;(); int month = 8; switch (month) &#123; case 1: futureMonths.add(&quot;January&quot;); case 2: futureMonths.add(&quot;February&quot;); case 3: futureMonths.add(&quot;March&quot;); case 4: futureMonths.add(&quot;April&quot;); case 5: futureMonths.add(&quot;May&quot;); case 6: futureMonths.add(&quot;June&quot;); case 7: futureMonths.add(&quot;July&quot;); case 8: futureMonths.add(&quot;August&quot;); case 9: futureMonths.add(&quot;September&quot;); case 10: futureMonths.add(&quot;October&quot;); case 11: futureMonths.add(&quot;November&quot;); case 12: futureMonths.add(&quot;December&quot;); break; default: break; &#125; if (futureMonths.isEmpty()) &#123; System.out.println(&quot;Invalid month number&quot;); &#125; else &#123; for (String monthName : futureMonths) &#123; System.out.println(monthName); &#125; &#125; &#125;&#125; 这是代码的输出： 12345AugustSeptemberOctoberNovemberDecember 从技术上讲，不需要最后一次中断，因为流不在switch语句中。建议使用中断，这样修改代码更容易，更不容易出错。默认部分处理其中一个case部分未显式处理的所有值。 下面的代码示例SwitchDemo2展示了一个语句如何具有多个大小写标签。代码示例计算特定月份的天数： 123456789101112131415161718192021222324252627282930313233class SwitchDemo2 &#123; public static void main(String[] args) &#123; int month = 2; int year = 2000; int numDays = 0; switch (month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: numDays = 31; break; case 4: case 6: case 9: case 11: numDays = 30; break; case 2: if (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) numDays = 29; else numDays = 28; break; default: System.out.println(&quot;Invalid month.&quot;); break; &#125; System.out.println(&quot;Number of Days = &quot; + numDays); &#125;&#125; 这是代码的输出： 1Number of Days = 29 在switch语句中使用字符串在JavaSE7及更高版本中，可以在switch语句的表达式中使用String对象。下面的代码示例StringSwitchDemo根据名为month的字符串的值显示月份数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class StringSwitchDemo &#123; public static int getMonthNumber(String month) &#123; int monthNumber = 0; if (month == null) &#123; return monthNumber; &#125; switch (month.toLowerCase()) &#123; case &quot;january&quot;: monthNumber = 1; break; case &quot;february&quot;: monthNumber = 2; break; case &quot;march&quot;: monthNumber = 3; break; case &quot;april&quot;: monthNumber = 4; break; case &quot;may&quot;: monthNumber = 5; break; case &quot;june&quot;: monthNumber = 6; break; case &quot;july&quot;: monthNumber = 7; break; case &quot;august&quot;: monthNumber = 8; break; case &quot;september&quot;: monthNumber = 9; break; case &quot;october&quot;: monthNumber = 10; break; case &quot;november&quot;: monthNumber = 11; break; case &quot;december&quot;: monthNumber = 12; break; default: monthNumber = 0; break; &#125; return monthNumber; &#125; public static void main(String[] args) &#123; String month = &quot;August&quot;; int returnedMonthNumber = StringSwitchDemo.getMonthNumber(month); if (returnedMonthNumber == 0) &#123; System.out.println(&quot;Invalid month&quot;); &#125; else &#123; System.out.println(returnedMonthNumber); &#125; &#125;&#125; 此代码的输出为8。 将switch表达式中的String与与每个大小写标签关联的表达式进行比较，就像String一样。正在使用相等方法。为了使StringSwitchDemo示例接受任何月份，不管大小写，月份都转换为小写（使用toLowerCase方法），并且与大小写标签关联的所有字符串都是小写的。 注意：此示例检查switch语句中的表达式是否为空。确保任何switch语句中的表达式都不为空，以防止引发NullPointerException。 The while和do while语句while语句在特定条件为真时连续执行一个语句块。其语法可以表示为： 123while (expression) &#123; statement(s)&#125; while语句计算表达式，表达式必须返回布尔值。如果表达式的计算结果为true，则while语句执行while块中的语句。while语句继续测试表达式并执行其块，直到表达式的计算结果为false。使用while语句打印从1到10的值可以在以下WhileDemo程序中完成： 123456789class WhileDemo &#123; public static void main(String[] args)&#123; int count = 1; while (count &lt; 11) &#123; System.out.println(&quot;Count is: &quot; + count); count++; &#125; &#125;&#125; 您可以使用while语句实现无限循环，如下所示： 123while (true)&#123; // your code goes here&#125; Java编程语言还提供了一个do-while语句，可以如下表示： 123do &#123; statement(s)&#125; while (expression); do-while和while的区别在于，do-where在循环的底部而不是顶部计算其表达式。因此，do块中的语句始终至少执行一次，如以下DoWhileDemo程序所示： 123456789class DoWhileDemo &#123; public static void main(String[] args)&#123; int count = 1; do &#123; System.out.println(&quot;Count is: &quot; + count); count++; &#125; while (count &lt; 11); &#125;&#125; for语句for语句提供了一种紧凑的方法来迭代一系列值。程序员经常将其称为“for循环”，因为它重复循环直到满足特定条件。for语句的一般形式可以表示如下： 1234for (初始化; 结束; 定期的处理) &#123; statement(s)&#125; 使用此版本的for语句时，请记住： 初始化表达式初始化循环；它在循环开始时执行一次。 当终止表达式的计算结果为false时，循环终止。 增量表达式在循环的每次迭代之后被调用；对于这个表达式来说，增加或减少一个值是完全可以接受的。 以下程序ForDemo使用for语句的一般形式将数字1到10打印到标准输出： 1234567class ForDemo &#123; public static void main(String[] args)&#123; for(int i=1; i&lt;11; i++)&#123; System.out.println(&quot;Count is: &quot; + i); &#125; &#125;&#125; 该程序的输出为： 12345678910Count is: 1Count is: 2Count is: 3Count is: 4Count is: 5Count is: 6Count is: 7Count is: 8Count is: 9Count is: 10 注意代码如何在初始化表达式中声明变量。此变量的范围从其声明扩展到由for语句控制的块的末尾，因此它也可以用于终止表达式和增量表达式中。如果在循环之外不需要控制for语句的变量，最好在初始化表达式中声明该变量。名称i、j和k通常用于控制for循环；在初始化表达式中声明它们会限制它们的寿命并减少错误。 for循环的三个表达式是可选的；可以如下创建无限循环： 12345// infinite loopfor ( ; ; ) &#123; // your code goes here&#125; for语句还有另一种形式，设计用于通过 Collections 和 arrays 进行迭代。这种形式有时被称为增强的for语句，可用于使循环更紧凑、更易于阅读。为了演示，请考虑以下数组，其中包含数字1到10： 1int[] numbers = &#123;1,2,3,4,5,6,7,8,9,10&#125;; 以下程序EnhancedForDemo使用增强的for在数组中循环： 123456789class EnhancedForDemo &#123; public static void main(String[] args)&#123; int[] numbers = &#123;1,2,3,4,5,6,7,8,9,10&#125;; for (int item : numbers) &#123; System.out.println(&quot;Count is: &quot; + item); &#125; &#125;&#125; 在本例中，变量项保存数字数组中的当前值。此程序的输出与之前相同： 12345678910Count is: 1Count is: 2Count is: 3Count is: 4Count is: 5Count is: 6Count is: 7Count is: 8Count is: 9Count is: 10 我们建议尽可能使用for语句的这种形式，而不是一般形式。 分支语句break语句break语句有两种形式：标记和未标记。您在前面关于switch语句的讨论中看到了未标记的表单。您还可以使用未标记的中断来终止for、while或do while循环，如以下BreakDemo程序所示： 1234567891011121314151617181920212223242526class BreakDemo &#123; public static void main(String[] args) &#123; int[] arrayOfInts = &#123; 32, 87, 3, 589, 12, 1076, 2000, 8, 622, 127 &#125;; int searchfor = 12; int i; boolean foundIt = false; for (i = 0; i &lt; arrayOfInts.length; i++) &#123; if (arrayOfInts[i] == searchfor) &#123; foundIt = true; break; &#125; &#125; if (foundIt) &#123; System.out.println(&quot;Found &quot; + searchfor + &quot; at index &quot; + i); &#125; else &#123; System.out.println(searchfor + &quot; not in the array&quot;); &#125; &#125;&#125; 该程序在数组中搜索数字12。以粗体显示的break语句在找到该值时终止for循环。然后，控制流转移到for循环之后的语句。该程序的输出是： 1Found 12 at index 4 未标记的break语句终止最内部的switch、for、while或do while语句，但标记的breark终止外部语句。下面的程序BreakWithLabelDemo与前面的程序类似，但使用嵌套for循环搜索二维数组中的值。当找到该值时，标记为break将终止外部for循环（标记为“search”）： 1234567891011121314151617181920212223242526272829303132class BreakWithLabelDemo &#123; public static void main(String[] args) &#123; int[][] arrayOfInts = &#123; &#123; 32, 87, 3, 589 &#125;, &#123; 12, 1076, 2000, 8 &#125;, &#123; 622, 127, 77, 955 &#125; &#125;; int searchfor = 12; int i; int j = 0; boolean foundIt = false; search: for (i = 0; i &lt; arrayOfInts.length; i++) &#123; for (j = 0; j &lt; arrayOfInts[i].length; j++) &#123; if (arrayOfInts[i][j] == searchfor) &#123; foundIt = true; break search; &#125; &#125; &#125; if (foundIt) &#123; System.out.println(&quot;Found &quot; + searchfor + &quot; at &quot; + i + &quot;, &quot; + j); &#125; else &#123; System.out.println(searchfor + &quot; not in the array&quot;); &#125; &#125;&#125; 这是程序的输出。 1Found 12 at 1, 0 break语句终止标记语句；它不会将控制流传递到标签。控制流被转移到紧跟在标记（终止）语句之后的语句。 continue语句continue语句跳过for、while或do while循环的当前迭代。未标记的表单跳到最内层循环体的末尾，并计算控制循环的布尔表达式。下面的程序ContinueDemo逐个处理字符串，计算字母“p”的出现次数。如果当前字符不是p，continue语句将跳过循环的其余部分，并转到下一个字符。如果是“p”，程序将增加字母计数。 123456789101112131415161718class ContinueDemo &#123; public static void main(String[] args) &#123; String searchMe = &quot;peter piper picked a &quot; + &quot;peck of pickled peppers&quot;; int max = searchMe.length(); int numPs = 0; for (int i = 0; i &lt; max; i++) &#123; // interested only in p&#x27;s if (searchMe.charAt(i) != &#x27;p&#x27;) continue; // process p&#x27;s numPs++; &#125; System.out.println(&quot;Found &quot; + numPs + &quot; p&#x27;s in the string.&quot;); &#125;&#125; 以下是该程序的输出： 1Found 9 p&#x27;s in the string. 要更清楚地看到这种效果，请尝试删除continue语句并重新编译。当你再次运行程序时，计数会出错，说它找到了35个p而不是9。 带标签的continue语句跳过用给定标签标记的外部循环的当前迭代。下面的示例程序ContinueWithLabelDemo使用嵌套循环在另一个字符串中搜索子字符串。需要两个嵌套循环：一个迭代子字符串，一个迭代正在搜索的字符串。下面的程序ContinueWithLabelDemo使用continue的标记形式跳过外部循环中的迭代。 1234567891011121314151617181920212223242526class ContinueWithLabelDemo &#123; public static void main(String[] args) &#123; String searchMe = &quot;Look for a substring in me&quot;; String substring = &quot;sub&quot;; boolean foundIt = false; int max = searchMe.length() - substring.length(); test: for (int i = 0; i &lt;= max; i++) &#123; int n = substring.length(); int j = i; int k = 0; while (n-- != 0) &#123; if (searchMe.charAt(j++) != substring.charAt(k++)) &#123; continue test; &#125; &#125; foundIt = true; break test; &#125; System.out.println(foundIt ? &quot;Found it&quot; : &quot;Didn&#x27;t find it&quot;); &#125;&#125; 这是这个程序的输出： 1Found it return 语句分支语句的最后一个是return语句。return语句从当前方法退出，控制流返回到调用该方法的位置。return语句有两种形式：一种返回值，另一种不返回值。要返回值，只需将值（或计算值的表达式）放在return关键字之后。 1return ++count; 返回值的数据类型必须与方法声明的返回值的类型匹配。当方法声明为void时，使用不返回值的返回形式。 1return; Classes and Objects 课程将涵盖您需要了解的关于编写方法的所有内容。 控制流程语句总结if-then语句是所有控制流语句中最基本的。它告诉您的程序只有在特定测试的结果为true时才执行某段代码。当“if”子句的计算结果为false时，if-then-else语句提供了执行的辅助路径。与if-then和if-then-else不同，switch语句允许任意数量的可能执行路径。while和do while语句在特定条件为真时连续执行一个语句块。do-while和while的区别在于，do-where在循环的底部而不是顶部计算其表达式。因此，do块中的语句总是至少执行一次。for语句提供了一种紧凑的方法来迭代一系列值。它有两种形式，其中一种是为在集合和数组之间循环而设计的。","categories":[{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"}]}],"categories":[{"name":"创业","slug":"创业","permalink":"https://guoshunfa.com/categories/%E5%88%9B%E4%B8%9A/"},{"name":"复盘","slug":"复盘","permalink":"https://guoshunfa.com/categories/%E5%A4%8D%E7%9B%98/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/categories/SpringBoot/"},{"name":"服务器管理","slug":"服务器管理","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"},{"name":"娱乐","slug":"娱乐","permalink":"https://guoshunfa.com/categories/%E5%A8%B1%E4%B9%90/"},{"name":"阅读","slug":"阅读","permalink":"https://guoshunfa.com/categories/%E9%98%85%E8%AF%BB/"},{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务","slug":"服务","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1/"},{"name":"软件使用","slug":"软件使用","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"搭建单体SpringBoot项目","slug":"搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"},{"name":"技术","slug":"技术","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"搭建单体SpringBoot项目","slug":"技术/搭建单体SpringBoot项目","permalink":"https://guoshunfa.com/categories/%E6%8A%80%E6%9C%AF/%E6%90%AD%E5%BB%BA%E5%8D%95%E4%BD%93SpringBoot%E9%A1%B9%E7%9B%AE/"},{"name":"服务&组件","slug":"服务-组件","permalink":"https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1-%E7%BB%84%E4%BB%B6/"},{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/categories/HTML-CSS-JavaScript/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/categories/Java/"},{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/categories/Python/"},{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/categories/Swift/"},{"name":"软件技术框架","slug":"软件技术框架","permalink":"https://guoshunfa.com/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"知识","slug":"知识","permalink":"https://guoshunfa.com/tags/%E7%9F%A5%E8%AF%86/"},{"name":"总结","slug":"总结","permalink":"https://guoshunfa.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://guoshunfa.com/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://guoshunfa.com/tags/Java/"},{"name":"Quartz","slug":"Quartz","permalink":"https://guoshunfa.com/tags/Quartz/"},{"name":"Swagger","slug":"Swagger","permalink":"https://guoshunfa.com/tags/Swagger/"},{"name":"宝塔","slug":"宝塔","permalink":"https://guoshunfa.com/tags/%E5%AE%9D%E5%A1%94/"},{"name":"Linux","slug":"Linux","permalink":"https://guoshunfa.com/tags/Linux/"},{"name":"韩剧","slug":"韩剧","permalink":"https://guoshunfa.com/tags/%E9%9F%A9%E5%89%A7/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://guoshunfa.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"心理","slug":"心理","permalink":"https://guoshunfa.com/tags/%E5%BF%83%E7%90%86/"},{"name":"数据库","slug":"数据库","permalink":"https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"乐观锁","slug":"乐观锁","permalink":"https://guoshunfa.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"},{"name":"并发","slug":"并发","permalink":"https://guoshunfa.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"解决方案","slug":"解决方案","permalink":"https://guoshunfa.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"图床","slug":"图床","permalink":"https://guoshunfa.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Mysql","slug":"Mysql","permalink":"https://guoshunfa.com/tags/Mysql/"},{"name":"Oracle","slug":"Oracle","permalink":"https://guoshunfa.com/tags/Oracle/"},{"name":"Redis","slug":"Redis","permalink":"https://guoshunfa.com/tags/Redis/"},{"name":"SQL","slug":"SQL","permalink":"https://guoshunfa.com/tags/SQL/"},{"name":"mac","slug":"mac","permalink":"https://guoshunfa.com/tags/mac/"},{"name":"docker","slug":"docker","permalink":"https://guoshunfa.com/tags/docker/"},{"name":"Shell","slug":"Shell","permalink":"https://guoshunfa.com/tags/Shell/"},{"name":"Expect","slug":"Expect","permalink":"https://guoshunfa.com/tags/Expect/"},{"name":"IDEA","slug":"IDEA","permalink":"https://guoshunfa.com/tags/IDEA/"},{"name":"Debug","slug":"Debug","permalink":"https://guoshunfa.com/tags/Debug/"},{"name":"Maven","slug":"Maven","permalink":"https://guoshunfa.com/tags/Maven/"},{"name":"插件","slug":"插件","permalink":"https://guoshunfa.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://guoshunfa.com/tags/SpringSecurity/"},{"name":"集成","slug":"集成","permalink":"https://guoshunfa.com/tags/%E9%9B%86%E6%88%90/"},{"name":"用户权限验证","slug":"用户权限验证","permalink":"https://guoshunfa.com/tags/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/"},{"name":"Scheduled","slug":"Scheduled","permalink":"https://guoshunfa.com/tags/Scheduled/"},{"name":"定时器","slug":"定时器","permalink":"https://guoshunfa.com/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"name":"Logback","slug":"Logback","permalink":"https://guoshunfa.com/tags/Logback/"},{"name":"quartz","slug":"quartz","permalink":"https://guoshunfa.com/tags/quartz/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://guoshunfa.com/tags/spring-boot/"},{"name":"Kafka","slug":"Kafka","permalink":"https://guoshunfa.com/tags/Kafka/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://guoshunfa.com/tags/Activiti7/"},{"name":"Druid","slug":"Druid","permalink":"https://guoshunfa.com/tags/Druid/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://guoshunfa.com/tags/MongoDB/"},{"name":"mysql","slug":"mysql","permalink":"https://guoshunfa.com/tags/mysql/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://guoshunfa.com/tags/Mybatis/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://guoshunfa.com/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"},{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://guoshunfa.com/tags/MybatisPlus/"},{"name":"FreeMarker","slug":"FreeMarker","permalink":"https://guoshunfa.com/tags/FreeMarker/"},{"name":"模版引擎","slug":"模版引擎","permalink":"https://guoshunfa.com/tags/%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"},{"name":"TestNG","slug":"TestNG","permalink":"https://guoshunfa.com/tags/TestNG/"},{"name":"测试","slug":"测试","permalink":"https://guoshunfa.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Hutool","slug":"Hutool","permalink":"https://guoshunfa.com/tags/Hutool/"},{"name":"FastJson","slug":"FastJson","permalink":"https://guoshunfa.com/tags/FastJson/"},{"name":"Json","slug":"Json","permalink":"https://guoshunfa.com/tags/Json/"},{"name":"Profile","slug":"Profile","permalink":"https://guoshunfa.com/tags/Profile/"},{"name":"Jsoup","slug":"Jsoup","permalink":"https://guoshunfa.com/tags/Jsoup/"},{"name":"爬虫","slug":"爬虫","permalink":"https://guoshunfa.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Arthas","slug":"Arthas","permalink":"https://guoshunfa.com/tags/Arthas/"},{"name":"Git","slug":"Git","permalink":"https://guoshunfa.com/tags/Git/"},{"name":"Gitlab","slug":"Gitlab","permalink":"https://guoshunfa.com/tags/Gitlab/"},{"name":"Docker","slug":"Docker","permalink":"https://guoshunfa.com/tags/Docker/"},{"name":"GitlabRunner","slug":"GitlabRunner","permalink":"https://guoshunfa.com/tags/GitlabRunner/"},{"name":"gitlab","slug":"gitlab","permalink":"https://guoshunfa.com/tags/gitlab/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://guoshunfa.com/tags/Jenkins/"},{"name":"Nexus","slug":"Nexus","permalink":"https://guoshunfa.com/tags/Nexus/"},{"name":"Nginx","slug":"Nginx","permalink":"https://guoshunfa.com/tags/Nginx/"},{"name":"部署","slug":"部署","permalink":"https://guoshunfa.com/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Opengrok","slug":"Opengrok","permalink":"https://guoshunfa.com/tags/Opengrok/"},{"name":"SVN","slug":"SVN","permalink":"https://guoshunfa.com/tags/SVN/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://guoshunfa.com/tags/Tomcat/"},{"name":"HTML/CSS/JavaScript","slug":"HTML-CSS-JavaScript","permalink":"https://guoshunfa.com/tags/HTML-CSS-JavaScript/"},{"name":"组件库","slug":"组件库","permalink":"https://guoshunfa.com/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"PubSubJS","slug":"PubSubJS","permalink":"https://guoshunfa.com/tags/PubSubJS/"},{"name":"iframe","slug":"iframe","permalink":"https://guoshunfa.com/tags/iframe/"},{"name":"算法","slug":"算法","permalink":"https://guoshunfa.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"加密","slug":"加密","permalink":"https://guoshunfa.com/tags/%E5%8A%A0%E5%AF%86/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://guoshunfa.com/tags/Leetcode/"},{"name":"CSS","slug":"CSS","permalink":"https://guoshunfa.com/tags/CSS/"},{"name":"less","slug":"less","permalink":"https://guoshunfa.com/tags/less/"},{"name":"JS","slug":"JS","permalink":"https://guoshunfa.com/tags/JS/"},{"name":"类","slug":"类","permalink":"https://guoshunfa.com/tags/%E7%B1%BB/"},{"name":"AJAX","slug":"AJAX","permalink":"https://guoshunfa.com/tags/AJAX/"},{"name":"脚本","slug":"脚本","permalink":"https://guoshunfa.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://guoshunfa.com/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://guoshunfa.com/tags/Scrapy/"},{"name":"Swift","slug":"Swift","permalink":"https://guoshunfa.com/tags/Swift/"},{"name":"基础","slug":"基础","permalink":"https://guoshunfa.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"RESTful","slug":"RESTful","permalink":"https://guoshunfa.com/tags/RESTful/"},{"name":"Electron","slug":"Electron","permalink":"https://guoshunfa.com/tags/Electron/"},{"name":"pom.xml","slug":"pom-xml","permalink":"https://guoshunfa.com/tags/pom-xml/"},{"name":"settings.xml","slug":"settings-xml","permalink":"https://guoshunfa.com/tags/settings-xml/"},{"name":"Jar","slug":"Jar","permalink":"https://guoshunfa.com/tags/Jar/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://guoshunfa.com/tags/MyBatis/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://guoshunfa.com/tags/mybatis-plus/"},{"name":"介绍","slug":"介绍","permalink":"https://guoshunfa.com/tags/%E4%BB%8B%E7%BB%8D/"},{"name":"XML","slug":"XML","permalink":"https://guoshunfa.com/tags/XML/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://guoshunfa.com/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"https://guoshunfa.com/tags/Spring/"},{"name":"SpringEvent","slug":"SpringEvent","permalink":"https://guoshunfa.com/tags/SpringEvent/"},{"name":"React","slug":"React","permalink":"https://guoshunfa.com/tags/React/"},{"name":"Hook","slug":"Hook","permalink":"https://guoshunfa.com/tags/Hook/"},{"name":"跨域","slug":"跨域","permalink":"https://guoshunfa.com/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"UI组件库","slug":"UI组件库","permalink":"https://guoshunfa.com/tags/UI%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"Vue","slug":"Vue","permalink":"https://guoshunfa.com/tags/Vue/"},{"name":"Vuepress","slug":"Vuepress","permalink":"https://guoshunfa.com/tags/Vuepress/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://guoshunfa.com/tags/Wordpress/"},{"name":"若依","slug":"若依","permalink":"https://guoshunfa.com/tags/%E8%8B%A5%E4%BE%9D/"},{"name":"内网","slug":"内网","permalink":"https://guoshunfa.com/tags/%E5%86%85%E7%BD%91/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://guoshunfa.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"sshpass","slug":"sshpass","permalink":"https://guoshunfa.com/tags/sshpass/"},{"name":"Mac","slug":"Mac","permalink":"https://guoshunfa.com/tags/Mac/"},{"name":"linux","slug":"linux","permalink":"https://guoshunfa.com/tags/linux/"},{"name":"Curl","slug":"Curl","permalink":"https://guoshunfa.com/tags/Curl/"},{"name":"Http","slug":"Http","permalink":"https://guoshunfa.com/tags/Http/"},{"name":"ssh","slug":"ssh","permalink":"https://guoshunfa.com/tags/ssh/"},{"name":"树莓派","slug":"树莓派","permalink":"https://guoshunfa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"树莓派4B","slug":"树莓派4B","permalink":"https://guoshunfa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE4B/"},{"name":"homebrew","slug":"homebrew","permalink":"https://guoshunfa.com/tags/homebrew/"},{"name":"Nano","slug":"Nano","permalink":"https://guoshunfa.com/tags/Nano/"},{"name":"yum","slug":"yum","permalink":"https://guoshunfa.com/tags/yum/"},{"name":"存储过程","slug":"存储过程","permalink":"https://guoshunfa.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"存储函数","slug":"存储函数","permalink":"https://guoshunfa.com/tags/%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/"},{"name":"Jmeter","slug":"Jmeter","permalink":"https://guoshunfa.com/tags/Jmeter/"},{"name":"概念","slug":"概念","permalink":"https://guoshunfa.com/tags/%E6%A6%82%E5%BF%B5/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://guoshunfa.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"Stream","slug":"Stream","permalink":"https://guoshunfa.com/tags/Stream/"},{"name":"lambda","slug":"lambda","permalink":"https://guoshunfa.com/tags/lambda/"},{"name":"Jdk","slug":"Jdk","permalink":"https://guoshunfa.com/tags/Jdk/"},{"name":"反编译工具","slug":"反编译工具","permalink":"https://guoshunfa.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"},{"name":"Spel表达式","slug":"Spel表达式","permalink":"https://guoshunfa.com/tags/Spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"泛型","slug":"泛型","permalink":"https://guoshunfa.com/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"oracle","slug":"oracle","permalink":"https://guoshunfa.com/tags/oracle/"},{"name":"java","slug":"java","permalink":"https://guoshunfa.com/tags/java/"},{"name":"assert","slug":"assert","permalink":"https://guoshunfa.com/tags/assert/"},{"name":"断言","slug":"断言","permalink":"https://guoshunfa.com/tags/%E6%96%AD%E8%A8%80/"},{"name":"Validator","slug":"Validator","permalink":"https://guoshunfa.com/tags/Validator/"},{"name":"JVM","slug":"JVM","permalink":"https://guoshunfa.com/tags/JVM/"},{"name":"设计模式","slug":"设计模式","permalink":"https://guoshunfa.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"异常","slug":"异常","permalink":"https://guoshunfa.com/tags/%E5%BC%82%E5%B8%B8/"},{"name":"接口","slug":"接口","permalink":"https://guoshunfa.com/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"面向对象","slug":"面向对象","permalink":"https://guoshunfa.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]}