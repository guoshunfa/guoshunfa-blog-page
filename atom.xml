<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guoshunfa</title>
  
  <subtitle>快乐生活</subtitle>
  <link href="https://guoshunfa.com/atom.xml" rel="self"/>
  
  <link href="https://guoshunfa.com/"/>
  <updated>2024-07-11T07:55:19.549Z</updated>
  <id>https://guoshunfa.com/</id>
  
  <author>
    <name>guoshunfa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不卷学历和背景的赛道，也能月入过万？</title>
    <link href="https://guoshunfa.com/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%8C%E6%99%AF%E7%9A%84%E8%B5%9B%E9%81%93%EF%BC%8C%E4%B9%9F%E8%83%BD%E6%9C%88%E5%85%A5%E8%BF%87%E4%B8%87%EF%BC%9F/"/>
    <id>https://guoshunfa.com/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%8C%E6%99%AF%E7%9A%84%E8%B5%9B%E9%81%93%EF%BC%8C%E4%B9%9F%E8%83%BD%E6%9C%88%E5%85%A5%E8%BF%87%E4%B8%87%EF%BC%9F/</id>
    <published>2024-07-11T05:45:20.000Z</published>
    <updated>2024-07-11T07:55:19.549Z</updated>
    
    <content type="html"><![CDATA[<p>能力至上？好像并不是。现在就业环境首先看你的学历，其次是背景调查。能撑过去的还会有面试话术考核，在这种情况下大多数人可能就被筛选下来了。你说自己有能力，都没人鸟你。</p><img src="/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%8C%E6%99%AF%E7%9A%84%E8%B5%9B%E9%81%93%EF%BC%8C%E4%B9%9F%E8%83%BD%E6%9C%88%E5%85%A5%E8%BF%87%E4%B8%87%EF%BC%9F/image-20240711153144789.png" alt="image-20240711153144789" style="zoom:70%;"><p>有能力真的没饭吃？并不是，有个赛道并不需要学历和背景，那就是接单。这边很多伙伴靠接单月入过万，甚至几十个，还有正在当学生的程序员，只要有能力完全不看这些标签。</p><img src="/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%8C%E6%99%AF%E7%9A%84%E8%B5%9B%E9%81%93%EF%BC%8C%E4%B9%9F%E8%83%BD%E6%9C%88%E5%85%A5%E8%BF%87%E4%B8%87%EF%BC%9F/2177-kcpxnwv6307951.jpg" alt="img" style="zoom:50%;"><p>公司打工更多的是当螺丝钉，只需要管自己那一亩三分地。接单更考验的是综合实力，一人顶一个团队。举个例子，软件外包公司必要的环节：销售拉项目、项目经理管控项目、产品经理负责设计、美工负责界面设计、前端&amp;后端&amp;测试工程师负责开发和测试工作，让你自己做全部，其实也不太现实，毕竟一个人的精力是有限的，这个时候就需要考虑资源，你手里是否有这样的资源。假设我可以完成项目管理、开发测试，我可以找拉项目的伙伴接单，找懂界面设计的伙伴合作接单。这样一个项目你就可以接了，一个项目3w，按劳分配，共赢。</p><p>接单比技术更重要的是口碑。我们是要合作拿下这个项目，如果中途一个人掉链子，项目可就没了，你感觉无所谓，没了就看下一个单子。那我下次还会跟你合作嘛。所以口碑一定要保护好。合作的目的是共赢。感觉自己做不了，那就打个招呼退出，让组团的人再填充其他人。这样才有人跟你玩。</p><p>当然，你如果可以接受月入过万，就要接受一个月只能挣几千。接单本身就是不稳定的，接单人自称为自由职业者，自由本身就等于风险。能承担风险，就可以享受自由。</p><p>文章并不是希望各位都去接单，而是提供了一个可以选择的方向，提醒大家挣钱的方式有很多，没必要只看一种。</p><img src="/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%8C%E6%99%AF%E7%9A%84%E8%B5%9B%E9%81%93%EF%BC%8C%E4%B9%9F%E8%83%BD%E6%9C%88%E5%85%A5%E8%BF%87%E4%B8%87%EF%BC%9F/image-20240711154350844.png" alt="image-20240711154350844" style="zoom: 80%;"><blockquote><p>后面会陆续更新：</p><ol><li>如何找靠谱的合作伙伴。</li><li>接单每个环节应该如何做。</li><li>如何接到优质单子。</li><li>光派单一个月能挣多少。</li><li>不了解互联网行业，如何在里面分一杯羹。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;能力至上？好像并不是。现在就业环境首先看你的学历，其次是背景调查。能撑过去的还会有面试话术考核，在这种情况下大多数人可能就被筛选下来了。你说自己有能力，都没人鸟你。&lt;/p&gt;
&lt;img src=&quot;/2024/07/%E4%B8%8D%E5%8D%B7%E5%AD%A6%E5%</summary>
      
    
    
    
    <category term="创业" scheme="https://guoshunfa.com/categories/%E5%88%9B%E4%B8%9A/"/>
    
    
    <category term="知识" scheme="https://guoshunfa.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>回顾工作这几年</title>
    <link href="https://guoshunfa.com/2024/07/%E5%9B%9E%E9%A1%BE%E5%B7%A5%E4%BD%9C%E8%BF%99%E5%87%A0%E5%B9%B4/"/>
    <id>https://guoshunfa.com/2024/07/%E5%9B%9E%E9%A1%BE%E5%B7%A5%E4%BD%9C%E8%BF%99%E5%87%A0%E5%B9%B4/</id>
    <published>2024-07-09T06:19:23.000Z</published>
    <updated>2024-07-09T10:08:46.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>断更一年，今天开始恢复博客的更新。</p></blockquote><p>​先做个自我介绍，我叫郭顺发，哈尔滨人，坐标深圳，25岁，原Java全栈开发工程师，现在是自由职业者+创业。</p><p>​回顾工作这几年……</p><p>​19年毕业之后入职了一家北京的互联网企业，正式进入了软件开发工程师这个角色。跟大多数刚入行的同学一样，每天挠头，不清楚技术如何做，不清楚项目中的业务如何运转，我还偏内向，不太喜欢和同事沟通，导致效率很差。最后自己付出了很多努力才学会这些。非常感谢当时技术经理的耐心指导，和同事对我的帮助，这段经历是我最难忘的，也是我提升最多的。</p><p>​疫情来了，年假回家，我被困到了哈尔滨，不让回北京。呆了一个多月，这也是我最后陪父亲的一段时光，我永远忘不了我爸火车站送我的样子。过了很短时间，父亲查出来了肝硬化，一个月就走了。当时直接辞职回家呆了一段时间，想陪陪家里人，也调整调整自己。后面回北京前后入职了几家公司，但是当时状态很不好，在北京的出租房颓废了半年。一直在思考一个问题，人生的意义是什么？想到一个人勤勤恳恳一辈子，就活到50出头。</p><p>​后面玩了一款游戏，在游戏里遇到了很多伙伴，把自己投入进去后，突然想开了，我的人生就是要体验，要适当摆脱固有思维，做自己。</p><p>​大变估真的能让一个人彻底改变，从那以后一改往日的性格，不再在乎别人的眼光，也不再那么内向。</p><p>​后面联系了第一家公司的人事，又回到了那家公司，回去之后人都没变，还是那些个人，说实话感觉挺好的。</p><p>​干了一年左右，感觉公司突然开始抓员工的考勤、日报，很不对劲，干活也很累，我对公司内部的事儿不想了解，我也不清楚发生了什么。</p><p>​我突然有了个计划，回哈尔滨发展。</p><p>​说做就做，哈尔滨的一家外包公司联系到了我，价格谈的不错，我就收拾收拾回去了。</p><p>​体会了一下哈尔滨工作独特的处理方式，挺好玩的，工作也很轻松。项目一期做完，紧接着进入了二期，可惜的是外包公司换了，就是我的上级换了。合作的没那么愉快，控制欲太强了，哈，项目中节点交付完，我就撤了出来。</p><p>​离职之后，计划找下一个落脚的城市，定制了一个1-2个月的旅游计划，到处逛逛。</p><blockquote><p>济南：人是真多，红绿灯也多，去一个景点，打车跟步行一个时长。😑</p><p>青岛：都说青岛一半是东北人，去了是挺多，感觉到家了。我还是喜欢青岛的海边。</p><p>杭州：嗯，菜是不咋好吃。</p><p>苏州：风景挺好的。</p><p>东营：海边不错，就是没地铁。</p><p>深圳：啥都挺好，就是蟑螂大。</p><p>其他地方没啥影响了。</p></blockquote><p>​结束旅游之后，选了深圳这个城市，来了之后发现，md找不到工作（真不愿意背那些八股文）。</p><p>​后面机缘巧合下发现了接单的方式，感觉很适合我，自由。就直接all in进去了，4月1号开始到现在，注册了一个工作室，全身心的投入进去，不断学习、复盘，总体来说感觉还行。但是感觉还是力使错了，还是得想办法。</p><p>​最后总结一下，工作这几年遇到过大大小小的困难，但是回头看其实也就那样，有什么比死亡更难的呢。哈，干就完了。</p><blockquote><p>后面会陆续更新博客内容，打算分享自己这段时间的创业经历和以往小小经验，感兴趣的同学可以关注一波。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;断更一年，今天开始恢复博客的更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	先做个自我介绍，我叫郭顺发，哈尔滨人，坐标深圳，25岁，原Java全栈开发工程师，现在是自由职业者+创业。&lt;/p&gt;
&lt;p&gt;​	回顾工作这几年……&lt;/p&gt;
&lt;p&gt;​	1</summary>
      
    
    
    
    <category term="复盘" scheme="https://guoshunfa.com/categories/%E5%A4%8D%E7%9B%98/"/>
    
    
    <category term="总结" scheme="https://guoshunfa.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3集成Quartz极简版</title>
    <link href="https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E6%9E%81%E7%AE%80%E7%89%88/"/>
    <id>https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E6%9E%81%E7%AE%80%E7%89%88/</id>
    <published>2023-07-18T01:14:01.000Z</published>
    <updated>2024-01-28T11:41:39.305Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章项目：<a href="https://github.com/guoshunfa/guoshunfa-spring-demo/tree/6eceffc74282e750350a9eec6d26572d73f3fcdb/01.SpringBoot/SpringBoot%E9%9B%86%E6%88%90%E7%BB%84%E4%BB%B6%E5%BA%93/springboot-3-quartz-demo">Github Project</a></p></blockquote><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>文章所用版本：</p><ul><li>SpringBoot 3.1.1</li><li>Quartz 2.3.2</li><li>JDK 17</li></ul><h1 id="集成Quartz"><a href="#集成Quartz" class="headerlink" title="集成Quartz"></a>集成Quartz</h1><h2 id="引入quartz-maven库"><a href="#引入quartz-maven库" class="headerlink" title="引入quartz maven库"></a>引入quartz maven库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot用的是3.1.1，使用spring-boot-starter-quartz库，quartz版本默认为2.3.2。</p><p><img src="/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E6%9E%81%E7%AE%80%E7%89%88/image-20230718091850936.png" alt="image-20230718091850936"></p><h2 id="添加Quartz配置文件"><a href="#添加Quartz配置文件" class="headerlink" title="添加Quartz配置文件"></a>添加Quartz配置文件</h2><p>将quartz.properties文件添加到resource目录下。</p><p>（quartz.properties文件不是必须的，但要使用除最基本的配置之外的任何配置，它必须位于类路径上。）</p><p><img src="/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E6%9E%81%E7%AE%80%E7%89%88/image-20230718092052636.png" alt="image-20230718092052636"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这是最重要的一点！Quartz是一个可配置的应用程序。配置 Quartz 的最佳方法是编辑 quartz.properties 文件，并将其放在应用程序的类路径中。</p><p>建议创建自己的 quartz.properties 文件，而不是复制其他案例的配置，这样更整洁。</p><p>可用属性的完整文档可在 <a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration">Quartz 配置参考</a>中找到。</p><p>为了快速启动和运行，基本的 quartz.properties 如下所示：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.quartz.scheduler.instanceName</span> = <span class="string">MyScheduler</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span> = <span class="string">3</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span> = <span class="string">org.quartz.simpl.RAMJobStore</span></span><br></pre></td></tr></table></figure><p>此配置创建的调度程序具有以下特征：</p><ul><li>org.quartz.scheduler.instanceName - 此调度程序的名称将是“MyScheduler”。</li><li>org.quartz.threadPool.threadCount - 线程池中有 3 个线程，这意味着最多可以同时运行 3 个作业。</li><li>org.quartz.jobStore.class - Quartz 的所有数据，例如作业和触发器的详细信息，都保存在内存中（而不是保存在数据库中）。 即使您有一个数据库并希望将其与Quartz一起使用，我也建议您在通过数据库打开一个全新的维度之前，先让Quartz与RamJobStore合作。</li></ul><h2 id="启动示例应用程序"><a href="#启动示例应用程序" class="headerlink" title="启动示例应用程序"></a>启动示例应用程序</h2><p>添加测试类QuartzTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// Grab the Scheduler instance from the Factory</span></span><br><span class="line">          <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// and start it off</span></span><br><span class="line">          scheduler.start();</span><br><span class="line"></span><br><span class="line">          scheduler.shutdown();</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">          se.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意代码示例中的静态导入;这些将在下面的代码示例中发挥作用。</p><p>如果您尚未设置日志记录，则所有日志都将发送到控制台，您的输出将如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">09:24:01.268 [main] INFO org.quartz.impl.StdSchedulerFactory -- Using default implementation for ThreadExecutor</span><br><span class="line">09:24:01.311 [main] INFO org.quartz.core.SchedulerSignalerImpl -- Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl</span><br><span class="line">09:24:01.311 [main] INFO org.quartz.core.QuartzScheduler -- Quartz Scheduler v.2.3.2 created.</span><br><span class="line">09:24:01.312 [main] INFO org.quartz.simpl.RAMJobStore -- RAMJobStore initialized.</span><br><span class="line">09:24:01.313 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler meta-data: Quartz Scheduler (v2.3.2) &#x27;MyScheduler&#x27; with instanceId &#x27;NON_CLUSTERED&#x27;</span><br><span class="line">  Scheduler class: &#x27;org.quartz.core.QuartzScheduler&#x27; - running locally.</span><br><span class="line">  NOT STARTED.</span><br><span class="line">  Currently in standby mode.</span><br><span class="line">  Number of jobs executed: 0</span><br><span class="line">  Using thread pool &#x27;org.quartz.simpl.SimpleThreadPool&#x27; - with 3 threads.</span><br><span class="line">  Using job-store &#x27;org.quartz.simpl.RAMJobStore&#x27; - which does not support persistence. and is not clustered.</span><br><span class="line"></span><br><span class="line">09:24:01.313 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler &#x27;MyScheduler&#x27; initialized from default resource file in Quartz package: &#x27;quartz.properties&#x27;</span><br><span class="line">09:24:01.313 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler version: 2.3.2</span><br><span class="line">09:24:01.314 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED started.</span><br><span class="line">09:24:01.315 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutting down.</span><br><span class="line">09:24:01.315 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED paused.</span><br><span class="line">09:24:01.315 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutdown complete.</span><br></pre></td></tr></table></figure><p>为了更有效的展示定时器的呈现效果，这里再加一下。</p><p>调整QuartzTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从工厂获取调度程序实例</span></span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并启动它</span></span><br><span class="line">            scheduler.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义作业并将其与我们的 HelloJob 类绑定</span></span><br><span class="line">            <span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> newJob(HelloJob.class)</span><br><span class="line">                    .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 触发作业立即运行，然后每 3 秒重复一次</span></span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> newTrigger()</span><br><span class="line">                    .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(simpleSchedule()</span><br><span class="line">                            .withIntervalInSeconds(<span class="number">3</span>)</span><br><span class="line">                            .repeatForever())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 告诉quartz使用我们的触发器安排作业</span></span><br><span class="line">            scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">            scheduler.shutdown();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <em>使用 StdSchedulerFactory.getDefaultScheduler（） 获取调度程序后，应用程序在调用 scheduler.shutdown（） 之前不会终止，因为会有活动线程。</em></p></blockquote><p>添加定时任务类HelloJob</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是HelloJob，我开始执行。&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">600</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;我是HelloJob，我执行结束。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">09:36:46.942 [main] INFO org.quartz.impl.StdSchedulerFactory -- Using default implementation for ThreadExecutor</span><br><span class="line">09:36:46.973 [main] INFO org.quartz.core.SchedulerSignalerImpl -- Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl</span><br><span class="line">09:36:46.973 [main] INFO org.quartz.core.QuartzScheduler -- Quartz Scheduler v.2.3.2 created.</span><br><span class="line">09:36:46.974 [main] INFO org.quartz.simpl.RAMJobStore -- RAMJobStore initialized.</span><br><span class="line">09:36:46.976 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler meta-data: Quartz Scheduler (v2.3.2) &#x27;MyScheduler&#x27; with instanceId &#x27;NON_CLUSTERED&#x27;</span><br><span class="line">  Scheduler class: &#x27;org.quartz.core.QuartzScheduler&#x27; - running locally.</span><br><span class="line">  NOT STARTED.</span><br><span class="line">  Currently in standby mode.</span><br><span class="line">  Number of jobs executed: 0</span><br><span class="line">  Using thread pool &#x27;org.quartz.simpl.SimpleThreadPool&#x27; - with 3 threads.</span><br><span class="line">  Using job-store &#x27;org.quartz.simpl.RAMJobStore&#x27; - which does not support persistence. and is not clustered.</span><br><span class="line"></span><br><span class="line">09:36:46.976 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler &#x27;MyScheduler&#x27; initialized from default resource file in Quartz package: &#x27;quartz.properties&#x27;</span><br><span class="line">09:36:46.976 [main] INFO org.quartz.impl.StdSchedulerFactory -- Quartz scheduler version: 2.3.2</span><br><span class="line">09:36:46.977 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED started.</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">我是HelloJob，我开始执行。</span><br><span class="line">09:37:47.047 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutting down.</span><br><span class="line">09:37:47.047 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED paused.</span><br><span class="line">09:37:47.048 [main] INFO org.quartz.core.QuartzScheduler -- Scheduler MyScheduler_$_NON_CLUSTERED shutdown complete.</span><br><span class="line">我是HelloJob，我执行结束。</span><br><span class="line">与目标 VM 断开连接, 地址为: &#x27;&#x27;127.0.0.1:60612&#x27;，传输: &#x27;套接字&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration/">Configuration Reference (quartz-scheduler.org)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章项目：&lt;a href=&quot;https://github.com/guoshunfa/guoshunfa-spring-demo/tree/6eceffc74282e750350a9eec6d26572d73f3fcdb/01.SpringBoot</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="https://guoshunfa.com/tags/Java/"/>
    
    <category term="Quartz" scheme="https://guoshunfa.com/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3集成Quartz详细版</title>
    <link href="https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E8%AF%A6%E7%BB%86%E7%89%88/"/>
    <id>https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E8%AF%A6%E7%BB%86%E7%89%88/</id>
    <published>2023-07-18T01:14:01.000Z</published>
    <updated>2024-01-28T11:41:39.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章项目：<a href="https://github.com/guoshunfa/guoshunfa-spring-demo/tree/6eceffc74282e750350a9eec6d26572d73f3fcdb/01.SpringBoot/SpringBoot%E9%9B%86%E6%88%90%E7%BB%84%E4%BB%B6%E5%BA%93/springboot-3-quartz-detailed-demo">Github Project</a></p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文章会描述如何用SpringBoot更好的集成Quartz定时器，从Quartz配置、如何持久化、如何设计等方面进行描述。本文章不</p><p><strong>文章所用版本：</strong></p><ul><li>SpringBoot 3.1.1</li><li>Quartz 2.3.2</li><li>JDK 17</li><li>Mysql 8.0.33</li><li>MongoDB 6.0.8</li></ul><h1 id="Quartz配置描述"><a href="#Quartz配置描述" class="headerlink" title="Quartz配置描述"></a>Quartz配置描述</h1><p>Quartz 的配置通常通过使用属性文件来完成，并结合使用 StdSchedulerFactory （使用配置文件并实例化调度程序）。</p><p>默认情况下，StdSchedulerFactory 从“当前工作目录”加载一个名为“quartz.properties”的属性文件。 如果失败，则加载位于 org&#x2F;quartz 包中的“quartz.properties”文件（作为资源）。如果你 希望使用这些默认值以外的文件，您必须定义系统属性“org.quartz.properties”以指向 所需的文件。</p><p>或者，您可以通过在之前调用 initialize（xx） 方法之一来显式初始化工厂 在 StdSchedulerFactory 上调用 getScheduler（）。</p><p>指定的 JobStore、ThreadPool 和其他 SPI 类的实例将按名称创建，然后按名称创建 配置文件中为它们指定的其他属性将通过调用等效的“set”在实例上设置。 方法。例如，如果属性文件包含属性“org.quartz.jobStore.myProp &#x3D; 10”，则在 JobStore 类已被实例化，将在其上调用方法 ‘setMyProp（）’。类型转换为基元 Java 类型（整数、长整型、浮点型、双精度型、布尔值和字符串）在调用属性的 setter 之前执行 方法。</p><p>一个属性可以通过按照约定指定值来引用另一个属性的值 “$@other.property.name”，例如，引用调度程序的实例名称作为某些其他属性的值， 您将使用“$@org.quartz.scheduler.instanceName”。</p><h2 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h2><blockquote><p>主调度程序设置的配置。</p></blockquote><p>这些属性配置调度程序的标识以及各种其他“顶级”设置。</p><table><thead><tr><th align="left">属性名称</th><th align="left">要求</th><th align="left">类型</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">org.quartz.scheduler.instanceName</td><td align="left">no</td><td align="left">string</td><td align="left">‘QuartzScheduler’</td></tr><tr><td align="left">org.quartz.scheduler.instanceId</td><td align="left">no</td><td align="left">string</td><td align="left">‘NON_CLUSTERED’</td></tr><tr><td align="left">org.quartz.scheduler.instanceIdGenerator.class</td><td align="left">no</td><td align="left">string (class name)</td><td align="left">org.quartz.simpl .SimpleInstanceIdGenerator</td></tr><tr><td align="left">org.quartz.scheduler.threadName</td><td align="left">no</td><td align="left">string</td><td align="left">instanceName + ‘_QuartzSchedulerThread’</td></tr><tr><td align="left">org.quartz.scheduler .makeSchedulerThreadDaemon</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.scheduler .threadsInheritContextClassLoaderOfInitializer</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.scheduler.idleWaitTime</td><td align="left">no</td><td align="left">long</td><td align="left">30000</td></tr><tr><td align="left">org.quartz.scheduler.dbFailureRetryInterval</td><td align="left">no</td><td align="left">long</td><td align="left">15000</td></tr><tr><td align="left">org.quartz.scheduler.classLoadHelper.class</td><td align="left">no</td><td align="left">string (class name)</td><td align="left">org.quartz.simpl .CascadingClassLoadHelper</td></tr><tr><td align="left">org.quartz.scheduler.jobFactory.class</td><td align="left">no</td><td align="left">string (class name)</td><td align="left">org.quartz.simpl.PropertySettingJobFactory</td></tr><tr><td align="left">org.quartz.context.key.SOME_KEY</td><td align="left">no</td><td align="left">string</td><td align="left">none</td></tr><tr><td align="left">org.quartz.scheduler.userTransactionURL</td><td align="left">no</td><td align="left">string (url)</td><td align="left">‘java:comp&#x2F;UserTransaction’</td></tr><tr><td align="left">org.quartz.scheduler .wrapJobExecutionInUserTransaction</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.scheduler.skipUpdateCheck</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.scheduler .batchTriggerAcquisitionMaxCount</td><td align="left">no</td><td align="left">int</td><td align="left">1</td></tr><tr><td align="left">org.quartz.scheduler .batchTriggerAcquisitionFireAheadTimeWindow</td><td align="left">no</td><td align="left">long</td><td align="left">0</td></tr></tbody></table><p><strong>org.quartz.scheduler.instanceName</strong></p><p>可以是任何字符串，并且该值对调度程序本身没有意义 - 而是用作客户端的机制 用于在同一程序中使用多个实例时区分调度程序的代码。如果您使用的是群集 功能，您必须对集群中“逻辑上”相同的调度程序的每个实例使用相同的名称。</p><p><strong>org.quartz.scheduler.instanceId</strong></p><p>可以是任何字符串，但对于所有调度程序必须是唯一的，就好像它们是 簇。如果您希望为您生成 Id，则可以使用值“AUTO”作为实例 ID。或值 “SYS_PROP”，如果您希望值来自系统属性“org.quartz.scheduler.instanceId”。</p><p><strong>org.quartz.scheduler.instanceIdGenerator.class</strong></p><p>仅当 <em>org.quartz.scheduler.instanceId</em> 设置为“AUTO”时才使用。默认为 “org.quartz.simpl.SimpleInstanceIdGenerator”，它根据主机名和时间戳生成实例 ID。 其他 IntanceIdGenerator 实现包括 SystemPropertyInstanceIdGenerator（获取实例 ID 来自系统属性“org.quartz.scheduler.instanceId”，以及使用 本地主机名（InetAddress.getLocalHost().getHostName()）。您还可以实现 InstanceIdGenerator接口。</p><p><strong>org.quartz.scheduler.threadName</strong></p><p>可以是作为 java 线程的有效名称的任何字符串。如果未指定此属性，线程将收到 调度程序的名称（“org.quartz.scheduler.instanceName”）加上附加的字符串“_QuartzSchedulerThread”。</p><p><strong>org.quartz.scheduler.makeSchedulerThreadDaemon</strong></p><p>一个布尔值（“true”或“false”），它指定调度程序的主线程应该是守护程序线程还是 不。另请参阅 <em>org.quartz.scheduler.makeSchedulerThreadDaemon</em> 属性，用于调整 <a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration/ConfigThreadPool.html">SimpleThreadPool</a> （如果这是线程池实现） 您正在使用（很可能是这种情况）。</p><p><strong>org.quartz.scheduler.threadsInheritContextClassLoaderOfInitializer</strong></p><p>一个布尔值（“true”或“false”），它指定 Quartz 生成的线程是否将继承上下文 初始化线程（初始化 Quartz 实例的线程）的类加载器。这将影响石英主 调度线程、JDBCJobStore 的 misfire 处理线程（如果使用 JDBCJobStore）、集群恢复线程（如果使用 使用集群），以及 SimpleThreadPool 中的线程（如果使用 SimpleThreadPool）。将此值设置为“true”可能会 帮助类装入、JNDI 查找以及与在应用程序服务器中使用 Quartz 相关的其他问题。</p><p><strong>org.quartz.scheduler.idleWaitTime</strong></p><p>是计划程序在重新查询可用触发器之前等待的时间量（以毫秒为单位），当 否则调度程序处于空闲状态。通常，您不必“调整”此参数，除非您使用的是 XA 事务， 并且存在延迟触发应立即触发的触发器的问题。小于 5000 毫秒的值不是 建议使用，因为它会导致过多的数据库查询。小于 1000 的值是不合法的。</p><p><strong>org.quartz.scheduler.dbFailureRetryInterval</strong></p><p>计划程序在检测到丢失 作业存储中的连接（例如，与数据库的连接）。这个参数在使用时显然不是很有意义 RamJobStore.</p><p><strong>org.quartz.scheduler.classLoadHelper.class</strong></p><p>默认使用最健壮的方法，即使用 “org.quartz.simpl.CascadingClassLoadHelper” 类 - 其中 turn 使用每隔一个 ClassLoadHelper 类，直到一个类工作。您可能不应该发现需要指定任何其他 类，尽管应用程序服务器中似乎发生了奇怪的事情。所有电流可能 ClassLoadHelper 实现可以在 <em>org.quartz.simpl</em> 包中找到。</p><p><strong>org.quartz.scheduler.jobFactory.class</strong></p><p>要使用的作业工厂的类名。JobFatcory 负责生成 JobClass 的实例。 默认值是“org.quartz.simpl.PropertySettingJobFactory”，它只是在类上调用 newInstance()来生成 每次即将执行时都有一个新实例。PropertySettingJobFactory 也反射性地 使用 SchedulerContext 和 Job and Trigger JobDataMap 的内容设置作业的 Bean 属性。</p><p><strong>org.quartz.context.key.SOME_KEY</strong></p><p>表示将作为字符串放入“调度程序上下文”的名称-值对。（请参阅 Scheduler.getContext（））。 例如，设置“org.quartz.context.key.MyKey &#x3D; MyValue”将执行等效于 scheduler.getContext().put(“MyKey”， “MyValue”).</p><blockquote><p>除非使用的是 JTA 事务，否则配置文件中应省略与事务相关的属性。</p></blockquote><p><strong>org.quartz.scheduler.userTransactionURL</strong></p><p>应设置为 JNDI URL，Quartz 可以在该 URL 上找到应用程序服务器的 UserTransaction 管理器。默认 值（如果未指定）为 “java:comp&#x2F;UserTransaction” - 它适用于几乎所有的应用程序服务器。网络圈 用户可能需要将此属性设置为“JTA&#x2F;UserTransaction”。仅当 Quartz 配置为使用 JobStoreCMT 和 <em>org.quartz.scheduler.wrapJobExecutionInUserTransaction</em> 设置为 true。</p><p><strong>org.quartz.scheduler.wrapJobExecutionInUserTransaction</strong></p><p>如果希望 Quartz 在对作业调用 execute 之前启动用户事务，则应设置为 “true”。Tx将 在作业的执行方法完成后提交，并在更新作业数据映射（如果它是有状态作业）之后提交。这 默认值为“假”。您可能还对使用 <em>@ExecuteInJTATransaction</em> 注释感兴趣 在您的作业类上，这使您可以控制单个作业是否应启动 JTA 事务 - 而此属性会导致它对所有作业发生。</p><p><strong>org.quartz.scheduler.skipUpdateCheck</strong></p><p>是否跳过运行快速 Web 请求以确定是否有可用于 Quartz 的更新版本 下载。如果检查运行，并找到更新，它将在 Quartz 的日志中报告为可用。你 还可以使用系统属性“org.terracotta.quartz.skipUpdateCheck&#x3D;true”禁用更新检查（其中 您可以在系统环境中设置，也可以在 java 命令行上设置为 -D）。建议您禁用 生产部署的更新检查。</p><p><strong>org.quartz.scheduler.batchTriggerAcquisition MaxCount</strong></p><p>允许调度程序节点一次获取（用于触发）的最大触发器数。默认值 为 1。数字越大，触发效率越高（在需要 一次全部触发） - 但代价是群集节点之间可能存在不平衡的负载。如果此值 属性设置为 &gt; 1，并使用 JDBC JobStore，然后属性“org.quartz.jobStore.acquireTriggersWithinLock” 必须设置为“true”以避免数据损坏。</p><p><strong>org.quartz.scheduler.batchTriggerAcquisition FireAheadTimeWindow</strong></p><p>允许在预定触发时间之前获取和触发触发器的时间量（以毫秒为单位）。<br>默认值为 0。数字越大，批量获取触发触发器的可能性就越大 并一次触发多个触发器 - 代价是触发器时间表未得到精确遵守（触发器可能会 早点开这个量）。在调度程序具有非常大的情况下，这可能很有用（为了性能起见） 需要同时或接近同时触发的触发器数。</p><h2 id="线程池的配置"><a href="#线程池的配置" class="headerlink" title="线程池的配置"></a>线程池的配置</h2><blockquote><p>调整作业执行的资源</p></blockquote><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.threadPool.class</td><td align="left">yes</td><td align="left">string (class name)</td><td align="left">null</td></tr><tr><td align="left">org.quartz.threadPool.threadCount</td><td align="left">yes</td><td align="left">int</td><td align="left">-1</td></tr><tr><td align="left">org.quartz.threadPool.threadPriority</td><td align="left">no</td><td align="left">int</td><td align="left">Thread.NORM_PRIORITY (5)</td></tr></tbody></table><p><strong>org.quartz.threadPool.class</strong></p><p>是要使用的线程池实现的名称。Quartz附带的线程池是“org.quartz.simpl.SimpleThreadPool”，应该满足几乎每个用户的需求。它的行为非常简单，并且经过了很好的测试。它提供了一个固定大小的线程池，这些线程池“存活”了调度程序的生存期。</p><p><strong>org.quartz.threadPool.threadCount</strong></p><p>可以是任何正整数，尽管您应该意识到只有 1 到 100 之间的数字非常实用。这是可用于并发执行作业的线程数。如果您只有几个作业每天触发几次，那么 1 个线程就足够了！如果您有数以万计的作业，每分钟都会触发许多作业，那么您可能希望线程计数更像 50 或 100（这在很大程度上取决于您的作业执行的工作的性质以及您的系统资源！</p><p><strong>org.quartz.threadPool.threadPriority</strong></p><p>可以是介于 <em>Thread.MIN_PRIORITY</em> (which is 1)和 <em>Thread.MAX_PRIORITY</em> (which is 10)之间的任何 int。默认值为 <em>Thread.NORM_PRIORITY</em> (5)。</p><h3 id="特定于简单线程池的属性"><a href="#特定于简单线程池的属性" class="headerlink" title="特定于简单线程池的属性"></a>特定于简单线程池的属性</h3><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.threadPool.makeThreadsDaemons</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.threadPool.threadsInheritGroupOfInitializingThread</td><td align="left">no</td><td align="left">boolean</td><td align="left">true</td></tr><tr><td align="left">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.threadPool.threadNamePrefix</td><td align="left">no</td><td align="left">string</td><td align="left">[Scheduler Name]_Worker</td></tr></tbody></table><p><strong>org.quartz.threadPool.makeThreadsDaemons</strong></p><p>可以设置为“true”，以将池中的线程创建为守护程序线程。默认值为“假”。另请参阅 <em><a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration/ConfigMain.html">org.quartz.scheduler.makeSchedulerThreadDaemon</a></em> 属性。</p><p><strong>org.quartz.threadPool.threadsInheritGroupOfInitializingThread</strong></p><p>可以为“真”或“假”，默认为 true。</p><p><strong>org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</strong></p><p>可以是“真”或“假”，默认为假。</p><p><strong>org.quartz.threadPool.threadNamePrefix</strong></p><p>工作线程池中线程名称的前缀 - 将延迟一个数字。</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>如果使用自己的线程池实现，则只需将属性命名为：</p><p><strong>设置自定义线程池的属性</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.quartz.threadPool.class</span> = <span class="string">com.mycompany.goo.FooThreadPool</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.somePropOfFooThreadPool</span> = <span class="string">someValue</span></span><br></pre></td></tr></table></figure><h2 id="侦听器的配置"><a href="#侦听器的配置" class="headerlink" title="侦听器的配置"></a>侦听器的配置</h2><p>全局侦听器可以由 StdSchedulerFactory 实例化和配置，或者您的应用程序可以自己完成 ，然后将侦听器注册到计划程序。“全局”听众收听每个事件 作业&#x2F;触发器，而不仅仅是直接引用它们的作业&#x2F;触发器。</p><p>通过配置文件配置侦听器包括给出一个名称，然后指定 类名，以及要在实例上设置的任何其他属性。该类必须具有无参数构造函数，并且 属性以反射方式设置。仅支持基元数据类型值（包括字符串）。</p><p>因此，定义“全局”触发器侦听器的常规模式是：</p><p><strong>配置全局触发器侦听器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.triggerListener.NAME.class = com.foo.MyListenerClass</span><br><span class="line">org.quartz.triggerListener.NAME.propName = propValue</span><br><span class="line">org.quartz.triggerListener.NAME.prop2Name = prop2Value</span><br></pre></td></tr></table></figure><p>定义“全局”JobListener 的一般模式是：</p><p><strong>配置全局作业侦听器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobListener.NAME.class = com.foo.MyListenerClass</span><br><span class="line">org.quartz.jobListener.NAME.propName = propValue</span><br><span class="line">org.quartz.jobListener.NAME.prop2Name = prop2Value</span><br></pre></td></tr></table></figure><h2 id="配置调度程序插件"><a href="#配置调度程序插件" class="headerlink" title="配置调度程序插件"></a>配置调度程序插件</h2><blockquote><p>向调度程序添加功能</p></blockquote><p>就像通过配置文件配置插件的侦听器一样，包括给出一个名称，然后指定类名，以及要在实例上设置的任何其他属性。该类必须具有 no-arg 构造函数，并且属性以反射方式设置。仅支持基元数据类型值（包括字符串）。</p><p>因此，定义插件的一般模式是：</p><p><strong>配置插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.plugin.NAME.class = com.foo.MyPluginClass</span><br><span class="line">org.quartz.plugin.NAME.propName = propValue</span><br><span class="line">org.quartz.plugin.NAME.prop2Name = prop2Value</span><br></pre></td></tr></table></figure><p>Quartz附带了几个插件，可以在<em>org.quartz.plugins</em>包（和子包）中找到。配置其中一些的示例如下：</p><h3 id="日志记录触发器历史记录插件的示例配置"><a href="#日志记录触发器历史记录插件的示例配置" class="headerlink" title="日志记录触发器历史记录插件的示例配置"></a>日志记录触发器历史记录插件的示例配置</h3><p>日志记录触发器历史插件捕获触发事件（它也是一个触发器侦听器）并使用雅加达共享资源日志记录。请参阅该类的 JavaDoc 以获取所有可能参数的列表。</p><p><strong>日志记录触发器历史记录插件的示例配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.plugin.triggHistory.class = \</span><br><span class="line">  org.quartz.plugins.history.LoggingTriggerHistoryPlugin</span><br><span class="line">org.quartz.plugin.triggHistory.triggerFiredMessage = \</span><br><span class="line">  Trigger \&#123;1\&#125;.\&#123;0\&#125; fired job \&#123;6\&#125;.\&#123;5\&#125; at: \&#123;4, date, HH:mm:ss MM/dd/yyyy&#125;</span><br><span class="line">org.quartz.plugin.triggHistory.triggerCompleteMessage = \</span><br><span class="line">  Trigger \&#123;1\&#125;.\&#123;0\&#125; completed firing job \&#123;6\&#125;.\&#123;5\&#125; at \&#123;4, date, HH:mm:ss MM/dd/yyyy\&#125;.</span><br></pre></td></tr></table></figure><h3 id="XML-调度数据处理器插件的示例配置"><a href="#XML-调度数据处理器插件的示例配置" class="headerlink" title="XML 调度数据处理器插件的示例配置"></a>XML 调度数据处理器插件的示例配置</h3><p>作业初始化插件从 XML 文件中读取一组作业和触发器，并在初始化期间将它们添加到调度程序中。它还可以删除现有数据。有关更多详细信息，请参阅该类的 JavaDoc。</p><p><strong>作业初始化插件的示例配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.plugin.jobInitializer.class = \</span><br><span class="line">  org.quartz.plugins.xml.XMLSchedulingDataProcessorPlugin</span><br><span class="line">org.quartz.plugin.jobInitializer.fileNames = \</span><br><span class="line">  data/my_job_data.xml</span><br><span class="line">org.quartz.plugin.jobInitializer.failOnFileNotFound = true</span><br></pre></td></tr></table></figure><p>该文件的 XML 架构定义可在此处找到：</p><p><a href="http://www.quartz-scheduler.org/xml/job_scheduling_data_1_8.xsd">http://www.quartz-scheduler.org/xml/job_scheduling_data_1_8.xsd</a></p><h3 id="关机钩子插件配置示例"><a href="#关机钩子插件配置示例" class="headerlink" title="关机钩子插件配置示例"></a>关机钩子插件配置示例</h3><p>关闭钩子插件捕获 JVM 终止的事件，并在调度程序上调用关闭。</p><p><strong>关机钩子插件的配置示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.plugin.shutdownhook.class = \</span><br><span class="line">  org.quartz.plugins.management.ShutdownHookPlugin</span><br><span class="line">org.quartz.plugin.shutdownhook.cleanShutdown = true</span><br></pre></td></tr></table></figure><h2 id="RMI-服务器和客户机的配置"><a href="#RMI-服务器和客户机的配置" class="headerlink" title="RMI 服务器和客户机的配置"></a>RMI 服务器和客户机的配置</h2><blockquote><p>使用远程的 Quartz 实例</p></blockquote><p>没有一个主要属性是必需的，并且所有属性都有“合理”的默认值。通过RMI使用石英时，您 需要启动一个 Quartz 实例，并将其配置为通过 RMI “导出”其服务。然后，创建客户端到 服务器通过配置 Quartz 调度程序将其工作“代理”到服务器。</p><blockquote><p>某些用户在客户端和服务器之间遇到类可用性（即作业类）问题。要工作 通过这些问题，您需要了解RMI的“代码库”和RMI安全管理器。您可能会发现这些 有用的资源：</p></blockquote><p>RMI和代码库的出色描述：<a href="http://www.kedwards.com/jini/codebase.html%E3%80%82%E9%87%8D%E7%82%B9%E4%B9%8B%E4%B8%80">http://www.kedwards.com/jini/codebase.html。重点之一</a> 就是要意识到“代码库”被客户端使用！</p><p>有关安全管理器的快速信息：<a href="http://gethelp.devx.com/techtips/java_pro/10MinuteSolutions/10min0500.asp">http://gethelp.devx.com/techtips/java_pro/10MinuteSolutions/10min0500.asp</a></p><p>最后，从Java API文档中，阅读RMISecurityManager的文档。</p><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.scheduler.rmi.export</td><td align="left">no</td><td align="left">false</td></tr><tr><td align="left">org.quartz.scheduler.rmi.registryHost</td><td align="left">no</td><td align="left">‘localhost’</td></tr><tr><td align="left">org.quartz.scheduler.rmi.registryPort</td><td align="left">no</td><td align="left">1099</td></tr><tr><td align="left">org.quartz.scheduler.rmi.createRegistry</td><td align="left">no</td><td align="left">‘never’</td></tr><tr><td align="left">org.quartz.scheduler.rmi.serverPort</td><td align="left">no</td><td align="left">random</td></tr><tr><td align="left">org.quartz.scheduler.rmi.proxy</td><td align="left">no</td><td align="left">false</td></tr></tbody></table><p><strong>org.quartz.scheduler.rmi.export</strong></p><p>如果您希望 Quartz 调度程序通过 RMI 将自身导出为服务器，请将“rmi.export”标志设置为 true。</p><p><strong>org.quartz.scheduler.rmi.registryHost</strong></p><p>可以找到 RMI 注册表的主机（通常为“本地主机”）。</p><p><strong>org.quartz.scheduler.rmi.registryPort</strong></p><p>RMI 注册表正在侦听的端口（通常为 1099）。</p><p><strong>org.quartz.scheduler.rmi.createRegistry</strong></p><p>设置“rmi.createRegistry”标志，根据您希望Quartz如何导致创建RMI注册表。使用“假” 或“从不”，如果您不希望 Quartz 创建注册表（例如，如果您已经运行了外部注册表）。用 “true”或“as_needed”，如果您希望 Quartz 首先尝试使用现有注册表，然后回退到创建 一。如果您希望 Quartz 尝试创建注册表，然后回退到使用现有注册表，请使用“always”。如果 注册表已创建，它将绑定到给定的“org.quartz.scheduler.rmi.registryPort”属性中的端口号，并且 ‘org.quartz.rmi.registryHost’ 应该是 “localhost”。</p><p><strong>org.quartz.scheduler.rmi.serverPort</strong></p><p>Quartz 计划程序服务将绑定和侦听连接的端口。默认情况下，RMI 服务 将“随机”选择一个端口，因为调度程序绑定到 RMI 注册表。</p><p><strong>org.quartz.scheduler.rmi.proxy</strong></p><p>如果要连接到（使用）远程服务的调度程序，请将“org.quartz.scheduler.rmi.proxy”标志设置为 true。 然后，还必须为 RMI 注册表进程指定主机和端口 - 通常是“localhost”端口 1099。</p><blockquote><p>为“org.quartz.scheduler.rmi.export”和“org.quartz.scheduler.rmi.export”指定“true”值是没有意义的 “org.quartz.scheduler.rmi.proxy”在同一个配置文件中 - 如果这样做，“导出”选项将被忽略。值为 “export”和“proxy”属性的“false”当然是有效的，如果您没有通过RMI使用Quartz。</p></blockquote><h2 id="RAMJobStore-的配置"><a href="#RAMJobStore-的配置" class="headerlink" title="RAMJobStore 的配置"></a>RAMJobStore 的配置</h2><blockquote><p>将作业和触发器存储在内存中</p></blockquote><p>RAMJobStore 用于将调度信息（作业、触发器和日历）存储在内存中。RAMJobStore 快速且轻量级，但当进程终止时，所有调度信息都会丢失。</p><p><strong>RAMJobStore 是通过设置“org.quartz.jobStore.class”属性来选择的，如下所示：</strong></p><p><strong>将调度程序的作业存储设置为 RAMJobStore</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore</span><br></pre></td></tr></table></figure><p>RAMJobStore 可以使用以下属性进行调整：</p><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.jobStore.misfireThreshold</td><td align="left">no</td><td align="left">int</td><td align="left">60000</td></tr></tbody></table><p><strong>org.quartz.jobStore.misfireThreshold</strong></p><p>调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。</p><h2 id="JDBC-JobStoreTX-的配置"><a href="#JDBC-JobStoreTX-的配置" class="headerlink" title="JDBC-JobStoreTX 的配置"></a>JDBC-JobStoreTX 的配置</h2><blockquote><p>通过JDBC将作业和触发器存储在数据库中</p></blockquote><p>JDBCJobStore 用于在关系数据库中存储调度信息（作业、触发器和日历）。实际上，您可以根据所需的事务行为选择两个单独的 JDBCJobStore 类。</p><p>JobStoreTX 通过在每次操作（例如添加作业）后在数据库连接上调用 commit（）（或 rollback（））来管理所有事务本身。JDBCJobStore 适用于在独立应用程序中使用 Quartz，或者如果应用程序未使用 JTA 事务，则适用于 Servlet 容器。</p><p>JobStoreTX是通过设置“org.quartz.jobStore.class”属性来选择的，如下所示：</p><p><strong>将调度程序的作业存储设置为 JobStoreTX</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br></pre></td></tr></table></figure><p>可以使用以下属性调整 JobStoreTX：</p><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.jobStore.driverDelegateClass</td><td align="left">yes</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.dataSource</td><td align="left">yes</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.tablePrefix</td><td align="left">no</td><td align="left">string</td><td align="left">“QRTZ_”</td></tr><tr><td align="left">org.quartz.jobStore.useProperties</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.misfireThreshold</td><td align="left">no</td><td align="left">int</td><td align="left">60000</td></tr><tr><td align="left">org.quartz.jobStore.isClustered</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.clusterCheckinInterval</td><td align="left">no</td><td align="left">long</td><td align="left">15000</td></tr><tr><td align="left">org.quartz.jobStore.maxMisfiresToHandleAtATime</td><td align="left">no</td><td align="left">int</td><td align="left">20</td></tr><tr><td align="left">org.quartz.jobStore.dontSetAutoCommitFalse</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.selectWithLockSQL</td><td align="left">no</td><td align="left">string</td><td align="left">“SELECT * FROM {0}LOCKS WHERE SCHED_NAME &#x3D; {1} AND LOCK_NAME &#x3D; ? FOR UPDATE”</td></tr><tr><td align="left">org.quartz.jobStore.txIsolationLevelSerializable</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.acquireTriggersWithinLock</td><td align="left">no</td><td align="left">boolean</td><td align="left">false (or true - see doc below)</td></tr><tr><td align="left">org.quartz.jobStore.lockHandler.class</td><td align="left">no</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.driverDelegateInitString</td><td align="left">no</td><td align="left">string</td><td align="left">null</td></tr></tbody></table><p><strong>org.quartz.jobStore.driverDelegateClass</strong></p><p>驱动程序代表了解不同数据库系统的特定“方言”。可能的选择包括：</p><ul><li>org.quartz.impl.jdbcjobstore.StdJDBCDelegate （用于完全符合JDBC的驱动程序）</li><li>org.quartz.impl.jdbcjobstore.MSSQLDelegate （for Microsoft SQL Server， and Sybase）</li><li>org.quartz.impl.jdbcjobstore.PostgreSQLDelegate</li><li>org.quartz.impl.jdbcjobstore.WebLogicDelegate （for WebLogic drivers）</li><li>org.quartz.impl.jdbcjobstore.oracle.OracleDelegate</li><li>org.quartz.impl.jdbcjobstore.oracle.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序）</li><li>org.quartz.impl.jdbcjobstore.oracle.weblogic.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序）</li><li>org.quartz.impl.jdbcjobstore.CloudscapeDelegate</li><li>org.quartz.impl.jdbcjobstore.DB2v6Delegate</li><li>org.quartz.impl.jdbcjobstore.DB2v7Delegate</li><li>org.quartz.impl.jdbcjobstore.DB2v8Delegate</li><li>org.quartz.impl.jdbcjobstore.HSQLDBDelegate</li><li>org.quartz.impl.jdbcjobstore.PointbaseDelegate</li><li>org.quartz.impl.jdbcjobstore.SybaseDelegate</li></ul><p>请注意，已知许多数据库与 StdJDBCDelegate 配合使用，而其他数据库已知与其他数据库的委托配合使用，例如 Derby 与 Cloudscape 委托配合良好（这并不奇怪）。</p><p><strong>org.quartz.jobStore.dataSource</strong></p><p>此属性的值必须是配置属性文件中定义的数据源之一的名称。有关详细信息，请参阅<a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration/ConfigDataSources.html">数据源的配置文档</a>。</p><p><strong>org.quartz.jobStore.tablePrefix</strong></p><p>JDBCJobStore 的“表前缀”属性是一个字符串，等于在数据库中创建的 Quartz 表的前缀。如果 Quartz 表使用不同的表前缀，则可以在同一数据库中拥有多组 Quartz 表。</p><p><strong>org.quartz.jobStore.useProperties</strong></p><p>“use properties”标志指示 JDBCJobStore JobDataMaps 中的所有值都将是字符串，因此可以存储为名称-值对，而不是在 BLOB 列中以序列化形式存储更复杂的对象。这可能很方便，因为您可以避免将非字符串类序列化为 BLOB 时可能出现的类版本控制问题。</p><p><strong>org.quartz.jobStore.misfireThreshold</strong></p><p>调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。</p><p><strong>org.quartz.jobStore.isClustered</strong></p><p>设置为“true”以打开聚类功能。如果有多个 Quartz 实例使用同一组数据库表，则必须将此属性设置为“true”…否则你将经历浩劫。有关详细信息，请参阅群集的配置文档。</p><p><strong>org.quartz.jobStore.clusterCheckinInterval</strong></p><p>设置此实例与群集的其他实例“签入”*的频率（以毫秒为单位）。影响检测失败实例的速度。</p><p><strong>org.quartz.jobStore.maxMisfiresToHandleAtATime</strong></p><p>作业存储将在给定传递中处理的最大触发触发器数。一次处理多个（超过几十个）可能会导致数据库表被锁定足够长的时间，以至于触发其他（尚未错误触发）触发器的性能可能会受到阻碍。</p><p><strong>org.quartz.jobStore.dontSetAutoCommitFalse</strong></p><p>将此参数设置为“true”告诉 Quartz 不要在从数据源获取的连接上调用 setAutoCommit（false）。这在某些情况下可能会有所帮助，例如，如果您的驱动程序在已经关闭时被调用时会抱怨。此属性默认为 false，因为大多数驱动程序要求调用 setAutoCommit（false）。</p><p><strong>org.quartz.jobStore.selectWithLockSQL</strong></p><p>必须是在“LOCKS”表中选择一行并在该行上放置锁的 SQL 字符串。如果未设置，则默认值为“从{0}锁定中选择 *，其中 SCHED_NAME &#x3D; {1} 和 LOCK_NAME &#x3D; ？用于更新“，适用于大多数数据库。“{0}”在运行时替换为上面配置的TABLE_PREFIX。“{1}”将替换为调度程序的名称。</p><p><strong>org.quartz.jobStore.txIsolationLevelSerializable</strong></p><p>值“true”告诉Quartz（使用JobStoreTX或CMT时）在JDBC连接上调用setTransactionIsolation（Connection.TRANSACTION_SERIALIZABLE）。这有助于防止某些数据库在高负载下出现锁定超时，以及“持久”事务。</p><p><strong>org.quartz.jobStore.acquireTriggersWithinLock</strong></p><p>是否应在显式数据库锁中获取下一个要触发的触发器。这曾经是必要的（在以前的Quartz版本中）以避免特定数据库的死锁，但不再被认为是必要的，因此默认值为“false”。</p><p>如果将“org.quartz.scheduler.batchTriggerAcquisition MaxCount”设置为 &gt; 1，并且使用了 JDBC JobStore，则必须将此属性设置为“true”以避免数据损坏（从 Quartz 2.1.1 开始，如果 batchTriggerAcquisitionMaxCount 设置为 1，则“true”现在是默认值&gt;）。</p><p><strong>org.quartz.jobStore.lockHandler.class</strong></p><p>用于生成 org.quartz.impl.jdbcjobstore.Semaphore 实例的类名，用于对作业存储数据进行锁定控制。这是一项高级配置功能，大多数用户不应使用它。默认情况下，Quartz 将选择最合适的（预捆绑）信号量实现来使用。“org.quartz.impl.jdbcjobstore.UpdateLockRowSemaphore” <a href="http://jira.opensymphony.com/browse/QUARTZ-497">QUARTZ-497</a>可能对MS SQL Server用户感兴趣。参见<a href="http://jira.opensymphony.com/browse/QUARTZ-441">石英-441</a>。</p><p><strong>org.quartz.jobStore.driverDelegateInitString</strong></p><p>可在初始化期间传递给 DriverDelegate 的属性（及其值）的管道分隔列表。</p><p>字符串的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;settingName=settingValue|otherSettingName=otherSettingValue|...&quot;</span><br></pre></td></tr></table></figure><p>StdJDBCDelegate 及其所有后代（所有随 Quartz 一起提供的委托）支持名为“triggerPersistenceDelegateClasses”的属性，该属性可以设置为以逗号分隔的类列表，这些类实现用于存储自定义触发器类型的 TriggerPersistenceDelegate 接口。有关为自定义触发器编写持久性委托的示例，请参阅 Java 类 SimplePropertiesTriggerPersistenceDelegateSupport 和 SimplePropertiesTriggerPersistenceDelegateSupport。</p><h2 id="JDBC-JobStoreCMT-的配置"><a href="#JDBC-JobStoreCMT-的配置" class="headerlink" title="JDBC-JobStoreCMT 的配置"></a>JDBC-JobStoreCMT 的配置</h2><blockquote><p>JDBC with JTA 容器管理 交易</p></blockquote><p>JDBCJobStore 用于在关系数据库中存储调度信息（作业、触发器和日历）。实际上，您可以根据所需的事务行为选择两个单独的 JDBCJobStore 类。</p><p>JobStoreCMT依赖于由使用Quartz的应用程序管理的事务。在尝试调度（或取消调度）作业&#x2F;触发器之前，JTA 事务必须正在进行中。这允许调度的“工作”成为应用程序“更大”事务的一部分。JobStoreCMT 实际上需要使用两个数据源 - 一个数据源的连接事务由应用程序服务器（通过 JTA）管理，另一个数据源的连接不参与全局 （JTA） 事务。JobStoreCMT 适用于应用程序使用 JTA 事务（例如通过 EJB Session Beans）来执行其工作的情况。</p><p>通过设置“org.quartz.jobStore.class”属性来选择JobStore，如下所示：</p><p><strong>将调度程序的作业存储设置为 JobStoreCMT</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreCMT</span><br></pre></td></tr></table></figure><p>可以使用以下属性调整 JobStoreCMT：</p><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.jobStore.driverDelegateClass</td><td align="left">yes</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.dataSource</td><td align="left">yes</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.nonManagedTXDataSource</td><td align="left">yes</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.tablePrefix</td><td align="left">no</td><td align="left">string</td><td align="left">“QRTZ_”</td></tr><tr><td align="left">org.quartz.jobStore.useProperties</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.misfireThreshold</td><td align="left">no</td><td align="left">int</td><td align="left">60000</td></tr><tr><td align="left">org.quartz.jobStore.isClustered</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.clusterCheckinInterval</td><td align="left">no</td><td align="left">long</td><td align="left">15000</td></tr><tr><td align="left">org.quartz.jobStore.maxMisfiresToHandleAtATime</td><td align="left">no</td><td align="left">int</td><td align="left">20</td></tr><tr><td align="left">org.quartz.jobStore.dontSetAutoCommitFalse</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.dontSetNonManagedTXConnectionAutoCommitFalse</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.selectWithLockSQL</td><td align="left">no</td><td align="left">string</td><td align="left">“SELECT * FROM {0}LOCKS WHERE SCHED_NAME &#x3D; {1} AND LOCK_NAME &#x3D; ? FOR UPDATE”</td></tr><tr><td align="left">org.quartz.jobStore.txIsolationLevelSerializable</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.txIsolationLevelReadCommitted</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.jobStore.acquireTriggersWithinLock</td><td align="left">no</td><td align="left">boolean</td><td align="left">false (or true - see doc below)</td></tr><tr><td align="left">org.quartz.jobStore.lockHandler.class</td><td align="left">no</td><td align="left">string</td><td align="left">null</td></tr><tr><td align="left">org.quartz.jobStore.driverDelegateInitString</td><td align="left">no</td><td align="left">string</td><td align="left">null</td></tr></tbody></table><p><strong>org.quartz.jobStore.driverDelegateClass</strong></p><p>驱动程序代表了解不同数据库系统的特定“方言”。可能的选择包括：</p><ul><li>org.quartz.impl.jdbcjobstore.StdJDBCDelegate （用于完全符合JDBC的驱动程序）</li><li>org.quartz.impl.jdbcjobstore.MSSQLDelegate （for Microsoft SQL Server， and Sybase）</li><li>org.quartz.impl.jdbcjobstore.PostgreSQLDelegate</li><li>org.quartz.impl.jdbcjobstore.WebLogicDelegate （for WebLogic drivers）</li><li>org.quartz.impl.jdbcjobstore.oracle.OracleDelegate</li><li>org.quartz.impl.jdbcjobstore.oracle.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序）</li><li>org.quartz.impl.jdbcjobstore.oracle.weblogic.WebLogicOracleDelegate （用于 Weblogic 中使用的 Oracle 驱动程序）</li><li>org.quartz.impl.jdbcjobstore.CloudscapeDelegate</li><li>org.quartz.impl.jdbcjobstore.DB2v6Delegate</li><li>org.quartz.impl.jdbcjobstore.DB2v7Delegate</li><li>org.quartz.impl.jdbcjobstore.DB2v8Delegate</li><li>org.quartz.impl.jdbcjobstore.HSQLDBDelegate</li><li>org.quartz.impl.jdbcjobstore.PointbaseDelegate</li><li>org.quartz.impl.jdbcjobstore.SybaseDelegate</li></ul><p>请注意，已知许多数据库与 StdJDBCDelegate 配合使用，而其他数据库已知与其他数据库的委托配合使用，例如 Derby 与 Cloudscape 委托配合良好（这并不奇怪）。</p><p><strong>org.quartz.jobStore.dataSource</strong></p><p>此属性的值必须是配置属性文件中定义的数据源之一的名称。对于 JobStoreCMT，此数据源需要包含能够参与 JTA（例如容器管理的）事务的连接。这通常意味着数据源将在应用程序服务器内部由应用程序服务器配置和维护，Quartz 将通过 JNDI 获取它的句柄。有关详细信息，请参阅<a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration/ConfigDataSources.html">数据源的配置文档</a>。</p><p><strong>org.quartz.jobStore.nonManagedTXDataSource</strong></p><p>JobStoreCMT <em>需要一个</em>（第二个）数据源，其中包含<em>不属于</em>容器管理事务的连接。此属性的值必须是配置属性文件中定义的数据源之一的名称。此数据源必须包含非 CMT 连接，或者换句话说，Quartz 直接调用 commit（） 和 rollback（） 的连接是合法的。</p><p><strong>org.quartz.jobStore.tablePrefix</strong></p><p>JDBCJobStore 的“表前缀”属性是一个字符串，等于在数据库中创建的 Quartz 表的前缀。如果 Quartz 表使用不同的表前缀，则可以在同一数据库中拥有多组 Quartz 表。</p><p><strong>org.quartz.jobStore.useProperties</strong></p><p>“use properties”标志指示 JDBCJobStore JobDataMaps 中的所有值都将是字符串，因此可以存储为名称-值对，而不是在 BLOB 列中以序列化形式存储更复杂的对象。这可能很方便，因为您可以避免将非字符串类序列化为 BLOB 时可能出现的类版本控制问题。</p><p><strong>org.quartz.jobStore.misfireThreshold</strong></p><p>调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。</p><p><strong>org.quartz.jobStore.isClustered</strong></p><p>设置为“true”以打开聚类功能。如果有多个 Quartz 实例使用同一组数据库表，则必须将此属性设置为“true”…否则你将经历浩劫。有关详细信息，请参阅群集的配置文档。</p><p><strong>org.quartz.jobStore.clusterCheckinInterval</strong></p><p>设置此实例与群集的其他实例“签入”*的频率（以毫秒为单位）。影响检测失败实例的速度。</p><p><strong>org.quartz.jobStore.maxMisfiresToHandleAtATime</strong></p><p>作业存储将在给定传递中处理的最大触发触发器数。一次处理多个（超过几十个）可能会导致数据库表被锁定足够长的时间，以至于触发其他（尚未错误触发）触发器的性能可能会受到阻碍。</p><p><strong>org.quartz.jobStore.dontSetAutoCommitFalse</strong></p><p>将此参数设置为“true”告诉 Quartz 不要在从数据源获取的连接上调用 <em>setAutoCommit（false）。</em>这在某些情况下可能会有所帮助，例如，如果您的驱动程序在已经关闭时被调用时会抱怨。此属性默认为 false，因为大多数驱动程序要求调用 <em>setAutoCommit（false）。</em></p><p><strong>org.quartz.jobStore.dontSetNonManagedTXConnectionAutoCommitFalse</strong></p><p>与属性 <em>org.quartz.jobStore.dontSetAutoCommitFalse</em> 相同，只是它适用于非 ManagedTXDataSource。</p><p><strong>org.quartz.jobStore.selectWithLockSQL</strong></p><p>必须是在“LOCKS”表中选择一行并在该行上放置锁的 SQL 字符串。如果未设置，则默认值为“从{0}锁定中选择 *，其中 SCHED_NAME &#x3D; {1} 和 LOCK_NAME &#x3D; ？用于更新“，适用于大多数数据库。“{0}”在运行时替换为上面配置的TABLE_PREFIX。“{1}”将替换为调度程序的名称。</p><p><strong>org.quartz.jobStore.txIsolationLevelSerializable</strong></p><p>值“true”告诉Quartz在JDBC连接上调用<em>setTransactionIsolation（Connection.TRANSACTION_SERIALIZABLE</em>）。这有助于防止某些数据库在高负载下出现锁定超时，以及“持久”事务。</p><p><strong>org.quartz.jobStore.txIsolationLevelReadCommit</strong></p><p>当设置为 “true” 时，此属性告诉 Quartz 在非托管 JDBC 连接上调用 <em>setTransactionIsolation（Connection.TRANSACTION_READ_COMMITTED</em>）。这有助于防止某些数据库（如 DB2）在高负载下出现锁定超时，以及“持久”事务。</p><p><strong>org.quartz.jobStore.acquireTriggersWithinLock</strong></p><p>是否应在显式数据库锁中获取下一个要触发的触发器。这曾经是必要的（在以前的Quartz版本中）以避免特定数据库的死锁，但不再被认为是必要的，因此默认值为“false”。</p><p>如果将“org.quartz.scheduler.batchTriggerAcquisition MaxCount”设置为 &gt; 1，并且使用了 JDBC JobStore，则必须将此属性设置为“true”以避免数据损坏（从 Quartz 2.1.1 开始，如果 batchTriggerAcquisitionMaxCount 设置为 1，则“true”现在是默认值&gt;）。</p><p><strong>org.quartz.jobStore.lockHandler.class</strong></p><p>用于生成 org.quartz.impl.jdbcjobstore.Semaphore 实例的类名，用于对作业存储数据进行锁定控制。这是一项高级配置功能，大多数用户不应使用它。默认情况下，Quartz 将选择最合适的（预捆绑）信号量实现来使用。“org.quartz.impl.jdbcjobstore.UpdateLockRowSemaphore” <a href="http://jira.opensymphony.com/browse/QUARTZ-497">QUARTZ-497</a>可能对MS SQL Server用户感兴趣。与Quartz捆绑在一起的“JTANonClusteredSemaphore”在使用JobStoreCMT时可能会提高性能，尽管它是一个实验性实现。参见石英-441和<a href="http://jira.opensymphony.com/browse/QUARTZ-442">石英-442</a></p><p><strong>org.quartz.jobStore.driverDelegateInitString</strong></p><p>可在初始化期间传递给 DriverDelegate 的属性（及其值）的管道分隔列表。</p><p>字符串的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;settingName=settingValue|otherSettingName=otherSettingValue|...&quot;</span><br></pre></td></tr></table></figure><p>StdJDBCDelegate 及其所有后代（所有随 Quartz 一起提供的委托）支持名为“triggerPersistenceDelegateClasses”的属性，该属性可以设置为以逗号分隔的类列表，这些类实现用于存储自定义触发器类型的 TriggerPersistenceDelegate 接口。有关为自定义触发器编写持久性委托的示例，请参阅 Java 类 SimplePropertiesTriggerPersistenceDelegateSupport 和 SimplePropertiesTriggerPersistenceDelegateSupport。</p><h2 id="数据源的配置"><a href="#数据源的配置" class="headerlink" title="数据源的配置"></a>数据源的配置</h2><blockquote><p>供 JDBC-JobStore 使用</p></blockquote><p>如果您使用的是 JDBC-Jobstore，则需要一个数据源（如果您使用的是 JobStoreCMT，则需要两个数据源）。</p><p>可以通过三种方式配置数据源：</p><ol><li>在 quartz.properties 文件中指定的所有池属性，以便 Quartz 可以创建数据源本身。</li><li>可以指定应用程序服务器管理的数据源的 JNDI 位置，以便 Quartz 可以使用它。</li><li>自定义<em>定义的org.quartz.utils.ConnectionProvider</em>实现。</li></ol><p>建议将数据源最大连接大小配置为至少为线程池中的工作线程数加 3。 如果应用程序还频繁调用计划程序 API，则可能需要其他连接。如果您使用的是 JobStoreCMT， “非托管”数据源的最大连接大小应至少为 4。</p><p>必须为您定义的每个数据源（通常为一个或两个）指定一个名称，并且为每个数据源定义的属性必须包含该名称，如下所示。数据源的“NAME”可以是您想要的任何内容，除了在分配给 JDBCJobStore 时能够识别它之外，没有任何意义。</p><h3 id="Quartz-创建的数据源使用以下属性进行定义："><a href="#Quartz-创建的数据源使用以下属性进行定义：" class="headerlink" title="Quartz 创建的数据源使用以下属性进行定义："></a>Quartz 创建的数据源使用以下属性进行定义：</h3><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.dataSource.NAME.driver</td><td align="left">yes</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.URL</td><td align="left">yes</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.user</td><td align="left">no</td><td align="left">String</td><td align="left">“”</td></tr><tr><td align="left">org.quartz.dataSource.NAME.password</td><td align="left">no</td><td align="left">String</td><td align="left">“”</td></tr><tr><td align="left">org.quartz.dataSource.NAME.maxConnections</td><td align="left">no</td><td align="left">int</td><td align="left">10</td></tr><tr><td align="left">org.quartz.dataSource.NAME.validationQuery</td><td align="left">no</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.idleConnectionValidationSeconds</td><td align="left">no</td><td align="left">int</td><td align="left">50</td></tr><tr><td align="left">org.quartz.dataSource.NAME.validateOnCheckout</td><td align="left">no</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">org.quartz.dataSource.NAME.discardIdleConnectionsSeconds</td><td align="left">no</td><td align="left">int</td><td align="left">0 (disabled)</td></tr></tbody></table><p><strong>org.quartz.dataSource.NAME.driver</strong></p><p>必须是数据库的 JDBC 驱动程序的 Java 类名。</p><p><strong>org.quartz.dataSource.NAME.URL</strong></p><p>用于连接到数据库的连接 URL（主机、端口等）。</p><p><strong>org.quartz.dataSource.NAME.user</strong></p><p>连接到数据库时要使用的用户名。</p><p><strong>org.quartz.dataSource.NAME.password</strong></p><p>连接到数据库时要使用的密码。</p><p><strong>org.quartz.dataSource.NAME.maxConnections</strong></p><p>数据源可以在其连接池中创建的最大连接数。</p><p><strong>org.quartz.dataSource.NAME.validationQuery</strong></p><p>是可选的 SQL 查询字符串，数据源可用于检测和替换失败&#x2F;损坏的连接。<br>例如，oracle 用户可能会选择“从user_tables中选择table_name”——这是一个永远不应该的查询。 失败 - 除非连接确实错误。</p><p><strong>org.quartz.dataSource.NAME.idleConnectionValidationSeconds</strong></p><p>空闲连接测试之间的秒数 - 仅在设置了验证查询属性时启用。<br>默认值为 50 秒。</p><p><strong>org.quartz.dataSource.NAME.validateOnCheckout</strong></p><p>是否应在每次检索连接时执行用于验证连接的数据库 sql 查询 以确保它仍然有效。如果为 false，则验证将在签入时进行。默认值为假。</p><p><strong>org.quartz.dataSource.NAME.discardIdleConnectionsSeconds</strong></p><p>在连接空闲了这么多秒后丢弃连接。0 禁用该功能。默认值为 0。</p><p><strong>石英定义的数据源示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.dataSource.myDS.driver = oracle.jdbc.driver.OracleDriver</span><br><span class="line">org.quartz.dataSource.myDS.URL = jdbc:oracle:thin:@10.0.1.23:1521:demodb</span><br><span class="line">org.quartz.dataSource.myDS.user = myUser</span><br><span class="line">org.quartz.dataSource.myDS.password = myPassword</span><br><span class="line">org.quartz.dataSource.myDS.maxConnections = 30</span><br></pre></td></tr></table></figure><h3 id="对应用程序服务器数据源的引用使用以下属性定义："><a href="#对应用程序服务器数据源的引用使用以下属性定义：" class="headerlink" title="对应用程序服务器数据源的引用使用以下属性定义："></a>对应用程序服务器数据源的引用使用以下属性定义：</h3><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.dataSource.NAME.jndiURL</td><td align="left">yes</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.java.naming.factory.initial</td><td align="left">no</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.java.naming.provider.url</td><td align="left">no</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.java.naming.security.principal</td><td align="left">no</td><td align="left">String</td><td align="left">null</td></tr><tr><td align="left">org.quartz.dataSource.NAME.java.naming.security.credentials</td><td align="left">no</td><td align="left">String</td><td align="left">null</td></tr></tbody></table><p><strong>org.quartz.dataSource.NAME.jndiURL</strong></p><p>由应用程序服务器管理的数据源的 JNDI URL。</p><p><strong>org.quartz.dataSource.NAME.java.nameing.factory.initial</strong></p><p>您希望使用的 JNDI InitialContextFactory 的（可选）类名。</p><p><strong>org.quartz.dataSource.NAME.java.naming.provider.url</strong></p><p>用于连接到 JNDI 上下文的（可选）URL。</p><p><strong>org.quartz.dataSource.NAME.java.nameing.security.principal</strong></p><p>用于连接到 JNDI 上下文的（可选）用户主体。</p><p><strong>org.quartz.dataSource.NAME.java.nameing.security.credentials</strong></p><p>用于连接到 JNDI 上下文的（可选）用户凭证。</p><p><strong>从应用程序服务器引用的数据源示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.dataSource.myOtherDS.jndiURL=jdbc/myDataSource</span><br><span class="line">org.quartz.dataSource.myOtherDS.java.naming.factory.initial=com.evermind.server.rmi.RMIInitialContextFactory</span><br><span class="line">org.quartz.dataSource.myOtherDS.java.naming.provider.url=ormi://localhost</span><br><span class="line">org.quartz.dataSource.myOtherDS.java.naming.security.principal=admin</span><br><span class="line">org.quartz.dataSource.myOtherDS.java.naming.security.credentials=123</span><br></pre></td></tr></table></figure><h3 id="自定义连接提供程序实现"><a href="#自定义连接提供程序实现" class="headerlink" title="自定义连接提供程序实现"></a>自定义连接提供程序实现</h3><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.dataSource.NAME.connectionProvider.class</td><td align="left">yes</td><td align="left">String (class name)</td><td align="left">null</td></tr></tbody></table><p><strong>org.quartz.dataSource.NAME.connectionProvider.class</strong></p><p>要使用的连接提供程序的类名。实例化类后，Quartz 可以自动设置实例上的配置属性，Bean 样式。</p><p><strong>使用自定义连接提供程序实现的示例</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.quartz.dataSource.myCustomDS.connectionProvider.class</span> = <span class="string">com.foo.FooConnectionProvider</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myCustomDS.someStringProperty</span> = <span class="string">someValue</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myCustomDS.someIntProperty</span> = <span class="string">5</span></span><br></pre></td></tr></table></figure><h2 id="数据库群集的配置"><a href="#数据库群集的配置" class="headerlink" title="数据库群集的配置"></a>数据库群集的配置</h2><blockquote><p>实现故障转移和 使用 JDBC-JobStore 进行负载平衡</p></blockquote><p>Quartz 的集群功能通过故障转移和负载平衡功能为您的调度程序带来高可用性和可扩展性。</p><p><img src="/2023/07/SpringBoot3%E9%9B%86%E6%88%90Quartz%E8%AF%A6%E7%BB%86%E7%89%88/quartz_cluster.png" alt="img"></p><p>集群目前仅适用于 JDBC-Jobstore（JobStoreTX 或 JobStoreCMT），并且基本上是通过让集群的每个节点共享相同的数据库来工作的。</p><p>负载平衡会自动发生，群集的每个节点都会尽快触发作业。当触发器的触发时间发生时，第一个获取它的节点（通过在其上放置锁定）是将触发它的节点。</p><p>每次触发时，只有一个节点将触发作业。我的意思是，如果作业有一个重复触发器 告诉它每 10 秒触发一次，然后在 12：00：00 正好有一个节点将运行作业，而在 12：00：10 恰好运行一个节点 节点将运行作业等。它不一定每次都是同一个节点 - 它或多或少是随机的 节点运行它。对于繁忙的计划程序（大量触发器），负载平衡机制几乎是随机的，但有利于 非繁忙（例如几个触发器）调度程序的同一节点。</p><p>当其中一个节点在执行一个或多个作业时发生故障时，就会发生故障转移。当节点发生故障时， 其他节点检测情况并识别数据库中故障节点中正在进行的作业。<br>任何标记为恢复的作业（在 JobDetail 上带有“请求恢复”属性）将由 其余节点。未标记为恢复的作业将只是在下次触发相关触发器时释放以执行。</p><p>群集功能最适合横向扩展长时间运行和&#x2F;或 CPU 密集型作业（分配工作负载 在多个节点上）。如果需要横向扩展以支持数千个短期运行（例如 1 秒）作业，请考虑 使用多个不同的计划程序（包括用于 HA 的多个群集计划程序）对作业集进行分区。 调度程序使用集群范围的锁定，这种模式会在您添加更多节点时降低性能（当进入时） 超过大约三个节点 - 取决于数据库的功能等）。</p><p>通过将“org.quartz.jobStore.isClustered”属性设置为“true”来启用群集。集群中的每个实例都应使用 quartz.properties 文件的相同副本。例外情况是使用相同的属性文件，但允许以下例外情况：不同的线程池大小和“org.quartz.scheduler.instanceId”属性的不同值。群集中的每个节点都必须具有唯一的 instanceId，通过将“AUTO”作为此属性的值，可以轻松完成此操作（无需不同的属性文件）。有关详细信息，请参阅有关 JDBC-JobStore 的配置属性的信息。</p><blockquote><p>切勿在单独的计算机上运行群集，除非它们的时钟使用某种形式的时间同步服务（守护程序）进行同步，该服务非常有规律地运行（时钟必须在一秒内）。如果您不熟悉如何执行此操作，请参阅 <a href="http://www.boulder.nist.gov/timefreq/service/its.htm%E3%80%82">http://www.boulder.nist.gov/timefreq/service/its.htm。</a></p></blockquote><blockquote><p>切勿针对任何其他实例正在运行的同一组数据库表启动 （scheduler.start（）） 非集群实例。您可能会遇到严重的数据损坏，并且肯定会遇到不稳定的行为。</p></blockquote><p><strong>群集调度程序的示例属性</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># Configure Main Scheduler Properties  </span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceName</span> = <span class="string">MyClusteredScheduler</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceId</span> = <span class="string">AUTO</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># Configure ThreadPool  </span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.quartz.threadPool.class</span> = <span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span> = <span class="string">25</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadPriority</span> = <span class="string">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># Configure JobStore  </span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.quartz.jobStore.misfireThreshold</span> = <span class="string">60000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span> = <span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.driverDelegateClass</span> = <span class="string">org.quartz.impl.jdbcjobstore.oracle.OracleDelegate</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.useProperties</span> = <span class="string">false</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.dataSource</span> = <span class="string">myDS</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tablePrefix</span> = <span class="string">QRTZ_</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.quartz.jobStore.isClustered</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.clusterCheckinInterval</span> = <span class="string">20000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># Configure Datasources  </span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.quartz.dataSource.myDS.driver</span> = <span class="string">oracle.jdbc.driver.OracleDriver</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myDS.URL</span> = <span class="string">jdbc:oracle:thin:@polarbear:1521:dev</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myDS.user</span> = <span class="string">quartz</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myDS.password</span> = <span class="string">quartz</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myDS.maxConnections</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.myDS.validationQuery</span>=<span class="string">select 0 from dual</span></span><br></pre></td></tr></table></figure><h2 id="TerracottaJobStore-的配置"><a href="#TerracottaJobStore-的配置" class="headerlink" title="TerracottaJobStore 的配置"></a>TerracottaJobStore 的配置</h2><blockquote><p>没有数据库的集群！</p></blockquote><p>TerracottaJobStore 用于在 Terracotta 服务器中存储调度信息（作业、触发器和日历）。<br>TerracottaJobStore比使用数据库存储调度数据（通过JDBC-JobStore）的性能要高得多， 而且还提供群集功能，例如负载平衡和故障转移。</p><p>您可能需要考虑如何设置 Terracotta 服务器的影响，尤其是配置 用于打开诸如在磁盘上存储数据、利用 fsync 和运行 Terracotta 数组等功能的选项 HA 服务器。</p><p>群集功能最适合横向扩展长时间运行和&#x2F;或 CPU 密集型作业（分配工作负载 在多个节点上）。如果需要横向扩展以支持数千个短期运行（例如 1 秒）作业，请考虑 使用多个不同的计划程序对作业集进行分区。使用多个调度程序当前强制使用 群集范围的锁定，这种模式会在添加更多客户端时降低性能。</p><p>有关此 JobStore 和兵马俑的更多信息，请访问 <a href="http://www.terracotta.org/quartz">http://www.terracotta.org/quartz ›</a></p><p><strong>TerracottaJobStore 是通过设置“org.quartz.jobStore.class”属性来选择的，如下所示：</strong></p><p><strong>将调度程序的作业存储设置为兵马俑作业商店</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.class = org.terracotta.quartz.TerracottaJobStore</span><br></pre></td></tr></table></figure><p>可以使用以下属性调整 TerracottaJobStore：</p><table><thead><tr><th align="left">Property Name</th><th align="left">Required</th><th align="left">Type</th><th align="left">Default Value</th></tr></thead><tbody><tr><td align="left">org.quartz.jobStore.tcConfigUrl</td><td align="left">yes</td><td align="left">string</td><td align="left"></td></tr><tr><td align="left">org.quartz.jobStore.misfireThreshold</td><td align="left">no</td><td align="left">int</td><td align="left">60000</td></tr></tbody></table><p><strong>org.quartz.jobStore.tcConfigUrl</strong></p><p>标识要连接到的 Terracotta 服务器位置的主机和端口，例如“localhost：9510”。</p><p><strong>org.quartz.jobStore.misfireThreshold</strong></p><p>调度程序在被视为“错误触发”之前“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果未在配置中输入此属性）为 60000（60 秒）。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/configuration/index.html">Configuration Reference (quartz-scheduler.org)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章项目：&lt;a href=&quot;https://github.com/guoshunfa/guoshunfa-spring-demo/tree/6eceffc74282e750350a9eec6d26572d73f3fcdb/01.SpringBoot</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="https://guoshunfa.com/tags/Java/"/>
    
    <category term="Quartz" scheme="https://guoshunfa.com/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3集成Swagger</title>
    <link href="https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Swagger/"/>
    <id>https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Swagger/</id>
    <published>2023-07-11T06:52:01.000Z</published>
    <updated>2024-01-28T11:41:39.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章项目：<a href="https://github.com/guoshunfa/guoshunfa-spring-demo/tree/97f59e0921f21bfd09e864a34e646efa2eeff4d8/01.SpringBoot/SpringBoot%E9%9B%86%E6%88%90%E7%BB%84%E4%BB%B6%E5%BA%93/springboot-3-swagger-demo">Github Project</a></p></blockquote><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul><li>jdk17</li><li>SpringBoot3.1.1</li><li>SpringDoc2.1.0</li></ul><h2 id="为什么不继续使用springfox？"><a href="#为什么不继续使用springfox？" class="headerlink" title="为什么不继续使用springfox？"></a>为什么不继续使用springfox？</h2><p>springfox 已经停止更新很久了，SpringBoot新版本都不支持。为了能够继续使用Swagger，只能调整继承库。</p><h2 id="什么是SpringDoc？"><a href="#什么是SpringDoc？" class="headerlink" title="什么是SpringDoc？"></a>什么是SpringDoc？</h2><p><code>springdoc-openapi</code>Java 库有助于使用 Spring 引导项目自动生成 API 文档。 通过在运行时检查应用程序来根据 Spring 配置、类结构和各种注释推断 API 语义。<code>springdoc-openapi</code></p><p>自动生成 JSON&#x2F;YAML 和 HTML 格式 API 中的文档。 本文档可以通过使用 swagger-api 注释的评论来完成。</p><p>此库支持：</p><ul><li>OpenAPI 3</li><li>Spring-boot v3 （Java 17 &amp; Jakarta EE 9）</li><li>JSR-303，专门用于@NotNull、@Min、@Max和@Size。</li><li>招摇的用户界面</li><li>OAuth 2</li><li>GraalVM 原生镜像</li></ul><p>以下视频介绍了库：</p><p><a href="https://youtu.be/utRxyPfFlDw"><img src="/2023/07/SpringBoot3%E9%9B%86%E6%88%90Swagger/springdoc-openapi-prez.gif" alt="spring.io 会议"></a></p><p>这是一个基于社区的项目，不是由Spring框架贡献者（Pivotal）维护的。</p><h1 id="集成Swagger"><a href="#集成Swagger" class="headerlink" title="集成Swagger"></a>集成Swagger</h1><h2 id="引入maven"><a href="#引入maven" class="headerlink" title="引入maven"></a>引入maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot引入Swagger的maven库之前，需要先引入springboot-web的maven，否则没有效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加API接口"><a href="#添加API接口" class="headerlink" title="添加API接口"></a>添加API接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Operation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Parameter;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.tags.Tag;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;测试controller&quot;, description = &quot;测试&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/guoshunfa&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;测试接口&quot;, description = &quot;测试接口&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/swagger/test/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@Parameter(name = &quot;param1&quot;, description = &quot;阿拉啦啦&quot;)</span> String param1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动项目查看效果"><a href="#启动项目查看效果" class="headerlink" title="启动项目查看效果"></a>启动项目查看效果</h2><p>浏览器前往：<a href="http://ip:port/swagger-ui/index.html">http://ip:port/swagger-ui/index.html</a></p><p><img src="/2023/07/SpringBoot3%E9%9B%86%E6%88%90Swagger/1689057092970.png" alt="1689057092970"></p><h1 id="如何从Swagger低版本迁移"><a href="#如何从Swagger低版本迁移" class="headerlink" title="如何从Swagger低版本迁移"></a>如何从Swagger低版本迁移</h1><ul><li>删除 springfox 和 swagger 2 依赖项。改为添加依赖项。<code>springdoc-openapi-starter-webmvc-ui</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>将 swagger 2 注释替换为 swagger 3 注释（它已包含在依赖项中）。 招摇 3 注释的包是 .<code>springdoc-openapi-starter-webmvc-ui</code> <code>io.swagger.v3.oas.annotations</code><ul><li><code>@Api</code>→<code>@Tag</code></li><li><code>@ApiIgnore</code>→或<code>@Parameter(hidden = true)</code> <code>@Operation(hidden = true)</code> <code>@Hidden</code></li><li><code>@ApiImplicitParam</code>→<code>@Parameter</code></li><li><code>@ApiImplicitParams</code>→<code>@Parameters</code></li><li><code>@ApiModel</code>→<code>@Schema</code></li><li><code>@ApiModelProperty(hidden = true)</code>→<code>@Schema(accessMode = READ_ONLY)</code></li><li><code>@ApiModelProperty</code>→<code>@Schema</code></li><li><code>@ApiOperation(value = &quot;foo&quot;, notes = &quot;bar&quot;)</code>→<code>@Operation(summary = &quot;foo&quot;, description = &quot;bar&quot;)</code></li><li><code>@ApiParam</code>→<code>@Parameter</code></li><li><code>@ApiResponse(code = 404, message = &quot;foo&quot;)</code>→<code>@ApiResponse(responseCode = &quot;404&quot;, description = &quot;foo&quot;)</code></li></ul></li><li>此步骤是可选的：仅<strong>当您有多个</strong> bean 时，才将它们替换为 bean。<code>Docket``GroupedOpenApi</code></li></ul><p>以前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">publicApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;org.github.springshop.web.public&quot;</span>))</span><br><span class="line">            .paths(PathSelectors.regex(<span class="string">&quot;/public.*&quot;</span>))</span><br><span class="line">            .build()</span><br><span class="line">            .groupName(<span class="string">&quot;springshop-public&quot;</span>)</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">adminApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;org.github.springshop.web.admin&quot;</span>))</span><br><span class="line">            .paths(PathSelectors.regex(<span class="string">&quot;/admin.*&quot;</span>))</span><br><span class="line">            .apis(RequestHandlerSelectors.withMethodAnnotation(Admin.class))</span><br><span class="line">            .build()</span><br><span class="line">            .groupName(<span class="string">&quot;springshop-admin&quot;</span>)</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GroupedOpenApi <span class="title function_">publicApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">            .group(<span class="string">&quot;springshop-public&quot;</span>)</span><br><span class="line">            .pathsToMatch(<span class="string">&quot;/public/**&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GroupedOpenApi <span class="title function_">adminApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">            .group(<span class="string">&quot;springshop-admin&quot;</span>)</span><br><span class="line">            .pathsToMatch(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">            .addOpenApiMethodFilter(method -&gt; method.isAnnotationPresent(Admin.class))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你<strong>只有一个</strong> - 删除它，而是将属性添加到你的 ：<code>Docket</code> <code>application.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">springdoc.packagesToScan</span>=<span class="string">package1, package2</span></span><br><span class="line"><span class="attr">springdoc.pathsToMatch</span>=<span class="string">/v1, /api/balance/**</span></span><br></pre></td></tr></table></figure><ul><li>添加类型的 bean。请参阅示例：<code>OpenAPI</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OpenAPI <span class="title function_">springShopOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">            .info(<span class="keyword">new</span> <span class="title class_">Info</span>().title(<span class="string">&quot;SpringShop API&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;Spring shop sample application&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;v0.0.1&quot;</span>)</span><br><span class="line">            .license(<span class="keyword">new</span> <span class="title class_">License</span>().name(<span class="string">&quot;Apache 2.0&quot;</span>).url(<span class="string">&quot;http://springdoc.org&quot;</span>)))</span><br><span class="line">            .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">            .description(<span class="string">&quot;SpringShop Wiki Documentation&quot;</span>)</span><br><span class="line">            .url(<span class="string">&quot;https://springshop.wiki.github.org/docs&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Springdoc-openapi-配置"><a href="#Springdoc-openapi-配置" class="headerlink" title="Springdoc-openapi 配置"></a>Springdoc-openapi 配置</h1><p><code>springdoc-openapi</code>依赖于使用标准文件位置的标准 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">Spring 配置</a>属性（YML 或属性）。</p><h3 id="Springdoc-OpenAPI-核心属性"><a href="#Springdoc-OpenAPI-核心属性" class="headerlink" title="Springdoc-OpenAPI 核心属性"></a>Springdoc-OpenAPI 核心属性</h3><table><thead><tr><th align="left">参数名称</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">springdoc.api-docs.path</td><td align="left"><code>/v3/api-docs</code></td><td align="left"><code>String</code>，用于 Json 格式的 OpenAPI 文档的自定义路径。</td></tr><tr><td align="left">springdoc.api-docs.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用 springdoc-openapi 端点（默认为 &#x2F;v3&#x2F;api-docs）。</td></tr><tr><td align="left">springdoc.packages-to-scan</td><td align="left"><code>*</code></td><td align="left"><code>List of Strings</code>.要扫描的包列表（逗号分隔）</td></tr><tr><td align="left">springdoc.paths-to-match</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.要匹配的路径列表（逗号分隔）</td></tr><tr><td align="left">springdoc.produces-to-match-to</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.生成要匹配的媒体类型列表（逗号分隔）</td></tr><tr><td align="left">springdoc.headers-to-match</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.要匹配的标头列表（逗号分隔）</td></tr><tr><td align="left">springdoc.consumptions-to-matchs.</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.要匹配的消耗媒体类型列表（逗号分隔）</td></tr><tr><td align="left">springdoc.paths-to-exclude</td><td align="left"></td><td align="left"><code>List of Strings</code>.要排除的路径列表（逗号分隔）</td></tr><tr><td align="left">springdoc.packages-to-exclude</td><td align="left"></td><td align="left"><code>List of Strings</code>.要排除的包列表（逗号分隔）</td></tr><tr><td align="left">springdoc.default-consumptions-media-type</td><td align="left"><code>application/json</code></td><td align="left"><code>String</code>.默认使用媒体类型。</td></tr><tr><td align="left">springdoc.default-produces-media-type</td><td align="left"><code>**/**</code></td><td align="left"><code>String</code>.默认生成媒体类型。</td></tr><tr><td align="left">springdoc.cache.disabled</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.禁用计算的 OpenAPI 的 springdoc-openapi 缓存。</td></tr><tr><td align="left">springdoc.show-actuator</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.显示执行器端点。</td></tr><tr><td align="left">springdoc.auto-tag-classes</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用 springdoc-openapi 自动标记。</td></tr><tr><td align="left">springdoc.model-and-view-allow</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.允许带有 ModelAndView 的 RestControllers 返回出现在 OpenAPI 描述中。</td></tr><tr><td align="left">springdoc.override-with-generic-response</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.如果为 true，则自动将@ControllerAdvice响应添加到所有生成的响应中。</td></tr><tr><td align="left">springdoc.api-docs.groups.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用 springdoc-openapi 组。</td></tr><tr><td align="left">springdoc.group-configs[0].group</td><td align="left"></td><td align="left"><code>String</code>.组名称</td></tr><tr><td align="left">springdoc.group-configs[0].display-name</td><td align="left"></td><td align="left"><code>String</code>.组的显示名称。</td></tr><tr><td align="left">springdoc.group-configs[0].packages-to-scan</td><td align="left"><code>*</code></td><td align="left"><code>List of Strings</code>.要扫描组的包列表（逗号分隔）</td></tr><tr><td align="left">springdoc.group-configs[0].paths-to-match</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.要为组匹配的路径列表（逗号分隔）</td></tr><tr><td align="left">springdoc.group-configs[0].paths-to-exclude</td><td align="left">&#96;&#96;</td><td align="left"><code>List of Strings</code>.要为组排除的路径列表（逗号分隔）</td></tr><tr><td align="left">springdoc.group-configs[0].packages-to-exclude</td><td align="left"></td><td align="left"><code>List of Strings</code>.要为组排除的包列表（逗号分隔）</td></tr><tr><td align="left">springdoc.group-configs[0].produces-to-match</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.生成要匹配的媒体类型列表（逗号分隔）</td></tr><tr><td align="left">springdoc.group-configs[0].consumes-to-match</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.要匹配的消耗媒体类型列表（逗号分隔）</td></tr><tr><td align="left">springdoc.group-configs[0].headers-to-match</td><td align="left"><code>/*</code></td><td align="left"><code>List of Strings</code>.要匹配的标头列表（逗号分隔）</td></tr><tr><td align="left">springdoc.webjars.prefix</td><td align="left"><code>/webjars</code></td><td align="left"><code>String</code>，要更改 webjars 前缀，该前缀可见 swagger-ui 的 URL 为 spring-webflux。</td></tr><tr><td align="left">springdoc.api-docs.resolve-schema-properties</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.在@Schema（名称、标题和说明）上启用属性解析程序。</td></tr><tr><td align="left">springdoc.remove-broken-reference-definition</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用删除损坏的引用定义。</td></tr><tr><td align="left">springdoc.writer-with-default-pretty-printer</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.启用OpenApi规范的漂亮打印。</td></tr><tr><td align="left">springdoc.model-converters.deprecating-converter.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用弃用模型转换器。</td></tr><tr><td align="left">springdoc.model-converters.polymorphic-converter.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用多态模型转换器。</td></tr><tr><td align="left">springdoc.model-converters.pageable-converter.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用可分页模型转换器。</td></tr><tr><td align="left">springdoc.model-converters.sort-converter.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用排序转换器。</td></tr><tr><td align="left">springdoc.use-fqn</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.启用完全限定名称。</td></tr><tr><td align="left">springdoc.show-login-endpoint</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.使 Spring 安全登录端点可见。</td></tr><tr><td align="left">springdoc.pre-load-enabled</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.预加载设置，用于在应用程序启动时加载 OpenAPI。</td></tr><tr><td align="left">springdoc.writer-with-order-by-keys</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.启用确定性&#x2F;字母顺序排序。</td></tr><tr><td align="left">springdoc.use-management-port</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.在执行器管理端口上公开招摇 UI。</td></tr><tr><td align="left">springdoc.disable-i18n</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.使用 i18n 禁用自动翻译。</td></tr><tr><td align="left">springdoc.show-spring-cloud-functions</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.显示弹簧云函数 Web 终结点。</td></tr><tr><td align="left">springdoc.enable-groovy</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.启用 Groovy 支持。</td></tr><tr><td align="left">springdoc.enable-spring-security</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.启用弹簧安全支持。</td></tr><tr><td align="left">springdoc.enable-kotlin</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.启用 Kotlin 支持。</td></tr><tr><td align="left">Springdoc.enable-hateoas</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.启用弹簧支持。</td></tr><tr><td align="left">springdoc.enable-data-rest</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.启用弹簧数据休息支持。</td></tr><tr><td align="left">springdoc.api-docs.version</td><td align="left"><code>openapi_3_0</code></td><td align="left"><code>String</code>.选择或（使用值 ）。<code>OpenAPI 3.0``OpenAPI 3.1``OPENAPI_3_1</code></td></tr><tr><td align="left">springdoc.default-flat-param-object</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.默认平展参数。</td></tr><tr><td align="left">springdoc.default-support-form-data</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.在指定 api 以接受表单数据时默认设置表单数据的参数。</td></tr><tr><td align="left">springdoc.nullable-request-parameter-enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.默认启用对 Kotlin 中可为空的请求参数的支持。</td></tr><tr><td align="left">springdoc.show-oauth2-endpoint</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.使 Spring 安全性 oauth2 端点可见。</td></tr></tbody></table><h3 id="Swagegr-UI-属性"><a href="#Swagegr-UI-属性" class="headerlink" title="Swagegr UI 属性"></a>Swagegr UI 属性</h3><ul><li>上提供了对 swagger-ui 属性的支持。请参阅<a href="https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/">官方文档</a>。<code>springdoc-openapi</code></li><li>您可以在文档中使用与 Spring 引导属性相同的 swagger-ui 属性。</li></ul><blockquote><p>所有这些属性都应使用以下前缀声明：<code>springdoc.swagger-ui</code></p></blockquote><table><thead><tr><th align="left">参数名称</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">springdoc.swagger-ui.path</td><td align="left"><code>/swagger-ui.html</code></td><td align="left"><code>String</code>，用于 swagger-ui HTML 文档的自定义路径。</td></tr><tr><td align="left">springdoc.swagger-ui.enabled</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.禁用 swagger-ui 端点（默认情况下为 &#x2F;swagger-ui.html）。</td></tr><tr><td align="left">springdoc.swagger-ui.configUrl</td><td align="left"><code>/v3/api-docs/swagger-config</code></td><td align="left"><code>String</code>.要从中获取外部配置文档的 URL。</td></tr><tr><td align="left">springdoc.swagger-ui.layout</td><td align="left"><code>BaseLayout</code></td><td align="left"><code>String</code>.通过插件系统提供的组件的名称，用作 Swagger UI 的顶级布局。</td></tr><tr><td align="left">springdoc.swagger-ui.validatorUrl</td><td align="left"><code>validator.swagger.io/validator</code></td><td align="left">默认情况下，Swagger UI 会尝试根据 swagger.io 的在线验证器验证规范。您可以使用此参数设置不同的验证程序 URL，例如，对于本地部署的验证<a href="https://github.com/swagger-api/validator-badge">程序验证程序徽章</a>。将其设置为 ，或者将禁用验证。<code>none``127.0.0.1``localhost</code></td></tr><tr><td align="left">springdoc.swagger-ui.tryItOutEnabled</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.控制默认情况下是否应启用“试用”部分。</td></tr><tr><td align="left">springdoc.swagger-ui.filter</td><td align="left"><code>false</code></td><td align="left"><code>Boolean OR String</code>.如果设置，则启用筛选。顶部栏将显示一个编辑框，可用于筛选显示的标记操作。可以是用于启用或禁用的布尔值，也可以是字符串，在这种情况下，将使用该字符串作为筛选器表达式启用筛选。筛选区分大小写，与标记内任意位置的筛选器表达式匹配。</td></tr><tr><td align="left">springdoc.swagger-ui.operationsSorter</td><td align="left"></td><td align="left"><code>Function=(a ⇒ a)</code>.对每个 API 的操作列表应用排序。它可以是“alpha”（按路径字母数字排序），“method”（按HTTP方法排序）或函数（参见Array.prototype.sort（）以了解排序函数的工作原理）。默认值为服务器返回的顺序不变。</td></tr><tr><td align="left">springdoc.swagger-ui.tagsSorter</td><td align="left"></td><td align="left"><code>Function=(a ⇒ a)</code>.对每个 API 的标记列表应用排序。它可以是“alpha”（按路径字母数字排序）或<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">函数，请参阅 Array.prototype.sort（）</a> 以学习如何编写排序函数）。每次传递时，将两个标记名称字符串传递给分拣机。默认值是由 Swagger UI 确定的顺序。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth2RedirectUrl</td><td align="left"><code>/swagger-ui/oauth2-redirect.html</code></td><td align="left"><code>String</code>.OAuth 重定向网址。</td></tr><tr><td align="left">springdoc.swagger-ui.displayOperationId</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.控制操作 ID 在操作列表中的显示。缺省值为 。<code>false</code></td></tr><tr><td align="left">springdoc.swagger-ui.displayRequestDuration</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.控制“试用”请求的请求持续时间（以毫秒为单位）的显示。</td></tr><tr><td align="left">springdoc.swagger-ui.deepLink</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.如果设置为 ，则启用标签和操作的深层链接。有关更多信息，请参阅 [深层链接文档]（&#x2F;docs&#x2F;usage&#x2F;deep-linking.md）。<code>true</code></td></tr><tr><td align="left">springdoc.swagger-ui.defaultModelsExpandDepth</td><td align="left"><code>1</code></td><td align="left"><code>Number</code>.模型的默认扩展深度（设置为 -1 将完全隐藏模型）。</td></tr><tr><td align="left">springdoc.swagger-ui.defaultModelExpandDepth</td><td align="left"><code>1</code></td><td align="left"><code>Number</code>.模型示例部分上模型的默认扩展深度。</td></tr><tr><td align="left">springdoc.swagger-ui.defaultModelRendering</td><td align="left"></td><td align="left"><code>String=[&quot;example&quot;*, &quot;model&quot;]</code>.控制首次呈现 API 时模型的显示方式。（用户始终可以通过单击“模型”和“示例值”链接来切换给定模型的渲染。</td></tr><tr><td align="left">springdoc.swagger-ui.docExpansion</td><td align="left"></td><td align="left"><code>String=[&quot;list&quot;*, &quot;full&quot;, &quot;none&quot;]</code>.控制操作和标记的默认展开设置。它可以是“列表”（仅展开标签）、“完整”（展开标签和操作）或“无”（不展开任何内容）。</td></tr><tr><td align="left">springdoc.swagger-ui.maxDisplayTags</td><td align="left"></td><td align="left"><code>Number</code>.如果设置，将显示的标记操作数限制为最多此数量。默认值为显示所有操作。</td></tr><tr><td align="left">springdoc.swagger-ui.showExtensions</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.控制供应商扩展 （） 字段和操作、参数和架构的值的显示。<code>x-</code></td></tr><tr><td align="left">springdoc.swagger-ui.url</td><td align="left"></td><td align="left"><code>String</code>.要配置，自定义 OpenAPI 文件的路径。如果使用，将被忽略。<code>urls</code></td></tr><tr><td align="left">springdoc.swagger-ui.showCommonExtensions</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.控制参数的扩展 （、、、、） 字段和值的显示。<code>pattern``maxLength``minLength``maximum``minimum</code></td></tr><tr><td align="left">springdoc.swagger-ui.supportedSubmitMethods</td><td align="left"></td><td align="left"><code>Array=[&quot;get&quot;, &quot;put&quot;, &quot;post&quot;, &quot;delete&quot;, &quot;options&quot;, &quot;head&quot;, &quot;patch&quot;, &quot;trace&quot;]</code>.启用了“试用”功能的 HTTP 方法列表。空数组禁用所有操作的“试用”。这不会从显示中过滤操作。</td></tr><tr><td align="left">springdoc.swagger-ui.queryConfigEnabled</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.自 以来禁用。此参数启用（旧版）通过 URL 搜索参数覆盖配置参数。在启用此功能之前<a href="https://github.com/swagger-api/swagger-ui/security/advisories/GHSA-qrmm-w75w-3wpx">，请参阅安全公告</a>。<code>v1.6.0</code></td></tr><tr><td align="left">springdoc.swagger-ui.oauth. additionalQueryStringParams</td><td align="left"></td><td align="left"><code>String</code>.添加到授权 URL 和令牌 URL 的其他查询参数。</td></tr><tr><td align="left">springdoc.swagger-ui.disable-swagger-default-url</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.禁用 swagger-ui 默认宠物商店网址。（从 v1.4.1 开始可用）。</td></tr><tr><td align="left">springdoc.swagger-ui.urls[0].url</td><td align="left"></td><td align="left"><code>URL</code>.Topbar 插件使用的 swagger 组的 url。URL 在此数组中的所有项中必须是唯一的，因为它们用作标识符。</td></tr><tr><td align="left">springdoc.swagger-ui.urls[0].name</td><td align="left"></td><td align="left"><code>String</code>.Topbar 插件使用的 swagger 组的名称。名称在此数组中的所有项中必须是唯一的，因为它们用作标识符。</td></tr><tr><td align="left">springdoc.swagger-ui.urlsPrimaryName</td><td align="left"></td><td align="left"><code>String</code>.加载 Swagger UI 时将显示的招摇组的名称。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth.clientId</td><td align="left"></td><td align="left"><code>String</code>.默认客户端 ID。必须是字符串。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth.clientSecret</td><td align="left"></td><td align="left"><code>String</code>.默认客户端机密。切勿在生产环境中使用此参数。它公开了重要的安全信息。此功能仅适用于开发&#x2F;测试环境。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth.realm</td><td align="left"></td><td align="left"><code>String</code>.领域查询参数（适用于 OAuth 1）已添加到授权 URL 和令牌 URL。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth.appName</td><td align="left"></td><td align="left"><code>String</code>.OAuth 应用程序名称，显示在授权弹出窗口中。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth.scopeSeparator</td><td align="left"></td><td align="left"><code>String</code>.用于传递范围的 OAuth 范围分隔符，在调用之前进行编码，默认值为空格（编码值 %20）。</td></tr><tr><td align="left">springdoc.swagger-ui.csrf.enabled</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.启用 CSRF 支持</td></tr><tr><td align="left">springdoc.swagger-ui.csrf.use-local-storage</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.从本地存储获取 CSRF 令牌。</td></tr><tr><td align="left">springdoc.swagger-ui.csrf.use-session-storage</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.从会话存储中获取 CSRF 令牌。</td></tr><tr><td align="left">springdoc.swagger-ui.csrf.cookie-name</td><td align="left"><code>XSRF-TOKEN</code></td><td align="left"><code>String</code>.可选的 CSRF，用于设置 CSRF cookie 名称。</td></tr><tr><td align="left">springdoc.swagger-ui.csrf.header-name</td><td align="left"><code>X-XSRF-TOKEN</code></td><td align="left"><code>String</code>.可选的 CSRF，用于设置 CSRF 标头名称。</td></tr><tr><td align="left">springdoc.swagger-ui.syntaxHighlight.activated</td><td align="left"><code>true</code></td><td align="left"><code>Boolean</code>.是否应激活语法突出显示。</td></tr><tr><td align="left">springdoc.swagger-ui.syntaxHighlight.theme</td><td align="left"><code>agate</code></td><td align="left"><code>String</code>..<a href="https://highlightjs.org/static/demo/">突出显示.js</a>要使用的语法着色主题。（只有这 6 种样式可用。<code>String=[&quot;agate&quot;*, &quot;arta&quot;, &quot;monokai&quot;, &quot;nord&quot;, &quot;obsidian&quot;, &quot;tomorrow-night&quot;]</code></td></tr><tr><td align="left">springdoc.swagger-ui.oauth. useBasicAuthentication WithAccessCodeGrant</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.仅针对访问代码流激活。在对 tokenURL 的authorization_code请求期间，使用 HTTP 基本身份验证方案（具有基本 base64encode（client_id + client_secret）的授权标头）传递客户端密码。</td></tr><tr><td align="left">springdoc.swagger-ui.oauth. usePkceWithAuthorization CodeGrant</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.仅适用于授权代码流。代码交换的证明密钥为 OAuth 公共客户端带来了增强的安全性。</td></tr><tr><td align="left">springdoc.swagger-ui.persistAuthorization</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.如果设置为 true，它将保留授权数据，并且在浏览器关闭&#x2F;刷新时不会丢失</td></tr><tr><td align="left">springdoc.swagger-ui.use-root-path</td><td align="left"><code>false</code></td><td align="left"><code>Boolean</code>.如果设置为 true，则可以直接从应用程序根路径访问 swagger-u。</td></tr></tbody></table><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://springdoc.org/">Springdoc-OpenAPI v2.1.0</a></p></li><li><p><a href="https://swagger.io/">Swagger官网</a></p></li><li><p><a href="https://github.com/swagger-api">Swagger官方Github主页</a></p></li><li><p><a href="https://github.com/swagger-api/swagger-core">Swagegr Core Github</a></p></li><li><p><a href="https://github.com/swagger-api/swagger-core/wiki/">Swagger 官方WIKI</a></p></li><li><p><a href="https://springdoc.org/">SpringDoc官网</a></p></li><li><p><a href="https://github.com/springdoc">SpringDoc Github</a></p></li><li><p><a href="https://github.com/springdoc/springdoc-openapi">springdoc-openapi Github</a></p></li></ul><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h1><ul><li><a href="https://guoshunfa.com/2023/07/SpringBoot2%E9%9B%86%E6%88%90Swagger/">SpringBoot2集成Swagger</a></li><li><a href="https://guoshunfa.com/2023/07/SpringBoot3%E9%9B%86%E6%88%90Swagger/">SpringBoot3集成Swagger</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章项目：&lt;a href=&quot;https://github.com/guoshunfa/guoshunfa-spring-demo/tree/97f59e0921f21bfd09e864a34e646efa2eeff4d8/01.SpringBoot</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="https://guoshunfa.com/tags/Java/"/>
    
    <category term="Swagger" scheme="https://guoshunfa.com/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2集成Swagger</title>
    <link href="https://guoshunfa.com/2023/07/SpringBoot2%E9%9B%86%E6%88%90Swagger/"/>
    <id>https://guoshunfa.com/2023/07/SpringBoot2%E9%9B%86%E6%88%90Swagger/</id>
    <published>2023-07-11T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章仓库：<a href="https://github.com/guoshunfa/guoshunfa-spring-demo/tree/97f59e0921f21bfd09e864a34e646efa2eeff4d8/01.SpringBoot/SpringBoot%E9%9B%86%E6%88%90%E7%BB%84%E4%BB%B6%E5%BA%93/springboot-2-swagger-demo">Github Project</a></p></blockquote><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>本文章所用版本：</p><ul><li>SpringBoot 2.2.6.RELEASE</li><li>springfox 3.0.0</li><li>jdk 8</li></ul><p>不同的版本会导致版本冲突，切换版本时建议先去官方查看是否互相兼容。</p><h1 id="开始集成-Swagger"><a href="#开始集成-Swagger" class="headerlink" title="开始集成 Swagger"></a>开始集成 Swagger</h1><h2 id="导入swagger-maven-库"><a href="#导入swagger-maven-库" class="headerlink" title="导入swagger maven 库"></a>导入swagger maven 库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot引入Swagger的maven库之前，需要先引入springboot-web的maven，否则没有效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加swagger配置类"><a href="#添加swagger配置类" class="headerlink" title="添加swagger配置类"></a>添加swagger配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.oas.annotations.EnableOpenApi;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Configuration 标识当前类是配置类，与@Bean搭配使用会直接注册为bean。</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// @EnableOpenApi 标识开启生成接口文档功能（只有开启了OpenApi,才可以实现生成接口文档的功能）</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;swagger-1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.OAS_30)</span><br><span class="line">                .groupName(<span class="string">&quot;swagger-1&quot;</span>)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis( RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;swagger-2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRest2Api</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.OAS_30)</span><br><span class="line">                .groupName(<span class="string">&quot;swagger-2&quot;</span>)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis( RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">// 添加标题</span></span><br><span class="line">                .title(<span class="string">&quot;郭顺发 SpringBoot+Swagger接口文档平台&quot;</span> + System.currentTimeMillis())</span><br><span class="line">                <span class="comment">// 添加描述</span></span><br><span class="line">                .description(<span class="string">&quot;https://www.guoshunfa.com&quot;</span>)</span><br><span class="line">                <span class="comment">// 添加版本</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写API接口"><a href="#编写API接口" class="headerlink" title="编写API接口"></a>编写API接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(&quot;测试controller&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/guoshunfa&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试接口&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/swagger/test/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@ApiParam(&quot;阿拉啦啦&quot;)</span> String param1)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看swagger-ui效果"><a href="#查看swagger-ui效果" class="headerlink" title="查看swagger-ui效果"></a>查看swagger-ui效果</h2><p>启动项目，将</p><p>浏览器访问 <a href="http://ip:port/swagger-ui/index.html">http://ip:port/swagger-ui/index.html</a></p><p><img src="/2023/07/SpringBoot2%E9%9B%86%E6%88%90Swagger/image-20230711133253689.png" alt="image-20230711133253689"></p><h3 id="其他页面展示效果-swagger-bootstrap-ui-效果"><a href="#其他页面展示效果-swagger-bootstrap-ui-效果" class="headerlink" title="其他页面展示效果 - swagger-bootstrap-ui 效果"></a>其他页面展示效果 - swagger-bootstrap-ui 效果</h3><p><strong>使用其他ui需要引入maven</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>浏览器访问 <a href="http://ip:port/doc.html">http://ip:port/doc.html</a></p><p><img src="/2023/07/SpringBoot2%E9%9B%86%E6%88%90Swagger/1689053804648.png" alt="1689053804648"></p><h1 id="Swagger-API"><a href="#Swagger-API" class="headerlink" title="Swagger API"></a>Swagger API</h1><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#api">@Api</a></td><td>将类标记为 Swagger 资源。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apiimplicitparam-apiimplicitparams">@ApiImplicitParam</a></td><td>表示 API 操作中的单个参数。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apiimplicitparam-apiimplicitparams">@ApiImplicitParams</a></td><td>允许多个 ApiImplicitParam 对象列表的包装器。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apimodel">@ApiModel</a></td><td>提供有关 Swagger 模型的其他信息。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apimodelproperty">@ApiModelProperty</a></td><td>添加和操作模型属性的数据。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apioperation">@ApiOperation</a></td><td>描述针对特定路径的操作或通常是 HTTP 方法。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apiparam">@ApiParam</a></td><td>为操作参数添加额外的元数据。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apiresponses-apiresponse">@ApiResponse</a></td><td>描述操作的可能响应。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apiresponses-apiresponse">@ApiResponses</a></td><td>允许多个 ApiResponse 对象列表的包装器。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#authorization-authorizationscope">@Authorization</a></td><td>声明要在资源或操作上使用的授权方案。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#authorization-authorizationscope">@AuthorizationScope</a></td><td>描述 OAuth2 授权范围。</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#responseHeader">@ResponseHeader</a></td><td>表示可以作为响应的一部分提供的标头。</td></tr></tbody></table><p>最新版本还添加了许多注释，用于在 Swagger 定义级别添加扩展和元数据：</p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#swaggerdefinition">@SwaggerDefinition</a></td><td>要添加到生成的 Swagger 定义中的定义级属性</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#info">@Info</a></td><td>Swagger 定义的一般元数据</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#contact">@Contact</a></td><td>用于描述 Swagger 定义的联系人的属性</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#license">@License</a></td><td>用于描述 Swagger 定义的许可证的属性</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#extension">@Extension</a></td><td>添加包含属性的扩展</td></tr><tr><td><a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#extensionproperty">@ExtensionProperty</a></td><td>将自定义属性添加到扩展</td></tr></tbody></table><h2 id="资源-API-声明"><a href="#资源-API-声明" class="headerlink" title="资源 API 声明"></a>资源 API 声明</h2><h3 id="Api"><a href="#Api" class="headerlink" title="@Api"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Api.html">@Api</a></h3><p>在 Swagger 2.0 中，资源被标签替换，这会影响<code>@Api</code>注释。它不再用于声明资源，而现在用于为在它下定义的所有操作应用定义。</p><p>JAX-RS 的用法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Path(&quot;/pet&quot;)</span><br><span class="line">@Api(value = &quot;pet&quot;, authorizations = &#123;</span><br><span class="line">      @Authorization(value=&quot;sampleoauth&quot;, scopes = &#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">@Produces(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span><br><span class="line">public class PetResource &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们说这个类下的操作的标签是<code>pet</code>（所以它们都会被组合在一起）。Swagger 将获取<code>@Produces</code>注释，但如果您愿意，您可以覆盖此值。</p><p><code>@Api</code>也可用于在资源级别声明授权。这些定义适用于该资源下的所有操作，但如果需要，可以在操作级别覆盖。在上面的示例中，我们添加了一个先前声明的 OAuth2 授权方案，没有任何范围。有关更多详细信息，请检查<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#authorization-authorizationscope">@Authorization</a>注释。</p><p>除了使用<code>value()</code>，您可以使用<code>tags()</code>允许您为操作设置多个标签的属性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Api(tags = &#123;&quot;external_info&quot;,&quot;user_info&quot;&#125;)</span><br></pre></td></tr></table></figure><p>请注意，在这种情况下，<code>value()</code>即使它存在也会被忽略。</p><p>布尔<code>hidden</code>属性可用于完全隐藏 @Api，即使它已声明。这在使用子资源删除不需要的工件时特别有用。</p><p>在 swagger-core 1.5.X 中，<code>description()</code>不再使用<code>basePath()</code>、 和。<code>position()</code></p><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Api.html">javadocs</a>。</strong></p><h2 id="运营声明"><a href="#运营声明" class="headerlink" title="运营声明"></a>运营声明</h2><h3 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiOperation.html">@ApiOperation</a></h3><p><code>@ApiOperation</code>用于声明单个操作。操作被认为是路径和 HTTP 方法的唯一组合。</p><p>JAX-RS 的用法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GET</span><br><span class="line">@Path(&quot;/findByStatus&quot;)</span><br><span class="line">@ApiOperation(value = &quot;Finds Pets by status&quot;,</span><br><span class="line">   notes = &quot;Multiple status values can be provided with comma seperated strings&quot;,</span><br><span class="line">   response = Pet.class,</span><br><span class="line">   responseContainer = &quot;List&quot;)</span><br><span class="line">public Response findPetsByStatus(...) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>注释的<code>value</code>是对 API 的简短描述。由于它显示在 Swagger-UI 的操作列表中，并且位置大小有限，因此应保持简短（最好小于 120 个字符）。这<code>notes</code>允许您提供有关操作的更多详细信息。<code>response</code>是方法的返回类型。请注意，实际的方法声明返回的<code>Response</code>是一个通用 JAX-RS 类，而不是发送给用户的实际响应。如果返回的对象是实际结果，可以直接使用，不用在注解中声明。由于我们想要返回一个宠物列表，我们使用<code>responseContainer</code>. 请记住，Java 具有类型擦除，因此在返回类型中使用泛型可能无法正确解析，并且<code>response</code>应该直接使用。JAX-RS 注释将<code>@GET</code>用作操作的 (HTTP)<code>method</code>字段，它<code>@Path</code>会告诉我们操作的路径（操作分组在同一路径下，每个使用的 HTTP 方法一个）。</p><p>输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &quot;/pet/findByStatus&quot;: &#123;</span><br><span class="line">&quot;get&quot;: &#123;</span><br><span class="line">  &quot;tags&quot;: [</span><br><span class="line">    &quot;pet&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;summary&quot;: &quot;Finds Pets by status&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Multiple status values can be provided with comma seperated strings&quot;,</span><br><span class="line">  &quot;responses&quot;: &#123;</span><br><span class="line">    &quot;200&quot;: &#123;</span><br><span class="line">      &quot;description&quot;: &quot;successful operation&quot;,</span><br><span class="line">      &quot;schema&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;array&quot;,</span><br><span class="line">        &quot;items&quot;: &#123;</span><br><span class="line">          &quot;$ref&quot;: &quot;#/definitions/Pet&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br></pre></td></tr></table></figure><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiOperation.html">javadocs</a>。</strong></p><h3 id="ApiResponses-ApiResponse"><a href="#ApiResponses-ApiResponse" class="headerlink" title="@ApiResponses , @ApiResponse"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiResponses.html">@ApiResponses</a> , <a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiResponse.html">@ApiResponse</a></h3><p>使用 HTTP 状态代码返回错误（或其他成功消息）是一种常见的做法。<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apioperation">虽然在@ApiOperation</a>中定义了操作的一般返回类型，但应使用这些注释来描述其余的返回代码。</p><p>描述了一个具体的<code>@ApiResponse</code>可能响应。不能直接在方法或类&#x2F;接口上使用，需要包含在数组值中<code>@ApiResponses</code>（无论是一个响应还是多个响应）。</p><p>如果响应伴随着身体，也可以描述身体模型（每个响应一个模型）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApiResponses(value = &#123; </span><br><span class="line">    @ApiResponse(code = 400, message = &quot;Invalid ID supplied&quot;, </span><br><span class="line">                 responseHeaders = @ResponseHeader(name = &quot;X-Rack-Cache&quot;, description = &quot;Explains whether or not a cache was used&quot;, response = Boolean.class)),</span><br><span class="line">    @ApiResponse(code = 404, message = &quot;Pet not found&quot;) &#125;)</span><br><span class="line">public Response getPetById(...) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在 swagger-core 1.5.X 中，您还可以添加响应标头的描述，如上例所示。</p><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看 javadocs（<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiResponses.html">@ApiResponses</a>、<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiResponse.html">@ApiResponse</a>）</strong>。</p><h3 id="Authorization-AuthorizationScope"><a href="#Authorization-AuthorizationScope" class="headerlink" title="@Authorization , @AuthorizationScope"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Authorization.html">@Authorization</a> , <a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/AuthorizationScope.html">@AuthorizationScope</a></h3><p>这些注释仅用作<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#api">@Api</a>和<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apioperation">@ApiOperation</a>的输入，而不是直接用于资源和操作。一旦您声明并配置了您在 API 中支持的授权方案，您就可以使用这些注释来记录资源或特定操作需要哪种授权方案。这<code>@AuthorizationScope</code>是特定于 OAuth2 授权方案的情况，您可能希望指定特定的支持范围。</p><p>@Authorization 和 @AuthorizationScope 转换为<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject">Security Requirement Object</a>。</p><p>实现（JAX-RS、Servlet 或其他）之间的行为是相同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;Add a new pet to the store&quot;, </span><br><span class="line">  authorizations = &#123;</span><br><span class="line">    @Authorization(</span><br><span class="line">        value=&quot;petoauth&quot;, </span><br><span class="line">        scopes = &#123; @AuthorizationScope(scope = &quot;add:pet&quot;) &#125;</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">public Response addPet(...) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们声明该<code>addPet</code>操作使用<code>petoauth</code>授权方案（我们假设它是 OAuth2 授权方案）。然后使用我们通过说它需要范围<code>@AuthorizationScope</code>来微调定义。<code>add:pet</code>如上所述，您可以看到<code>@AuthorizationScope</code>用作 的输入<code>@Authorization</code>，而后者又用作 的输入<code>@ApiOperation</code>。请记住，这些注释只能用作 和 的<code>@Api</code>输入<code>@ApiOperation</code>。直接在类或方法上使用它们中的任何一个都将被忽略。</p><p>输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;security&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;petoauth&quot;: [</span><br><span class="line">      &quot;add:pet&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>有关此注解、用法和边缘情况的更多详细信息，请查看 javadocs（<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Authorization.html">@Authorization</a>、<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/AuthorizationScope.html">@AuthorizationScope</a>）</strong>。</p><h3 id="ApiParam"><a href="#ApiParam" class="headerlink" title="@ApiParam"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiParam.html">@ApiParam</a></h3><p><code>@ApiParam</code>仅与 JAX-RS 参数注释（<code>@PathParam</code>、<code>@QueryParam</code>、<code>@HeaderParam</code>和<code>@FormParam</code>JAX-RS 2 中的）一起使用<code>@BeanParam</code>。虽然 swagger-core 默认扫描这些注释，但<code>@ApiParam</code>可用于在参数中添加更多详细信息或更改从代码中读取的值。</p><p>在 Swagger 规范中，这转换为<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameterObject">Parameter Object</a>。</p><p>Swagger 将选取<code>value()</code>这些注解并将它们用作参数名称，并且基于注解它还将设置参数类型。</p><p>如果存在，Swagger 还将使用 的值<code>@DefaultValue</code>作为默认值属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> @Path(&quot;/&#123;username&#125;&quot;)</span><br><span class="line"> @ApiOperation(value = &quot;Updated user&quot;,</span><br><span class="line">    notes = &quot;This can only be done by the logged in user.&quot;)</span><br><span class="line">public Response updateUser(</span><br><span class="line">      @ApiParam(value = &quot;name that need to be updated&quot;, required = true) @PathParam(&quot;username&quot;) String username,</span><br><span class="line">      @ApiParam(value = &quot;Updated user object&quot;, required = true) User user) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>这里我们有两个参数。第一个，<code>username</code>它是路径的一部分。第二个是主体，在本例中是一个用户对象。请注意，这两个参数的<code>required</code>属性都设置为<code>true</code>。对于@PathParam，这是多余的，因为默认情况下它是强制性的并且不能被覆盖。</p><p>输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &quot;parameters&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;username&quot;,</span><br><span class="line">    &quot;in&quot;: &quot;path&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;name that need to be deleted&quot;,</span><br><span class="line">    &quot;required&quot;: true,</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;in&quot;: &quot;body&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;body&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;Updated user object&quot;,</span><br><span class="line">    &quot;required&quot;: true,</span><br><span class="line">    &quot;schema&quot;: &#123;</span><br><span class="line">      &quot;$ref&quot;: &quot;#/definitions/User&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiParam.html">javadocs</a>。</strong></p><h3 id="ApiImplicitParam-ApiImplicitParams"><a href="#ApiImplicitParam-ApiImplicitParams" class="headerlink" title="@ApiImplicitParam , @ApiImplicitParams"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiImplicitParam.html">@ApiImplicitParam</a> , <a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiImplicitParams.html">@ApiImplicitParams</a></h3><p>您可能希望手动描述操作参数。这可能有多种原因，例如：</p><ul><li>使用不使用 JAX-RS 注释的 Servlet。</li><li>想要隐藏定义的参数并用完全不同的定义覆盖它。</li><li>描述在到达 JAX-RS 实现之前由过滤器或其他资源使用的参数。</li></ul><p>由于可以包含多个参数，因此<code>@ApiImplicitParams</code>允许多个<code>@ApiImplicitParam</code>定义。</p><p>在 Swagger 规范中，这些转换为<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameterObject">Parameter Object</a>。</p><p>隐式定义参数时，设置<code>name</code>和<code>dataType</code>Swagger<code>paramType</code>的定义正确很重要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ApiImplicitParams(&#123;</span><br><span class="line">   @ApiImplicitParam(name = &quot;name&quot;, value = &quot;User&#x27;s name&quot;, required = true, dataType = &quot;string&quot;, paramType = &quot;query&quot;),</span><br><span class="line">   @ApiImplicitParam(name = &quot;email&quot;, value = &quot;User&#x27;s email&quot;, required = false, dataType = &quot;string&quot;, paramType = &quot;query&quot;),</span><br><span class="line">   @ApiImplicitParam(name = &quot;id&quot;, value = &quot;User ID&quot;, required = true, dataType = &quot;long&quot;, paramType = &quot;query&quot;)</span><br><span class="line"> &#125;)</span><br><span class="line">public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们可以看到一个带有多个参数的 Servlet 定义。<code>dataType</code>可以是原始名称或类名称。可以是 Swagger 支持的<code>paramType</code>任何参数类型（有关详细信息，请参阅 javadocs 或规范）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &quot;parameters&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;User&#x27;s name&quot;,</span><br><span class="line">    &quot;required&quot;: true,</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;in&quot;: &quot;query&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;email&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;User&#x27;s email&quot;,</span><br><span class="line">    &quot;required&quot;: false,</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;in&quot;: &quot;query&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;User ID&quot;,</span><br><span class="line">    &quot;required&quot;: true,</span><br><span class="line">    &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">    &quot;format&quot;: &quot;int64&quot;,</span><br><span class="line">    &quot;in&quot;: &quot;query&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看 javadocs（<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiImplicitParam.html">@ApiImplicitParam</a>、<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiImplicitParams.html">@ApiImplicitParams</a>）</strong>。</p><h3 id="ResponseHeader"><a href="#ResponseHeader" class="headerlink" title="@ResponseHeader"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ResponseHeader.html">@ResponseHeader</a></h3><p>如果要描述响应标头，只需将其添加到<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apioperation">@ApiOperation</a>或<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#apiresponses-apiresponse">@ApiResponse</a>，同时提供标头的名称、描述和类型。</p><p>例如，在给定的响应中，它将如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApiResponses(value = &#123; </span><br><span class="line">    @ApiResponse(code = 400, message = &quot;Invalid ID supplied&quot;, </span><br><span class="line">                 responseHeaders = @ResponseHeader(name = &quot;X-Rack-Cache&quot;, description = &quot;Explains whether or not a cache was used&quot;, response = Boolean.class)),</span><br><span class="line">    @ApiResponse(code = 404, message = &quot;Pet not found&quot;) &#125;)</span><br><span class="line">public Response getPetById(...) &#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ResponseHeader.html">javadocs</a>。</strong></p><h3 id="模型声明"><a href="#模型声明" class="headerlink" title="模型声明"></a>模型声明</h3><h3 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiModel.html">@ApiModel</a></h3><p>Swagger-core 基于在整个 API 内省中对模型定义的引用来构建模型定义。允许您操作模型的<code>@ApiModel</code>元数据，从简单的描述或名称更改到多态性的定义。</p><p>这转化为 Swagger 规范中的<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject">模式对象</a>。</p><p>在其基本功能中，您<code>@ApiModel</code>可以更改模型的名称并为其添加描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel(value=&quot;DifferentModel&quot;, description=&quot;Sample model for the documentation&quot;)</span><br><span class="line">class OriginalModel &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们将模型的名称从 OriginalModel 更改为 DifferentModel。</p><p>输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;DifferentModel&quot;: &#123;</span><br><span class="line">     &quot;description&quot;: &quot;Sample model for the documentation&quot;,</span><br><span class="line">     .</span><br><span class="line">     .</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>您还可以<code>@ApiModel</code>通过指定子类型来实现模型组合，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel(value = &quot;Pet&quot;, subTypes = &#123;Cat.class&#125;)</span><br><span class="line">public class Pet &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swagger-samples 中提供了此场景的示例：</p><p><a href="https://github.com/swagger-api/swagger-samples/blob/master/java/java-jaxrs/src/main/java/io/swagger/sample/model/Pet.java">https://github.com/swagger-api/swagger-samples/blob/master/java/java-jaxrs/src/main/java/io/swagger/sample/model/Pet.java</a></p><p><a href="https://github.com/swagger-api/swagger-samples/blob/master/java/java-jaxrs/src/main/java/io/swagger/sample/model/Vehicle.java">https://github.com/swagger-api/swagger-samples/blob/master/java/java-jaxrs/src/main/java/io/swagger/sample/model/Vehicle.java</a></p><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiModel.html">javadocs</a>。</strong></p><h3 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiModelProperty.html">@ApiModelProperty</a></h3><p>虽然 swagger-core 将自省字段和 setter&#x2F;getter，但它还将读取和处理 JAXB 注释。允许控制 Swagger 特定的<code>@ApiModelProperty</code>定义，例如允许的值和附加注释。如果您想在某些情况下隐藏该属性，它还提供了额外的过滤属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ApiModelProperty(value = &quot;pet status in the store&quot;, allowableValues = &quot;available,pending,sold&quot;)</span><br><span class="line">public String getStatus() &#123;</span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是向模型属性添加简短描述的简单示例。还可以观察到，虽然<code>status</code>是一个字符串，但我们将它记录为只有三个可能的值。</p><p>它的输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;properties&quot;: &#123;</span><br><span class="line">      ...,</span><br><span class="line">      &quot;status&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;pet status in the store&quot;,</span><br><span class="line">        &quot;enum&quot;: [</span><br><span class="line">          &quot;available&quot;,</span><br><span class="line">          &quot;pending&quot;,</span><br><span class="line">          &quot;sold&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>有关此注释、用法和边缘情况的更多详细信息，请查看<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ApiModelProperty.html">javadocs</a>。</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="SwaggerDefinition"><a href="#SwaggerDefinition" class="headerlink" title="@SwaggerDefinition"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/SwaggerDefinition.html">@SwaggerDefinition</a></h3><p><a href="http://swagger.io/specification#swagger-object">SwaggerDefinition 注释提供了与Swagger</a>对象的许多（但不是全部）顶级属性相对应的属性，允许您为自动生成的定义设置这些属性。注释可以在 Swagger 自动配置过程中扫描的任何类上，即它不必在 JAX-RS API 类上，而可以只是在标记&#x2F;配置接口上，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@SwaggerDefinition(</span><br><span class="line">        info = @Info(</span><br><span class="line">                description = &quot;Gets the weather&quot;,</span><br><span class="line">                version = &quot;V12.0.12&quot;,</span><br><span class="line">                title = &quot;The Weather API&quot;,</span><br><span class="line">                termsOfService = &quot;http://theweatherapi.io/terms.html&quot;,</span><br><span class="line">                contact = @Contact(</span><br><span class="line">                   name = &quot;Rain Moore&quot;, </span><br><span class="line">                   email = &quot;rain.moore@theweatherapi.io&quot;, </span><br><span class="line">                   url = &quot;http://theweatherapi.io&quot;</span><br><span class="line">                ),</span><br><span class="line">                license = @License(</span><br><span class="line">                   name = &quot;Apache 2.0&quot;, </span><br><span class="line">                   url = &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span><br><span class="line">                )</span><br><span class="line">        ),</span><br><span class="line">        consumes = &#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;,</span><br><span class="line">        produces = &#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;,</span><br><span class="line">        schemes = &#123;SwaggerDefinition.Scheme.HTTP, SwaggerDefinition.Scheme.HTTPS&#125;,</span><br><span class="line">        tags = &#123;</span><br><span class="line">                @Tag(name = &quot;Private&quot;, description = &quot;Tag used to denote operations as private&quot;)</span><br><span class="line">        &#125;, </span><br><span class="line">        externalDocs = @ExternalDocs(value = &quot;Meteorology&quot;, url = &quot;http://theweatherapi.io/meteorology.html&quot;)</span><br><span class="line">)</span><br><span class="line">public interface TheWeatherApiConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面显示的属性会导致相应的元数据被添加到生成的 swagger.json &#x2F; swagger.yaml 文件中</p><p>如果您有多个 @SwaggerDefinition 注释，它们将按照它们被发现的顺序进行聚合 - 任何重复的注释属性都将覆盖以前的属性。</p><h3 id="Info"><a href="#Info" class="headerlink" title="@Info"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Info.html">@Info</a></h3><p>@Info 注释为 Swagger 定义添加通用元数据属性 - 对应于规范中的<a href="http://swagger.io/specification#infoObject">Info</a>对象。如上例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SwaggerDefinition(</span><br><span class="line">        info = @Info(</span><br><span class="line">                description = &quot;Gets the weather&quot;,</span><br><span class="line">                version = &quot;V12.0.12&quot;,</span><br><span class="line">                title = &quot;The Weather API&quot;,</span><br><span class="line">                termsOfService = &quot;http://theweatherapi.io/terms.html&quot;,</span><br><span class="line">                ...</span><br><span class="line">        ),</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有关受支持属性的完整列表，请参阅<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Info.html">javadoc 。</a></p><h3 id="Contact"><a href="#Contact" class="headerlink" title="@Contact"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Contact.html">@Contact</a></h3><p>@Contact 注释将联系人属性添加到 Swagger 定义的 @Info 部分 - 对应于规范中的<a href="http://swagger.io/specification#contactObject">联系人</a>对象。如上例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SwaggerDefinition(</span><br><span class="line">        info = @Info(</span><br><span class="line">                ...</span><br><span class="line">                contact = @Contact(</span><br><span class="line">                   name = &quot;Rain Moore&quot;, </span><br><span class="line">                   email = &quot;rain.moore@theweatherapi.io&quot;, </span><br><span class="line">                   url = &quot;http://theweatherapi.io&quot;</span><br><span class="line">                ),</span><br><span class="line">                ...</span><br><span class="line">        ),</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有关受支持属性的列表，请参阅<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Contact.html">javadoc 。</a></p><h3 id="License"><a href="#License" class="headerlink" title="@License"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/License.html">@License</a></h3><p>@License 注释将许可证属性添加到 Swagger 定义的 @Info 部分 - 对应于规范中的<a href="http://swagger.io/specification#licenseObject">许可证</a>对象。如上例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SwaggerDefinition(</span><br><span class="line">        info = @Info(</span><br><span class="line">                ...</span><br><span class="line">                license = @License(</span><br><span class="line">                   name = &quot;Apache 2.0&quot;, </span><br><span class="line">                   url = &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span><br><span class="line">                )</span><br><span class="line">        ),</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有关受支持属性的列表，请参阅<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/License.html">javadoc 。</a></p><h3 id="Extension"><a href="#Extension" class="headerlink" title="@Extension"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Extension.html">@Extension</a></h3><p>扩展注释允许将<a href="http://swagger.io/specification#vendorExtensions">扩展属性</a>添加到 Swagger 定义中。它目前在 @ApiOperation、@Info 和 @Tag 注释中受支持。有两种使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   extensions = &#123;</span><br><span class="line">       @Extension(properties = &#123;</span><br><span class="line">           @ExtensionProperty(name = &quot;test1&quot;, value = &quot;value1&quot;),</span><br><span class="line">           @ExtensionProperty(name = &quot;test2&quot;, value = &quot;value2&quot;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这将导致以下json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   &quot;x-test1&quot; : &quot;value1&quot;,</span><br><span class="line">   &quot;x-test2&quot; : &quot;value2&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果在注释中没有明确地这样做，属性名称将自动以“x-”为前缀。</p><p>或者，您可以将扩展名命名为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   extensions = &#123; </span><br><span class="line">       @Extension( name = &quot;my-extension&quot;, properties = &#123;</span><br><span class="line">           @ExtensionProperty(name = &quot;test1&quot;, value = &quot;value1&quot;),</span><br><span class="line">           @ExtensionProperty(name = &quot;test2&quot;, value = &quot;value2&quot;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这将导致以下json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   &quot;x-my-extension&quot; : &#123;</span><br><span class="line">      &quot;test1&quot; : &quot;value1&quot;,</span><br><span class="line">      &quot;test2&quot; : &quot;value2&quot;</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>它将包含的扩展属性包装在 JSON 对象中。</p><h3 id="ExtensionProperty"><a href="#ExtensionProperty" class="headerlink" title="@ExtensionProperty"></a><a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/ExtensionProperty.html">@ExtensionProperty</a></h3><p>扩展中的单个属性 - 有关示例，请参见前面的<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#extension">@Extension</a>部分。</p><h2 id="自定义-Swagger-定义"><a href="#自定义-Swagger-定义" class="headerlink" title="自定义 Swagger 定义"></a>自定义 Swagger 定义</h2><p>如果您出于任何原因想要自定义生成的 Swagger 定义超出注释的范围，您可以为 Swagger 引擎提供提供相应回调的 ReaderListener：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface ReaderListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called before the Swagger definition gets populated from scanned classes. Use this method to</span><br><span class="line">     * pre-process the Swagger definition before it gets populated.</span><br><span class="line">     *</span><br><span class="line">     * @param reader the reader used to read annotations and build the Swagger definition</span><br><span class="line">     * @param swagger the initial swagger definition</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    void beforeScan(Reader reader, Swagger swagger);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called after a Swagger definition has been populated from scanned classes. Use this method to</span><br><span class="line">     * post-process Swagger definitions.</span><br><span class="line">     *</span><br><span class="line">     * @param reader the reader used to read annotations and build the Swagger definition</span><br><span class="line">     * @param swagger the configured Swagger definition</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    void afterScan(Reader reader, Swagger swagger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用此注解进行资源扫描期间找到的任何类都将被实例化并相应地调用。例如下面的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BasePathModifier implements ReaderListener &#123;</span><br><span class="line">    void beforeScan(Reader reader, Swagger swagger)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    void afterScan(Reader reader, Swagger swagger)&#123;</span><br><span class="line">        swagger.setBasePath( System.getProperty( &quot;swagger.basepath&quot;, swagger.getBasePath() ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将允许您从系统属性覆盖生成的 basePath。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://swagger.io/">Swagger官网</a> </li><li><a href="https://github.com/swagger-api">Swagger官方Github主页</a></li><li><a href="https://github.com/swagger-api/swagger-core">Swagegr Core Github</a></li><li><a href="https://github.com/swagger-api/swagger-core/wiki/">Swagger 官方WIKI</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章仓库：&lt;a href=&quot;https://github.com/guoshunfa/guoshunfa-spring-demo/tree/97f59e0921f21bfd09e864a34e646efa2eeff4d8/01.SpringBoot</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://guoshunfa.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="https://guoshunfa.com/tags/Java/"/>
    
    <category term="Swagger" scheme="https://guoshunfa.com/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>同步至腾讯云开发者社区</title>
    <link href="https://guoshunfa.com/2023/07/%E5%90%8C%E6%AD%A5%E8%87%B3%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA/"/>
    <id>https://guoshunfa.com/2023/07/%E5%90%8C%E6%AD%A5%E8%87%B3%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA/</id>
    <published>2023-07-03T08:28:15.000Z</published>
    <updated>2024-01-28T11:41:39.236Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=eiey4wuskvsz">https://cloud.tencent.com/developer/support-plan?invite_code=eiey4wuskvsz</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：&lt;a href=&quot;https://cloud.tencent.com/developer/support-plan?invite_code=eiey4wuskvsz&quot;&gt;https://cloud.tencent.com/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux CentOS安装宝塔</title>
    <link href="https://guoshunfa.com/2023/06/Linux-CentOS%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94/"/>
    <id>https://guoshunfa.com/2023/06/Linux-CentOS%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94/</id>
    <published>2023-06-16T13:48:34.000Z</published>
    <updated>2024-01-28T11:41:39.265Z</updated>
    
    <content type="html"><![CDATA[<p>宝塔是一个安全高效的服务器运维面板，可以直接从宝塔平台上部署web项目、监控服务器资源使用情况、快捷操作文件、<br>一键安装软件及部署源码。详细内容可以移步前往<a href="https://www.bt.cn/">宝塔官网</a>。</p><h1 id="CentOS安装宝塔"><a href="#CentOS安装宝塔" class="headerlink" title="CentOS安装宝塔"></a>CentOS安装宝塔</h1><ol><li><p>前往<a href="https://www.bt.cn/">宝塔官网</a>。<br><img src="/2023/06/Linux-CentOS%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94/01.png" alt="img"></p></li><li><p>点击“立即免费安装”按钮，页面会跳转到宝塔安装界面。</p></li><li><p>到达宝塔安装界面后，往下滑，找到标题“Linux面板*.*.*安装脚本”。</p></li><li><p>找到Centos安装脚本。</p><blockquote><p>这里备份一下备份一下脚本内容，如果需要请前往官网制定位置进行查看。</p></blockquote></li></ol><p>Centos安装脚本：<code>yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</code></p><p>万能安装脚本：<code>if [ -f /usr/bin/curl ];then curl -sSO https://download.bt.cn/install/install_panel.sh;else wget -O install_panel.sh https://download.bt.cn/install/install_panel.sh;fi;bash install_panel.sh ed8484bec</code></p><ol start="5"><li>下载完成之后，命令行会给提示。前往提示中的url地址，输入用户名和密码，即可到达服务器内的宝塔平台。</li></ol><p><img src="/2023/06/Linux-CentOS%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94/02.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;宝塔是一个安全高效的服务器运维面板，可以直接从宝塔平台上部署web项目、监控服务器资源使用情况、快捷操作文件、&lt;br&gt;一键安装软件及部署源码。详细内容可以移步前往&lt;a href=&quot;https://www.bt.cn/&quot;&gt;宝塔官网&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;CentO</summary>
      
    
    
    
    <category term="服务器管理" scheme="https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="宝塔" scheme="https://guoshunfa.com/tags/%E5%AE%9D%E5%A1%94/"/>
    
    <category term="Linux" scheme="https://guoshunfa.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>韩剧推荐</title>
    <link href="https://guoshunfa.com/2023/06/%E9%9F%A9%E5%89%A7%E6%8E%A8%E8%8D%90/"/>
    <id>https://guoshunfa.com/2023/06/%E9%9F%A9%E5%89%A7%E6%8E%A8%E8%8D%90/</id>
    <published>2023-06-16T13:29:49.000Z</published>
    <updated>2024-01-28T11:41:39.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的解放日志"><a href="#我的解放日志" class="headerlink" title="我的解放日志"></a>我的解放日志</h2><p>类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2022</p><p>主演：李民基,金智媛,孙锡久</p><p>导演：金锡允</p><p>简介：此剧讲述了关于想要逃离无语人生的昌锡，基正，美正三姐弟以及一个神秘外地人之间的温情故事。是一部讲述了人生到达了界限，即使没有对策下猛药也想要脱离“现在”的他们的解放期温暖共鸣故事。李民基剧中饰演二儿子廉昌熙一角，没有梦想，无欲无求，经常被家人无视。金智媛剧中饰演在无色彩人生中，渴望得到解放的小女儿廉美贞一角，天生内向，小心谨慎。孙锡久饰演神秘外来人具氏一角。365天都喝醉，不知道他到底是个什么样的人。李艾儿饰演大女儿廉基正一角，对爱情真挚，像火一样的性格。</p><p>评分：9.1 （截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟🌟 极大程度的反应了社会的真实现状，主角三个人在性格、遭遇、机遇完全不同的情况下，最终找到了人生的价值。很多读者在观看时都会产生共鸣，这也是这个电视剧成功的部分。</p><h2 id="我们的蓝调"><a href="#我们的蓝调" class="headerlink" title="我们的蓝调"></a>我们的蓝调</h2><p>类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2022</p><p>主演：李秉宪,申敏儿,车胜元,金宇彬,韩智敏,李姃垠,严正化,金惠子,高斗心,朴智焕,崔英俊</p><p>导演：金奎泰</p><p>简介：该剧是卢熙京编剧和金圭泰导演继《那年冬天风在吹》《LIVE》后再次合作的作品，共20集，将描绘不同人的人生，本剧已于7月底开拍。讲述的是年轻时学生时代青涩的朋友们上了年纪再见面发生的故事，是一部颇具抒情色彩的作品。</p><p>评分：8.0 （截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟</p><h2 id="再次我的人生"><a href="#再次我的人生" class="headerlink" title="再次我的人生"></a>再次我的人生</h2><p>类型：剧情,犯罪,奇幻 &#x2F; 地区：韩国 &#x2F; 年份：2022</p><p>主演：李准基,李璟荣,金智恩,郑尚勋,金永勋,李顺载,崔光一,红毗罗,金炯默,朴哲民,金姬贞,车珠英,玄宇成,柳东根,金希珍,</p><p>导演：韩哲洙</p><p>简介：该片改编自同名小说，讲述人生第二次的热血检察官绝对的对恶的惩罚记。一个雨夜，检察官金奚宇在与罪犯最后的对决中落败。跌入江水本该死去的他却被上天给予了重生一次的契机。再次醒来的他发现自己回到了高中时代，一场为了正义之名的复仇，展开了，这一次他能将位高权重的罪犯绳之以法吗？</p><p>评分：8.3（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟</p><h2 id="杀人者的购物目录"><a href="#杀人者的购物目录" class="headerlink" title="杀人者的购物目录"></a>杀人者的购物目录</h2><p>类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2022</p><p>主演：李光洙,金雪炫</p><p>导演：李彦禧</p><p>简介：《杀人者的购物目录》是一部讲述我们这个虽然知道表面但完全不知道全貌的时代，看似熟悉的邻里却发生着儿童虐待，再开发等各种犯罪和危机状况的社区现实型惊悚剧。李光洙在剧中饰演超市的取货员大成。《杀人者的购物目录》改编自姜智英（音译）作家的同名小说，剧本由韩志完（音译）作家执笔，导演由曾与李光洙合作过电影《侦探2》的导演李彦禧担任，播出平台正在讨论中。</p><p>评分：7.0（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟</p><h2 id="向你奔去的速度493km"><a href="#向你奔去的速度493km" class="headerlink" title="向你奔去的速度493km"></a>向你奔去的速度493km</h2><p>类型：爱情,运动 &#x2F; 地区：韩国 &#x2F; 年份：2022</p><p>主演：朴柱炫,蔡钟协,权昭贤,徐智蕙,金茂俊,曹秀香,全惠媛,朴智炫</p><p>导演：赵雄</p><p>简介：此剧是一部运动爱情题材电视剧，讲述了25岁，羽毛球实业组选手们的故事。主要讲述了混合双打男女主对羽毛球的热爱和爱情故事。</p><p>评分：7.3（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟</p><h2 id="二十五，二十一"><a href="#二十五，二十一" class="headerlink" title="二十五，二十一"></a>二十五，二十一</h2><p>类型：爱情 &#x2F; 地区：韩国 &#x2F; 年份：2022</p><p>主演：金泰梨,南柱赫,金知妍,崔显旭,李周明</p><p>导演：郑志贤</p><p>简介：南柱赫、金泰梨有望主演tvN新剧《二十五 二十一》(스물다섯 스물하나，暂译)。该剧由郑志贤(《国王：永远的君主》)执导，权度恩(《请输入搜索词：WWW》)操刀剧本，讲述1998-2021年间的故事，1998年22岁和18岁的两位主人公相遇，到了1999年时两人开始互相伤害，2000年时两人开始互相依靠，直到2001年两人才开始一段恋情。 南柱赫将饰演UBS体育记者白一镇，他23岁时成为电台记者，在暗访时伪装成化妆品推销员，后来在亚运会期间成为体育记者。在亚运会的比赛中他与金牌得主罗熙度(金泰梨饰)相遇。女主角罗熙度是高中击剑部的国家代表队队员。目前，两人经纪公司表示正在商议中，该剧计划今年冬天tvN播出。</p><p>评分：9.1（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟🌟 </p><h2 id="废柴舅舅"><a href="#废柴舅舅" class="headerlink" title="废柴舅舅"></a>废柴舅舅</h2><p>类型：剧情,喜剧 &#x2F; 地区：韩国 &#x2F; 年份：2021</p><p>主演：吴政世,全慧珍,黄雨瑟惠,李时媛,朴善英,李尚禹,李庆勋</p><p>导演：池英洙</p><p>更新：2022-01-31 04:01:56</p><p>简介：该剧翻拍自同名BBC英剧，讲述照顾12岁侄子，为了守护侄子的无业游民叔叔孤军奋斗成长故事。</p><p>评分：7.2（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟</p><h2 id="那年，我们的夏天"><a href="#那年，我们的夏天" class="headerlink" title="那年，我们的夏天"></a>那年，我们的夏天</h2><p>类型：爱情 &#x2F; 地区：韩国 &#x2F; 年份：2021</p><p>主演：崔宇植,金多美, 金圣喆,卢正义</p><p>简介：这对争吵不休的昔日恋人，高中时曾拍过一部爆红纪录片。因为这部作品，两人时隔多年又被拉回镜头前，也回到彼此的生活中。</p><p>评分：8.7（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟🌟</p><h2 id="鱿鱼游戏"><a href="#鱿鱼游戏" class="headerlink" title="鱿鱼游戏"></a>鱿鱼游戏</h2><p>类型：悬疑,惊悚 &#x2F; 地区：韩国 &#x2F; 年份：2021</p><p>主演：李政宰,魏化俊,许成泰,金周灵,朴海秀,孔刘,元春圭,郑浩妍</p><p>导演：黄东赫</p><p>简介：Netflix |《鱿鱼游戏》「一切只是一场游戏。」456 位参赛者，456 亿元奖金赌上自己的命，玩小孩玩的游戏《鱿鱼游戏》将于9月17日Netflix 独家上线。</p><p>评分：8.6（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟🌟</p><h2 id="机智医生生活第二季"><a href="#机智医生生活第二季" class="headerlink" title="机智医生生活第二季"></a>机智医生生活第二季</h2><p>类型：剧情 &#x2F; 地区：韩国 &#x2F; 年份：2021</p><p>主演：曹政奭,柳演锡,郑敬淏,金大明,田美都,河允庆</p><p>导演：申元浩</p><p>简介：在医院里，每位病人及每件事都至关重要，身为医生同时也是平凡人的五人帮，将在此面对人生的起起落落。</p><p>评分：9.5（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟🌟</p><h2 id="窥探"><a href="#窥探" class="headerlink" title="窥探"></a>窥探</h2><p>类型：剧情,悬疑,犯罪 &#x2F; 地区：韩国 &#x2F; 年份：2021</p><p>主演：李昇基,李熙俊,朴柱炫,景收真,安在旭,金贞兰,权华焕,赵在允,金英玉,安内相,金英在,表志勋,禹志贤</p><p>导演：崔俊裴</p><p>简介：以「如果可以通过胎儿基因检测是否为精神病患者，肚子里的孩子被确认是患者，您是否会选择生下来？」为主题所展开的故事。将不同于以往精神病题材的电视剧。李昇基饰演正直的年轻刑警，面对不公正的事就据理力争，将与让全国陷入恐怖的先天精神病患的罪犯对峙，完全改变自己人生的角色。</p><p>评分：8.6（截止2022年5月24日）</p><p>个人评价：🌟🌟🌟🌟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;我的解放日志&quot;&gt;&lt;a href=&quot;#我的解放日志&quot; class=&quot;headerlink&quot; title=&quot;我的解放日志&quot;&gt;&lt;/a&gt;我的解放日志&lt;/h2&gt;&lt;p&gt;类型：剧情 &amp;#x2F; 地区：韩国 &amp;#x2F; 年份：2022&lt;/p&gt;
&lt;p&gt;主演：李民基,金智媛,孙锡</summary>
      
    
    
    
    <category term="娱乐" scheme="https://guoshunfa.com/categories/%E5%A8%B1%E4%B9%90/"/>
    
    
    <category term="韩剧" scheme="https://guoshunfa.com/tags/%E9%9F%A9%E5%89%A7/"/>
    
  </entry>
  
  <entry>
    <title>思维模式</title>
    <link href="https://guoshunfa.com/2023/01/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://guoshunfa.com/2023/01/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-01-16T13:41:31.000Z</published>
    <updated>2024-01-28T11:41:39.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优质思维模式"><a href="#优质思维模式" class="headerlink" title="优质思维模式"></a>优质思维模式</h2><ul><li><p><strong>二八原则</strong>。相对于全面的人，这个社会更加愿意奖励有专长的人。事业发展的好的人，在某方面都有特长。雷军“Are you ok？”鬼畜都看过，一般大学生比雷军英语都好，但他的管理能力，商业洞察却是少有人的企及。他在商业上的成功依靠的是他的长处。</p></li><li><p><strong>默认设置</strong>。“默认设置”拉长到三年时间，足以拉长人与人的差距。默认设置指的是一个人在没有外力强制需要完成任务的时候，他自发地会做什么。有些人没事的时候喜欢刷视频（比如我），有些人则会喜欢在没事的时候看书。建议现在开始优化自己2-3个“默认设置”。</p></li><li><p><strong>对答案、抄答案</strong>。不要有“问答案”而是“对答案”的意识。“问答案”是直接要结果不管中间的推导过程。而“对答案”则是自己通过努力思考，做好准备之后询问别人的思路，寻找差异，进行学习。</p></li><li><p>只有捍卫你自己的权利，别人才会尊重你的诉求。不要做老好人，一次又一次的退让只会换来别人变本加厉的压榨。要想清楚自己的底线。</p></li><li><p>情绪有变现价值。不要给自己的情绪带着走。想想当下想要达成的目的，然后用合适的情绪来帮助目的的达成。</p></li></ul><h2 id="常用的思维方式"><a href="#常用的思维方式" class="headerlink" title="常用的思维方式"></a>常用的思维方式</h2><h3 id="5W2H分析法"><a href="#5W2H分析法" class="headerlink" title="5W2H分析法"></a>5W2H分析法</h3><blockquote><p>适用于分析问题、解决问题。</p></blockquote><p>​5W2H分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。简单、方便，易于理解、使用，富有启发意义，广泛用于企业管理和技术活动，对于<a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96/1513">决策</a>和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p><p>（1）<a href="https://baike.baidu.com/item/WHAT/61780">WHAT</a>——是什么？目的是什么？做什么工作？</p><p>（2）WHY——为什么要做？可不可以不做？有没有替代方案？</p><p>（3）<a href="https://baike.baidu.com/item/WHO/74453">WHO</a>——谁？由谁来做？</p><p>（4）<a href="https://baike.baidu.com/item/WHEN/2306122">WHEN</a>——何时？什么时间做？什么时机最适宜？</p><p>（5）WHERE——何处？在哪里做？</p><p>（6）<a href="https://baike.baidu.com/item/HOW/2286245">HOW</a> ——怎么做？如何提高效率？如何实施？方法是什么？</p><p>（7）HOW MUCH——多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</p><h3 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h3><blockquote><p>适用于学习概念、内容。</p></blockquote><p>​费曼学习法的核心要义是通过复述概念并反馈结果来加强记忆。</p><p>（1）明确目标：你想学习的概念、内容。</p><p>（2）以教促学：写出自己的理解。</p><p>（3）化整为零：将目标内容分解为一个个基础知识点。</p><p>（4）总结提炼：合并内容，简化并提炼核心内容，通过联想来打比方。</p><p><img src="https://file.pandacode.cn/blog/202203192136013.jpg" alt="img"> </p><h3 id="二八法则（马特莱法则）"><a href="#二八法则（马特莱法则）" class="headerlink" title="二八法则（马特莱法则）"></a>二八法则（马特莱法则）</h3><blockquote><p>适用于如何以正确的视角观看事物。（着重点）</p><p><a href="https://baike.baidu.com/item/%E5%B8%95%E7%B4%AF%E6%89%98%E6%B3%95%E5%88%99/7224763">百度百科</a></p></blockquote><p>​在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此称二八定律。</p><p>多场景的例子：</p><ul><li>时间法则：化20%的时间会产生成果的80%。 </li><li>咨询法则：20%的人占用了我们时间的80%。</li><li>产品法则：产品的20%带来利润的80%。 </li><li>阅读法则：20%的书篇幅包括了内容的80%。 </li><li>工作法则：20%的工作给80%的满意。 </li><li>演讲法则：20%的演讲产生影响的80%。 </li><li>捐赠法则：20%的人捐出金钱的80%。 </li><li>领导法则：20%的人作出80%的决定。 </li><li>资源法则：20%的人耗掉资源的80%。 </li><li>金钱法则：20%的人占有财富的80%。</li></ul><h2 id="圈子"><a href="#圈子" class="headerlink" title="圈子"></a>圈子</h2><h3 id="密友五次元理论"><a href="#密友五次元理论" class="headerlink" title="密友五次元理论"></a>密友五次元理论</h3><p>一个人的财富和智慧，就是他最常接触的5个人平均值。</p><h2 id="时刻清醒"><a href="#时刻清醒" class="headerlink" title="时刻清醒"></a>时刻清醒</h2><ul><li>如果你想要脱胎换骨般的改变，你必须有意识的生活，这个方法非常简单，不容错过，大多数人没有过自己的生活，他们只是接受了生活，但你一旦接受了生活，你就得靠某些事物生活，浪费你时间和精力的事物。</li><li>精神的成熟者，他对外表现出来的不是老，精神的成熟者，他对外表现出来的是一种内部世界的和谐，他对外表现出来的是一种凡事都很从容，他表现出来的是一种他的心灵啊，总是很轻盈，他表现出来的是他的胸襟总是很坦荡，这才是真正精神成熟的人。</li><li>只有当你真正的体会到了痛苦，你才会真正的知道，平凡的幸福有多么幸福，你才会珍惜这些平凡的幸福。</li></ul><p>真正的幸福啊，并不是得到你极力追求的东西，而是那些你习以为常，知道失去后悔莫及的东西。真正的富有，并不是拥有豪车豪宅，狐朋狗友遍天下，因为这些看似的富有，无法填满你内心那个千疮百孔的心。</p><p>———罗翔</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/152547764">世上最强学习方法——费曼学习法（深度学习）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优质思维模式&quot;&gt;&lt;a href=&quot;#优质思维模式&quot; class=&quot;headerlink&quot; title=&quot;优质思维模式&quot;&gt;&lt;/a&gt;优质思维模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;二八原则&lt;/strong&gt;。相对于全面的人，这个社会更加愿意奖励有专长的人</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《100天后会死的鳄鱼君》第一遍阅读</title>
    <link href="https://guoshunfa.com/2022/11/%E3%80%8A100%E5%A4%A9%E5%90%8E%E4%BC%9A%E6%AD%BB%E7%9A%84%E9%B3%84%E9%B1%BC%E5%90%9B%E3%80%8B%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/"/>
    <id>https://guoshunfa.com/2022/11/%E3%80%8A100%E5%A4%A9%E5%90%8E%E4%BC%9A%E6%AD%BB%E7%9A%84%E9%B3%84%E9%B1%BC%E5%90%9B%E3%80%8B%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/</id>
    <published>2022-11-07T11:20:09.000Z</published>
    <updated>2024-01-28T11:41:39.310Z</updated>
    
    <content type="html"><![CDATA[<p>编写时间：2022&#x2F;11&#x2F;07 19:20</p><p>作者：【日】菊池祐纪。</p><p><img src="/2022/11/%E3%80%8A100%E5%A4%A9%E5%90%8E%E4%BC%9A%E6%AD%BB%E7%9A%84%E9%B3%84%E9%B1%BC%E5%90%9B%E3%80%8B%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/100%E6%97%A5%E5%BE%8C%E3%81%AB%E6%AD%BB%E3%81%AC%E3%83%AF%E3%83%8B.jpg" alt="100日後に死ぬワニ"></p><p>《100天后会死的鳄鱼君》主要记录着一个鳄鱼（主人公），将在100天后去世的故事。</p><p>故事的内容很简单，也很平淡，只是记录者主人公一天的日常。但是唯一不同的是，站在上帝视角的我，是知道100天后他会死亡的。抱着这种心态去看这部作品，就会不断的反思。</p><p>故事以四格漫画的进行进行记载，一页代表着一天，上方记录着正在进行的天数，下方记录着100天倒计时，这种描述方式很压抑，也在不断的提醒读者，主人公的生命快到了尽头。</p><p>鳄鱼君也是只是一个很普通的人，所以很容易让读者产生共鸣。故事没有说明鳄鱼君是否知道自己的寿命已经进入了倒计时，鳄鱼君每天都还在全力以赴的活着。</p><p>从故事中可以看到鳄鱼君真的和大多数普通人一样：</p><ul><li>憧憬着自己的爱情，但没有足够的勇气去争取，对方的任何细节都会注意，一点点拒绝就会想要退缩，一点点希望就会很开心，也不敢去打扰对方，总觉得自己会被拒绝；</li><li>做着自己不喜欢的工作，只是为了维持生计；</li><li>有自己的梦想，但不敢承受后果；</li><li>有两三个真心朋友，平时嘻嘻哈哈，有困难了还能互相搀扶；</li><li>有一个压榨自己的领导，每天干不完的工作；</li><li>一两个不错的同事，工作时不至于太消极；</li><li>平时喜欢撸串，隔三差五找朋友聚一聚；</li><li>喜欢看综艺节目，每次都能逗的哈哈大笑；</li><li>看到心动的商品，会忍不住的下单；</li><li>保留了本心，保留了善良；</li><li>休息日喜欢睡懒觉，谁也叫不醒；</li><li>喜欢和朋友玩街机游戏，感觉那个时候才是最放松的；</li><li>自己能做到的事但别人没做到，就会感觉别人没有认真；</li><li>喜欢追剧，即使他的上映时间是明年春天；</li><li>对任何事都很乐观，躺平能解决一切；</li><li>喜欢玩扭蛋，虽然每次手气都很差；</li></ul><h2 id="好句"><a href="#好句" class="headerlink" title="好句"></a>好句</h2><p><strong>我和你都是“100天”后即将死去的鳄鱼，虽然不知道生命什么时候终结，但还是要全力以赴的活着。</strong></p><p>每个人的终点都是一样的，其实相比于结果我觉得更应该注重过程，每天都活成自己希望的样子，对自己抱有足够的信心，更加努力的向目标前进，拒绝任何负面情绪的入侵，更加注重做一件事的过程而不是结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在信息发达的时代，可以0成本的能看到别人形形色色的人生，不断的攀比才会产生焦虑。其实平凡、普通才是大多数人的生活。保留住本心，健康快乐的生活，才是我所期望的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编写时间：2022&amp;#x2F;11&amp;#x2F;07 19:20&lt;/p&gt;
&lt;p&gt;作者：【日】菊池祐纪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/%E3%80%8A100%E5%A4%A9%E5%90%8E%E4%BC%9A%E6%AD%BB%E7%9A%84%E9</summary>
      
    
    
    
    <category term="阅读" scheme="https://guoshunfa.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="读书笔记" scheme="https://guoshunfa.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="心理" scheme="https://guoshunfa.com/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《刻意练习》回顾第一遍阅读</title>
    <link href="https://guoshunfa.com/2022/11/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E5%9B%9E%E9%A1%BE%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/"/>
    <id>https://guoshunfa.com/2022/11/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E5%9B%9E%E9%A1%BE%E7%AC%AC%E4%B8%80%E9%81%8D%E9%98%85%E8%AF%BB/</id>
    <published>2022-11-02T18:13:50.000Z</published>
    <updated>2024-01-28T11:41:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>编写时间：2022&#x2F;11&#x2F;03 02:13 （失眠ing）</p><p>《刻意练习》Anders Ericsson | Robert Pool</p><p>距离上次阅读完《刻意练习》已经有半年的时间了，为了加深对这本书的印象，临时写一篇读书笔记。</p><p>首先，先说一下《刻意练习》这本书能给我带来什么，当时看了这本书的书名，我的感觉是他应该能给我带来一个学习东西的方法，其实并不是。《刻意练习》这本书是通过大量的案例来告诉我们一个真实的想象：所有人都以为“杰出”源于“天赋”，“天才”却说：我的成就源于“正确的练习”。</p><p>“天才真的存在吗”，好多人对于别人的“擅长”，都认定他是一个“天赋”极好的“天才”，现实真的如此吗。同样做编程的开发人，有的工作3年只能到中级的水平，有的工作3年已经是资深了。从结果上看，同样的时间，最终的水平有很大的差异，从过程上看，两个人都是在持续学习，也都很刻苦。感觉3年就达到资深水平的人很有编程的“天赋”，但真的是这样吗。我们反观两位的学习过程就可以看出端倪。工作3年到达中级水平的开发者，每天虽然很充实，但是重复性工作太多，也没有一个明确的规划、良好的学习氛围、厉害的导师，导致3年内的进步极少。而3年就到达资深水平的开发者，自己有一套学习方式和明确的规划，时常请教公司内部的技术大拿，才会在短短的3年时间里让自己的能力有很大的提升。这是这本书传递给我的一个最重要的思想之一：通过正确的训练与练习，每个人都可以有“天赋”。</p><p>“有目的的练习”，作者记录了一个实验，我说出9位数的数字，说完后让你迅速默写出来。这个实验的实验对象是一个十几岁的孩子，在不断更新迭代练习方式和大量时间的训练之后，那个孩子从一开始的默写9位数，到后来的默写几十位数，再到几百位数。通过有目的的练习，可以激发出来你想象不到的“潜力”。那什么是有目的的练习：走出你的舒适区，但要以专注的方式制定明确的目标，为达到那些目标制定一个计划，而且想出监视你的进步的方法。还要想办法保持你的动机。</p><p>“大脑的适应能力”，不要低估自己大脑的适应能力，当你走出舒适圈后，通过不断的挑战自己的极限，来改变自己的大脑。但是要有尺度，在过长的时间内过分的逼迫自己，可能导致倦怠和学习低效。当然，如果停止训练，便不会再进步，</p><p>刻意练习的特点：</p><p>刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能。训练的方案应当由导师或教练来设计和监管，他们即熟悉杰出人物的能力，也熟悉怎么样才能最好的提高那种能力。<br>刻意练习发生在人们的舒适区之外，而且要求学生持续不断的尝试那些刚好超过他当前能力范围的事物。因此，它需要人们付出近乎最大限度的努力。一般来讲，这并不令人心情愉快。<br>刻意练习包含得到良好的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进。一旦设定了总体目标，导师或教练将制订一个计划，以便实现一系列微小的改变，最后将这些改变积累起来，构成之前期望的更大的变化。改进目标表现的某些方面，使得从业者能够看到他的表现通过训练得到了提高。<br>刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动。简单的遵照导师或教练的之事去做，还不够，学生必须紧跟他的练习和特定目标，以便能做出适当的调整，控制练习。<br>刻意练习包含反馈，以及为应对那些反馈而进行调整的努力，在练习过程的早期，大量的反馈来自导师或教练，他们将监测学生的进步，指出存在的问题，而且提供解决这些问题的方法。随着时间的推移，学生必须学会自己监测自己、自己发现错误，并做出相应调整。这种自我检测，薛瑶高效的心理表征。<br>刻意练习既产生有效的心理表征，又依靠有效的心理表征。提高水平与改进心理表征是相辅相成的，两者不可偏废；随着人们水平的提升，表征也变得更加详尽和有效，反过来使得人们可能实现更大程度的改进。心理表征使人们能监测在训练中和实际的工作中做得怎么样。它们表明了做某件事的正确方法，并使得人们注意到什么时候做的不对，以及怎样来纠正。<br>刻意练习通过着重关注过去获取的技能的某些特定方面，致力于针对性的提高那些方面，而且几乎总是包括构建或修改那些过去已经获取的技能；随着时间的推移，这种逐步的改进最终将造就卓越的表现。由于新技能的学习是建立在现有技能基础上的，因此导师会为初学者提供正确的基本技能，使学生后来能在更高层面上重新学习那些基本的技能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编写时间：2022&amp;#x2F;11&amp;#x2F;03 02:13 （失眠ing）&lt;/p&gt;
&lt;p&gt;《刻意练习》Anders Ericsson | Robert Pool&lt;/p&gt;
&lt;p&gt;距离上次阅读完《刻意练习》已经有半年的时间了，为了加深对这本书的印象，临时写一篇读书笔记。&lt;/</summary>
      
    
    
    
    <category term="阅读" scheme="https://guoshunfa.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="读书笔记" scheme="https://guoshunfa.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="心理" scheme="https://guoshunfa.com/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Final Cat Pro 软件操作</title>
    <link href="https://guoshunfa.com/2022/10/Final-Cat-Pro-%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://guoshunfa.com/2022/10/Final-Cat-Pro-%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2022-10-16T13:34:41.000Z</published>
    <updated>2024-01-28T11:41:39.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高质量教学视频：<a href="https://space.bilibili.com/402780815">PAPAYA电脑教室</a> | <a href="https://www.youtube.com/watch?v=H883qIGV48E&t=1909s">youtube 苹果公司御用剪辑师教你如何使用final cut pro让你成为电影大师</a> &#x2F; <a href="https://www.bilibili.com/video/BV1qE411c7co?share_source=copy_web">附带bilibili视频</a> </p></blockquote><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="视频文件操作"><a href="#视频文件操作" class="headerlink" title="视频文件操作"></a>视频文件操作</h3><p>将视频加入主故事线最后：选择视频文件 + E。（E：end）</p><p>将视频加入主故事线最前方：选择视频文件 + W。</p><p>叠加视频，放入主故事线上方：Q</p><p>以覆盖的方式插入视频：D</p><p>切割视频：command + B</p><p>视频速度控制：command + R</p><p>速度控制拦切割：shift + B</p><p>设定界限：X</p><p>直接删除视频片段：backspace。</p><p>删除视频片段，保留视频所在区间：delete</p><p>做记号：M</p><p>位置迁移：P</p><p>视频素材截取：I 左截取 O 右截取</p><p>视频素材标记 &#x2F; 视频素材取消标记：F &#x2F; U</p><h3 id="时间轴控制"><a href="#时间轴控制" class="headerlink" title="时间轴控制"></a>时间轴控制</h3><p>shift + Z，可将影片拉长到跟时间轴等宽。</p><p>command + （ - &#x2F; + ）可以缩放&#x2F;拉伸时间轴。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;高质量教学视频：&lt;a href=&quot;https://space.bilibili.com/402780815&quot;&gt;PAPAYA电脑教室&lt;/a&gt; | &lt;a href=&quot;https://www.youtube.com/watch?v=H883qIGV48E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>乐观锁解决数据库并发修改问题</title>
    <link href="https://guoshunfa.com/2022/07/%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/"/>
    <id>https://guoshunfa.com/2022/07/%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-相关信息描述"><a href="#1-相关信息描述" class="headerlink" title="1. 相关信息描述"></a>1. 相关信息描述</h2><h3 id="1-1-数据库并发场景描述"><a href="#1-1-数据库并发场景描述" class="headerlink" title="1.1. 数据库并发场景描述"></a>1.1. 数据库并发场景描述</h3><p>表中有一属性，记录着当前记录被查询的次数。每一次查询之后会把处理过程甩给event（观察者模式）。如果一段时间内访问量变大会出现并发问题。并发会导致数据的不准确。</p><h3 id="1-2-什么是乐观锁"><a href="#1-2-什么是乐观锁" class="headerlink" title="1.2. 什么是乐观锁"></a>1.2. 什么是乐观锁</h3><blockquote><p>乐观锁（ Optimistic Locking ） 相对<a href="https://baike.baidu.com/item/%E6%82%B2%E8%A7%82%E9%94%81">悲观锁</a>而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1">事务</a>而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号等于数据库表当前版本号，则予以更新，否则认为是过期数据。</p></blockquote><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><h3 id="2-1-场景描述"><a href="#2-1-场景描述" class="headerlink" title="2.1.  场景描述"></a>2.1.  场景描述</h3><p>SpringBoot + Mysql</p><h3 id="2-2-数据库表调整"><a href="#2-2-数据库表调整" class="headerlink" title="2.2. 数据库表调整"></a>2.2. 数据库表调整</h3><p>加入属性version，用来做乐观锁验证。</p><h3 id="2-3-sql调整"><a href="#2-3-sql调整" class="headerlink" title="2.3. sql调整"></a>2.3. sql调整</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> test_user <span class="keyword">set</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-服务层逻辑加入乐观锁"><a href="#2-4-服务层逻辑加入乐观锁" class="headerlink" title="2.4. 服务层逻辑加入乐观锁"></a>2.4. 服务层逻辑加入乐观锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userAgeAddOne</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">TestUser</span> <span class="variable">testUser</span> <span class="operator">=</span> userTestMapper.findById(id);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userTestMapper.userAgeAddOne(testUser.getId(), testUser.getVersion());</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        userAgeAddOne(id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-相关信息描述&quot;&gt;&lt;a href=&quot;#1-相关信息描述&quot; class=&quot;headerlink&quot; title=&quot;1. 相关信息描述&quot;&gt;&lt;/a&gt;1. 相关信息描述&lt;/h2&gt;&lt;h3 id=&quot;1-1-数据库并发场景描述&quot;&gt;&lt;a href=&quot;#1-1-数据库并发场景描述&quot;</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://guoshunfa.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="乐观锁" scheme="https://guoshunfa.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
    <category term="并发" scheme="https://guoshunfa.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="解决方案" scheme="https://guoshunfa.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建图床</title>
    <link href="https://guoshunfa.com/2022/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <id>https://guoshunfa.com/2022/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.237Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p><p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p><p><strong>Q：搭建图床的方式</strong></p><p>A：推荐使用GitHub作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用<code>jsDelivr</code>免费CDN加速。<code>jsDelivr</code>是国外的一家优秀的公共 CDN 服务提供商，该平台是首个「打通中国大陆与海外的免费CDN服务」，无须担心中国防火墙问题而影响使用。官网：<a href="http://www.jsdelivr.com/">http://www.jsdelivr.com/(opens new window)</a>,</p><p>B：Gitee+PicX。</p><p>B：OSS存储，特点是稳定、容量大，缺点就是存储付费+流量付费（大），可以使用ECS内网访问躲避流量费用。</p><p>Q：如何统一管理</p><p>A：使用域名进行解析。</p><h2 id="方案一：GitHub-jsDelivr-PicGo"><a href="#方案一：GitHub-jsDelivr-PicGo" class="headerlink" title="方案一：GitHub + jsDelivr + PicGo"></a>方案一：GitHub + jsDelivr + PicGo</h2><blockquote><p><a href="https://xugaoyi.com/pages/a5f73af5185fdf0a/">Evan’s blog</a></p></blockquote><ol><li>新建GitHub仓库，注意仓库要设置成<strong>公开</strong>。</li><li>参照 <a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">官方文档 </a>生成一个token密钥。</li><li>在 <a href="https://github.com/Molunerfinn/picgo/releases">这里 </a>下载PicGo，安装完成后打开，<code>图床设置</code> 选 <code>GitHub图床</code>，并填写相应的信息<ul><li>仓库名：前面新建的仓库，格式：<code>&lt;用户名&gt;/&lt;仓库名&gt;</code></li><li>分支名：填写主分支<code>master</code>即可</li><li>Token：前面生成的token密钥</li><li>存储路径：按你自己的需求填写</li><li>自定义域名：图片上传后，PicGo 会按照 <code>自定义域名+上传的图片名</code> 的方式生成访问链接，此处我们填写<code>jsDelivr</code>的CDN加速地址，格式：<code>https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;</code></li></ul></li></ol><p><img src="https://file.pandacode.cn//blog/202109121328260.png" alt="image-20210912132734188"></p><h2 id="方案二：OSS-ECS-PicGo"><a href="#方案二：OSS-ECS-PicGo" class="headerlink" title="方案二：OSS + ECS +PicGo"></a>方案二：OSS + ECS +PicGo</h2><ol><li>手里有一个准备好的OSS，一般购买的都是只是存储，而外网访问会产生流量，<a href="https://www.aliyun.com/price/product?spm=a2c4g.11186623.0.0.6eb32845s433Ab#/oss/detail/ossbag">流量费用</a>见下图。内网访问免费，可以使用ECS云服务器做代理转发。</li></ol><p><img src="https://file.pandacode.cn//blog/202109121325802.png" alt="image-20210912132509318"></p><ol start="2"><li>ECS云服务器使用nginx做转发。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80 default_server;</span><br><span class="line">listen [::]:80 default_server;</span><br><span class="line">server_name 47.**.**.43; </span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Load configuration files for the default server block.</span><br><span class="line">include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass https://bucketname.oss-cn-beijing-internal.aliyuncs.com; </span><br><span class="line">proxy_set_header Host $host; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>server_name</strong>：对外提供反向代理服务的IP，即ECS实例的外网地址。</p></li><li><p>proxy_pass</p><p>：填写跳转的域名。</p><ul><li>当ECS实例与Bucket在同一地域时，填写目标Bucket的内网访问域名。访问域名介绍请参见<a href="https://help.aliyun.com/document_detail/31834.htm#concept-hh2-4tv-tdb">OSS访问域名使用规则</a>。</li><li>当ECS实例与Bucket不在同一地域时，填写目标Bucket的外网访问域名。</li><li>因OSS的安全设置，当使用默认域名通过浏览器访问OSS中的图片或网页文件时，会直接下载。所以，若您的用户需通过浏览器预览Bucket中的图片或网页文件，需为Bucket绑定自定义域名，并在此项中添加已绑定的域名。绑定自定义域名操作请参见<a href="https://help.aliyun.com/document_detail/31902.htm#concept-ozw-m2r-5fb">绑定自定义域名</a>。</li></ul></li><li><p>proxy_set_header Host $host</p><p>：添加此项时，Nginx会在向OSS请求的时候，将host替换为ECS的访问地址。遇到以下情况时，您需要添加此项。</p><ul><li>遇到签名错误问题。</li><li>如果您的域名已解析到ECS实例的外网上，且您的用户需要通过浏览器预览Bucket中的图片或网页文件。您可以将您的域名绑定到ECS实例代理的Bucket上，不配置CNAME。这种情况下，<strong>proxy_pass</strong>项可直接配置Bucket的内网或外网访问地址。绑定自定义域名操作请参见<a href="https://help.aliyun.com/document_detail/31902.htm#concept-ozw-m2r-5fb">绑定自定义域名</a>。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t # 验证配置文件是否正确</span><br><span class="line">service nginx restart # 重启nginx服务</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Q：为什么要使用图床呢？什么是图床？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来</summary>
      
    
    
    
    <category term="服务" scheme="https://guoshunfa.com/categories/%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="解决方案" scheme="https://guoshunfa.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="图床" scheme="https://guoshunfa.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 介绍</title>
    <link href="https://guoshunfa.com/2022/07/Mysql-%E4%BB%8B%E7%BB%8D/"/>
    <id>https://guoshunfa.com/2022/07/Mysql-%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><h4 id="Mac-安装Mysql"><a href="#Mac-安装Mysql" class="headerlink" title="Mac 安装Mysql"></a>Mac 安装Mysql</h4><blockquote><p><a href="https://juejin.im/post/6844903831298375693">MySQL安装（Mac版）</a></p></blockquote> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure><h4 id="Docker-安装-Mysql"><a href="#Docker-安装-Mysql" class="headerlink" title="Docker 安装 Mysql"></a>Docker 安装 Mysql</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker查询mysql镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取mysql镜像</span></span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=root  docker.io/mysql:latest</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 3306:3306 将主机3306端口映射到容器3306端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e MYSQL_ROOT_PASSWORD=root 设置远程登录的root用户密码为root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name zyz-name 可选，设置容器别名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mysql 镜像名称</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Mysql&quot;&gt;&lt;a href=&quot;#安装Mysql&quot; class=&quot;headerlink&quot; title=&quot;安装Mysql&quot;&gt;&lt;/a&gt;安装Mysql&lt;/h2&gt;&lt;h4 id=&quot;Mac-安装Mysql&quot;&gt;&lt;a href=&quot;#Mac-安装Mysql&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://guoshunfa.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 介绍</title>
    <link href="https://guoshunfa.com/2022/07/Oracle-%E4%BB%8B%E7%BB%8D/"/>
    <id>https://guoshunfa.com/2022/07/Oracle-%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Oracle-安装"><a href="#1-Oracle-安装" class="headerlink" title="1. Oracle 安装"></a>1. Oracle 安装</h2><h3 id="1-1-Docker-快捷安装"><a href="#1-1-Docker-快捷安装" class="headerlink" title="1.1. Docker 快捷安装"></a>1.1. Docker 快捷安装</h3><blockquote><p>还没有安装docker服务的，请跳转到<a href="/pages/b54954/">Docker - 介绍</a>章节。</p></blockquote><ol><li>拉取oracle镜像</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure><ol start="2"><li>安装oracle容器</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 9090:8080 -p 1521:1521 registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure><blockquote><p>初始用户名密码：system&#x2F;helowin；服务名：helowin</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.zhihu.com/question/19629769">Mac 上如何安装 Oracle 客户端？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Oracle-安装&quot;&gt;&lt;a href=&quot;#1-Oracle-安装&quot; class=&quot;headerlink&quot; title=&quot;1. Oracle 安装&quot;&gt;&lt;/a&gt;1. Oracle 安装&lt;/h2&gt;&lt;h3 id=&quot;1-1-Docker-快捷安装&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Oracle" scheme="https://guoshunfa.com/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 错误记录</title>
    <link href="https://guoshunfa.com/2022/07/Oracle-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
    <id>https://guoshunfa.com/2022/07/Oracle-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误：sqlplus-command-not-found"><a href="#错误：sqlplus-command-not-found" class="headerlink" title="错误：sqlplus: command not found"></a>错误：sqlplus: command not found</h2><blockquote><p> 转载自：<a href="https://www.cnblogs.com/sprinng/p/6548540.html">https://www.cnblogs.com/sprinng/p/6548540.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整成对应oracle地址</span></span><br><span class="line">export ORACLE_BASE=/u01/app/oracle</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意调整对应版本</span></span><br><span class="line">export ORACLE_HOME=$ORACLE_BASE/product/10.2.0/db_1</span><br><span class="line">su - root</span><br><span class="line">ln -s $ORACLE_HOME/bin/sqlplus /usr/bin</span><br><span class="line">su - oracle</span><br><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;错误：sqlplus-command-not-found&quot;&gt;&lt;a href=&quot;#错误：sqlplus-command-not-found&quot; class=&quot;headerlink&quot; title=&quot;错误：sqlplus: command not found&quot;&gt;&lt;/a&gt;错</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Oracle" scheme="https://guoshunfa.com/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 设置ID自增</title>
    <link href="https://guoshunfa.com/2022/07/Oracle%E8%AE%BE%E7%BD%AEID%E8%87%AA%E5%A2%9E/"/>
    <id>https://guoshunfa.com/2022/07/Oracle%E8%AE%BE%E7%BD%AEID%E8%87%AA%E5%A2%9E/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-先有个表"><a href="#1-先有个表" class="headerlink" title="1. 先有个表"></a>1. 先有个表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 首先得有个表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">user_id number <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">user_name varchar2(<span class="number">30</span>),</span><br><span class="line">credits number,</span><br><span class="line">user_password varchar2(<span class="number">32</span>),</span><br><span class="line">last_visit <span class="type">date</span>,</span><br><span class="line">last_ip varchar2(<span class="number">23</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="2-创建一个序列"><a href="#2-创建一个序列" class="headerlink" title="2. 创建一个序列"></a>2. 创建一个序列</h2><blockquote><p>转载自：<a href="https://blog.csdn.net/jiejie5945/article/details/44198283">https://blog.csdn.net/jiejie5945/article/details/44198283</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 为这个表创建序列</span><br><span class="line"><span class="keyword">create</span> sequence T_USER_SEQ</span><br><span class="line">minvalue <span class="number">1</span></span><br><span class="line">maxvalue <span class="number">999999999999999999999999999</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">21</span></span><br><span class="line">increment <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line">cache <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>参数描述：</p><ul><li><p><code>create sequence seq_name</code>：创建序列，<code>seq_name</code>为序列名称</p></li><li><p><code>minvalue</code>：自增最小值，缺省值为nominvalue，即不设置最小值。</p></li><li><p><code>maxvalue</code>：自增最大值，缺省值为nomaxvalue，即不设置最大值；系统能产生的最大值为10的27次方。</p></li><li><p><code>start with</code>：自增开始值，设置成21则从21开始自增。</p></li><li><p><code>increment by</code>：自增数值，设置成1则每次递增1，负数表示递减，缺省值为1。</p></li><li><p><code>cache</code>：定义缓存序列的个数，缺省值为20，nocache表示不设置缓存；使用缓存可以提高序列的性能，但数据库出错时会造成数据丢失使序列不连续。</p></li><li><p><code>NOCYCLE</code>：一直累加，不循环</p></li><li><p><code>cycle</code>：定义当序列达到最大&#x2F;小值后是否循环，缺省值为不循环；<code>nocycle</code>：不循环；**<code>cycle</code><strong>：循环；如果不使用循环达到限制值后继续产生新值就会出错；使用循环达到最大值后的下一个值为1，和</strong><code>start</code>** **<code>with</code>**设置的值无关，递增还是<code>increment</code> **<code>by</code>**设置的值；</p></li></ul><h3 id="2-1-序列详细描述"><a href="#2-1-序列详细描述" class="headerlink" title="2.1. 序列详细描述"></a>2.1. 序列详细描述</h3><p>一旦定义了<code>emp_sequence</code>，你就可以用<code>CURRVAL</code>，<code>NEXTVAL</code><br><code>CURRVAL</code> &#x3D; 返回<code>sequence</code>的当前值<br><code>NEXTVAL</code> &#x3D; 增加<code>sequence</code>的值，然后返回<code>sequence</code>值<br>比如：<br><code>emp_sequence.CURRVAL</code><br><code>emp_sequence.NEXTVAL</code></p><p>可以使用<code>sequence</code>的地方：</p><ul><li>不包含子查询、<code>snapshot</code>、<code>VIEW</code>的 <code>SELECT</code> 语句</li><li><code>INSERT</code>语句的子查询中</li><li><code>NSERT</code>语句的<code>VALUES</code>中</li><li><code>UPDATE</code> 的 <code>SET</code>中</li></ul><p>可以看如下例子： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span></span><br><span class="line">(empseq.nextval, <span class="string">&#x27;LEWIS&#x27;</span>, <span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7902</span>, SYSDATE, <span class="number">1200</span>, <span class="keyword">NULL</span>, <span class="number">20</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> empseq.currval <span class="keyword">FROM</span> DUAL; </span><br></pre></td></tr></table></figure><p>但是要注意的是： </p><ul><li>第一次<code>NEXTVAL</code>返回的是初始值；随后的<code>NEXTVAL</code>会自动增加你定义的<code>INCREMENT BY</code>值，<br>然后返回增加后的值。<code>CURRVAL</code> 总是返回当前<code>sequence</code>的值，但是在第一次<code>NEXTVAL</code><br>初始化之后才能使用<code>CURRVAL</code>，否则会出错。一次<code>NEXTVAL</code>会增加一次<code>sequence</code>的值，<br>所以如果你在同一个语句里面使用多个<code>NEXTVAL</code>，其值就是不一样的。明白？ </li><li>如果指定<code>CACHE</code>值，<code>oracle</code>就可以预先在内存里面放置一些<code>sequence</code>，这样存取的快<br>些。</li><li><code>cache</code>里面的取完后，<code>oracle</code>自动再取一组到<code>cache</code>。 使用<code>cache</code>或许会跳号， 比如<br>数据库突然不正常<code>down</code>掉（<code>shutdown abort</code>),<code>cache</code>中的<code>sequence</code>就会丢失. 所以可<br>以在<code>create sequence</code>的时候用<code>nocache</code>防止这种情况。</li></ul><h3 id="2-2-调整序列"><a href="#2-2-调整序列" class="headerlink" title="2.2. 调整序列"></a>2.2. 调整序列</h3><p>你或者是该<code>sequence</code>的<code>owner</code>，或者有<code>ALTER ANY sequence</code>权限才能改动<code>sequence</code>。 可<br>以<code>alter</code>除<code>start</code>值之外的所有<code>sequence</code>参数。如果想要改变<code>start</code>值，必须<code>drop sequence</code><br>再<code>re-create</code>。例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> sequence emp_sequence</span><br><span class="line">INCREMENT <span class="keyword">BY</span> <span class="number">10</span></span><br><span class="line">MAXVALUE <span class="number">10000</span></span><br><span class="line"><span class="keyword">CYCLE</span> <span class="comment">-- 到10000后从头开始</span></span><br><span class="line">NOCACHE;</span><br></pre></td></tr></table></figure><p>影响<code>sequence</code>的初始化参数：<br><code>sequence_CACHE_ENTRIES =</code><br>设置能同时被<code>cache</code>的<code>sequence</code>数目。 </p><p>可以很简单的<code>Drop sequence </code><br><code>DROP sequence order_seq; </code></p><h2 id="3-创建一个触发器"><a href="#3-创建一个触发器" class="headerlink" title="3.  创建一个触发器"></a>3.  创建一个触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">trigger</span> t_user_tr</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> t_user</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> t_user_seq.nextval <span class="keyword">into</span> :new.user_id <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span> t_user_tr;</span><br></pre></td></tr></table></figure><p><strong>参数描述：</strong></p><ul><li><code>t_user_tr</code>: 随意的名字，不要重复就行</li><li><code>t_user</code>: 表名</li><li><code>user_id</code> ：自增的id</li></ul><p><strong>删除触发器：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_name;</span><br></pre></td></tr></table></figure><p><strong>参数描述</strong></p><ul><li><em>trigger_name</em>：要删除的触发器的名称。</li></ul><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming1&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming1&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming1&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming2&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;1114&#x27;</span>,sysdate,<span class="string">&#x27;192.168.37.132&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/qq_42055933/article/details/117401672">https://blog.csdn.net/qq_42055933/article/details/117401672</a></li><li><a href="https://blog.csdn.net/QingXu1234/article/details/116048728">oracle如何实现ID自增长</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-先有个表&quot;&gt;&lt;a href=&quot;#1-先有个表&quot; class=&quot;headerlink&quot; title=&quot;1. 先有个表&quot;&gt;&lt;/a&gt;1. 先有个表&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Oracle" scheme="https://guoshunfa.com/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Redis 介绍</title>
    <link href="https://guoshunfa.com/2022/07/Redis-%E4%BB%8B%E7%BB%8D/"/>
    <id>https://guoshunfa.com/2022/07/Redis-%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-07-01T04:01:01.000Z</published>
    <updated>2024-01-28T11:41:39.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://redis.io/docs/">redis 官方文档</a> | <a href="https://www.redis.net.cn/">redis 中文网</a></p></blockquote><h2 id="1-Mac-系统安装Reids"><a href="#1-Mac-系统安装Reids" class="headerlink" title="1. Mac 系统安装Reids"></a>1. Mac 系统安装Reids</h2><h3 id="1-1-安装Homebrew"><a href="#1-1-安装Homebrew" class="headerlink" title="1.1. 安装Homebrew"></a>1.1. 安装Homebrew</h3><p>如果已经安装可以忽略，没有安装的请查看小明之前写好的文章 <a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/a454PtDeCtqWykd2uqP0ig">mac安装homebrew</a></p><h3 id="1-2-使用Homebrew安装Redis"><a href="#1-2-使用Homebrew安装Redis" class="headerlink" title="1.2. 使用Homebrew安装Redis"></a>1.2. 使用Homebrew安装Redis</h3><h4 id="1-2-1-安装命令"><a href="#1-2-1-安装命令" class="headerlink" title="1.2.1. 安装命令"></a>1.2.1. 安装命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><h4 id="1-2-2-查看软件安装及配置文件位置"><a href="#1-2-2-查看软件安装及配置文件位置" class="headerlink" title="1.2.2.  查看软件安装及配置文件位置"></a>1.2.2.  查看软件安装及配置文件位置</h4><p>Homebrew安装的软件会默认在<code>/usr/local/Cellar/</code>路径下；</p><p>redis的配置文件<code>redis.conf</code>存放在<code>/usr/local/etc</code>路径下。</p><h4 id="1-2-3-启动redis服务"><a href="#1-2-3-启动redis服务" class="headerlink" title="1.2.3. 启动redis服务"></a>1.2.3. 启动redis服务</h4><h6 id="1-2-3-1-方法一："><a href="#1-2-3-1-方法一：" class="headerlink" title="1.2.3.1. 方法一："></a>1.2.3.1. 方法一：</h6><p>brew除了可以帮助我们安装软件以外，还可以帮助我们启动软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start redis</span><br></pre></td></tr></table></figure><h6 id="1-2-3-2-方法二："><a href="#1-2-3-2-方法二：" class="headerlink" title="1.2.3.2. 方法二："></a>1.2.3.2. 方法二：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure><h4 id="1-2-4-查看redis服务进程"><a href="#1-2-4-查看redis服务进程" class="headerlink" title="1.2.4. 查看redis服务进程"></a>1.2.4. 查看redis服务进程</h4><p>我们可以通过下面命令查看redis是否正在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axu | grep redis</span><br></pre></td></tr></table></figure><h4 id="1-2-5-redis-cli连接redis服务"><a href="#1-2-5-redis-cli连接redis服务" class="headerlink" title="1.2.5. redis-cli连接redis服务"></a>1.2.5. redis-cli连接redis服务</h4><p>redis默认端口号<strong>6379</strong>，默认<strong>auth</strong>为空，输入以下命令即可连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><h4 id="1-2-6-关闭redis服务"><a href="#1-2-6-关闭redis服务" class="headerlink" title="1.2.6. 关闭redis服务"></a>1.2.6. 关闭redis服务</h4><p>优雅的关闭<code>redis-cli shutdown</code>或者杀死<code>sudo pkill redis-server</code></p><h4 id="1-2-7-redis-conf配置文件说明"><a href="#1-2-7-redis-conf配置文件说明" class="headerlink" title="1.2.7. redis.conf配置文件说明"></a>1.2.7. redis.conf配置文件说明</h4><p>redis默认是前台启动，如果我们想以守护进程的方式运行（后台运行），可以在<strong>redis.conf</strong>中将<code>daemonize no</code>,修改成<code>yes</code>即可。</p><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><h3 id="Linux安装Redis"><a href="#Linux安装Redis" class="headerlink" title="Linux安装Redis"></a><a href="https://blog.csdn.net/m0_37959155/article/details/108897863">Linux安装Redis</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://redis.io/docs/&quot;&gt;redis 官方文档&lt;/a&gt; | &lt;a href=&quot;https://www.redis.net.cn/&quot;&gt;redis 中文网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoshunfa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://guoshunfa.com/tags/Redis/"/>
    
  </entry>
  
</feed>
